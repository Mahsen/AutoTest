L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c"
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Legacy.c
N * Purpose: Network Legacy API Wrapper Functions
N * Rev.:    V7.11.0
N *----------------------------------------------------------------------------*/
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 11 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c" 2
N#include "rl_net_lib.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_lib.h
N * Purpose: Network Library Definitions
N * Rev.:    V7.13.4
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_LIB_H
N#define __RL_NET_LIB_H
N
N#include "rl_net_ds.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_ds.h
N * Purpose: Network API (Dual-stack IPv4/IPv6)
N * Rev.:    V7.13.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_DS_H
N#define __RL_NET_DS_H
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 15 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 16 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include "RTE_Components.h"
L 1 ".\RTE\_Main\RTE_Components.h" 1
N
N
N/*
N
N * Auto generated Run-Time-Environment Configuration File
N
N *      *** Do not modify ! ***
N
N *
N
N * Project: 'main' 
N
N * Target:  'Main' 
N
N */
N
N
N
N#ifndef RTE_COMPONENTS_H
N
N#define RTE_COMPONENTS_H
N
N
N
N
N
N/*
N
N * Define the Device Header File: 
N
N */
N
N#define CMSIS_device_header "LPC17xx.h"
N
N
N
N/* ARM::CMSIS:RTOS:Keil RTX:4.82.0 */
N
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N
N/* Keil.MDK-Plus::Network:CORE:IPv4 Release:7.14.0 */
N
N#define RTE_Network_Core                /* Network Core */
N
N          #define RTE_Network_IPv4                /* Network IPv4 Stack */
N
N          #define RTE_Network_Release             /* Network Release Version */
N
N/* Keil.MDK-Plus::Network:Interface:ETH:7.14.0 */
N
N#define RTE_Network_Interface_ETH_0     /* Network Interface ETH 0 */
N
N
N
N/* Keil.MDK-Plus::Network:Legacy API:7.14.0 */
N
N#define RTE_Network_Legacy              /* Network Legacy */
N
N/* Keil.MDK-Plus::Network:Socket:TCP:7.14.0 */
N
N#define RTE_Network_Socket_TCP          /* Network Socket TCP */
N
N/* Keil::CMSIS Driver:Ethernet MAC:2.12.0 */
N
N#define RTE_Drivers_ETH_MAC0            /* Driver ETH_MAC0 */
N
N/* Keil::CMSIS Driver:Ethernet PHY:DP83848C:6.2.0 */
N
N#define RTE_Drivers_PHY_DP83848C        /* Driver PHY DP83848C */
N
N/* Keil::Device:Startup:1.0.0 */
N
N#define RTE_DEVICE_STARTUP_LPC17XX      /* Device Startup for NXP17XX */
N
N
N
N
N
N#endif /* RTE_COMPONENTS_H */
N
L 17 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N#ifdef __clang__
S  #define __weak    __attribute__((weak))
N#endif
N
N/// Network to host byte order conversion.
N#if defined(__BIG_ENDIAN) || defined(__ARM_BIG_ENDIAN)
X#if 0L || 0L
S  #define ntohl(v)              (uint32_t)(v)
S  #define ntohs(v)              (uint16_t)(v)
N#elif defined (__CC_ARM)
X#elif 1L
N  /* ARM Compiler 4/5 */
N  #define ntohl(v)              (uint32_t)(__rev(v))
N  #define ntohs(v)              (uint16_t)(__rev(v) >> 16)
N#else
S  /* ARM Compiler 6 */
S  #define ntohl(v)              __builtin_bswap32((uint32_t)(v))
S  #define ntohs(v)              __builtin_bswap16((uint16_t)(v))
N#endif
N
N/// Host to network byte order conversion.
N#define htons(v)                ntohs(v)
N#define htonl(v)                ntohl(v)
N
N/// General definitions.
N#define NET_ADDR_ETH_LEN        6       ///< Ethernet MAC Address Length in bytes
N#define NET_ADDR_IP4_LEN        4       ///< IPv4 Address Length in bytes
N#define NET_ADDR_IP6_LEN        16      ///< IPv6 Address Length in bytes
N#define NET_HOSTNAME_LEN        16      ///< Hostname Buffer Length in bytes
N#define NET_ROOT_DIR_LEN        80      ///< Service Root Folder Length in bytes
N
N/// Network Address types.
N#define NET_ADDR_ANY           (-1)     ///< IP address any
N#define NET_ADDR_IP4            0       ///< IPv4 Address
N#define NET_ADDR_IP6            1       ///< IPv6 Address
N
N/// Network Address IPv4/IPv6 capable.
Ntypedef struct net_addr {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4 or \ref NET_ADDR_IP6
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP6_LEN];      ///< IPv4 or IPv6 address (array 16 bytes, MSB first)
X  uint8_t  addr[16];      
N} NET_ADDR;
N
N/// Network Address IPv4 only.
Ntypedef struct net_addr4 {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP4_LEN];      ///< IPv4 address (array 4 bytes, MSB first)
X  uint8_t  addr[4];      
N} NET_ADDR4;
N
N/// Service Authentication definitions.
N#define NET_USERNAME_LEN        16      ///< Username Buffer Length in bytes
N#define NET_PASSWORD_LEN        16      ///< Password Buffer Length in bytes
N
N/// Network Access definitions. 
N#define NET_ACCESS_FILE_READ            0x01  ///< File Read is allowed
N#define NET_ACCESS_FILE_WRITE           0x02  ///< File Write is allowed
N#define NET_ACCESS_DIRECTORY_CREATE     0x04  ///< Directory Create is allowed
N#define NET_ACCESS_DIRECTORY_REMOVE     0x08  ///< Directory Remove is allowed
N#define NET_ACCESS_DIRECTORY_LIST       0x10  ///< Directory List is allowed
N
N/// Status code values returned by Network library functions.
Ntypedef enum {
N  netOK                       = 0,      ///< Operation succeeded
N  netBusy,                              ///< Process is busy
N  netError,                             ///< Unspecified error
N  netInvalidParameter,                  ///< Invalid parameter specified
N  netWrongState,                        ///< Wrong state error
N  netDriverError,                       ///< Driver error
N  netServerError,                       ///< Server error
N  netAuthenticationFailed,              ///< User authentication failed
N  netDnsResolverError,                  ///< DNS host resolver failed
N  netFileError,                         ///< File not found or file r/w error
N  netTimeout                            ///< Operation timeout
N} netStatus;
N
N/// UDP Checksum Options.
N#define NET_UDP_CHECKSUM_SEND   0x01    ///< Calculate Checksum for UDP send frames (default)
N#define NET_UDP_CHECKSUM_VERIFY 0x02    ///< Verify Checksum for received UDP frames (default)
N
N/// UDP Socket Options.
Ntypedef enum {
N  netUDP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netUDP_OptionTTL,                     ///< IPv4 Multi-cast Time to Live; val=TTL
N  netUDP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netUDP_OptionHopLimit,                ///< IPv6 Multi-cast Hop Limit; val=HopLimit
N  netUDP_OptionInterface,               ///< IPv4 Broadcast Interface; val=if_id (class and number)
N  netUDP_OptionChecksum                 ///< UDP Checksum Options
N} netUDP_Option;
N
N/// UDP Event callback function.
Ntypedef uint32_t (*netUDP_cb_t)(int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N/// TCP Socket Events.
Ntypedef enum {
N  netTCP_EventConnect         = 0,      ///< Connect request received event
N  netTCP_EventEstablished,              ///< Connection established event
N  netTCP_EventClosed,                   ///< Connection was properly closed
N  netTCP_EventAborted,                  ///< Connection is for some reason aborted
N  netTCP_EventACK,                      ///< Previously send data acknowledged
N  netTCP_EventData                      ///< Data received event
N} netTCP_Event;
N
N/// TCP Socket States.
Ntypedef enum {
N  netTCP_StateINVALID         =-1,      ///< Invalid Socket
N  netTCP_StateUNUSED          = 0,      ///< Entry is free and unused
N  netTCP_StateCLOSED,                   ///< Entry allocated, socket still closed
N  netTCP_StateLISTEN,                   ///< Socket waiting for incoming connection
N  netTCP_StateSYN_RECEIVED,             ///< SYN frame received
N  netTCP_StateSYN_SENT,                 ///< SYN packet sent to establish a connection
N  netTCP_StateFIN_WAIT_1,               ///< Close started FIN packet was sent
N  netTCP_StateFIN_WAIT_2,               ///< Our FIN ACK-ed, waiting for remote FIN
N  netTCP_StateCLOSING,                  ///< Received FIN independently of our FIN
N  netTCP_StateLAST_ACK,                 ///< Waiting for last ACK for our FIN
N  netTCP_StateTIME_WAIT,                ///< Timed waiting for 2MSL
N  netTCP_StateESTABLISHED               ///< TCP Connection established
N} netTCP_State;
N
N/// TCP Socket Options.
Ntypedef enum {
N  netTCP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netTCP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netTCP_OptionTimeout,                 ///< TCP Idle Timeout; val=timeout (in seconds)
N  netTCP_OptionKeepAlive,               ///< TCP Keep Alive; val: 0=disabled (default), 1=enabled
N  netTCP_OptionFlowControl,             ///< TCP Flow Control; val: 0=disabled (default), 1=enabled
N  netTCP_OptionDelayedACK               ///< TCP Delayed Acknowledgment; val: 0=disabled (default), 1=enabled 
N} netTCP_Option;
N
N/// TCP Event callback function.
Ntypedef uint32_t (*netTCP_cb_t)(int32_t socket, netTCP_Event event, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N#ifdef RTE_Network_Socket_BSD
S
S//  ==== BSD Socket definitions ====
S
S/// BSD Socket Address Family.
S#define AF_UNSPEC               0       ///< Unspecified
S#define AF_INET                 1       ///< Internet Address Family
S#define AF_NETBIOS              2       ///< NetBios-style addresses
S#define AF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Protocol families (same as address families).
S#define PF_UNSPEC               0       ///< Unspecified
S#define PF_INET                 1       ///< Internet Address Family
S#define PF_NETBIOS              2       ///< NetBios-style addresses
S#define PF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Socket Type.
S#define SOCK_STREAM             1       ///< Stream Socket (Connection oriented)
S#define SOCK_DGRAM              2       ///< Datagram Socket (Connectionless)
S
S/// BSD Socket Protocol.
S#define IPPROTO_TCP             1       ///< TCP Protocol
S#define IPPROTO_UDP             2       ///< UDP Protocol
S
S/// BSD Internet Addresses IPv4.
S#define INADDR_ANY              0x00000000  ///< All IP addresses accepted
S#define INADDR_NONE             0xffffffff  ///< No IP address accepted
S#define INADDR_LOOPBACK         0x7f000001  ///< Localhost IP address
S
S/// BSD Socket flags parameter.
S#define MSG_DONTWAIT            0x01    ///< Enables non-blocking operation
S#define MSG_PEEK                0x02    ///< Peeks at the incoming data
S#define MSG_TRUNC               0x04    ///< Normal data was truncated
S#define MSG_CTRUNC              0x08    ///< Control data was truncated
S
S/// BSD Socket ioctl commands.
S#define FIONBIO                 1       ///< Set mode (blocking/non-blocking)
S
S/// BSD Socket level.
S#define SOL_SOCKET              1       ///< Socket Level
S#define IPPROTO_IP              2       ///< IPv4 Level
S#define IPPROTO_IPV6            3       ///< IPv6 Level
S
S/// BSD Socket options.
S#define SO_KEEPALIVE            1       ///< Keep Alive
S#define SO_RCVTIMEO             2       ///< Timeout for blocking receive (in milliseconds)
S#define SO_SNDTIMEO             3       ///< Timeout for blocking send (in milliseconds)
S#define SO_TYPE                 4       ///< Socket type (read only)
S
S/// BSD Socket IPv4 options.
S#define IP_TOS                  1       ///< Type of Service (TOS)
S#define IP_TTL                  2       ///< Time to Live (TTL)
S#define IP_RECVDSTADDR          3       ///< Receive destination IPv4 address
S
S/// BSD Socket IPv6 options.
S#define IPV6_TCLASS             1       ///< Traffic Class
S#define IPV6_MULTICAST_HOPS     2       ///< Multi-cast Hop Limit
S#define IPV6_RECVDSTADDR        3       ///< Receive destination IPv6 address
S
S/// BSD Socket Error codes.
S#define BSD_ERROR               (-1)    ///< Unspecified error
S#define BSD_ESOCK               (-2)    ///< Invalid socket descriptor
S#define BSD_EINVAL              (-3)    ///< Invalid parameter
S#define BSD_ENOTSUP             (-11)   ///< Operation or feature not supported
S#define BSD_ENOMEM              (-5)    ///< Not enough memory
S#define BSD_ELOCKED             (-7)    ///< Socket locked by another thread
S#define BSD_EWOULDBLOCK         (-4)    ///< Operation would block
S#define BSD_ETIMEDOUT           (-8)    ///< Operation timed out
S#define BSD_EINPROGRESS         (-9)    ///< Operation in progress
S#define BSD_ENOTCONN            (-6)    ///< Socket not connected
S#define BSD_EISCONN             (-12)   ///< Socket is connected
S#define BSD_ECONNREFUSED        (-13)   ///< Connection rejected by the peer
S#define BSD_ECONNRESET          (-14)   ///< Connection reset by the peer
S#define BSD_ECONNABORTED        (-15)   ///< Connection aborted locally
S#define BSD_EALREADY            (-16)   ///< Connection already in progress
S#define BSD_EADDRINUSE          (-17)   ///< Address already in use
S#define BSD_EDESTADDRREQ        (-18)   ///< Destination address required
S#define BSD_EHOSTNOTFOUND       (-10)   ///< Host not found
S
S/// BSD Socket legacy Error codes.
S#define BSD_SUCCESS             0       ///< Success
S#define BSD_ERROR_SOCKET        BSD_ESOCK
S#define BSD_ERROR_PARAMETER     BSD_EINVAL
S#define BSD_ERROR_WOULDBLOCK    BSD_EWOULDBLOCK
S#define BSD_ERROR_NOMEMORY      BSD_ENOMEM
S#define BSD_ERROR_CLOSED        BSD_ENOTCONN
S#define BSD_ERROR_LOCKED        BSD_ELOCKED
S#define BSD_ERROR_TIMEOUT       BSD_ETIMEDOUT
S#define BSD_ERROR_INPROGRESS    BSD_EINPROGRESS
S#define BSD_ERROR_NONAME        BSD_EHOSTNOTFOUND
S
S//  ==== BSD Socket structures ====
S
S/// Generic Socket Address structure.
Stypedef struct sockaddr {
S  uint16_t sa_family;                   ///< Address family
S  int8_t   sa_data[14];                 ///< Direct address (up to 14 bytes)
S} SOCKADDR;
S
S#if   defined(__CC_ARM)
S  #pragma push
S  #pragma anon_unions
S#elif defined(__clang__)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S#endif
S
S/// Generic IPv4 Address structure.
Stypedef struct in_addr {
S  union {
S    struct {
S      uint8_t s_b1,s_b2,s_b3,s_b4;      ///< IP address, byte access
S    };
S    struct {
S      uint16_t s_w1,s_w2;               ///< IP address, short int access
S    };
S    uint32_t s_addr;                    ///< IP address in network byte order
S  };
S} IN_ADDR;
S
S/// Generic IPv6 Address structure.
Stypedef struct in6_addr {
S  union {
S    uint8_t  s6_b[16];                  ///< IP6 address, byte access
S    uint16_t s6_w[8];                   ///< IP6 address, short int access
S  };
S} IN6_ADDR;
S#define s6_addr     s6_b
S
S#if   defined(__CC_ARM)
S  #pragma pop
S#elif defined(__clang__)
S  #pragma clang diagnostic pop
S#endif
S
S/// IPv4 Socket Address structure.
Stypedef struct sockaddr_in {
S  int16_t  sin_family;                  ///< Socket domain
S  uint16_t sin_port;                    ///< Port
S  IN_ADDR  sin_addr;                    ///< IP address
S  int8_t   sin_zero[8];                 ///< reserved
S} SOCKADDR_IN;
S
S/// IPv6 Socket Address structure.
Stypedef struct sockaddr_in6 {
S  int16_t  sin6_family;                 ///< Socket domain
S  uint16_t sin6_port;                   ///< Port
S  uint32_t sin6_flowinfo;               ///< IP6 flow information
S  IN6_ADDR sin6_addr;                   ///< IP6 address
S} SOCKADDR_IN6;
S
S/// Socket Address storage structure.
Stypedef struct sockaddr_storage {
S  int16_t ss_family;                    ///< Address family
S  int8_t  __ss_pad1[2];                 ///< reserved
S  int32_t __ss_align;                   ///< reserved, structure alignment
S  int8_t  __ss_pad2[16];                ///< reserved
S} SOCKADDR_STORAGE;
S
S/// BSD Host Entry structure.
Stypedef struct hostent {
S  char   *h_name;                       ///< Official name of host
S  char  **h_aliases;                    ///< Pointer to an array of alias names
S  int16_t h_addrtype;                   ///< Address Type: AF_INET, AF_NETBIOS
S  int16_t h_length;                     ///< Length of address in bytes
S  char  **h_addr_list;                  ///< Pointer to an array of IPv4 addresses
S} HOSTENT;
S
S/// BSD address string length.
S#define INET_ADDRSTRLEN         16      ///< IP address string length
S#define INET6_ADDRSTRLEN        46      ///< IP6 address string length
S
S/// BSD fd_set size.
S#define FD_SETSIZE              64      ///< Maximum number of sockets in fd_set structure
S
S/// BSD fd_set structure.
Stypedef struct fd_set {
S  uint32_t fd_bits[(FD_SETSIZE+31)>>5]; ///< Set of sockets bit-mask
S} fd_set;
S
S/// BSD timeval structure.
Stypedef struct timeval {
S  uint32_t tv_sec;                      ///< Time interval: seconds
S  uint32_t tv_usec;                     ///< Time interval: microseconds
S} timeval;
S
S/// BSD safe read/write fd_set macros.
S#define FD_WR(fd,code)          if ((fd > 0) && (fd <= FD_SETSIZE)) { code; }
S#define FD_RD(fd,code)          (((fd > 0) && (fd <= FD_SETSIZE)) ? (code) : 0)
S
S/// BSD initialize and test fd_set macros.
S#define FD_SET(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] |=  (1U << ((fd-1)&0x1F)))
S#define FD_CLR(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] &= ~(1U << ((fd-1)&0x1F)))
S#define FD_ISSET(fd,set)        FD_RD(fd, (set)->fd_bits[(fd-1)>>5] &   (1U << ((fd-1)&0x1F)))
S#define FD_ZERO(set)            memset(set, 0, sizeof(*set))
S
S/// BSD scatter/gather array of items.
Stypedef struct iovec {
S  void    *iov_base;                    ///< Starting address
S  uint32_t iov_len;                     ///< Number of bytes to transfer
S} IOVEC;
S
S/// BSD message header structure.
Stypedef struct msghdr {
S  void    *msg_name;                    ///< Optional pointer to source address
S  uint32_t msg_namelen;                 ///< Size of address buffer
S  IOVEC   *msg_iov;                     ///< An array of iovec buffers for the message
S  int32_t  msg_iovlen;                  ///< Number of elements in msg_iov
S  void    *msg_control;                 ///< Ancillary data
S  uint32_t msg_controllen;              ///< Ancillary data buffer length
S  int32_t  msg_flags;                   ///< Flags on received message
S} MSGHDR;
S
S/// BSD cmsg header structure.
Stypedef struct cmsghdr {
S  uint32_t cmsg_len;                    ///< Data byte count, including the cmsghdr
S  int32_t  cmsg_level;                  ///< Originating protocol
S  int32_t  cmsg_type;                   ///< Protocol-specific type
S} CMSGHDR;
S
S/// BSD access ancillary data macros (RFC 2292).
S#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ? \
S                                 (CMSGHDR *)(mhdr)->msg_control             : \
S                                 (CMSGHDR *)NULL
X#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ?                                  (CMSGHDR *)(mhdr)->msg_control             :                                  (CMSGHDR *)NULL
S#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) > \
S                                 (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ? \
S                                 (CMSGHDR *)NULL                                                   : \
S                                 (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
X#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) >                                  (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ?                                  (CMSGHDR *)NULL                                                   :                                  (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
S#define CMSG_DATA(cmsg)         ((uint8_t *)(cmsg) + sizeof(CMSGHDR))
S#define CMSG_ALIGN(len)         (((len) + 3) & ~3U)
S#define CMSG_LEN(len)           ((len) + sizeof(CMSGHDR))
S#define CMSG_SPACE(len)          CMSG_ALIGN((len) + sizeof(CMSGHDR))
S
N#endif /* RTE_Network_Socket_BSD */
N
N/// Interface Class
N#define NET_IF_CLASS_ETH        (1U << 8)   ///< Ethernet interface
N#define NET_IF_CLASS_WIFI       (2U << 8)   ///< WiFi interface
N#define NET_IF_CLASS_PPP        (3U << 8)   ///< PPP interface
N#define NET_IF_CLASS_SLIP       (4U << 8)   ///< SLIP interface
N
N/// Interface Option codes.
Ntypedef enum {
N  netIF_OptionMAC_Address,              ///< Ethernet MAC Address (6 bytes)
N  netIF_OptionVLAN_Identifier,          ///< Ethernet VLAN Identifier (2 bytes)
N  netIF_OptionIP4_MTU,                  ///< IPv4 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP4_Address,              ///< IPv4 Address (4 bytes)
N  netIF_OptionIP4_SubnetMask,           ///< IPv4 Subnet mask (4 bytes)
N  netIF_OptionIP4_DefaultGateway,       ///< IPv4 Default Gateway (4 bytes)
N  netIF_OptionIP4_PrimaryDNS,           ///< IPv4 Primary DNS (4 bytes)
N  netIF_OptionIP4_SecondaryDNS,         ///< IPv4 Secondary DNS (4 bytes)
N  netIF_OptionIP6_MTU,                  ///< IPv6 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP6_LinkLocalAddress,     ///< IPv6 Link-local Address (16 bytes)
N  netIF_OptionIP6_StaticAddress,        ///< IPv6 Static Address (16 bytes)
N  netIF_OptionIP6_DynamicAddress,       ///< IPv6 Dynamic Address (16 bytes)
N  netIF_OptionIP6_SubnetPrefixLength,   ///< IPv6 Subnet Prefix-length (1 byte)
N  netIF_OptionIP6_DefaultGateway,       ///< IPv6 Default Gateway (16 bytes)
N  netIF_OptionIP6_PrimaryDNS,           ///< IPv6 Primary DNS (16 bytes)
N  netIF_OptionIP6_SecondaryDNS          ///< IPv6 Secondary DNS (16 bytes)
N} netIF_Option;
N
N/// Interface IP Versions.
Ntypedef enum {
N  netIF_VersionIP4,                     ///< IP version 4
N  netIF_VersionIP6                      ///< IP version 6
N} netIF_Version;
N
N/// Ethernet link speed.
N#define NET_ETH_SPEED_10M       0       ///< 10 Mbps link speed
N#define NET_ETH_SPEED_100M      1       ///< 100 Mbps link speed
N#define NET_ETH_SPEED_1G        2       ///< 1 Gpbs link speed
N
N/// Ethernet duplex mode.
N#define NET_ETH_DUPLEX_HALF     0       ///< Half duplex link
N#define NET_ETH_DUPLEX_FULL     1       ///< Full duplex link
N
N/// Ethernet link information.
Ntypedef struct net_eth_link_info {
N  uint32_t speed  : 2;                  ///< Link speed: 0= 10 MBit, 1= 100 MBit, 2= 1 GBit
N  uint32_t duplex : 1;                  ///< Duplex mode: 0= Half, 1= Full
N} NET_ETH_LINK_INFO;
N
N/// Ethernet Callback Events.
Ntypedef enum {
N  netETH_LinkDown             = 0,      ///< Link down
N  netETH_LinkUp,                        ///< Link up; val=link_info
N  netETH_Wakeup,                        ///< Wake-up (on Magic Packet)
N  netETH_TimerAlarm                     ///< Timer Alarm (PTP)
N} netETH_Event;
N
N/// WiFi Security Types.
Ntypedef enum {
N  netWiFi_SecurityOpen        = 0,      ///< Open
N  netWiFi_SecurityWEP,                  ///< Wired Equivalent Privacy
N  netWiFi_SecurityWPA,                  ///< WiFi Protected Access
N  netWiFi_SecurityWPA2,                 ///< WiFi Protected Access 2
N  netWiFi_SecurityUnknown     = 255     ///< Unknown security
N} netWiFi_Security;
N
N/// WiFi Driver Options.
Ntypedef enum {
N  netWiFi_OptionBSSID         = 1,      ///< BSSID of AP
N  netWiFi_OptionTxPower,                ///< Transmit Power
N  netWiFi_OptionLpTimer,                ///< Low Power deep-sleep timer
N  netWiFi_OptionDTIM,                   ///< DTIM interval
N  netWiFi_OptionBeacon                  ///< Beacon interval
N} netWiFi_Option;
N
N/// WiFi WPS Methods.
Ntypedef enum {
N  netWiFi_WPS_None            = 0,      ///< Not used
N  netWiFi_WPS_PBC,                      ///< With Push Button Configuration
N  netWiFi_WPS_PIN                       ///< With PIN
N} netWiFi_WPS;
N
N/// WiFi Configuration.
Ntypedef struct net_wifi_config {
N  const char      *ssid;                ///< Network name, a null-terminated string
N  const char      *password;            ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel (0=auto)
N  uint8_t          reserved;            ///< Reserved
N  netWiFi_WPS      wps_method;          ///< WiFi Protected Setup method
N  const char      *wps_pin;             ///< WPS PIN, a null-terminated string
N} NET_WIFI_CONFIG;
N
N/// WiFi Network information.
Ntypedef struct net_wifi_net_info {
N  char             ssid[32+1];          ///< Network name, a null-terminated string
N  char             password[64+1];      ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_NET_INFO;
N
N/// WiFi Scan information.
Ntypedef struct net_wifi_scan_info {
N  char             ssid[32+1];          ///< Service Set Identifier (null-terminated)
N  uint8_t          bssid[6];            ///< Basic Service Set Identifier
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_SCAN_INFO;
N
N/// ARP Cache Entry types.
Ntypedef enum {
N  netARP_CacheFixedIP,                  ///< Fixed IP address is refreshed after timeout
N  netARP_CacheTemporaryIP               ///< Temporary IP address is removed after timeout
N} netARP_CacheType;
N
N/// DHCP Option Codes.
N#define NET_DHCP_OPTION_IP_ADDRESS     0 ///< IP address change event
N#define NET_DHCP_OPTION_NTP_SERVERS   42 ///< NTP Servers option
N#define NET_DHCP_OPTION_CLIENT_ID     61 ///< Client-identifier option
N#define NET_DHCP_OPTION_BOOTFILE_NAME 67 ///< Bootfile name option
N
N/// DHCPv6 Option Codes.
N#define NET_DHCP6_OPTION_IP_ADDRESS   0 ///< IPv6 address change event
N
N/// DHCP Option Item.
Ntypedef struct net_dhcp_option_item {
N  uint8_t code;                         ///< Option type code
N  uint8_t length;                       ///< Length of Option value
N  uint8_t *value;                       ///< Pointer to Option value
N} NET_DHCP_OPTION_ITEM;
N
N/// DHCP Private Options.
Nextern NET_DHCP_OPTION_ITEM netDHCP_PrivateOptionsTableN[];  ///< DHCP Private Options Table
Nextern uint8_t              netDHCP_PrivateOptionsCountN;    ///< Number of DHCP Private Options
N
N/// DHCPv6 Modes.
Ntypedef enum {
N  netDHCP6_ModeStateless      = 0,      ///< Stateless DHCPv6 mode
N  netDHCP6_ModeStateful                 ///< Stateful DHCPv6 mode
N} netDHCP6_Mode;
N
N/// Ping Callback Events.
Ntypedef enum {
N  netPing_EventSuccess        = 0,      ///< Pinged Host responded
N  netPing_EventTimeout                  ///< Timeout, no ping response received
N} netPing_Event;
N
N/// Ping Control Flags.
N#define NET_PING_IP4_ONLY       0x01    ///< Force using IPv4 only
N#define NET_PING_IP6_ONLY       0x02    ///< Force using IPv6 only
N
N/// ARP Probe Callback Events.
Ntypedef enum {
N  netARP_EventSuccess         = 0,      ///< Probed Host responded
N  netARP_EventTimeout                   ///< Timeout, no response to ARP probe
N} netARP_Event;
N
N/// NDP Probe Callback Events.
Ntypedef enum {
N  netNDP_EventSuccess         = 0,      ///< Probed Host responded
N  netNDP_EventTimeout                   ///< Timeout, no response to NDP probe
N} netNDP_Event;
N
N/// DNS Client Callback Events.
Ntypedef enum {
N  netDNSc_EventSuccess        = 0,      ///< Host name successfully resolved
N  netDNSc_EventTimeout,                 ///< Timeout resolving host
N  netDNSc_EventNotResolved,             ///< DNS Error, no such name
N  netDNSc_EventError                    ///< Erroneous response packet
N} netDNSc_Event;
N
N/// FTP Commands.
Ntypedef enum {
N  netFTP_CommandPUT,                    ///< Puts a file on FTP server
N  netFTP_CommandGET,                    ///< Retrieves a file from FTP server
N  netFTP_CommandAPPEND,                 ///< Append file on FTP server (with create)
N  netFTP_CommandDELETE,                 ///< Deletes a file on FTP server
N  netFTP_CommandLIST,                   ///< Lists files stored on FTP server
N  netFTP_CommandRENAME,                 ///< Renames a file on FTP server
N  netFTP_CommandMKDIR,                  ///< Makes a directory on FTP server
N  netFTP_CommandRMDIR,                  ///< Removes an empty directory on FTP server
N  netFTP_CommandNLIST                   ///< Lists file names only (short format)
N} netFTP_Command;
N
N/// FTP Server Events.
Ntypedef enum {
N  netFTPs_EventLogin,                   ///< User logged in, session is busy
N  netFTPs_EventLogout,                  ///< User logged out, session is idle
N  netFTPs_EventLoginFailed,             ///< User login failed (invalid credentials)
N  netFTPs_EventDownload,                ///< File download ended
N  netFTPs_EventUpload,                  ///< File upload ended
N  netFTPs_EventDelete,                  ///< File deleted
N  netFTPs_EventRename,                  ///< File or directory renamed
N  netFTPs_EventMakeDirectory,           ///< Directory created
N  netFTPs_EventRemoveDirectory,         ///< Directory removed
N  netFTPs_EventOperationDenied,         ///< Requested file operation denied
N  netFTPs_EventLocalFileError,          ///< Local file operation error
N  netFTPs_EventFileError,               ///< Generic file operation error
N  netFTPs_EventError                    ///< Generic FTP server error
N} netFTPs_Event;
N
N/// FTP Client Requests.
Ntypedef enum {
N  netFTPc_RequestUsername,              ///< Username to login to FTP server
N  netFTPc_RequestPassword,              ///< Password to login to FTP server
N  netFTPc_RequestDirectory,             ///< Working directory path on server for all commands
N  netFTPc_RequestName,                  ///< File or Directory name for FTP commands 
N  netFTPc_RequestNewName,               ///< New File or Directory name for RENAME command
N  netFTPc_RequestListMask,              ///< File filter/mask for LIST command (wildcards allowed)
N  netFTPc_RequestList,                  ///< Received data if LIST command is given
N  netFTPc_RequestLocalFilename          ///< Local filename (including path)
N} netFTPc_Request;
N
N/// FTP Client Events.
Ntypedef enum {
N  netFTPc_EventSuccess        = 0,      ///< File operation successful
N  netFTPc_EventTimeout,                 ///< Timeout on file operation
N  netFTPc_EventLoginFailed,             ///< Login error, username/password invalid
N  netFTPc_EventAccessDenied,            ///< File access not allowed
N  netFTPc_EventFileNotFound,            ///< File not found
N  netFTPc_EventInvalidDirectory,        ///< Working directory path not found
N  netFTPc_EventLocalFileError,          ///< Local file read/write error
N  netFTPc_EventError                    ///< Generic FTP client error 
N} netFTPc_Event;
N
N/// TFTP Client Events.
Ntypedef enum {
N  netTFTPc_EventSuccess       = 0,      ///< File operation successful
N  netTFTPc_EventTimeout,                ///< Timeout on file operation
N  netTFTPc_EventAccessDenied,           ///< File access not allowed
N  netTFTPc_EventFileNotFound,           ///< File not found
N  netTFTPc_EventDiskFull,               ///< Disk full
N  netTFTPc_EventLocalFileError,         ///< Local file read/write error
N  netTFTPc_EventError                   ///< Generic TFTP client error
N} netTFTPc_Event;          
N
N/// Telnet Server Messages.
Ntypedef enum {
N  netTELNETs_MessageWelcome,            ///< Initial welcome message
N  netTELNETs_MessageLogin,              ///< Login message, if authentication is enabled
N  netTELNETs_MessageUsername,           ///< Username request login message
N  netTELNETs_MessagePassword,           ///< Password request login message
N  netTELNETs_MessageLoginFailed,        ///< Incorrect login error message
N  netTELNETs_MessageLoginTimeout,       ///< Login timeout error message
N  netTELNETs_MessagePrompt,             ///< Prompt message
N  netTELNETs_MessageUnsolicited         ///< Unsolicited message (triggered by netTELNETs_RequestMessage)
N} netTELNETs_Message;
N
N/// SMTP Client Request.
Ntypedef enum {
N  netSMTPc_RequestUsername,             ///< Username to login to SMTP server
N  netSMTPc_RequestPassword,             ///< Password to login to SMTP server
N  netSMTPc_RequestSender,               ///< Email address of the sender
N  netSMTPc_RequestRecipient,            ///< Email address of the recipient
N  netSMTPc_RequestSubject,              ///< Subject of email
N  netSMTPc_RequestBody                  ///< Email body in plain ASCII format
N} netSMTPc_Request;
N
N/// SMTP Client Events.
Ntypedef enum {
N  netSMTPc_EventSuccess       = 0,      ///< Email successfully sent
N  netSMTPc_EventTimeout,                ///< Timeout sending email
N  netSMTPc_EventAuthenticationFailed,   ///< Authentication failed, username/password invalid
N  netSMTPc_EventError                   ///< Error when sending email
N} netSMTPc_Event;
N
N/// SMTP Mail Transfer Agent Flags.
N#define NET_SMTP_MTA_USETLS     0x01    ///< Use secure TLS mode (Implicit TLS)
N
N/// SMTP Email Descriptor.
Ntypedef struct net_smtp_mail {
N  const char *From;                     ///< Sender address, can be NULL
N  const char *To;                       ///< Recipient(s), can be NULL
N  const char *Cc;                       ///< Carbon copy recipient(s), can be NULL
N  const char *Bcc;                      ///< Blind carbon copy recipient(s), can be NULL
N  const char *Subject;                  ///< Subject of email, can be NULL
N  const char *Message;                  ///< Email message body, can be NULL
N  const char *Attachment;               ///< Email attachment(s), can be NULL
N  const char *Encoding;                 ///< Default encoding type, can be NULL
N} NET_SMTP_MAIL;
N
N/// SMTP Mail Transfer Agent Descriptor.
Ntypedef struct net_smtp_mta {
N  const char *Address;                  ///< Server address (FQDN or IP address)
N  uint16_t    Port;                     ///< Server port number, can be 0
N  uint16_t    Flags;                    ///< Service control flags
N  const char *Username;                 ///< Account user name, can be NULL
N  const char *Password;                 ///< Account password, can be NULL
N} NET_SMTP_MTA;
N
N/// SNTP Client Mode.
Ntypedef enum {
N  netSNTPc_ModeUnicast        = 0,      ///< Unicast mode to access public NTP server
N  netSNTPc_ModeBroadcast                ///< Broadcast mode for local LAN
N} netSNTPc_Mode;
N
N/// Ping Event callback function.
Ntypedef void (*netPing_cb_t)(netPing_Event event);
N
N/// ARP Probe Event callback function.
Ntypedef void (*netARP_cb_t)(netARP_Event event);
N
N/// NDP Probe Event callback function.
Ntypedef void (*netNDP_cb_t)(netNDP_Event event);
N
N/// DNS Client Event callback function.
Ntypedef void (*netDNSc_cb_t)(netDNSc_Event event, const NET_ADDR *addr);
N
N/// SNTP Client callback function.
Ntypedef void (*netSNTPc_cb_t)(uint32_t seconds, uint32_t seconds_fraction);
N
N/// SNMP-MIB definitions.
N#define NET_SNMP_MIB_INTEGER    0x02    ///< MIB entry type INTEGER
N#define NET_SNMP_MIB_OCTET_STR  0x04    ///< MIB entry type OCTET_STRING
N#define NET_SNMP_MIB_OBJECT_ID  0x06    ///< MIB entry type OBJECT_IDENTIFIER
N#define NET_SNMP_MIB_IP_ADDR    0x40    ///< MIB entry type IP ADDRESS (uint8_t[4])
N#define NET_SNMP_MIB_COUNTER    0x41    ///< MIB entry type COUNTER (uint32_t)
N#define NET_SNMP_MIB_GAUGE      0x42    ///< MIB entry type GAUGE (uint32_t)
N#define NET_SNMP_MIB_TIME_TICKS 0x43    ///< MIB entry type TIME_TICKS
N#define NET_SNMP_MIB_ATR_RO     0x80    ///< MIB entry attribute READ_ONLY
N#define NET_SNMP_MIB_OID_SIZE   17      ///< Max.size of Object ID value
N#define NET_SNMP_MIB_STR_SIZE   110     ///< Max.size of Octet String variable
N#define NET_SNMP_MIB_READ       0       ///< MIB entry Read access
N#define NET_SNMP_MIB_WRITE      1       ///< MIB entry Write access
N
N/// SNMP-MIB macros.
N#define NET_SNMP_MIB_STR(s)     sizeof(s)-1, s
N#define NET_SNMP_MIB_INT(o)     sizeof(o), (void *)&o
N#define NET_SNMP_MIB_IP(ip)     4, (void *)&ip
N#define NET_SNMP_MIB_OID0(f,s)  (f*40 + s)
N
N/// SNMP-MIB Entry information.
Ntypedef struct net_snmp_mib_info {
N  uint8_t type;                         ///< Object Type
N  uint8_t oid_len;                      ///< Object ID length
N  uint8_t oid[NET_SNMP_MIB_OID_SIZE];   ///< Object ID value
X  uint8_t oid[17];   
N  uint8_t var_size;                     ///< Size of a variable
N  void    *var;                         ///< Pointer to a variable
N  void    (*cb_func)(int32_t mode);     ///< Write/Read event callback function
N} const NET_SNMP_MIB_INFO;
N
N/// FS Interface Time info
Ntypedef struct net_fs_time {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} NET_FS_TIME;
N
N/// FS Interface Attributes
N#define NET_FS_ATTR_FILE        1       ///< File entry
N#define NET_FS_ATTR_DIRECTORY   2       ///< Directory entry
N
N
N//  ==== Network System API ====
N
N/// \brief Initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netInitialize (void);
N
N/// \brief De-initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUninitialize (void);
N
N/// \brief Retrieve localhost name.  [\ref thread-safe]
N/// \return        pointer to localhost name, a null-terminated string.
Nextern const char *netSYS_GetHostName (void);
N
N/// \brief Set localhost name. [\ref thread-safe]
N/// \param[in]     hostname      new localhost name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSYS_SetHostName (const char *hostname);
N
N//  ==== UDP Socket API ====
N
N/// \brief Allocate a free UDP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netUDP_GetSocket (netUDP_cb_t cb_func);
N
N/// \brief Release UDP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_ReleaseSocket (int32_t socket);
N
N/// \brief Open UDP socket for communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     port          local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Open (int32_t socket, uint16_t port);
N
N/// \brief Stop UDP communication and close socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Close (int32_t socket);
N
N/// \brief Allocate memory for UDP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netUDP_GetBuffer (uint32_t size);
N
N/// \brief Send data to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Send (int32_t socket, const NET_ADDR *addr, uint8_t *buf, uint32_t len);
N
N/// \brief Set UDP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netUDP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_SetOption (int32_t socket, netUDP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of UDP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return        local port number.
N///                - 0           = socket invalid or in invalid state.
Nextern uint16_t  netUDP_GetLocalPort (int32_t socket);
N
N//  ==== TCP Socket API ====
N
N/// \brief Allocate a free TCP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netTCP_GetSocket (netTCP_cb_t cb_func);
N
N/// \brief Release TCP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ReleaseSocket (int32_t socket);
N
N/// \brief Open TCP socket for incoming connection. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     port          local port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Listen (int32_t socket, uint16_t port);
N
N/// \brief Initiate a TCP connection to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     local_port    local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Connect (int32_t socket, const NET_ADDR *addr, uint16_t local_port);
N
N/// \brief Stop TCP communication and start closing procedure. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Close (int32_t socket);
N
N/// \brief Instantly stop TCP communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Abort (int32_t socket);
N
N/// \brief Determine maximum number of data bytes that can be sent in TCP packet. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        maximum segment size in bytes.
Nextern uint32_t  netTCP_GetMaxSegmentSize (int32_t socket);
N
N/// \brief Allocate memory for TCP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netTCP_GetBuffer (uint32_t size);
N
N/// \brief Check if TCP socket can send data. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      send status:
N///              - true        = Ready to send data.
N///              - false       = Not ready.
Nextern bool      netTCP_SendReady (int32_t socket);
Xextern _Bool      netTCP_SendReady (int32_t socket);
N
N/// \brief Send a data packet to remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Send (int32_t socket, uint8_t *buf, uint32_t len);
N
N/// \brief Determine current state of a TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      state information as defined with \ref netTCP_State.
Nextern netTCP_State netTCP_GetState (int32_t socket);
N
N/// \brief Reset TCP window size to a default value from the configuration. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ResetReceiveWindow (int32_t socket);
N
N/// \brief Set TCP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netTCP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_SetOption (int32_t socket, netTCP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        local port number.
N///                - 0         = socket invalid or in invalid state.
Nextern uint16_t  netTCP_GetLocalPort (int32_t socket);
N
N/// \brief Retrieve IP address and port number of remote peer. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for remote peer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_GetPeer (int32_t socket, NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Determine TCP socket connection timeout. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        connection timeout timer in seconds.
N///                - 0         = socket invalid or in invalid state.
Nextern uint32_t  netTCP_GetTimer (int32_t socket);
N
N//  ==== BSD Socket API ====
N
N#ifdef RTE_Network_Socket_BSD
S/// \brief Create a communication endpoint called socket. [\ref thread-safe]
S/// \param[in]     family        address family:
S///                              - AF_INET        = address family IPv4.
S///                              - AF_INET6       = address family IPv6.
S/// \param[in]     type          connection type of a socket:
S///                              - SOCK_STREAM    = connection based type.
S///                              - SOCK_DGRAM     = datagram connectionless type.
S/// \param[in]     protocol      protocol type:
S///                              - IPPROTO_TCP    = must be used with SOCK_STREAM type.
S///                              - IPPROTO_UDP    = must be used with SOCK_DGRAM TYPE.
S///                              - 0              = for system auto-select.
S/// \return      status information:
S///              - Socket descriptor (>0).
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOMEM          = No free sockets available.
Sextern int socket (int family, int type, int protocol);
S
S/// \brief Assign a local address and port to a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing local IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or already bound.
S///              - BSD_EADDRINUSE      = Address or port already in use.
S///              - BSD_EISCONN         = Socket already connected.
Sextern int bind (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Set a socket in a listening mode. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     backlog       number of connection requests that can be accepted.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter, socket not bound or already listening.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ERROR           = Failed to create socket backlog.
Sextern int listen (int sock, int backlog);
S
S/// \brief Accept connect request for a listening socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    addr          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - New socket descriptor (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Socket not in listen mode.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int accept (int sock, SOCKADDR *addr, int *addrlen);
S
S/// \brief Connect a socket to a remote host. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing remote IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket in wrong state.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EALREADY        = Connection already in progress.
S///              - BSD_EINPROGRESS     = Operation in progress.
S///              - BSD_EISCONN         = Socket is connected.
S///              - BSD_ECONNREFUSED    = Connection rejected by the peer.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int connect (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Send data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int send (int sock, const char *buf, int len, int flags);
S
S/// \brief Send data to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \param[in]     to            structure containing remote IP address and port.
S/// \param[in]     tolen         length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendto (int sock, const char *buf, int len, int flags, const SOCKADDR *to, int tolen);
S
S/// \brief Send a message to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to target address (NULL for none).
S///                              - array of application buffer(s) containing the message.
S///                              - pointer to the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendmsg (int sock, const MSGHDR *msg, int flags);
S
S/// \brief Receive data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recv (int sock, char *buf, int len, int flags);
S
S/// \brief Receive data from endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \param[out]    from          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] fromlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvfrom (int sock, char *buf, int len, int flags, SOCKADDR *from, int *fromlen);
S
S/// \brief Receive a message from a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in,out] msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to buffer to store the source address to (NULL for none).
S///                              - array of application buffer(s) for the incomming message.
S///                              - pointer to buffer for the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvmsg (int sock, MSGHDR *msg, int flags);
S
S/// \brief Close socket and release socket descriptor. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ERROR           = Unspecified error.
Sextern int closesocket (int sock);
S
S/// \brief Retrieve IP address and port number of the endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTCONN        = Socket not connected.
Sextern int getpeername (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve local IP address and port number. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket not bound.
Sextern int getsockname (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve options for the socket.  [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be retrieved:
S///                              - SO_TYPE             = Type of a socket.
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[out]    optval        pointer to the buffer that will receive the option value.
S/// \param[in,out] optlen        input length of buffer, return length of the data.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int getsockopt (int sock, int level, int optname, char *optval, int *optlen);
S
S/// \brief Manipulate options for the socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be set:
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[in]     optval        pointer to the buffer containing the option value.
S/// \param[in]     optlen        size of the buffer containing the option value.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int setsockopt (int sock, int level, int optname, const char *optval, int optlen);
S
S/// \brief Control IO mode of a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     cmd           command to perform:
S///                              - FIONBIO  = enable non-blocking mode.
S/// \param[in]     argp          command's parameter.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int ioctlsocket (int sock, long cmd, unsigned long *argp);
S
S/// \brief Check the status of one or more sockets. [\ref thread-safe]
S/// \param[in]     nfds          range of sockets to be checked.
S/// \param[in,out] readfds       pointer to the set of sockets to check for read.
S///                              - NULL for none.
S/// \param[in,out] writefds      pointer to the set of sockets to check for write.
S///                              - NULL for none.
S/// \param[in,out] errorfds      pointer to the set of sockets to check for error.
S///                              - NULL for none.
S/// \param[in]     timeout       pointer to maximum time for select to wait.
S///                              - NULL for blocking wait for event.
S/// \return      status information:
S///              - number of ready sockets (>0)
S///              - 0                   = Operation timed out.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ERROR           = Suspend operation failed.
Sextern int select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
S
S/// \brief Retrieve host IP address from host name. [\ref thread-safe]
S/// \param[in]     name          host name.
S/// \param[out]    err           pointer to where to return error code (NULL for none):
S///                              - 0                   = Operation successful.
S///                              - BSD_EINVAL          = Invalid parameter.
S///                              - BSD_ELOCKED         = Resolver locked by another thread.
S///                              - BSD_ETIMEDOUT       = Operation timed out.
S///                              - BSD_EHOSTNOTFOUND   = Host not found.
S///                              - BSD_ERROR           = Unspecified error.
S/// \return      status information:
S///              - \ref HOSTENT result structure.
S///              - NULL in case of error.
Sextern HOSTENT *gethostbyname (const char *name, int *err);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \return      status information:
S///              - Internet address on success.
S///              - INADDR_NONE = on error.
Sextern IN_ADDR inet_addr (const char *cp);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \param[out]    addr          buffer where the converted IPv4 address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_aton (const char *cp, IN_ADDR *addr);
S
S/// \brief Convert from network address to a text string. [\ref not_thread-safe]
S/// \param[in]     in            Internet IPv4 host address to convert.
S/// \return      pointer to the formatted string.
Sextern const char *inet_ntoa (IN_ADDR in);
S
S/// \brief Convert from text address to a binary network address. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           text address to be converted.
S/// \param[out]    dst           buffer where the converted address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_pton (int af, const char *src, void *dst);
S
S/// \brief Convert from binary network address to a text string. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           binary address in network byte order to be converted.
S/// \param[out]    dst           buffer where the converted text address is to be stored.
S/// \param[in]     size          size of the buffer, at least:
S///                              - INET_ADDRSTRLEN for AF_INET.
S///                              - INET6_ADDRSTRLEN for AF_INET6.
S/// \return      pointer to the formatted string.
S///              - NULL in case of error.
Sextern const char *inet_ntop (int af, const void *src, char *dst, int size);
N#endif /* RTE_Network_Socket_BSD */
N
N//  ==== Interface User API ====
N
N/// \brief Get the current value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_GetOption (uint32_t if_id, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetOption (uint32_t if_id, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set default network interface for Internet access. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip_version    IP version as specified by \ref netIF_Version.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetDefault (uint32_t if_id, netIF_Version ip_version);
N
N//  ==== Ethernet Interface User API ====
N
N/// \brief Send raw Ethernet data. [\ref thread-safe]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netETH_SendRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Determine whether the ARP table has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     type          address cache type.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheIP (uint32_t if_id, const uint8_t *ip4_addr, netARP_CacheType type);
N
N/// \brief Determine whether the ARP table has IP address resolved for requested MAC address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheMAC (uint32_t if_id, const uint8_t *mac_addr);
N
N/// \brief Get IP address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip4_addr      resolved IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip4_addr);
N
N/// \brief Get MAC address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetMAC (uint32_t if_id, const uint8_t *ip4_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_Probe (uint32_t if_id, const uint8_t *ip4_addr, netARP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_ProbeX (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Determine whether neighbor cache has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_CacheIP (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Get IP address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip6_addr      resolved IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip6_addr);
N
N/// \brief Get MAC address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetMAC (uint32_t if_id, const uint8_t *ip6_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_Probe (uint32_t if_id, const uint8_t *ip6_addr, netNDP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_ProbeX (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Join this host to a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Join (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Leave a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Leave (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Enable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Enable (uint32_t if_id);
N
N/// \brief Disable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Disable (uint32_t if_id);
N
N/// \brief Set DHCP Option value at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_SetOption (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Enable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mode          DHCPv6 operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Enable (uint32_t if_id, netDHCP6_Mode mode);
N
N/// \brief Disable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Disable (uint32_t if_id);
N
N//  ==== Ethernet Interface Callbacks ====
N
N/// \brief Notify the user of Ethernet link state change event. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     event         Ethernet link state event as defined in \ref netETH_Event.
N/// \param[in]     val           pointer to the event value.
N/// \return        none.
Nextern void      netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val);
N
N/// \brief Receive raw Ethernet data. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the received data.
N/// \param[in]     len           length of received data in bytes.
N/// \return        none.
Nextern void      netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Notify the user of DHCP event or extended DHCP option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Notify the user of DHCPv6 event or extended DHCPv6 option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCPv6 option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP6_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N//  ==== WiFi Interface User API ====
N
N/// \brief Search for available WiFi networks. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    scan_info     array of structures for storing the scan information.
N/// \param[in,out] scan_num      input maximum number, return number of WiFi networks found.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Scan (uint32_t if_num, NET_WIFI_SCAN_INFO scan_info[], uint32_t *scan_num);
N
N/// \brief Get the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetOption (uint32_t if_num, netWiFi_Option option, void *buf, uint32_t buf_len);
N
N/// \brief Set the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_SetOption (uint32_t if_num, netWiFi_Option option, const void *buf, uint32_t buf_len);
N
N/// \brief Activate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     config        pointer to the structure with configuration parameters.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Activate (uint32_t if_num, const NET_WIFI_CONFIG *config);
N
N/// \brief Deactivate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Deactivate (uint32_t if_num);
N
N/// \brief Get the connection state of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      connection state:
N///               - true       = Station connected to access point.
N///               - false      = Station not connected.
Nextern bool      netWiFi_IsConnected (uint32_t if_num);
Xextern _Bool      netWiFi_IsConnected (uint32_t if_num);
N
N/// \brief Get the network information of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    net_info      structure for storing the network information.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetNetInfo (uint32_t if_num, NET_WIFI_NET_INFO *net_info);
N
N//  ==== PPP Interface User API ====
N
N/// \brief Start PPP interface to accept incoming PPP connection. [\ref thread-safe]
N/// \param[in]     username      remote username for authentication.
N/// \param[in]     password      remote password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Listen (const char *username, const char *password);
N
N/// \brief Start a dial-up connection to remote PPP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote PPP server.
N/// \param[in]     username      username for authentication.
N/// \param[in]     password      password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Connect (const char *dial_num, const char *username, const char *password);
N
N/// \brief Disconnect PPP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Close (void);
N
N/// \brief Determine the state of PPP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netPPP_LinkUp (void);
Xextern _Bool      netPPP_LinkUp (void);
N
N//  ==== SLIP Interface User API ====
N
N/// \brief Start SLIP interface to accept incoming SLIP connections. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Listen (void);
N
N/// \brief Start a dial-up connection to remote SLIP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote SLIP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Connect (const char *dial_num);
N
N/// \brief Disconnect SLIP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Close (void);
N
N/// \brief Determine the state of SLIP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netSLIP_LinkUp (void);
Xextern _Bool      netSLIP_LinkUp (void);
N
N//  ==== Ping User API ====
N
N/// \brief Start ICMP ping process. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of remote host.
N/// \param[in]     cb_func       callback function to call, when ping session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_Echo (const NET_ADDR *addr, netPing_cb_t cb_func);
N
N/// \brief Start ICMP ping process in blocking mode. [\ref thread-safe]
N/// \param[in]     target        remote hostname or absolute IP address.
N/// \param[in]     flags         ping process control flags.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_EchoX (const char *target, uint32_t flags);
N
N//  ==== DNS Client User API ====
N
N/// \brief Resolve IP address of a host from a hostname. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     cb_func       callback function to call, when DNS session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByName (const char *name, int16_t addr_type, netDNSc_cb_t cb_func);
N
N/// \brief Resolve IP address of a host from a hostname in blocking mode. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    addr          structure that will receive resolved IP address of the hostname.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByNameX (const char *name, int16_t addr_type, NET_ADDR *addr);
N
N/// \brief Flush or clear the local DNS cache. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_ClearCache (void);
N
N//  ==== FTP Server User API ====
N
N/// \brief Start FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Start (void);
N
N/// \brief Stop FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Stop (void);
N
N/// \brief Check if FTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netFTPs_Running (void);
Xextern _Bool      netFTPs_Running (void);
N
N/// \brief Get port number of FTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netFTPs_GetPort (void);
N
N/// \brief Set port number of FTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of FTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of FTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPassword (const char *password);
N
N/// \brief Determine if FTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netFTPs_LoginActive (void);
Xextern _Bool      netFTPs_LoginActive (void);
N
N/// \brief Enable or disable FTP server authentication. [\ref thread-safe]
N/// \param[in]     login       new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_LoginOnOff (bool login);
Xextern netStatus netFTPs_LoginOnOff (_Bool login);
N
N//  ==== FTP Server Access Interface ====
N
N/// \brief Accept or deny connection from remote FTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote FTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== FTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exists in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netFTPs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Check if remote user is allowed to access a file on FTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         full path of a file to access.
N/// \param[in]     access        access mode as defined with Network Access definitions.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
Xextern _Bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netFTPs_GetUserId (void);
N
N//  ==== FTP Server User Callbacks ====
N
N/// \brief Notify the user application about events in FTP server service. [\ref user-provided]
N/// \param[in]     event         FTP Server notification event as specified in \ref netFTPs_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPs_Notify (netFTPs_Event event);
N
N//  ==== FTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N/// \brief Delete a file in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to delete.
N/// \return
N///              - true        = File successfully deleted.
N///              - false       = Failed to delete a file.
Nextern bool      netFTPs_fdelete (const char *fname);
Xextern _Bool      netFTPs_fdelete (const char *fname);
N
N/// \brief Rename a file or directory in FTP server. [\ref interface]
N/// \param[in]     fname         old name to rename from.
N/// \param[in]     newname       new name to rename to.
N/// \return
N///              - true        = File or directory successfully renamed.
N///              - false       = Failed to rename a file or directory.
Nextern bool      netFTPs_frename (const char *fname, const char *newname);
Xextern _Bool      netFTPs_frename (const char *fname, const char *newname);
N
N/// \brief Make a new directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to create.
N/// \return
N///              - true        = Directory successfully created.
N///              - false       = Failed to create a directory.
Nextern bool      netFTPs_mkdir (const char *path);
Xextern _Bool      netFTPs_mkdir (const char *path);
N
N/// \brief Remove an empty directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to remove.
N/// \return
N///              - true        = Directory successfully removed.
N///              - false       = Failed to remove a directory.
Nextern bool      netFTPs_rmdir (const char *path);
Xextern _Bool      netFTPs_rmdir (const char *path);
N
N/// \brief Search the file system directory for matching files. [\ref interface]
N/// \param[in]     mask          file mask filter.
N/// \param[out]    fname         buffer to write filename to.
N///                              - NULL for none.
N/// \param[out]    fsize         pointer to where to return the file size.
N///                              - NULL for none.
N/// \param[out]    ftime         pointer to where to return the created or last modified time.
N///                              - NULL for none.
N/// \param[in]     first         find first file.
N/// \return      status information:
N///              - NET_FS_ATTR_FILE      = File found.
N///              - NET_FS_ATTR_DIRECTORY = Directory found.
N///              - 0                     = No entry found.
Nextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, bool first);
Xextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, _Bool first);
N
N//  ==== FTP Client User API ====
N
N/// \brief Start FTP client file operation session. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote FTP server.
N/// \param[in]     command       FTP command to perform.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPc_Connect (const NET_ADDR *addr, netFTP_Command command);
N
N//  ==== FTP Client User Callbacks ====
N
N/// \brief Request parameters for FTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netFTPc_Process (netFTPc_Request request, char *buf, uint32_t buf_len);
N
N/// \brief Notify the user application when FTP client operation ends. [\ref user-provided]
N/// \param[in]     event         FTP client notification event as specified in \ref netFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPc_Notify (netFTPc_Event event);
N
N//  ==== FTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in FTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Server User API ====
N
N/// \brief Start the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Start (void);
N
N/// \brief Stop the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Stop (void);
N
N/// \brief Check if the TFTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTFTPs_Running (void);
Xextern _Bool      netTFTPs_Running (void);
N
N/// \brief Get port number of the TFTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTFTPs_GetPort (void);
N
N/// \brief Set port number of the TFTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of TFTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netTFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of TFTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetRootPath (const char *path);
N
N//  ==== TFTP Server Access Interface ====
N
N/// \brief Accept or deny connection from a remote TFTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== TFTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in the TFTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Client User API ====
N
N/// \brief Put a file to a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Put (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N/// \brief Retrieve a file from a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Get (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N//  ==== TFTP Client User Callbacks ====
N
N/// \brief Notify the user application when TFTP client operation ends. [\ref user-provided]
N/// \param[in]     event         TFTP client notification event as specified in \ref netTFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netTFTPc_Notify (netTFTPc_Event event);
N
N//  ==== TFTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in the TFTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== Telnet Server User API ====
N
N/// \brief Start the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Start (void);
N
N/// \brief Stop the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Stop (void);
N
N/// \brief Check if the Telnet server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTELNETs_Running (void);
Xextern _Bool      netTELNETs_Running (void);
N
N/// \brief Get port number of the Telnet server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTELNETs_GetPort (void);
N
N/// \brief Set port number of the Telnet server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPort (uint16_t port);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPassword (const char *password);
N
N/// \brief Determine if Telnet server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netTELNETs_LoginActive (void);
Xextern _Bool      netTELNETs_LoginActive (void);
N
N/// \brief Enable or disable Telnet server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_LoginOnOff (bool login);
Xextern netStatus netTELNETs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected Telnet client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the Telnet server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netTELNETs_GetSession (void);
N
N/// \brief Check command string for a command. [\ref thread-safe]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[in]     user_cmd      user command to check for (in upper case).
N/// \return
N///              - true        = Command found in command string.
N///              - false       = Command not found.
Nextern bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
Xextern _Bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
N
N/// \brief Request a repeated call to netTELNETs_ProcessCommand function. [\ref thread-safe]
N/// \param[in]     delay         time period to wait in number of 100ms ticks.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RepeatCommand (uint32_t delay);
N
N/// \brief Request unsolicited message processing in netTELNETs_ProcessMessage function. [\ref thread-safe]
N/// \param[in]     session       session identification, when multiple connections are active.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RequestMessage (int32_t session);
N
N//  ==== Telnet Server User Callbacks ====
N
N/// \brief Process and execute a command requested by the Telnet client. [\ref user-provided]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[out]    buf           output buffer to write the return message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again for the same command.
N///                - return len | (1u<<30) = disconnect flag, the system disconnects
N///                                          the Telnet client.
Nextern uint32_t  netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Request a message for a Telnet server session. [\ref user-provided]
N/// \param[in]     msg           code of requested message.
N/// \param[out]    buf           output buffer to write the message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len);
N
N//  ==== Telnet Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote Telnet client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote Telnet client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== Telnet Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netTELNETs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netTELNETs_GetUserId (void);
N
N//  ==== HTTP Server User API ====
N
N/// \brief Start the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Start (void);
N
N/// \brief Stop the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Stop (void);
N
N/// \brief Check if the HTTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netHTTPs_Running (void);
Xextern _Bool      netHTTPs_Running (void);
N
N/// \brief Get port number of the HTTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netHTTPs_GetPort (void);
N
N/// \brief Set port number of the HTTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of HTTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netHTTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of HTTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPassword (const char *password);
N
N/// \brief Determine if the HTTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netHTTPs_LoginActive (void);
Xextern _Bool      netHTTPs_LoginActive (void);
N
N/// \brief Enable or disable HTTP server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_LoginOnOff (bool login);
Xextern netStatus netHTTPs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected remote HTTP client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the HTTP server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netHTTPs_GetSession (void);
N
N/// \brief Retrieve the preferred language setting from the browser. [\ref thread-safe]
N/// \return        pointer to the language code, a null-terminated string.
Nextern const char *netHTTPs_GetLanguage (void);
N
N/// \brief Get Content-Type HTML header, received in XML post request. [\ref thread-safe]
N/// \return        pointer to content type header, a null-terminated string.
Nextern const char *netHTTPs_GetContentType (void);
N
N//  ==== HTTP Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote HTTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote HTTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== HTTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \param[in]     password      pointer to password.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netHTTPs_CheckAccount (const char *username, const char *password);
N
N/// \brief Retrieve the secret word for the selected user. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[out]    buf           buffer to store the secret word to.
N/// \param[in]     buf_len       length of buffer.
N/// \return        none.
Nextern void      netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len);
N
N/// \brief Check if remote user is allowed to access a file on HTTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         name of a file to access.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
Xextern _Bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
N
N/// \brief Retrieve the user identification. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netHTTPs_GetUserId (void);
N
N/// \brief Calculate HA1 hash value for the given credentials. [\ref thread-safe]
N/// \param[in]     username      username, a null-terminated string.
N/// \param[in]     password      password, a null-terminated string.
N/// \param[out]    buf           buffer to store the hash value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_CalcHashHA1 (const char *username, const char *password, char *buf, uint32_t buf_len);
N
N//  ==== HTTP Server File System Interface ====
N
N/// \brief Open a file for reading in HTTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netHTTPs_fopen (const char *fname);
N
N/// \brief Close a file previously open in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netHTTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netHTTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Read a string from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           output buffer to write data to.
N/// \param[in]     size          size of output buffer.
N/// \return      status information:
N///              - Pointer to string on success.
N///              - NULL in case of an error.
Nextern char     *netHTTPs_fgets (void *file, char *buf, uint32_t size);
N
N/// \brief Retrieve file size and last modification time. [\ref interface]
N/// \param[in]     fname         name of the file.
N/// \param[out]    fsize         file size in bytes.
N/// \param[out]    ftime         created or last modified time.
N/// \return        none.
Nextern void      netHTTPs_fstat (const char *fname, uint32_t *fsize, uint32_t *ftime);
N
N//  ==== HTTP Server CGI ====
N
N/// \brief Process query string received by GET request. [\ref user-provided]
N/// \param[in]     qstr          pointer to the query string.
N/// \return        none.
Nextern void      netCGI_ProcessQuery (const char *qstr);
N
N/// \brief Process data received by POST request. [\ref user-provided]
N/// \param[in]     code          callback context:
N///                              - 0 = www-url-encoded form data.
N///                              - 1 = filename for file upload (null-terminated string).
N///                              - 2 = file upload raw data.
N///                              - 3 = end of file upload (file close requested).
N///                              - 4 = any other type of POST data (single or last stream).
N///                              - 5 = the same as 4, but with more data to follow.
N/// \param[in]     data          pointer to POST data.
N/// \param[in]     len           length of POST data.
N/// \return        none.
Nextern void      netCGI_ProcessData (uint8_t code, const char *data, uint32_t len);
N
N/// \brief Generate dynamic web data based on a CGI script. [\ref user-provided]
N/// \param[in]     env           environment string.
N/// \param[out]    buf           output data buffer.
N/// \param[in]     buf_len       size of output buffer (from 536 to 1440 bytes).
N/// \param[in,out] pcgi          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1U<<31) = repeat flag, the system calls this function
N///                                          again for the same script line.
N///                - return len | (1U<<30) = force transmit flag, the system transmits
N///                                          current packet immediately.
Nextern uint32_t  netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi);
N
N/// \brief Process environment variables and convert to ANSI format. [\ref thread-safe]
N/// \param[in]     env           pointer to environment variables.
N/// \param[out]    ansi          output buffer to write converted variable to.
N/// \param[in]     max_len       maximum length of environment variable.
N/// \return      status information:
N///              - pointer to the remaining environment variables to process.
N///              - NULL if there are no more environment variables to process.
Nextern const char *netCGI_GetEnvVar (const char *env, char *ansi, uint32_t max_len);
N
N/// \brief Override default character encoding in HTML documents. [\ref user-provided]
N/// \return        pointer to user defined character set type.
Nextern const char *netCGI_Charset (void);
N
N/// \brief Add custom MIME type for unsupported file types. [\ref user-provided]
N/// \param[in]     file_ext      filename extension, a null-terminated string.
N/// \return      MIME type information:
N///                - pointer to user defined Content-Type.
N///                - NULL for unknown type.
Nextern const char *netCGI_ContentType (const char *file_ext);
N
N/// \brief Redirect resource URL address to a new location. [\ref user-provided]
N/// \param[in]     file_name     resource filename, a null-terminated string.
N/// \return      URL redirection information:
N///                - pointer to user defined Location.
N///                - NULL for no URL address redirection.
Nextern const char *netCGI_Redirect (const char *file_name);
N
N/// \brief Override default Content-Type for CGX script files. [\ref user-provided]
N/// \return        pointer to user defined Content-Type.
Nextern const char *netCGX_ContentType (void);
N
N/// \brief Add custom HTTP response header. [\ref user-provided]
N/// \return        pointer to user defined HTTP header.
Nextern const char *netCGI_CustomHeader (void);
N
N//  ==== SMTP Client User API ====
N
N/// \brief Start SMTP client to send an email in legacy mode. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_Connect (const NET_ADDR *addr);
N
N/// \brief Send an email in blocking mode. [\ref thread-safe]
N/// \param[in]     mail          pointer to email content descriptor.
N/// \param[in]     mta           pointer to mail transfer agent descriptor.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_SendMail (const NET_SMTP_MAIL *mail, const NET_SMTP_MTA *mta);
N
N//  ==== SMTP Client User Callbacks ====
N
N/// \brief Request parameters for SMTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again when \a request is \ref netSMTPc_RequestBody.
Nextern uint32_t  netSMTPc_Process (netSMTPc_Request request, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Notify the user application when SMTP client operation ends. [\ref user-provided]
N/// \param[in]     event         SMTP client notification event as specified in \ref netSMTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netSMTPc_Notify (netSMTPc_Event event);
N
N/// \brief Accept or deny authentication requested by SMTP server. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return
N///              - true        = Authentication is accepted.
N///              - false       = Authentication is denied.
Nextern bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
Xextern _Bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
N
N//  ==== SMTP Client File System Interface ====
N
N/// \brief Open a file for reading in SMTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netSMTPc_fopen (const char *fname);
N
N/// \brief Close a file previously open in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netSMTPc_fclose (void *file);
N
N/// \brief Read block of data from a file in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netSMTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N//  ==== SNTP Client User API ====
N
N/// \brief Set mode of operation for SNTP client. [\ref thread-safe]
N/// \param[in]     mode          SNTP client operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_SetMode (netSNTPc_Mode mode);
N
N/// \brief Determine current time from NTP or SNTP time server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of NTP or SNTP server.
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[in]     cb_func       callback function to call, when the session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTime (const NET_ADDR *addr, netSNTPc_cb_t cb_func);
N
N/// \brief Determine current time from NTP or SNTP time server in blocking mode. [\ref thread-safe]
N/// \param[in]     server        server name or absolute IP address (FQDN or IP address).
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[out]    seconds       pointer to the variable to return time in seconds.
N/// \param[out]    seconds_fraction
N///                              pointer to the variable to return fraction of seconds.
N///                              - NULL for none.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTimeX (const char *server, uint32_t *seconds, uint32_t *seconds_fraction);
N
N//  ==== SNMP Agent User API ====
N
N/// \brief Send a trap message to the Trap Manager. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of the Trap server.
N///                              - NULL to use Trap server IP address from system configuration.
N/// \param[in]     generic       generic trap type:
N///                              - 0  = ColdStart trap.
N///                              - 1  = WarmStart trap.
N///                              - 2  = LinkDown trap.
N///                              - 3  = LinkUp trap.
N///                              - 4  = AuthenticationFailure trap.
N///                              - 5  = EgpNeighborLoss trap.
N///                              - 6  = EnterpriseSpecific trap.
N/// \param[in]     specific      specific trap type for generic enterpriseSpecific trap:
N///                              - must be set to 0 for generic traps 0 ... 5
N/// \param[in]     obj_list      object list included in trap message.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_Trap (const NET_ADDR *addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list);
N
N/// \brief Change SNMP community to a new community. [\ref thread-safe]
N/// \param[in]     community     new community, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetCommunity (const char *community);
N
N/// \brief Register MIB table to SNMP Agent. [\ref thread-safe]
N/// \param[in]     info          pointer to MIB table.
N/// \param[in]     size          size of MIB table in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetMIB_Table (const NET_SNMP_MIB_INFO *info, uint32_t size);
N
N// ==== Network Address Conversion ====
N
N/// \brief Convert IP address from binary to text form. [\ref thread-safe]
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     ip_addr       IPv4 or IPv6 address in binary form.
N/// \param[out]    string_buf    buffer to store converted IP address to.
N/// \param[in]     buf_len       length of a string buffer, at least:
N///                              - 16 characters for IPv4 address.
N///                              - 40 characters for IPv6 address.
N/// \return      pointer to \a string_buf with null-terminated IP address string.
N///              - NULL in case of parameter error.
Nextern const char *netIP_ntoa (int16_t addr_type, const uint8_t *ip_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert IP address from text to binary form. [\ref thread-safe]
N/// \param[in]     addr_string   network address string:
N///                              - in dotted-decimal IPv4 notation.
N///                              - in compressed colon-hexadecimal IPv6 notation.
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    ip_addr       IPv6 or IPv6 address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
Xextern _Bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
N
N/// \brief Convert MAC address from binary to text form. [\ref thread-safe]
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \param[out]    string_buf    buffer to store converted MAC address to.
N/// \param[in]     buf_len       length of a string buffer, at least 18 characters.
N/// \return      pointer to \a string_buf with null-terminated MAC address string.
N///              - NULL in case of parameter error.
Nextern const char *netMAC_ntoa (const uint8_t *mac_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert MAC address from text to binary form. [\ref thread-safe]
N/// \param[in]     mac_string    address string in hyphen MAC-address notation.
N/// \param[out]    mac_addr      MAC address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
Xextern _Bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_DS_H */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 2
N
N#ifdef __clang__
S  #pragma clang diagnostic ignored "-Wpadded"
N#endif
N
N/// General definitions
N#define NET_HEADER_LEN      4           ///< Network frame header length
N#define PHY_HEADER_LEN      14          ///< Physical/ethernet header length
N#define ETH_MAX_FRAME_SIZE  1514        ///< Maximum size of ethernet frame
N#define NET_USERNAME_SIZE   16          ///< Authentication username buffer size
N#define NET_PASSWORD_SIZE   16          ///< Authentication password buffer size
N#define NET_HA1_HASH_LEN    32          ///< HTTP Authentication HA1 hash length
N#define NET_ROOT_PATH_SIZE  128         ///< Root path buffer size
N#define NET_TCP_NO_ACK      0xFFFFFFFF  ///< Callback return value for no ACK
N#define NET_IF_CLASS_LOOP   (0 << 8)    ///< Loopback interface class
N
N/// Debug process definitions
N#ifdef RTE_Network_Debug_STDIO
S#define NET_SYSTEM_CORE     0           ///< Main system core
S#define NET_DYNAMIC_MEMORY  1           ///< Dynamic memory management
S#define NET_ETH_INTERFACE   2           ///< Ethernet interface 0
S#define NET_WIFI_INTERFACE  3           ///< WiFi interface
S#define NET_PPP_INTERFACE   4           ///< PPP interface
S#define NET_SLIP_INTERFACE  5           ///< SLIP interface
S#define NET_LOCAL_LOOPBACK  6           ///< Loopback virtual interface
S#define NET_ARP_CACHE       7           ///< Ethernet ARP cache
S#define NET_IP4_CORE        8           ///< IPv4 core and localhost
S#define NET_ICMP_CONTROL    9           ///< ICMP control service for IPv4
S
S#define NET_IGMP_HOST       10          ///< IGMP group managememt host for IPv4
S#define NET_IP6_CORE        11          ///< IPv6 core and localhost
S#define NET_ICMP6_CONTROL   12          ///< ICMP6 control service for IPv6
S#define NET_NDP_CACHE       13          ///< Ethernet Neighbor Discovery for IPv6
S#define NET_UDP_SOCKET      14          ///< UDP native socket
S#define NET_TCP_SOCKET      15          ///< TCP native socket
S#define NET_BSD_SOCKET      16          ///< BSD socket interface
S#define NET_NBNS_CLIENT     17          ///< NBNS client service for IPv4
S#define NET_DHCP_CLIENT     18          ///< DHCP client service for IPv4
S#define NET_DHCP6_CLIENT    19          ///< DHCP client service for IPv6
S
S#define NET_DNS_CLIENT      20          ///< DNS client service
S#define NET_SNMP_AGENT      21          ///< SNMP agent module
S#define NET_HTTP_SERVER     22          ///< HTTP server service
S#define NET_FTP_SERVER      23          ///< FTP server service
S#define NET_FTP_CLIENT      24          ///< FTP client service
S#define NET_TELNET_SERVER   25          ///< Telnet server service
S#define NET_TFTP_SERVER     26          ///< TFTP server service
S#define NET_TFTP_CLIENT     27          ///< TFTP client service
S#define NET_SMTP_CLIENT     28          ///< SMTP client service
S#define NET_SNTP_CLIENT     29          ///< SNTP client service
N#endif /* RTE_Network_Debug_STDIO */
N
N/// Telnet definitions
N#define TELNET_LBUF_SZ      96          ///< Command line buffer size in bytes
N#define TELNET_HIST_SZ      128         ///< Command history buffer size in bytes
N#define TELNET_FIFO_SZ      128         ///< Input character Fifo buffer in bytes
N
N/// BSD Socket ioctl commands
N#define FIONBIO             1           ///< Set mode (blocking/non-blocking)
N#define FIO_DELAY_ACK       2           ///< Set DELAY_ACK mode for stream socket
N#define FIO_KEEP_ALIVE      3           ///< Set KEEP_ALIVE mode for stream socket
N#define FIO_FLOW_CTRL       4           ///< Set FLOW_CTRL mode for stream socket
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// Network OS identifier
Ntypedef void *NETOS_ID;
N
N/// Network scheduler function type
Ntypedef void (*net_sys_fn_t) (void);
N
N/// System Error codes
Ntypedef enum net_error {
N  NET_ERROR_MEM_ALLOC,                  ///< Alloc memory failed, out of memory
N  NET_ERROR_MEM_FREE,                   ///< Free memory failed, memory slot invalid
N  NET_ERROR_MEM_CORRUPT,                ///< Memory corruption detected
N  NET_ERROR_CONFIG,                     ///< Network configuration error detected
N  NET_ERROR_UDP_ALLOC,                  ///< No free UDP sockets available
N  NET_ERROR_TCP_ALLOC,                  ///< No free TCP sockets available
N  NET_ERROR_TCP_STATE                   ///< TCP socket in undefined state
N} NET_ERROR;
N
N/// Frame buffer structure
Ntypedef struct net_frame {
N  uint16_t length;                      ///< Length of data in frame
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[];                   ///< Buffer data (protocol headers + data)
N	//}
N} NET_FRAME;
N
N/// Buffer queue structure
Ntypedef struct net_buffer {
N  struct net_buffer *next;              ///< Next buffer in the list
N  uint16_t length;                      ///< Length of data in buffer
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[];                  ///< Buffer data
N	//}
N} NET_BUFFER;
N
N/// Library variant optimization
N#ifdef RTE_Network_IPv6
S  #define  Network_IPv6
S  #define __ADDR            NET_ADDR
S  #define __ADDR_IP_LEN     NET_ADDR_IP6_LEN
N#else
N  #define __ADDR            NET_ADDR4
N  #define __ADDR_IP_LEN     NET_ADDR_IP4_LEN
N#endif
N#define __FRAME(buf)        ((NET_FRAME *)(uint32_t)(buf))
N#define __BUFFER(buf)       ((NET_BUFFER *)(uint32_t)(buf))
N
N/// Local Machine info version 4
Ntypedef struct net_localm {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint16_t Reserved;                    ///< Reserved (used for alignment)
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Local IP address
X  uint8_t  IpAddr[4];    
N  uint8_t  NetMask[NET_ADDR_IP4_LEN];   ///< Netmask
X  uint8_t  NetMask[4];   
N  uint8_t  DefGW[NET_ADDR_IP4_LEN];     ///< Default gateway
X  uint8_t  DefGW[4];     
N  uint8_t  PriDNS[NET_ADDR_IP4_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[4];    
N  uint8_t  SecDNS[NET_ADDR_IP4_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[4];    
N} NET_LOCALM;
N
N/// Local Machine info version 6
Ntypedef struct net_localm6 {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint8_t  HopLimit;                    ///< Hop limit for outging IP packets
N  uint8_t  PrefixLen;                   ///< Subnet prefix length
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  TempAddr[NET_ADDR_IP6_LEN];  ///< Temporary IPv6 address
X  uint8_t  TempAddr[16];  
N  uint8_t  LLAddr[NET_ADDR_IP6_LEN];    ///< Link-local address
X  uint8_t  LLAddr[16];    
N  uint8_t  DefGW[NET_ADDR_IP6_LEN];     ///< Default gateway
X  uint8_t  DefGW[16];     
N  uint8_t  PriDNS[NET_ADDR_IP6_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[16];    
N  uint8_t  SecDNS[NET_ADDR_IP6_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[16];    
N} NET_LOCALM6;
N
N/// ARP Cache Entry info
Ntypedef struct net_arp_info {
N  uint8_t  State;                       ///< Cache entry state
N  uint8_t  Type;                        ///< Cache entry type
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< IPv4 address
X  uint8_t  IpAddr[4];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  Reserved;                    ///< Reserved (not used)
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_ARP_INFO;
N
N/// IGMP Group info
Ntypedef struct net_igmp_info {
N  uint8_t  State;                       ///< Group membership state
N  uint8_t  Tout;                        ///< Timeout timer for reports
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Group IPv4 address
X  uint8_t  IpAddr[4];    
N} NET_IGMP_INFO;
N
N/// NDP Cache Entry info
Ntypedef struct net_ndp_info {
N  uint8_t  State;                       ///< Cache state
N  uint8_t  Flags;                       ///< State flags
N  uint16_t Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Id;                          ///< Entry identification number
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_NDP_INFO;
N
N/// IP4-Frag session info
Ntypedef struct net_ip4_frag_info {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Len;                         ///< Total length of datagram fragments
N  NET_FRAME *frag_list;                 ///< Fragment queue list
N} NET_IP4_FRAG_INFO;
N
N/// UDP Socket info
Ntypedef struct net_udp_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Flags;                       ///< State flags and options
N  uint16_t LocPort;                     ///< Local UDP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  uint8_t  McastTtl;                    ///< Multicast time to live for IPv4
N  uint8_t  HopLimit;                    ///< Multicast hop limit for IPv6
N  const struct net_if_cfg *net_if;      ///< Network interface for broadcast frames
N  netUDP_cb_t cb_func;                  ///< Event callback function
N} NET_UDP_INFO;
N
N/// TCP Socket info
Ntypedef struct net_tcp_info {
N  netTCP_State State;                   ///< Socket state
N  uint8_t  Type;                        ///< Socket type
N  uint8_t  Flags;                       ///< State flags
N  uint16_t LocPort;                     ///< Local TCP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  const uint8_t *LocAddr;               ///< Pointer to local IPv6 address
N  __ADDR   Peer;                        ///< Peer IP address and port
X  NET_ADDR4   Peer;                        
N  uint16_t MaxSegSize;                  ///< Transmit max. segment size
N  uint16_t ConnTout;                    ///< Connection timeout
N  uint16_t AliveTimer;                  ///< Keep alive timer
N  uint16_t RetryTimer;                  ///< Retransmission timer
N  uint8_t  AckTimer;                    ///< Receive delay-ack timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  DupAcks;                     ///< Number of duplicate acks (fast recovery)
N  uint32_t SendUna;                     ///< Send sequence number unacknowledged
N  uint32_t SendNext;                    ///< Next send sequence number
N  uint32_t SendChk;                     ///< Check sequence number for dupacks
N  uint32_t SendWl1;                     ///< Sequence number of last window update
N  uint32_t SendWl2;                     ///< Acknowledge number of last window update
N  uint16_t SendWin;                     ///< Current send window
N  int16_t  RttSa;                       ///< Scaled average for RTT estimator
N  int16_t  RttSv;                       ///< Scaled deviation for RTT estimator
N  uint16_t CWnd;                        ///< Congestion window
N  uint16_t SsThresh;                    ///< Slow start treshold
N  uint16_t RecWin;                      ///< Current receive window
N  uint32_t RecNext;                     ///< Next receive sequence number
N  NET_FRAME *unack_list;                ///< Unacked queue list
N  const struct net_if_cfg *net_if;      ///< Network interface for the route
N  netTCP_cb_t cb_func;                  ///< Event callback function
N} NET_TCP_INFO;
N
N/// BSD Socket info
Ntypedef struct net_bsd_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Socket;                      ///< Assigned TCP/UDP socket
N  uint8_t  Flags;                       ///< Flags for socket option
N  uint8_t  Type;                        ///< Type of socket
N  __ADDR   RemHost;                     ///< Remote IP address and port
X  NET_ADDR4   RemHost;                     
N  __ADDR   LocHost;                     ///< Local IP address and port
X  NET_ADDR4   LocHost;                     
N  uint8_t  AcceptSock;                  ///< Accept socket list
N  uint8_t  ParentSock;                  ///< Parent (server) socket
N  uint16_t RecvTout;                    ///< Blocking receive timeout
N  uint16_t Timer;                       ///< Receiver timer
N  uint8_t  SendTout;                    ///< Blocking send timeout
N  uint8_t  xTimer;                      ///< Sender timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Event;                       ///< Owner wait-for events
N  uint8_t  xEvent;                      ///< Sender wait-for events
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class for IPv6
N  NETOS_ID Thread;                      ///< Socket owner thread
N  NETOS_ID xThread;                     ///< Socket sender thread
N  NET_BUFFER *buf_list;                 ///< Rx data buffer list
N} NET_BSD_INFO;
N
N/// DNS Cache Entry info
Ntypedef struct net_dns_info {
N  uint32_t HostId;                      ///< Host Id (CRC32 value of host name)
N  uint16_t Tout;                        ///< Cache timeout timer
N  int16_t  Type;                        ///< Address type: IPv4 or IPv6
N  uint8_t  IpAddr[__ADDR_IP_LEN];       ///< Internet IP address
X  uint8_t  IpAddr[4];       
N} NET_DNS_INFO;
N
N/// TFTP Server Session info
Ntypedef struct net_tftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned UDP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Retries;                     ///< Retry counter
N  __ADDR   Client;                      ///< Client IP address and port (TID)
X  NET_ADDR4   Client;                      
N  uint16_t BlockSz;                     ///< Transfer block size
N  uint16_t BlockNr;                     ///< Block number
N  uint8_t  Timer;                       ///< Timeout timer
N  uint16_t BufLen;                      ///< Length of retransmit buffer
N  uint8_t  *Buf;                        ///< Transmit/retransmit buffer
N  void     *File;                       ///< File handle pointer
N} NET_TFTP_INFO;
N
N/// Telnet Session info
Ntypedef struct net_telnet_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  BCnt;                        ///< Received data byte count
N  uint16_t Tout;                        ///< Timeout delay timer
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Widx;                        ///< Fifo buffer write index
N  uint8_t  Ridx;                        ///< Fifo buffer read index
N  uint8_t  hNext;                       ///< History command next position
N  uint8_t  hCurr;                       ///< History command current position
N  uint32_t SVar;                        ///< Session private variable
N  char     LBuf[TELNET_LBUF_SZ];        ///< Data line buffer
X  char     LBuf[96];        
N  char     Fifo[TELNET_FIFO_SZ];        ///< Fifo buffer for received line/keycodes
X  char     Fifo[128];        
N  char     Hist[TELNET_HIST_SZ];        ///< Command history buffer
X  char     Hist[128];        
N} NET_TELNET_INFO;
N
N/// FTP Session info
Ntypedef struct net_ftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< TCP control socket
N  uint16_t Flags;                       ///< State flags
N  __ADDR   Client;                      ///< Client IP address and port
X  NET_ADDR4   Client;                      
N  uint16_t DPort;                       ///< Data port (active or passive)
N  uint8_t  DSocket;                     ///< TCP data socket
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Resp;                        ///< Server response code
N  uint8_t  PathLen;                     ///< Size of the path string
N  char    *Path;                        ///< Current working directory
N  char    *Name;                        ///< Absolute file/folder path name
N  void    *File;                        ///< File handle pointer
N} NET_FTP_INFO;
N
N/// HTTP Session info
Ntypedef struct net_http_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint16_t Flags;                       ///< State flags
N  uint8_t  FType;                       ///< File type: html, jpeg, gif,...
N  uint8_t  PostSt;                      ///< POST method processing state
N  uint16_t DelimSz;                     ///< Boundary delimiter size
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  TlsId;                       ///< TLS context identifier
N  uint8_t  Method;                      ///< Request method (GET,POST,...)
N  uint32_t CGIvar;                      ///< CGI session private variable
N  uint32_t DLen;                        ///< Data length (number of bytes to send)
N  uint32_t Count;                       ///< Total number of bytes sent
N  uint16_t BCnt;                        ///< Number of bytes sent in last packet
N  char     Lang[6];                     ///< Selected web language: en-us, de, fr...
N  uint32_t LMDate;                      ///< Last modified date (UTC format)
N  char    *Script;                      ///< Script buffer pointer
N  char    *pDelim;                      ///< Multipart boundary delimiter value
N  char    *pUser;                       ///< User MIME type or Redirect URL
N  void    *sFile;                       ///< Script interpreter file pointer
N  void    *dFile;                       ///< Data file pointer
N} NET_HTTP_INFO;
N
N/// HTTP Nonce Cache Entry info
Ntypedef struct net_http_nonce {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Count;                       ///< Number of references to nonce
N  char     Val[24];                     ///< Nonce value base64 encoded
N} NET_HTTP_NONCE;
N
N/// HTTP Error page info
Ntypedef struct net_http_error {
N  const char *header;                   ///< Common page header
N  const char *footer;                   ///< Common page footer
N  const char *e401;                     ///< 401 Unauthorized
N  const char *e403;                     ///< 403 Forbidden
N  const char *e404;                     ///< 404 Not Found
N  const char *e501;                     ///< 501 Not Implemented
N} const NET_HTTP_ERROR;
N
N/// SYS Configuration info
Ntypedef struct net_sys_cfg {
N  uint32_t   *MemPool;                  ///< Dynamic memory pool buffer
N  uint32_t   MemSize;                   ///< Memory pool size in bytes
N  char       *Path;                     ///< Path buffer for root-enabled services
N  const char *HostName;                 ///< Configured Local host name
N  bool       AutoStart;                 ///< Auto-Start server service
X  _Bool       AutoStart;                 
N  bool       TxQueUsed;                 ///< Tx queue used for PPP or SLIP
X  _Bool       TxQueUsed;                 
N  const net_sys_fn_t *fn_init;          ///< Network Init-function table
N  const net_sys_fn_t *fn_run;           ///< Network Run-function table
N} const NET_SYS_CFG;
N
N/// netIF_GetOption functions
Ntypedef struct {
N  netStatus (*eth_get_option) (uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*wifi_get_option)(uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*ppp_get_option) (netIF_Option,uint8_t*,uint32_t);
N  netStatus (*slip_get_option)(netIF_Option,uint8_t*,uint32_t);
N} const NETIF_GETOPT_FUNC;
N
N/// netIF_SetOption functions
Ntypedef struct {
N  netStatus (*eth_set_option) (uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*wifi_set_option)(uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*ppp_set_option) (netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*slip_set_option)(netIF_Option,const uint8_t*,uint32_t);
N} const NETIF_SETOPT_FUNC;
N
N/// ARP Configuration info
Ntypedef struct net_arp_cfg {
N  struct net_arp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_ARP_INFO *Table;                  ///< Cache table array
N  uint8_t  TabSize;                     ///< Cache table size
N  uint8_t  TimeOut;                     ///< Cache expiration time in seconds
N  uint8_t  MaxRetry;                    ///< Number of retries to resolve MAC address
N  uint8_t  Resend;                      ///< Resend timeout in seconds
N  bool     Notify;                      ///< Notify on IP address changes
X  _Bool     Notify;                      
N} const NET_ARP_CFG;
N
N/// IGMP Configuration info
Ntypedef struct net_igmp_cfg {
N  struct net_igmp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_IGMP_INFO *Table;                 ///< Group table array
N  uint16_t TabSize;                     ///< Group table size
N} const NET_IGMP_CFG;
N
N/// DHCP Client Configuration info
Ntypedef struct net_dhcp_cfg {
N  struct net_dhcp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const char *Vcid;                     ///< Vendor class identifier
N  uint8_t    VcidLen;                   ///< Length of Vendor class identifier
N  uint8_t    OptBootfile:1;             ///< Option bootfile enable
N  uint8_t    OptNtpServ :1;             ///< Option NTP servers enable
N} const NET_DHCP_CFG;
N
N/// IP4 Configuration info
Ntypedef struct net_ip4_cfg {
N  const char  *IpAddr;                  ///< IPv4 address
N  const char  *NetMask;                 ///< IPv4 network mask
N  const char  *DefGW;                   ///< Default gateway IPv4 address
N  const char  *PriDNS;                  ///< Primary DNS server
N  const char  *SecDNS;                  ///< Secondary DNS server
N  uint16_t     Mtu;                     ///< Maximum transmission unit
N  uint8_t      NoEcho  :1;              ///< Disable ping/echo response
N  uint8_t      EnNbns  :1;              ///< Enable NBNS protocol
N  NET_ARP_CFG *ArpCfg;                  ///< ARP configuration
N  NET_IGMP_CFG *IgmpCfg;                ///< IGMP configuration
N  NET_DHCP_CFG *DhcpCfg;                ///< DHCP configuraton
N} const NET_IP4_CFG;
N
N/// NDP Configuration info
Ntypedef struct net_ndp_cfg {
N  struct net_ndp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_NDP_INFO *Table;                  ///< Neighbor cache table
N  uint8_t   TabSize;                    ///< Cache table size
N  uint8_t   TimeOut;                    ///< Cache expiration time in seconds
N  uint8_t   MaxRetry;                   ///< Number of retries to resolve MAC address
N  uint8_t   Resend;                     ///< Resend timeout in seconds
N} const NET_NDP_CFG;
N
N/// DHCP6 Client Configuration info
Ntypedef struct net_dhcp6_cfg {
N  struct net_dhcp6_ctrl   *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  uint8_t    Stateful  :1;              ///< Statefull mode enabled
N  uint8_t    OptVclass :1;              ///< Option Vendor class enabled
N  uint32_t   EnterpId;                  ///< Enterprise-number
N  const char *VcData;                   ///< Vendor class data
N} const NET_DHCP6_CFG;
N
N/// IP6 Configuration info
Ntypedef struct net_ip6_cfg {
N  const char   *IpAddr;                 ///< IPv6 address
N  const char   *DefGW;                  ///< Default gateway IPv6 address
N  const char   *PriDNS;                 ///< Primary DNS server
N  const char   *SecDNS;                 ///< Secondary DNS server
N  uint8_t       PrefixLen;              ///< Address prefix length
N  uint8_t       NoEcho :1;              ///< Disable ping/echo response
N  NET_NDP_CFG  *NdpCfg;                 ///< Neighbor discovery configuration
N  NET_DHCP6_CFG *Dhcp6Cfg;              ///< DHCPv6 configuration
N} const NET_IP6_CFG;
N
N/// Interface status info
Ntypedef struct net_if_state {
N  bool     LinkUp;                      ///< Link up or WiFi connected
X  _Bool     LinkUp;                      
N  bool     MacNew;                      ///< Mac address changed
X  _Bool     MacNew;                      
N  uint16_t Offload;                     ///< Checksum offload flags
N} NET_IF_STATE;
N
N/// General Interface descriptor
Ntypedef struct net_if_cfg {
N  NET_IF_STATE *State;                  ///< Interface Status
N  uint16_t     Id;                      ///< Interface Identifier
N  char         Name[6];                 ///< Interface Name null-terminated
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  NET_LOCALM  *localm;                  ///< Local machine info IPv4
N  NET_IP4_CFG *Ip4Cfg;                  ///< IPv4 configuration
N  NET_LOCALM6 *localm6;                 ///< Local machine info IPv6
N  NET_IP6_CFG *Ip6Cfg;                  ///< IPv6 configuration
N  bool (*send_frame)(uint32_t,          ///< Send frame function
X  _Bool (*send_frame)(uint32_t,          
N                     NET_FRAME*,uint8_t);
N  void (*config_mcast)(uint32_t);       ///< Config Multicast MAC filter for LAN
N  bool (*output_lan)(uint32_t,          ///< Low level output for LAN (Eth, WiFi)
X  _Bool (*output_lan)(uint32_t,          
N                     NET_FRAME*);
N} const NET_IF_CFG;
N
N/// Ethernet Interface descriptor
Ntypedef struct net_eth_cfg {
N  struct net_eth_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvMac;                  ///< Registered MAC driver
N  const void  *DrvPhy;                  ///< Registered PHY driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint16_t     VlanTag;                 ///< Vlan tag identifier
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t);           ///< Driver event notification callback
N} const NET_ETH_CFG;
N
N/// WiFi Interface descriptor
Ntypedef struct net_wifi_cfg {
N  struct net_wifi_ctrl    *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvWifi;                 ///< Registered WiFi driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint8_t      Mode;                    ///< WiFi Mode (Station, AP)
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t,void*);     ///< Driver event notification callback
N} const NET_WIFI_CFG;
N
N/// Serial Device Configuration info
Ntypedef struct net_com_cfg {
N  struct net_com_ctrl   *Ctrl;          ///< Serial control block
N  struct net_modem_ctrl *ModemCtrl;     ///< Modem service control block
N  const void *DrvUsart;                 ///< Registered USART driver
N  const void *DrvModem;                 ///< Registered MODEM driver
N  const char *InitString;               ///< Modem initialization string
N  uint32_t    Speed;                    ///< Connection speed
N  uint8_t     FlowCtrl;                 ///< Flow control
N  uint8_t     MaxDelay;                 ///< Max. thread polling delay in ms
N  uint8_t     RecTout;                  ///< Frame receive timeout in ticks
N  void (*cb_event)  (uint32_t);         ///< USART driver event callback
N  void (*cb_request)(const char*,       ///< Modem driver request callback
N                     const char*,uint32_t,uint32_t);
N} const NET_COM_CFG;
N
N/// PPP Interface descriptor
Ntypedef struct net_ppp_cfg {
N  struct net_ppp_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint32_t     ACCmap;                  ///< Async control character map
N  uint16_t     RetryTout;               ///< Retry timeout in ticks
N  uint16_t     EchoTout;                ///< LCP echo timeout in seconds
N  uint8_t      MaxRetry;                ///< Number of retries
N  uint8_t      EnAuth   :1;             ///< Enable authentication
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      ObtainIp :1;             ///< Obtain client IP address automatically
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  struct net_lcp_ctrl       *LcpCtrl;   ///< LCP Service control block
N  const struct net_ppp_auth *PapAuth;   ///< PAP Authentication service
N  const struct net_ppp_auth *ChapAuth;  ///< CHAP Authentication service
N  struct net_ipcp_ctrl      *IpcpCtrl;  ///< IPCP Service control block
N} const NET_PPP_CFG;
N
N/// PPP PAP/CHAP Configuration info
Ntypedef struct net_ppp_auth {
N  void *Ctrl;                           ///< Authentication control block
N  void (*init)   (NET_PPP_CFG*);        ///< Initialize authentication
N  void (*uninit) (NET_PPP_CFG*);        ///< De-initialize authentication
N  void (*run)    (NET_PPP_CFG*);        ///< Run authentication
N  void (*process)(NET_PPP_CFG*,NET_FRAME*);///< Process authentication frame
N} const NET_PPP_AUTH;
N
N/// SLIP Interface descriptor
Ntypedef struct net_slip_cfg {
N  struct net_slip_ctrl    *Ctrl;        ///< SLIP Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N} const NET_SLIP_CFG;
N
N/// IP4-Frag Configuration info
Ntypedef struct net_ip4_frag_cfg {
N  NET_IP4_FRAG_INFO *Scb;               ///< Reassembly control block array
N  uint8_t  NumSess;                     ///< Max. number of reassembly sessions
N  uint16_t ReassTout;                   ///< Reassembly timeout in ticks
N} const NET_IP4_FRAG_CFG;
N
N/// UDP Socket Configuration info
Ntypedef struct net_udp_cfg {
N  NET_UDP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of UDP sockets
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_UDP_CFG;
N
N/// TCP Socket Configuration info
Ntypedef struct net_tcp_cfg {
N  NET_TCP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of TCP sockets
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint16_t SynRetryTout;                ///< SYN retry timeout in ticks
N  uint16_t InitRetryTout;               ///< Initial retransmit timeout in ticks
N  uint16_t DefTout;                     ///< Default connect timeout in seconds
N  uint16_t MaxSegSize;                  ///< Maximum segment size value
N  uint16_t RecWinSize;                  ///< Receiving window size in bytes
N  uint8_t  ConnRetry;                   ///< Number of retries to connect
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_TCP_CFG;
N
N/// BSD Socket Configuration info
Ntypedef struct net_bsd_cfg {
N  NET_BSD_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of BSD sockets
N  uint16_t RecvTout;                    ///< Blocking recv timeout in ticks
N} const NET_BSD_CFG;
N
N/// DNS Client Configuration info
Ntypedef struct net_dns_cfg {
N  NET_DNS_INFO *Table;                  ///< Cache table array
N  uint8_t   TabSize;                    ///< Cache table size
N} const NET_DNS_CFG;
N
N/// mbedTLS interface functions
Ntypedef struct net_tls_if {
N  uint8_t  (*get_context)(int32_t,netTCP_cb_t);  ///< Allocate secure TLS context
N  void     (*connect)    (uint8_t,const char *); ///< Connect to remote endpoint
N  void     (*listen)     (uint8_t);              ///< Listen for incomming connections
N  uint8_t *(*get_buf)    (uint32_t);             ///< Get memory for send buffer
N  void     (*write)      (uint8_t,const uint8_t*,uint32_t);///< Write data to TLS session
N  void     (*close)      (uint8_t,uint8_t);      ///< Close TLS session
N} const NET_TLS_IF;
N
N/// SMTP Client Attachment functions
Ntypedef struct {
N  uint32_t (*mail_attach)  (char*,uint32_t);     ///< Compose attachment
N  uint32_t (*mime_header)  (char*,const void*);  ///< Add MIME multipart header
N  const char*(*parse_fname)(const char*,void*);  ///< Parse attachment file name(s)
N} const NET_SMTP_ATTACH;
N
N/// SMTP Client Configuration info
Ntypedef struct net_smtp_cfg {
N  uint8_t   DefTout;                    ///< Default inactivity timeout
N  struct {                              ///< File System interface functions
N    void    *(*fopen) (const char*);             ///< Open file for reading
N    uint32_t (*fread) (void*,uint8_t*,uint32_t); ///< Read file data
N    void     (*fclose)(void*);                   ///< Close file
N  } fs_if;
N  NET_SMTP_ATTACH *attach_if;           ///< Attachment support interface
N  NET_TLS_IF      *tls_if;              ///< mbedTLS interface functions
N} const NET_SMTP_CFG;
N
N/// SNMP Agent Configuration info
Ntypedef struct net_snmp_cfg {
N  uint16_t   PortNum;                   ///< Listening port number
N  uint16_t   TrapPort;                  ///< Trap port number
N  const char *TrapIp;                   ///< Trap server IP address
N  const char *Community;                ///< Community name
N} const NET_SNMP_CFG;
N
N/// SNTP Client Configuration info
Ntypedef struct net_sntp_cfg {
N  const char *SrvIp;                    ///< NTP/SNTP server IP address
N  bool       Bcast;                     ///< Broadcast client mode (for LAN only)
X  _Bool       Bcast;                     
N} const NET_SNTP_CFG;
N
N/// TFTP Server Configuration info
Ntypedef struct net_tftp_cfg {
N  NET_TFTP_INFO *Scb;                   ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t PortNum;                     ///< Listening port number
N  uint8_t  DefTout;                     ///< Inactive session timeout in seconds
N  bool     EnFwall;                     ///< Enable firewall support
X  _Bool     EnFwall;                     
N  const char *Root;                     ///< Root folder path
N} const NET_TFTP_CFG;
N
N/// TFTP Client Configuration info
Ntypedef struct net_tftpc_cfg {
N  uint16_t BlockSize;                   ///< Transfer block size
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint8_t  MaxRetry;                    ///< Number of retries
N} const NET_TFTPC_CFG;
N
N/// Telnet Server Configuration info
Ntypedef struct net_telnet_cfg {
N  NET_TELNET_INFO *Scb;                 ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint8_t  NoEcho;                      ///< Disable server echo mode
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_TELNET_CFG;
N
N/// FTP Server Configuration info
Ntypedef struct net_ftp_cfg {
N  NET_FTP_INFO *Scb;                    ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  uint8_t  MsgLen;                      ///< Length of welcome message
N  const char *Msg;                      ///< Server welcome message
N  const char *Root;                     ///< Root folder path
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_FTP_CFG;
N
N/// FTP Client Configuration info
Ntypedef struct net_ftpc_cfg {
N  uint8_t DefTout;                      ///< Default inactivity timeout
N  bool    PasvMode;                     ///< FTP passive mode used
X  _Bool    PasvMode;                     
N} const NET_FTPC_CFG;
N
N/// HTTP Server Authentication functions
Ntypedef struct {
N  void    (*init)      (void);          ///< Initialize HTTP authentication
N  void    (*uninit)    (void);          ///< De-initialize HTTP authentication
N  void    (*run)       (void);          ///< Run HTTP authentication
N  uint32_t(*add_line)  (void*,char*);   ///< Add authentication header line
N  bool    (*parse_line)(void*,char*);   ///< Parse authentication header line
X  _Bool    (*parse_line)(void*,char*);   
N  void    (*calc_hash) (const char*,    ///< Calculate Digest hash HA1 value
N                        const char*,uint8_t*);
N} const NET_HTTP_AUTH;
N
N/// HTTP Server Configuration info
Ntypedef struct net_http_cfg {
N  NET_HTTP_INFO *Scb;                   ///< Session control block array
N  uint8_t   NumSess;                    ///< Max. number of active sessions
N  bool      EnAuth;                     ///< Enable user authentication
X  _Bool      EnAuth;                     
N  uint16_t  PortNum;                    ///< Listening port number
N  const char *SrvId;                    ///< Server-Id http header
N  const char *Root;                     ///< Root folder path
N  const char *Realm;                    ///< Authentication realm space
N  uint8_t    RealmLen;                  ///< Length of realm string
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t   UserLen;                    ///< Length of admin username
N  uint8_t   PasswLen;                   ///< Length of admin password
N  NET_HTTP_NONCE *Nonce;                ///< Nonce cache table array
N  uint8_t   NumNonce;                   ///< Max. number of cache entries
N  uint8_t   NonceTout;                  ///< Cache entry timeout in seconds
N  NET_HTTP_AUTH *auth_if;               ///< Authentication support interface
N  NET_TLS_IF    *tls_if;                ///< mbedTLS interface functions
N} const NET_HTTP_CFG;
N
N/// Generic unspecified address
Nextern const uint8_t net_addr_unspec[];
N
N/// Network configuration data
Nextern NET_SYS_CFG      net_sys_config;
Nextern NET_IF_CFG       net_eth0_if_config;
Nextern NET_IF_CFG       net_eth1_if_config;
Nextern NET_IF_CFG       net_wifi0_if_config;
Nextern NET_IF_CFG       net_wifi1_if_config;
Nextern NET_IF_CFG       net_ppp0_if_config;
Nextern NET_IF_CFG       net_slip0_if_config;
N
Nextern NET_ETH_CFG   *const net_eth_list[];
Nextern NET_WIFI_CFG  *const net_wifi_list[];
Nextern NET_PPP_CFG   *const net_ppp_list[];
Nextern NET_SLIP_CFG  *const net_slip_list[];
Nextern NET_IF_CFG    *const net_if_list_lan[];
Nextern NET_IF_CFG    *const net_if_list_all[];
Nextern NET_IF_CFG    *const net_if_inet_def[];
Nextern NET_IF_CFG    *const net_if_link_def[];
Nextern NET_ARP_CFG   *const net_arp_list[];
Nextern NET_IGMP_CFG  *const net_igmp_list[];
Nextern NET_DHCP_CFG  *const net_dhcp_list[];
Nextern NET_NDP_CFG   *const net_ndp_list[];
Nextern NET_DHCP6_CFG *const net_dhcp6_list[];
N
Nextern NET_IP4_FRAG_CFG net_ip4_frag_config;
Nextern NET_UDP_CFG      net_udp_config;
Nextern NET_TCP_CFG      net_tcp_config;
Nextern NET_BSD_CFG      net_bsd_config;
Nextern NET_HTTP_CFG     net_http_config;
Nextern NET_HTTP_ERROR   net_http_error;
Nextern NET_TELNET_CFG   net_telnet_config;
Nextern NET_TFTP_CFG     net_tftp_config;
Nextern NET_TFTPC_CFG    net_tftpc_config;
Nextern NET_FTP_CFG      net_ftp_config;
Nextern NET_FTPC_CFG     net_ftpc_config;
Nextern NET_DNS_CFG      net_dns_config;
Nextern NET_SMTP_CFG     net_smtp_config;
Nextern NET_SNMP_CFG     net_snmp_config;
Nextern NET_SNTP_CFG     net_sntp_config;
N
N/// Network uninit functions
Nextern const net_sys_fn_t net_sys_fn_uninit[];
N
N/// Network interface functions
Nextern NETIF_GETOPT_FUNC  netif_getopt_func;
Nextern NETIF_SETOPT_FUNC  netif_setopt_func;
N
N/// Network exported functions.
Nextern NET_PPP_AUTH     net_ppp0_pap_auth;
Nextern NET_PPP_AUTH     net_ppp0_chap_auth;
Nextern NET_SMTP_ATTACH  net_smtp_attach_func;
Nextern NET_HTTP_AUTH    net_http_auth_basic_func;
Nextern NET_HTTP_AUTH    net_http_auth_digest_func;
N
N/// Local machine info
N#ifdef RTE_Network_Legacy
Nextern NET_LOCALM  *const net_localm[4];
N#endif
N
N//  ==== Network system ====
N
N/// \brief Network Component core thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netCore_Thread (void const *arg);
N
N/// \brief Network core tick timer callback.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void net_sys_tick (void const *arg);
N
N/// \brief Signal Network Component error.
N/// \param[in]     error         system error code.
N/// \return        None.
Nextern void net_sys_error (NET_ERROR error);
N
N/// \brief Acquire Network core protection mutex.
N/// \return        None.
Nextern void net_sys_lock   (void);
N
N/// \brief Release Network core protection mutex.
N/// \return        None.
Nextern void net_sys_unlock (void);
N
N//  ==== OS abstraction layer ====
N
N/// \brief Initialize OS abstraction layer.
N/// \return        None.
Nextern void netos_init (void);
N
N/// \brief Create network core thread.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_create (void);
N
N/// \brief Delete network core thread.
N/// \param[in]     thread        thread identifier.
N/// \return        None.
Nextern void netos_thread_delete (NETOS_ID thread);
N
N/// \brief Get running thread identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_id (void);
N
N/// \brief Pass control to next ready thread.
N/// \return        None.
Nextern void netos_thread_pass (void);
N
N/// \brief Create network periodic tick timer.
N/// \return        timer identifier.
Nextern NETOS_ID netos_timer_create (void);
N
N/// \brief Delete network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \return        None.
Nextern void netos_timer_delete (NETOS_ID timer);
N
N/// \brief Start network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \param[in]     interval_ms   tick interval in millisec.
N/// \return        None.
Nextern void netos_timer_start (NETOS_ID timer, uint32_t interval_ms);
N
N/// \brief Create network protection mutex.
N/// \param[in]     sys_id        system identifier (0=core, 1=memory).
N/// \return        mutex identifier.
Nextern NETOS_ID netos_mutex_create (uint8_t sys_id);
N
N/// \brief Delete network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_mutex_delete (NETOS_ID mutex);
N
N/// \brief Lock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_lock (NETOS_ID mutex);
N
N/// \brief Unlock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_unlock (NETOS_ID mutex);
N
N/// \brief Delay network thread execution.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_delay (uint32_t ms);
N
N/// \brief Suspend thread until event flag is set.
N/// \param[in]     flag          event flag to wait for.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_flag_wait (uint32_t flag, uint32_t ms);
N
N/// \brief Set thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_set (NETOS_ID thread, uint32_t flag);
N
N/// \brief Clear thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_clear (NETOS_ID thread, uint32_t flag);
N
N/// \brief Create network interface thread and protection semaphore.
N/// \param[in]     if_id         Network interface identification.
N/// \param[out]    semaphore     pointer to semaphore identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netif_create (uint32_t if_id, NETOS_ID *semaphore);
N
N/// \brief Delete network interface thread and protection semaphore.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_delete (NETOS_ID thread, NETOS_ID semaphore);
N
N/// \brief Lock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_lock (NETOS_ID semaphore);
N
N/// \brief Unlock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_unlock (NETOS_ID semaphore);
N
N//  ==== Memory management ====
N
N/// \brief Allocate memory for the network frame.
N/// \param[in]     byte_size     buffer size in bytes.
N/// \return        Pointer to the allocated memory.
Nextern NET_FRAME *net_mem_alloc (uint32_t byte_size);
N
N/// \brief Release allocated memory.
N/// \param[in]     mem_ptr       pointer to the allocated memory.
N/// \return        None.
Nextern void net_mem_free (NET_FRAME *mem_ptr);
N
N//  ==== Ethernet interface ====
N
N/// \brief Ethernet interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netETH_Thread (void const *arg);
N
N/// \brief Initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_init (void);
N
N/// \brief De-initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_uninit (void);
N
N/// \brief Run ethernet interface main function.
N/// \return None.
Nextern void net_eth_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Configure ethernet multicast address filtering.
N/// \param[in]     if_num        Interface number.
N/// \return        None.
Nextern void net_eth_config_mcast (uint32_t if_num);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from eth driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (eth0, eth1).
N/// \return        None.
Nextern void net_eth_callback (uint32_t event, struct net_eth_ctrl *ctx);
N
N/// \brief Get MAC address for the given IP address (legacy).
N/// \param[in]     addr        structure containing IP address of a host.
N/// \return        Pointer to the MAC address in Neighbor cache.
Nextern const uint8_t *net_eth_get_addr (const __ADDR *addr);
Xextern const uint8_t *net_eth_get_addr (const NET_ADDR4 *addr);
N
N/// \brief Get current value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_init (void);
N
N/// \brief De-initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_uninit (void);
N
N/// \brief Run ARP cache main function.
N/// \return None.
Nextern void net_arp_cache_run (void);
N
N/// \brief Send a notification of local IP address change (gratuitous ARP).
N/// \param[in]     net_if        network interface descriptor.
N/// \return        None.
Nextern void net_arp_notify (NET_IF_CFG *net_if);
N
N/// \brief Initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_init (void);
N
N/// \brief De-initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_uninit (void);
N
N/// \brief Run IGMP group management main function.
N/// \return        None.
Nextern void net_igmp_host_run (void);
N
N/// \brief Process IGMP group management frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received IGMP group management frame.
N/// \return        None.
Nextern void net_igmp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Check if local host is a member of provided group.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     ip4_addr      multicast IPv4 address to be checked.
N/// \return
N///              - true        = Local host is member of IGMP group ipadr.
N///              - false       = Local host is not member.
Nextern bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
Xextern _Bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
N
N/// \brief Collect IP addresses of active IGMP groups.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[out]    buf           buffer to copy group IP addresses to.
N/// \return        Number of IPs copied.
Nextern uint32_t net_igmp_collect_mcast (NET_IF_CFG *net_if, uint8_t *buf);
N
N/// \brief Initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_init (void);
N
N/// \brief De-initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_uninit (void);
N
N/// \brief Run NDP cache main function.
N/// \return None.
Nextern void net_ndp_cache_run (void);
N
N/// \brief Process Neighbor Discovery frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received ND frame.
N/// \return        None.
Nextern void net_ndp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_init (void);
N
N/// \brief De-initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_uninit (void);
N
N/// \brief Initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_init (void);
N
N/// \brief De-initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_uninit (void);
N
N/// \brief Run DHCP client main function.
N/// \return        None.
Nextern void net_dhcp_client_run (void);
N
N/// \brief Initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_init (void);
N
N/// \brief De-initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_uninit (void);
N
N/// \brief Run DHCP6 client main function.
N/// \return        None.
Nextern void net_dhcp6_client_run (void);
N
N//  ==== WiFi interface ====
N
N/// \brief WiFi interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netWiFi_Thread (void const *arg);
N
N/// \brief Initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_init (void);
N
N/// \brief De-initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_uninit (void);
N
N/// \brief Run WiFi interface main function.
N/// \return None.
Nextern void net_wifi_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from wifi driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (wifi0, wifi1).
N/// \return        None.
Nextern void net_wifi_callback (uint32_t event, struct net_wifi_ctrl *ctx);
N
N/// \brief Get current value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== PPP interface ====
N
N/// \brief PPP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netPPP_Thread (void const *arg);
N
N/// \brief Initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_init (void);
N
N/// \brief De-initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_uninit (void);
N
N/// \brief Run PPP interface main function.
N/// \return        None.
Nextern void net_ppp_iface_run (void);
N
N/// \brief Construct PPP header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== SLIP interface ====
N
N/// \brief SLIP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netSLIP_Thread (void const *arg);
N
N/// \brief Initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_init (void);
N
N/// \brief De-initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_uninit (void);
N
N/// \brief Run SLIP interface main function.
N/// \return        None.
Nextern void net_slip_iface_run (void);
N
N/// \brief Send a SLIP frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of SLIP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== Serial and Modem interface ====
N
N/// \brief Send event notification from the USART driver.
N/// \param[in]     event         receive USART event.
N/// \param[in]     ctx           serial device context (ppp, slip).
N/// \return        None.
Nextern void net_com_callback (uint32_t event, struct net_com_ctrl *ctx);
N
N/// \brief Request callback from the modem driver.
N/// \param[in]     cmd           command to send to a modem driver.
N/// \param[in]     response      expected response to wait for.
N/// \param[in]     timeout       response timeout.
N/// \param[in]     retries       number of retries on failure.
N/// \param[in]     ctx           modem device context.
N/// \return        None.
Nextern void net_modem_callback (const char *cmd, const char *response, uint32_t timeout,
N                                uint32_t retries, struct net_modem_ctrl *ctx);
N
N//  ==== Network core ====
N
N/// \brief Initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_init (void);
N
N/// \brief De-initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_uninit (void);
N
N/// \brief Run loopback interface main function.
N/// \return        None.
Nextern void net_loop_iface_run (void);
N
N/// \brief Initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_init (void);
N
N/// \brief De-initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_uninit (void);
N
N/// \brief Run IPv4 reassembly main function.
N/// \return        None.
Nextern void net_ip4_frag_run (void);
N
N/// \brief Reassemble incoming IPv4 fragment.
N/// \param[in]     frame         incoming IPv4 datagram fragment.
N/// \return        pointer to assembled frame or NULL if not completed yet.
Nextern NET_FRAME *net_ip4_frag_add (NET_FRAME *frame);
N
N/// \brief Split outgoing IPv4 datagram to small fragments.
N/// \param[in]     frame         outgoing IPv4 datagram.
N/// \param[in]     mtu           maximum transmission unit.
N/// \return        pointer to generated frame fragment.
Nextern NET_FRAME *net_ip4_frag_get (NET_FRAME *frame, uint16_t mtu);
N
N/// \brief Initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_init (void);
N
N/// \brief De-initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_uninit (void);
N
N/// \brief Run Ping client main function.
N/// \return        None.
Nextern void net_ping_client_run (void);
N
N/// \brief Initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_init (void);
N
N/// \brief De-initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_uninit (void);
N
N/// \brief Process UDP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received UDP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_udp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_init (void);
N
N/// \brief De-initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_uninit (void);
N
N/// \brief Run TCP socket main function.
N/// \return        None.
Nextern void net_tcp_socket_run (void);
N
N/// \brief Process TCP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received TCP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_tcp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Set or change TCP socket callback function.
N/// \param[in]     socket        socket handle.
N/// \param[in]     cb_func       event listening callback function.
N/// \return        None.
Nextern void net_tcp_set_cb (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Retrieve TCP socket remote peer address.
N/// \param[in]     socket        socket handle.
N/// \return        pointer to network address structure.
Nextern NET_ADDR *net_tcp_get_peer_ptr (int32_t socket);
N
N/// \brief Convert TCP socket state into a string.
N/// \param[in]     state         socket state as defined with netTCP_State.
N/// \return        pointer to the text representation of a socket state.
Nextern const char *net_tcp_ntoa (netTCP_State state);
N
N/// \brief Initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_init (void);
N
N/// \brief De-initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_uninit (void);
N
N/// \brief Run DNS client main function.
N/// \return        None.
Nextern void net_dns_client_run (void);
N
N/// \brief Initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_init (void);
N
N/// \brief De-initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_uninit (void);
N
N/// \brief Run BSD socket main function.
N/// \return        None.
Nextern void net_bsd_socket_run (void);
N
N/// \brief Initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_init (void);
N
N/// \brief De-initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_uninit (void);
N
N//  ==== FTP server service ====
N
N/// \brief Initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_init (void);
N
N/// \brief De-initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_uninit (void);
N
N/// \brief Run FTP server main function.
N/// \return        None.
Nextern void net_ftp_server_run (void);
N
N//  ==== FTP client application ====
N
N/// \brief Initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_init (void);
N
N/// \brief De-initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_uninit (void);
N
N/// \brief Run FTP client main function.
N/// \return        None.
Nextern void net_ftp_client_run (void);
N
N//  ==== TFTP server service ====
N
N/// \brief Initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_init (void);
N
N/// \brief De-initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_uninit (void);
N
N/// \brief Run TFTP server main function.
N/// \return        None.
Nextern void net_tftp_server_run (void);
N
N//  ==== TFTP client application ====
N
N/// \brief Initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_init (void);
N
N/// \brief De-initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_uninit (void);
N
N/// \brief Run TFTP client main function.
N/// \return        None.
Nextern void net_tftp_client_run (void);
N
N//  ==== SMTP client application ====
N
N/// \brief Initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_init (void);
N
N/// \brief De-initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_uninit (void);
N
N/// \brief Run SMTP client main function.
N/// \return        None.
Nextern void net_smtp_client_run (void);
N
N//  ==== SNMP agent application ====
N
N/// \brief Initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_init (void);
N
N/// \brief De-initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_uninit (void);
N
N/// \brief Run SNMP agent main function.
N/// \return        None.
Nextern void net_snmp_agent_run (void);
N
N//  ==== SNTP client application ====
N
N/// \brief Initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_init (void);
N
N/// \brief De-initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_uninit (void);
N
N/// \brief Run SNTP client main function.
N/// \return        None.
Nextern void net_sntp_client_run (void);
N
N//  ==== Telnet server service ====
N
N/// \brief Initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_init (void);
N
N/// \brief De-initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_uninit (void);
N
N/// \brief Run Telnet server main function.
N/// \return        None.
Nextern void net_telnet_server_run (void);
N
N//  ==== HTTP server service ====
N
N/// \brief Initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_init (void);
N
N/// \brief De-initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_uninit (void);
N
N/// \brief Run HTTP server main function.
N/// \return        None.
Nextern void net_http_server_run (void);
N
N/// \brief Convert generic time to internal HTTP time format.
N/// \param[in]     hr            hours   [0..23].
N/// \param[in]     min           minutes [0..59].
N/// \param[in]     sec           seconds [0..59].
N/// \param[in]     day           day     [1..31].
N/// \param[in]     mon           month   [1..12].
N/// \param[in]     year          year    [1980..2107].
N/// \return        converted time in UTC format.
Nextern uint32_t net_http_time (uint8_t hr, uint8_t min, uint8_t sec, 
N                               uint8_t day, uint8_t mon, uint16_t year);
N
N//  ==== TLS interface ====
N
N/// \brief Initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceInit (void);
N
N/// \brief De-initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceUninit (void);
N
N/// \brief Allocate secure TLS context.
N/// \param[in]     socket        associated TCP socket.
N/// \param[in]     cb_func       event listening TCP callback function.
N/// \return        Secure session identifier or 0=none.
Nextern uint8_t netTLS_GetContext (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Establish encrypted TLS connection to remote endpoint.
N/// \param[in]     tls_id        TLS session id.
N/// \param[in]     srv_name      hostname of the server.
N/// \return        None.
Nextern void netTLS_Connect (uint8_t tls_id, const char *srv_name);
N
N/// \brief Start TLS server listening for encrypted connection.
N/// \param[in]     tls_id        TLS session id.
N/// \return        None.
Nextern void netTLS_Listen (uint8_t tls_id);
N
N/// \brief Allocate memory for TLS send buffer.
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
Nextern uint8_t *netTLS_GetBuffer (uint32_t size);
N
N///  \brief Write data to TLS session.
N///  \param[in]    tls_id        TLS context id.
N///  \param[in]    buf           pointer to data buffer.
N///  \param[in]    len           length of data (in bytes).
N///  \return       None.
Nextern void netTLS_Write (uint8_t tls_id, const uint8_t *buf, uint32_t len);
N
N/// \brief Stop TLS communication and close socket.
N/// \param[in]     tls_id        TLS context id.
N/// \param[in]     sock_mode     socket close mode: 1=normal, 0=abort.
N/// \return        None.
Nextern void netTLS_Close (uint8_t tls_id, uint8_t sock_mode);
N
N//  ==== Network address conversion ====
N
N/// \brief Copy IP address and port.
N/// \param[out]    dst_addr      destination IPv4 or IPv6 address.
N/// \param[in]     src_addr      source IPv4 or IPv6 address.
N/// \return        None.
Nextern void net_addr_copy (__ADDR *dst_addr, const __ADDR *src_addr);
Xextern void net_addr_copy (NET_ADDR4 *dst_addr, const NET_ADDR4 *src_addr);
N
N/// \brief Convert IPv4 address from binary to string.
N/// \param[in]     ip4_addr      IPv4 address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_addr4_ntoa (const uint8_t *ip4_addr);
N
N/// \brief Convert IPv4 address from text to binary form.
N/// \param[in]     cp            IPv4 address string (ie. "192.168.1.100").
N/// \param[out]    ip4_addr      4-byte address in binary form.
N/// \return
N///                - true  = successfull,
N///                - false = failed.
Nextern bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
Xextern _Bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
N
N/// \brief Convert MAC address from binary to string.
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_mac_ntoa (const uint8_t *mac_addr);
N
N//  ==== Network debug ====
N
N/// \brief Initialize STDIO debug interface.
N/// \return        None.
Nextern void net_debug_init (void);
N
N/// \brief Debug print information message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_info (int32_t proc, const char *fmt, ...);
N
N/// \brief Debug print error message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_error (int32_t proc, const char *fmt, ...);
N
N/// \brief Convert process id into a string.
N/// \param[in]     proc          network process id.
N/// \return        pointer to process id string.
Nextern const char *net_dbg_proc (int32_t proc);
N
N/// \brief Get current network time for debug.
N/// \return        pointer to current time string.
Nextern const char *net_dbg_time (void);
N
N/// \brief Initialize Event Recorder debug interface.
N/// \return        None.
Nextern void net_evr_init (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_LIB_H */
L 12 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c" 2
N#include "rl_net_legacy.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_legacy.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_legacy.h
N * Purpose: Network API (Legacy)
N * Rev.:    V7.13.2
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_LEGACY_H
N#define __RL_NET_LEGACY_H
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
N#include "rl_net_ds.h"
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N// General definitions
N#define ETH_ADDR_LEN                    NET_ADDR_ETH_LEN
N#define IP4_ADDR_LEN                    NET_ADDR_IP4_LEN
N#define IP6_ADDR_LEN                    NET_ADDR_IP6_LEN
N
N// Network Interfaces
N#define NETIF_ETH               0       // Network interface: Ethernet
N#define NETIF_PPP               1       // Network interface: PPP
N#define NETIF_SLIP              2       // Network interface: SLIP
N#define NETIF_LOCAL             3       // Network interface: Localhost (loopback)
N#define NETIF_NULL              4       // Network interface: Null (none)
N
N// BSD Socket ioctl commands
N#define FIO_DELAY_ACK           2       // Set DELAY_ACK mode for stream socket
N#define FIO_KEEP_ALIVE          3       // Set KEEP_ALIVE mode for stream socket
N#define FIO_FLOW_CTRL           4       // Set FLOW_CTRL mode for stream socket
N
N//  ==== Network Core ====
N
N// Functions
N#define net_initialize()                netInitialize()
N#define net_main()                      // Removed
N
N//  ==== UDP Sockets ====
N
N// Definitions
N#define UDP_OPT_SEND_CHECKSUM           NET_UDP_CHECKSUM_SEND
N#define UDP_OPT_VERIFY_CHECKSUM         NET_UDP_CHECKSUM_VERIFY
N
N// Types
Ntypedef uint32_t (*net_udp_cb_t)(int32_t socket, const uint8_t *ip_addr, uint16_t port, const uint8_t *buf, uint32_t len);
N
N// Functions
N#define udp_release_socket(soc)         netUDP_ReleaseSocket(soc)
N#define udp_open(soc,port)              netUDP_Open(soc,port)
N#define udp_close(soc)                  netUDP_Close(soc)
N#define udp_multicast_ttl(soc,ttl)      netUDP_SetOption(soc,netUDP_OptionTTL,ttl)
N#define udp_get_buf(size)               netUDP_GetBuffer(size)
N
Nextern int32_t udp_get_socket (uint8_t tos, uint8_t opt, net_udp_cb_t cb_func);
Nextern netStatus udp_send (int32_t socket, const uint8_t *ip_addr, uint16_t port, uint8_t *buf, uint32_t len);
Nextern net_udp_cb_t net_udp_cb_legacy[];
N
N//  ==== TCP Sockets ====
N
N// Definitions
N#define TCP_TYPE_SERVER         0       // Removed
N#define TCP_TYPE_CLIENT         0       // Removed
N#define TCP_TYPE_CLIENT_SERVER  0       // Removed
N#define TCP_TYPE_DELAY_ACK      0x01    // Socket Type: Delayed Acknowledge
N#define TCP_TYPE_FLOW_CTRL      0x02    // Socket Type: Flow Control
N#define TCP_TYPE_KEEP_ALIVE     0x04    // Socket Type: Keep Alive
N
N// Enums
N#define tcpEvent                        netTCP_Event
N#define tcpEventConnect                 netTCP_EventConnect
N#define tcpEventEstablished             netTCP_EventEstablished
N#define tcpEventClosed                  netTCP_EventClosed
N#define tcpEventAbort                   netTCP_EventAborted
N#define tcpEventACK                     netTCP_EventACK
N#define tcpEventData                    netTCP_EventData
N
N#define tcpState                        netTCP_State
N#define tcpStateUNUSED                  netTCP_StateUNUSED
N#define tcpStateCLOSED                  netTCP_StateCLOSED
N#define tcpStateLISTEN                  netTCP_StateLISTEN
N#define tcpStateSYN_RECEIVED            netTCP_StateSYN_RECEIVED
N#define tcpStateSYN_SENT                netTCP_StateSYN_SENT
N#define tcpStateFIN_WAIT_1              netTCP_StateFIN_WAIT_1
N#define tcpStateFIN_WAIT_2              netTCP_StateFIN_WAIT_2
N#define tcpStateCLOSING                 netTCP_StateCLOSING
N#define tcpStateLAST_ACK                netTCP_StateLAST_ACK
N#define tcpStateTIME_WAIT               netTCP_StateTIME_WAIT
N#define tcpStateESTABLISHED             netTCP_StateESTABLISHED
N
N// Types
Ntypedef uint32_t (*net_tcp_cb_t)(int32_t socket, tcpEvent event, const uint8_t *buf, uint32_t len);
Xtypedef uint32_t (*net_tcp_cb_t)(int32_t socket, netTCP_Event event, const uint8_t *buf, uint32_t len);
N
N// Functions
N#define tcp_release_socket(soc)         netTCP_ReleaseSocket(soc)
N#define tcp_listen(soc,port)            netTCP_Listen(soc,port)
N#define tcp_get_buf(size)               netTCP_GetBuffer(size)
N#define tcp_max_data_size(soc)          netTCP_GetMaxSegmentSize(soc)
N#define tcp_check_send(soc)             netTCP_SendReady(soc)
N#define tcp_send(soc,buf,len)           netTCP_Send(soc,buf,len)
N#define tcp_close(soc)                  netTCP_Close(soc)
N#define tcp_abort(soc)                  netTCP_Abort(soc)
N#define tcp_reset_window(soc)           netTCP_ResetReceiveWindow(soc)
N
Nextern int32_t tcp_get_socket (uint8_t type, uint8_t tos, uint32_t tout, net_tcp_cb_t cb_func);
Nextern netStatus tcp_connect (int32_t socket, const uint8_t *ip_addr, uint16_t port, uint16_t local_port);
Nextern tcpState tcp_get_state (int32_t socket);
Xextern netTCP_State tcp_get_state (int32_t socket);
Nextern const char *tcp_ntoa (tcpState state);
Xextern const char *tcp_ntoa (netTCP_State state);
Nextern net_tcp_cb_t net_tcp_cb_legacy[];
N
N//  ==== Ethernet Interface ====
N
N// Enums
N#define arpCacheType                    netARP_CacheType
N#define arpCacheFixedIP                 netARP_CacheFixedIP
N#define arpCacheTemporaryIP             netARP_CacheTemporaryIP
N
N// Ethernet Link Events
Ntypedef enum {
N  ethLinkDown,                          // Link down
N  ethLinkUp_10MHalfDuplex,              // Link up (10 MBit half duplex)
N  ethLinkUp_10MFullDuplex,              // Link up (10 MBit full duplex)
N  ethLinkUp_100MHalfDuplex,             // Link up (100 MBit half duplex)
N  ethLinkUp_100MFullDuplex,             // Link up (100 MBit full duplex)
N  ethLinkUp_1GHalfDuplex,               // Link up (1 GBit half duplex)
N  ethLinkUp_1GFullDuplex                // Link up (1 GBit full duplex)
N} ethLinkEvent;
N
N// DHCP Client Events
Ntypedef enum {
N  dhcpClientIPaddress     = 0,          // IP address change event
N  dhcpClientNTPservers    = 42,         // NTP Servers option
N  dhcpClientBootfileName  = 67          // Bootfile name option
N} dhcpClientOption;
N
N// Functions
N#define arp_cache_ip(n,ip4,type)        netARP_CacheIP(n,ip4,type)
N#define arp_cache_mac(n,mac)            netARP_CacheMAC(n,mac)
N#define arp_get_ip(mac,ip4)             netARP_GetIP(0,mac,ip4)
N#define arp_get_mac(ip4,mac)            netARP_GetMAC(0,ip4,mac)
N#define igmp_join(n,ip4)                netIGMP_Join(n,ip4)
N#define igmp_leave(n,ip4)               netIGMP_Leave(n,ip4)
N#define dhcp_disable(n)                 netDHCP_Disable(n)
N
Nextern void eth_link_notify (uint32_t if_num, ethLinkEvent event);
Nextern void dhcp_client_notify (uint32_t if_num, dhcpClientOption opt, const uint8_t *val, uint32_t len);
N
N//  ==== PPP Interface ====
N
N#define ppp_listen(user,passw)          netPPP_Listen(user,passw)
N#define ppp_connect(num,user,passw)     netPPP_Connect(num,user,passw)
N#define ppp_close()                     netPPP_Close()
N#define ppp_is_up()                     netPPP_LinkUp()
N
N//  ==== SLIP Interface ====
N
N#define slip_listen()                   netSLIP_Listen()
N#define slip_connect(num)               netSLIP_Connect(num)
N#define slip_close()                    netSLIP_Close()
N#define slip_is_up()                    netSLIP_LinkUp()
N
N//  ==== ICMP Ping ====
N
N// Enums
N#define icmpEvent                       netPing_Event
N#define icmpEventSuccess                netPing_EventSuccess
N#define icmpEventTimeout                netPing_EventTimeout
N
N// Types
N#define net_icmp_cb_t                   netPing_cb_t
N
N// Functions
Nextern netStatus icmp_ping (const uint8_t *ip_addr, net_icmp_cb_t cb_func);
Xextern netStatus icmp_ping (const uint8_t *ip_addr, netPing_cb_t cb_func);
N
N//  ==== DNS Client ====
N
N// Enums
N#define dnsClientEvent                  netDNSc_Event
N#define dnsClientSuccess                netDNSc_EventSuccess
N#define dnsClientTimeout                netDNSc_EventTimeout
N#define dnsClientNotResolved            netDNSc_EventNotResolved
N#define dnsClientError                  netDNSc_EventError
N
N// Types
Ntypedef void (*net_dns_client_cb_t)(dnsClientEvent event, const uint8_t *ip_addr);
Xtypedef void (*net_dns_client_cb_t)(netDNSc_Event event, const uint8_t *ip_addr);
N
N// Functions
Nextern netStatus get_host_by_name (const char *name, net_dns_client_cb_t cb_func);
N
N//  ==== FTP Server  ====
N
N// Enums
N#define ftpServerEvent                  netFTPs_Event
N#define ftpServerLogin                  netFTPs_EventLogin
N#define ftpServerLogout                 netFTPs_EventLogout
N#define ftpServerLoginFailed            netFTPs_EventLoginFailed
N#define ftpServerDownload               netFTPs_EventDownload
N#define ftpServerUpload                 netFTPs_EventUpload
N#define ftpServerDelete                 netFTPs_EventDelete
N#define ftpServerRename                 netFTPs_EventRename
N#define ftpServerMakeDirectory          netFTPs_EventMakeDirectory
N#define ftpServerRemoveDirectory        netFTPs_EventRemoveDirectory
N#define ftpServerOperationDenied        netFTPs_EventOperationDenied
N#define ftpServerLocalFileError         netFTPs_EventLocalFileError
N#define ftpServerFileError              netFTPs_EventFileError
N#define ftpServerError                  netFTPs_EventError
N
N// Functions
N#define ftp_check_username(user)            netFTPs_CheckUsername(user)
N#define ftp_check_password(user_id,passw)   netFTPs_CheckPassword(user_id,passw)
N#define ftp_get_user_id()                   netFTPs_GetUserId()
N#define ftp_server_notify(event)            netFTPs_Notify(event)
N
Nextern bool ftp_accept_client (const uint8_t *ip_addr, uint16_t port);
Xextern _Bool ftp_accept_client (const uint8_t *ip_addr, uint16_t port);
Nextern bool ftp_file_access (uint8_t user_id, const char *fname, uint8_t mode);
Xextern _Bool ftp_file_access (uint8_t user_id, const char *fname, uint8_t mode);
N
N// FS interface
N#define ftp_server_fopen(name,mode)         netFTPs_fopen(name,mode)
N#define ftp_server_fclose(f)                netFTPs_fclose(f)
N#define ftp_server_fread(f,buf,len)         netFTPs_fread(f,buf,len)
N#define ftp_server_fwrite(f,buf,len)        netFTPs_fwrite(f,buf,len)
N#define ftp_server_fdelete(name)            netFTPs_fdelete(name)
N#define ftp_server_frename(old,new)         netFTPs_frename(old,new)
N#define ftp_server_mkdir(path)              netFTPs_mkdir(path)
N#define ftp_server_rmdir(path)              netFTPs_rmdir(path)
N// ftp_server_ffind: Changed parameters and return value
N#define ftp_server_ffind(mask,name,size,time,first) \
N                                            netFTPs_ffind(mask,name,size,time,first)
X#define ftp_server_ffind(mask,name,size,time,first)                                             netFTPs_ffind(mask,name,size,time,first)
N
N//  ==== FTP Client ====
N
N// Enums
N#define ftpCommand                      netFTP_Command
N#define ftpPUT                          netFTP_CommandPUT
N#define ftpGET                          netFTP_CommandGET
N#define ftpAPPEND                       netFTP_CommandAPPEND
N#define ftpDELETE                       netFTP_CommandDELETE
N#define ftpLIST                         netFTP_CommandLIST
N#define ftpRENAME                       netFTP_CommandRENAME
N#define ftpMKDIR                        netFTP_CommandMKDIR
N#define ftpRMDIR                        netFTP_CommandRMDIR
N#define ftpNLIST                        netFTP_CommandNLIST
N
N#define ftpClientEvent                  netFTPc_Event
N#define ftpClientSuccess                netFTPc_EventSuccess
N#define ftpClientTimeout                netFTPc_EventTimeout
N#define ftpClientLoginFailed            netFTPc_EventLoginFailed
N#define ftpClientAccessDenied           netFTPc_EventAccessDenied
N#define ftpClientFileNotFound           netFTPc_EventFileNotFound
N#define ftpClientInvalidPath            netFTPc_EventInvalidDirectory
N#define ftpClientLocalFileError         netFTPc_EventLocalFileError
N#define ftpClientError                  netFTPc_EventError
N
N#define ftpClientRequest                netFTPc_Request
N#define ftpClientUsername               netFTPc_RequestUsername
N#define ftpClientPassword               netFTPc_RequestPassword
N#define ftpClientPath                   netFTPc_RequestDirectory
N#define ftpClientFilename               netFTPc_RequestName      // changed to RequestName
N#define ftpClientDirectory              netFTPc_RequestName      // changed to RequestName
N#define ftpClientNewName                netFTPc_RequestNewName
N#define ftpClientFilterMask             netFTPc_RequestListMask
N#define ftpClientList                   netFTPc_RequestList
N#define ftpClientLocalFile              netFTPc_RequestLocalFilename
N
N// Functions
N#define ftp_client_request(req,buf,len) netFTPc_Process(req,buf,len)
N#define ftp_client_notify(event)        netFTPc_Notify(event)
N
Nextern netStatus ftp_client_connect (const uint8_t *ip_addr, uint16_t port, ftpCommand command);
Xextern netStatus ftp_client_connect (const uint8_t *ip_addr, uint16_t port, netFTP_Command command);
N
N// FS interface
N#define ftp_client_fopen(name,mode)     netFTPc_fopen(name,mode)
N#define ftp_client_fclose(f)            netFTPc_fclose(f)
N#define ftp_client_fread(f,buf,len)     netFTPc_fread(f,buf,len)
N#define ftp_client_fwrite(f,buf,len)    netFTPc_fwrite(f,buf,len)
N
N//  ==== TFTP Server ====
N
N// Functions
Nextern bool tftp_accept_client (const uint8_t *ip_addr, uint16_t port);
Xextern _Bool tftp_accept_client (const uint8_t *ip_addr, uint16_t port);
N
N// FS interface
N#define tftp_server_fopen(name,mode)    netTFTPs_fopen(name,mode)
N#define tftp_server_fclose(f)           netTFTPs_fclose(f)
N#define tftp_server_fread(f,buf,len)    netTFTPs_fread(f,buf,len)
N#define tftp_server_fwrite(f,buf,len)   netTFTPs_fwrite(f,buf,len)
N
N//  ==== TFTP Client ====
N
N// Enums
N#define tftpClientEvent                 netTFTPc_Event
N#define tftpClientSuccess               netTFTPc_EventSuccess
N#define tftpClientTimeout               netTFTPc_EventTimeout
N#define tftpClientAccessDenied          netTFTPc_EventAccessDenied
N#define tftpClientFileNotFound          netTFTPc_EventFileNotFound
N#define tftpClientDiskFull              netTFTPc_EventDiskFull
N// not defined                          netTFTPc_EventLocalFileError
N#define tftpClientError                 netTFTPc_EventError
N
N// Functions
Nextern netStatus tftp_client_put (const uint8_t *ip_addr, uint16_t port, const char *src, const char *dst);
Nextern netStatus tftp_client_get (const uint8_t *ip_addr, uint16_t port, const char *src, const char *dst);
Nextern void tftp_client_notify (tftpClientEvent event);
Xextern void tftp_client_notify (netTFTPc_Event event);
N
N// FS interface
N#define tftp_client_fopen(name,mode)    netTFTPc_fopen(name,mode)
N#define tftp_client_fclose(f)           netTFTPc_fclose(f)
N#define tftp_client_fread(f,buf,len)    netTFTPc_fread(f,buf,len)
N#define tftp_client_fwrite(f,buf,len)   netTFTPc_fwrite(f,buf,len)
N
N//  ==== Telnet Server ====
N
N// Enums
N#define telnetServerMessage             netTELNETs_Message
N#define telnetServerWelcome             netTELNETs_MessageWelcome
N#define telnetServerPrompt              netTELNETs_MessagePrompt
N#define telnetServerLogin               netTELNETs_MessageLogin
N#define telnetServerUsername            netTELNETs_MessageUsername
N#define telnetServerPassword            netTELNETs_MessagePassword
N#define telnetServerLoginFailed         netTELNETs_MessageLoginFailed
N#define telnetServerLoginTimeout        netTELNETs_MessageLoginTimeout
N#define telnetServerUnsolicitedMessage  netTELNETs_MessageUnsolicited
N
N// Functions
N#define telnet_server_set_delay(delay)          netTELNETs_RepeatCommand(delay)
N#define telnet_server_get_session()             netTELNETs_GetSession()
N#define telnet_check_command(cmd,user)          netTELNETs_CheckCommand(cmd,user)
N#define telnet_server_message(msg,buf,len)      netTELNETs_ProcessMessage(msg,buf,len)
N#define telnet_server_process(cmd,buf,len,pvar) netTELNETs_ProcessCommand(cmd,buf,len,pvar)
N#define telnet_check_username(user)             netTELNETs_CheckUsername(user)
N#define telnet_check_password(id,passw)         netTELNETs_CheckPassword(id,passw)
N#define telnet_get_user_id()                    netTELNETs_GetUserId()
N
Nextern netStatus telnet_server_get_client (uint8_t *ip_addr, uint8_t *mac_addr);
Nextern bool telnet_accept_client (const uint8_t *ip_addr, uint16_t port);
Xextern _Bool telnet_accept_client (const uint8_t *ip_addr, uint16_t port);
N// bool telnet_server_message_poll (int32_t session); // Removed, use netTELNETs_RequestMessage()
N
N//  ==== HTTP Server ====
N
N// Functions
N#define http_get_env_var(env,ansi,mlen) netCGI_GetEnvVar(env,ansi,mlen)
N#define http_server_get_session()       netHTTPs_GetSession()
N#define http_server_get_lang()          netHTTPs_GetLanguage()
N#define http_server_get_content_type()  netHTTPs_GetContentType()
N#define cgi_process_query(qstr)         netCGI_ProcessQuery(qstr)
N#define cgi_process_data(code,data,len) netCGI_ProcessData(code,data,len)
N#define cgi_script(env,buf,buflen,pcgi) netCGI_Script(env,buf,buflen,pcgi)
N#define cgi_content_type(file_ext)      netCGI_ContentType(file_ext)
N#define cgx_content_type(v)             netCGX_ContentType(v)
N#define http_encoding(v)                netCGI_Charset(v)
N#define http_check_account(user,passw)  netHTTPs_CheckAccount(user,passw)
N#define http_file_access(user_id,fname) netHTTPs_FileAccess(user_id,fname)
N#define http_get_user_id()              netHTTPs_GetUserId()
N
Nextern bool http_accept_client (const uint8_t *ip_addr, uint16_t port);
Xextern _Bool http_accept_client (const uint8_t *ip_addr, uint16_t port);
Nextern netStatus http_server_get_client (uint8_t *ip_addr, uint8_t *mac_addr);
N
N// FS interface
N#define http_server_fopen(name)         netHTTPs_fopen(name)
N#define http_server_fclose(f)           netHTTPs_fclose(f)
N#define http_server_fread(f,buf,len)    netHTTPs_fread(f,buf,len)
N#define http_server_fgets(f,buf,size)   netHTTPs_fgets(f,buf,size)
N#define http_utc_time(h,m,s,d,mo,y)     net_http_time(h,m,s,d,mo,y)
N// uint32_t http_server_ftime (const char *fname); // Changed to netHTTPs_fstat()
N#define http_server_ftime(name,time,size) netHTTPs_fstat(name,time,size)
N
N//  ==== SMTP Client ====
N
N// Enums
N#define smtpClientRequest               netSMTPc_Request
N#define smtpClientUsername              netSMTPc_RequestUsername
N#define smtpClientPassword              netSMTPc_RequestPassword
N#define smtpClientSender                netSMTPc_RequestSender
N#define smtpClientRecipient             netSMTPc_RequestRecipient
N#define smtpClientSubject               netSMTPc_RequestSubject
N#define smtpClientBody                  netSMTPc_RequestBody
N
N#define smtpClientEvent                 netSMTPc_Event
N#define smtpClientSuccess               netSMTPc_EventSuccess
N#define smtpClientTimeout               netSMTPc_EventTimeout
N#define smtpClientError                 netSMTPc_EventError
N
N// Functions
N#define smtp_client_request(req,buf,len,pv) netSMTPc_Process(req,buf,len,pv)
N#define smtp_client_notify(event)           netSMTPc_Notify(event)
N
Nextern netStatus smtp_client_connect (const uint8_t *ip_addr, uint16_t port);
Nextern bool smtp_client_accept_authentication (const uint8_t *ip_addr);
Xextern _Bool smtp_client_accept_authentication (const uint8_t *ip_addr);
N
N//  ==== SNTP Client ====
N
N// Types
Ntypedef void (*net_sntp_client_cb_t)(uint32_t utc_time);
N
N// Functions
Nextern netStatus sntp_get_time (const uint8_t *ip_addr, net_sntp_client_cb_t cb_func);
N
N//  ==== SNMP Agent ====
N
N// Definitions
N#define MIB_INTEGER                     NET_SNMP_MIB_INTEGER
N#define MIB_OCTET_STR                   NET_SNMP_MIB_OCTET_STR
N#define MIB_OBJECT_ID                   NET_SNMP_MIB_OBJECT_ID
N#define MIB_IP_ADDR                     NET_SNMP_MIB_IP_ADDR
N#define MIB_COUNTER                     NET_SNMP_MIB_COUNTER
N#define MIB_GAUGE                       NET_SNMP_MIB_GAUGE
N#define MIB_TIME_TICKS                  NET_SNMP_MIB_TIME_TICKS
N#define MIB_ATR_RO                      NET_SNMP_MIB_ATR_RO
N#define MIB_OID_SIZE                    NET_SNMP_MIB_OID_SIZE
N#define MIB_STR_SIZE                    NET_SNMP_MIB_STR_SIZE
N#define MIB_READ                        NET_SNMP_MIB_READ
N#define MIB_WRITE                       NET_SNMP_MIB_WRITE
N
N// Macros
N#define MIB_STR(s)                      NET_SNMP_MIB_STR(s)
N#define MIB_INT(o)                      NET_SNMP_MIB_INT(o)
N#define MIB_IP(ip)                      NET_SNMP_MIB_IP(ip) 
N#define MIB_OID0(f,s)                   NET_SNMP_MIB_OID0(f,s)
N#define SNMP_MIB_SIZE(mib)              (sizeof(mib)) // use netSNMP_SetMIB_Table()
N
N// Types
Ntypedef struct snmp_mib {
N  uint8_t  Type;                        // Object Type
N  uint8_t  OidLen;                      // Object ID length
N  uint8_t  Oid[MIB_OID_SIZE];           // Object ID value
X  uint8_t  Oid[17];           
N  uint8_t  ValSz;                       // Size of a variable
N  void     *Val;                        // Pointer to a variable
N  void     (*cb_func)(int32_t mode);    // Write/Read event callback function
N} const SNMP_MIB;
N
N// Variables
N#define snmp_SysUpTime                  netSNMP_sysUpTime
N
N// Functions
N#define snmp_set_community(com)         netSNMP_SetCommunity(com)
N
Nextern netStatus snmp_trap (const uint8_t *ip_addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list);
N
N// ==== Network Address Conversion ====
N
N// Functions
N#define mac_aton(str,mac)               netMAC_aton(str,mac)
N
Nextern const char *ip4_ntoa (const uint8_t *ip4_addr);
Nextern bool ip4_aton (const char *cp, uint8_t *ip4_addr);
Xextern _Bool ip4_aton (const char *cp, uint8_t *ip4_addr);
Nextern const char *mac_ntoa (const uint8_t *mac_addr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_LEGACY_H */
L 13 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c" 2
N#include "Net_Config_Legacy.h"
L 1 ".\RTE\Network\Net_Config_Legacy.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Config_Legacy.h
N * Purpose: Network Configuration for Legacy API
N * Rev.:    V7.0.0
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>Network Legacy Configuration
N
N//   <q>Ethernet Notifications
N//   <i>Enable or disable Ethernet legacy notifications:
N//   <i> - eth_link_notify    (called from netETH_Notify)
N//   <i> - dhcp_client_notify (called from netDHCP_Notify)
N#define ETH_LEGACY              1
N
N//   <q>FTP Server Callbacks
N//   <i>Enable or disable FTP Server legacy callbacks:
N//   <i> - ftp_accept_client (called from netFTPs_AcceptClient)
N//   <i> - ftp_file_access   (called from netFTPs_FileAccess)
N#define FTP_SERVER_LEGACY       1
N
N//   <q>TFTP Server Callback
N//   <i>Enable or disable TFTP Server legacy callback:
N//   <i> - tftp_accept_client (called from netTFTPs_AcceptClient)
N#define TFTP_SERVER_LEGACY      1
N
N//   <q>TFTP Client Callback
N//   <i>Enable or disable TFTP Client legacy callback:
N//   <i> - tftp_client_notify (called from netTFTPc_Notify)
N#define TFTP_CLIENT_LEGACY      1
N
N//   <q>Telnet Server Callback
N//   <i>Enable or disable Telnet Server legacy callback:
N//   <i> - telnet_accept_client (called from netTELNETs_AcceptClient)
N#define TELNET_SERVER_LEGACY    1
N
N//   <q>HTTP Server Callback
N//   <i>Enable or disable HTTP Server legacy callback:
N//   <i> - http_accept_client (called from netHTTPs_AcceptClient)
N#define HTTP_SERVER_LEGACY      1
N
N//   <q>SMTP Client Callback
N//   <i>Enable or disable SMTP Client legacy callback:
N//   <i> - smtp_client_accept_authentication (called from netSMTPc_AcceptAuthentication)
N#define SMTP_CLIENT_LEGACY      1
N
N// </h>
N
N//------------- <<< end of configuration section >>> ---------------------------
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c" 2
N
N//  ==== UDP Sockets ====
N
N#ifdef RTE_Network_Socket_UDP
S/* Convert callback type netUDP_cb_t to net_udp_cb_t */
Sstatic uint32_t udp_cb_wrapper (int32_t socket, const NET_ADDR *addr,
S                                const uint8_t *buf, uint32_t len) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Ignore IPv6 */
S    return (0);
S  }
S  return (net_udp_cb_legacy[socket-1] (socket, addr->addr, addr->port, buf, len));
S}
S
S/* Allocate a free UDP socket */
Sint32_t udp_get_socket (uint8_t tos, uint8_t opt, net_udp_cb_t cb_func) {
S  int32_t sock;
S
S  /* Use callback wrapper */
S  sock = netUDP_GetSocket (udp_cb_wrapper);
S  if (sock <= 0) {
S    return (sock);
S  }
S  net_udp_cb_legacy[sock-1] = cb_func;
S  /* Default: tos = 0 */
S  if (tos != 0) {
S    netUDP_SetOption (sock, netUDP_OptionTOS, tos);
S  }
S  /* Default: Send Checksum and Verify Checksum */
S  if (opt != (NET_UDP_CHECKSUM_SEND | NET_UDP_CHECKSUM_VERIFY)) {
S    netUDP_SetOption (sock, netUDP_OptionChecksum, opt);
S  }
S  return (sock);
S}
S
S/* Send data to a remote node */
SnetStatus udp_send (int32_t socket, const uint8_t *ip_addr, uint16_t port,
S                                    uint8_t *buf, uint32_t len) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr and port to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  addr4.port      = port;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netUDP_Send (socket, (NET_ADDR *)&addr4, buf, len));
S}
S
N#endif /* RTE_Network_Socket_UDP */
N
N//  ==== TCP Sockets ====
N
N#ifdef RTE_Network_Socket_TCP
N/* Convert callback type netTCP_cb_t to net_tcp_cb_t */
Nstatic uint32_t tcp_cb_wrapper (int32_t socket, netTCP_Event event,
N                                const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
N  if (addr->addr_type != NET_ADDR_IP4) {
X  if (addr->addr_type != 0) {
N    /* Ignore IPv6 */
N    return (0);
N  }
N  if (event != netTCP_EventData) {
N    /* Provide IP4 address and port */
N    buf = addr->addr;
N    len = addr->port;
N  }
N  return (net_tcp_cb_legacy[socket-1] (socket, event, buf, len));
N}
N
N/* Allocate a free UDP socket */
Nint32_t tcp_get_socket (uint8_t type, uint8_t tos, uint32_t tout, net_tcp_cb_t cb_func) {
N  int32_t sock;
N
N  /* Use callback wrapper */
N  sock = netTCP_GetSocket (tcp_cb_wrapper);
N  if (sock <= 0) {
N    return (sock);
N  }
N  net_tcp_cb_legacy[sock-1] = cb_func;
N  /* Default tos = 0 */
N  if (tos != 0) {
N    netTCP_SetOption (sock, netTCP_OptionTOS, tos);
N  }
N  /* Default tout = 0 (using timeout from Net_Config_TCP.h) */
N  if (tout != 0) {
N    netTCP_SetOption (sock, netTCP_OptionTimeout, tout);
N  }
N  /* Delay ACK: default not enabled */
N  if (type & TCP_TYPE_DELAY_ACK) {
X  if (type & 0x01) {
N    netTCP_SetOption (sock, netTCP_OptionDelayedACK, 1);
N  }
N  /* Flow Control: default not enabled */
N  if (type & TCP_TYPE_FLOW_CTRL) {
X  if (type & 0x02) {
N    netTCP_SetOption (sock, netTCP_OptionFlowControl, 1);
N  }
N  /* Keep Alive: default not enabled */
N  if (type & TCP_TYPE_KEEP_ALIVE) {
X  if (type & 0x04) {
N    netTCP_SetOption (sock, netTCP_OptionKeepAlive, 1);
N  }
N  return (sock);
N}
N
N/* Initiate TCP connection to a remote node */
NnetStatus tcp_connect (int32_t socket,
N                       const uint8_t *ip_addr, uint16_t port, uint16_t local_port) {
N  NET_ADDR4 addr4;
N
N  /* Convert ip_addr and port to a structure */
N  addr4.addr_type = NET_ADDR_IP4;
X  addr4.addr_type = 0;
N  addr4.port      = port;
N  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
X  memcpy (addr4.addr, ip_addr, 4);
N  return (netTCP_Connect (socket, (NET_ADDR *)&addr4, local_port));
N}
N
N/* Determine current state of a TCP socket */
NtcpState tcp_get_state (int32_t socket) {
XnetTCP_State tcp_get_state (int32_t socket) {
N  netTCP_State state = netTCP_GetState (socket);
N  if (state == netTCP_StateINVALID) {
N    /* New state in Network-DS only */
N    return (netTCP_StateUNUSED);
N  }
N  return (state);
N}
N
N/* Convert TCP socket state into an ASCII string */
Nconst char *tcp_ntoa (tcpState state) {
Xconst char *tcp_ntoa (netTCP_State state) {
N  return (net_tcp_ntoa (state));
N}
N#endif /* RTE_Network_Socket_TCP */
N
N//  ==== Ethernet Interface ====
N
N#ifdef RTE_Network_Interface_ETH_0
N/* Notify the user of Ethernet link state change event */
N#if (ETH_LEGACY != 0)
X#if (1 != 0)
Nvoid netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val) {
N  if (event == netETH_LinkDown) {
N    eth_link_notify (if_num, ethLinkDown);
N  }
N  else if (event == netETH_LinkUp) {
N    switch (val) {
N      case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_10M:
X      case (0 << 2) | 0:
N        eth_link_notify (if_num, ethLinkUp_10MHalfDuplex);
N        break;
N      case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_10M:
X      case (1 << 2) | 0:
N        eth_link_notify (if_num, ethLinkUp_10MFullDuplex);
N        break;
N      case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_100M:
X      case (0 << 2) | 1:
N        eth_link_notify (if_num, ethLinkUp_100MHalfDuplex);
N        break;
N      case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_100M:
X      case (1 << 2) | 1:
N        eth_link_notify (if_num, ethLinkUp_100MFullDuplex);
N        break;
N      case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_1G:
X      case (0 << 2) | 2:
N        eth_link_notify (if_num, ethLinkUp_1GHalfDuplex);
N        break;
N      case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_1G:
X      case (1 << 2) | 2:
N        eth_link_notify (if_num, ethLinkUp_1GFullDuplex);
N        break;
N    }
N  }
N}
N/* Default function, when not provided by the user */
N__weak void eth_link_notify (uint32_t if_num, ethLinkEvent event) {
N  (void)if_num;
N  (void)event;
N}
N#endif /* ETH_LEGACY */
N
N/* Notify the user of DHCP event or extended DHCP option */
N#if (ETH_LEGACY != 0)
X#if (1 != 0)
Nvoid netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len) {
N  uint32_t if_num = if_id & 0xFF;
N  switch (option) {
N    case NET_DHCP_OPTION_IP_ADDRESS:
X    case 0:
N      dhcp_client_notify (if_num, dhcpClientIPaddress, val, len);
N      break;
N    case NET_DHCP_OPTION_NTP_SERVERS:
X    case 42:
N      dhcp_client_notify (if_num, dhcpClientNTPservers, val, len);
N      break;
N    case NET_DHCP_OPTION_BOOTFILE_NAME:
X    case 67:
N      dhcp_client_notify (if_num, dhcpClientBootfileName, val, len);
N      break;
N  }
N}
N/* Default function, when not provided by the user */
N__weak void dhcp_client_notify (uint32_t if_id, dhcpClientOption opt,
N                                const uint8_t *val, uint32_t len) {
N  (void)if_id;
N  (void)opt;
N  (void)val;
N  (void)len;
N}
N#endif /* ETH_LEGACY */
N#endif /* RTE_Network_Interface_ETH_0 */
N
N//  ==== ICMP Ping ====
N
N/* Start ICMP ping process */
NnetStatus icmp_ping (const uint8_t *ip_addr, net_icmp_cb_t cb_func) {
XnetStatus icmp_ping (const uint8_t *ip_addr, netPing_cb_t cb_func) {
N  NET_ADDR4 addr4;
N
N  /* Convert ip_addr to a structure */
N  addr4.addr_type = NET_ADDR_IP4;
X  addr4.addr_type = 0;
N  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
X  memcpy (addr4.addr, ip_addr, 4);
N  return (netPing_Echo ((NET_ADDR *)&addr4, cb_func));
N}
N
N//  ==== DNS Client ====
N
N#ifdef RTE_Network_DNS_Client
Sstatic net_dns_client_cb_t dns_cb_func;
S
S/* Convert callback type netDNSc_cb_t to net_dns_client_cb_t */
Sstatic void dns_cb_wrapper (netDNSc_Event event, const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Ignore IPv6 hosts */
S    dns_cb_func (dnsClientError, NULL);
S    return;
S  }
S  dns_cb_func (event, addr->addr);
S}
S
S/* Resolve IP address of a host from a hostname */
SnetStatus get_host_by_name (const char *name, net_dns_client_cb_t cb_func) {
S  netStatus retv;
S
S  retv = netDNSc_GetHostByName (name, NET_ADDR_IP4, dns_cb_wrapper);
S  if (retv == netOK) {
S    dns_cb_func = cb_func;
S  }
S  return (retv);
S}
N#endif /* RTE_Network_DNS_Client */
N
N//  ==== FTP Server ====
N
N#ifdef RTE_Network_FTP_Server
S/* Accept or deny connection from remote FTP client */
S#if (FTP_SERVER_LEGACY != 0)
Sbool netFTPs_AcceptClient (const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Deny IPv6 clients */
S    return (false);
S  }
S  return (ftp_accept_client (addr->addr, addr->port));
S}
S/* Default function, when not provided by the user */
S__weak bool ftp_accept_client (const uint8_t *ip_addr, uint16_t port) {
S  (void)ip_addr;
S  (void)port;
S  return (true);
S}
S#endif /* FTP_SERVER_LEGACY */
S
S/* Check if remote user is allowed to access a file on FTP server */
S#if (FTP_SERVER_LEGACY != 0)
Sbool netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access) {
S  uint8_t mode;
S
S  switch (access) {
S    case NET_ACCESS_FILE_READ:
S      mode = 0;
S      break;
S    case NET_ACCESS_FILE_WRITE:
S      mode = 1;
S      break;
S    case NET_ACCESS_DIRECTORY_CREATE:
S    case NET_ACCESS_DIRECTORY_REMOVE:
S      mode = 2;
S      break;
S    case NET_ACCESS_DIRECTORY_LIST:
S      mode = 3;
S      break;
S    default:
S      return (false);
S  }
S  return (ftp_file_access (user_id, fname, mode));
S}
S/* Default function, when not provided by the user */
S__weak bool ftp_file_access (uint8_t user_id, const char *fname, uint8_t mode) {
S  (void)user_id;
S  (void)fname;
S  (void)mode;
S  return (true);
S}
S#endif /* FTP_SERVER_LEGACY */
N#endif /* RTE_Network_FTP_Server */
N
N//  ==== FTP Client ====
N
N#ifdef RTE_Network_FTP_Client
S/* Start FTP client file operation session */
SnetStatus ftp_client_connect (const uint8_t *ip_addr, uint16_t port, ftpCommand command) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr and port to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  addr4.port      = port;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netFTPc_Connect ((NET_ADDR *)&addr4, command));
S}
N#endif /* RTE_Network_FTP_Client */
N
N//  ==== TFTP Server ====
N
N#ifdef RTE_Network_TFTP_Server
S/* Accept or deny connection from remote TFTP client */
S#if (TFTP_SERVER_LEGACY != 0)
Sbool netTFTPs_AcceptClient (const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Deny IPv6 clients */
S    return (false);
S  }
S  return (tftp_accept_client (addr->addr, addr->port));
S}
S/* Default function, when not provided by the user */
S__weak bool tftp_accept_client (const uint8_t *ip_addr, uint16_t port) {
S  (void)ip_addr;
S  (void)port;
S  return (true);
S}
S#endif /* TFTP_SERVER_LEGACY */
N#endif /* RTE_Network_TFTP_Server */
N
N//  ==== TFTP Client ====
N
N#ifdef RTE_Network_TFTP_Client
S/* Put a file to remote TFTP server */
SnetStatus tftp_client_put (const uint8_t *ip_addr, uint16_t port, const char *src, const char *dst) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr and port to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  addr4.port      = port;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netTFTPc_Put((NET_ADDR *)&addr4, dst, src));
S}
S
S/* Retrieve a file from remote TFTP server */
SnetStatus tftp_client_get (const uint8_t *ip_addr, uint16_t port, const char *src, const char *dst) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr and port to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  addr4.port      = port;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netTFTPc_Get((NET_ADDR *)&addr4, src, dst));
S}
S
S/* Notify the user application when TFTP client operation ends */
S#if (TFTP_CLIENT_LEGACY != 0)
Svoid netTFTPc_Notify (netTFTPc_Event event) {
S  if (event == netTFTPc_EventLocalFileError) {
S    tftp_client_notify (tftpClientDiskFull);
S    return;
S  }
S  tftp_client_notify (event);
S}
S/* Default function, when not provided by the user */
S__weak void tftp_client_notify (tftpClientEvent event) {
S  (void)event;
S}
S#endif /* TFTP_CLIENT_LEGACY */
N#endif /* RTE_Network_TFTP_Client */
N
N//  ==== Telnet Server ====
N
N#ifdef RTE_Network_Telnet_Server
S/* Get IP and MAC address of connected remote machine */
SnetStatus telnet_server_get_client (uint8_t *ip_addr, uint8_t *mac_addr) {
S  NET_ADDR4 addr4;
S  netStatus retv;
S
S  retv = netTELNETs_GetClient ((NET_ADDR *)&addr4, sizeof (addr4));
S  if (retv != netOK) {
S    return (retv);
S  }
S  memcpy (ip_addr, addr4.addr, NET_ADDR_IP4_LEN);
S  if (mac_addr != NULL) {
S    const uint8_t *mac = net_eth_get_addr ((__ADDR *)&addr4);
S    if (mac == NULL) {
S      mac = net_addr_unspec;
S    }
S    memcpy (mac_addr, mac, NET_ADDR_ETH_LEN);
S  }
S  return (netOK);
S}
S
S/* Accept or deny connection from remote Telnet client */
S#if (TELNET_SERVER_LEGACY != 0)
Sbool netTELNETs_AcceptClient (const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Deny IPv6 clients */
S    return (false);
S  }
S  return (telnet_accept_client (addr->addr, addr->port));
S}
S/* Default function, when not provided by the user */
S__weak bool telnet_accept_client (const uint8_t *ip_addr, uint16_t port) {
S  (void)ip_addr;
S  (void)port;
S  return (true);
S}
S#endif /* TELNET_SERVER_LEGACY */
N#endif /* RTE_Network_Telnet_Server */
N
N//  ==== HTTP Server ====
N
N#if defined(RTE_Network_Web_Server_RO) || defined(RTE_Network_Web_Server_FS)
X#if 0L || 0L
S/* Get IP and MAC address of connected remote machine */
SnetStatus http_server_get_client (uint8_t *ip_addr, uint8_t *mac_addr) {
S  NET_ADDR4 addr4;
S  netStatus retv;
S
S  retv = netHTTPs_GetClient ((NET_ADDR *)&addr4, sizeof (addr4));
S  if (retv != netOK) {
S    return (retv);
S  }
S  memcpy (ip_addr, addr4.addr, NET_ADDR_IP4_LEN);
S  if (mac_addr != NULL) {
S    const uint8_t *mac = net_eth_get_addr ((__ADDR *)&addr4);
S    if (mac == NULL) {
S      mac = net_addr_unspec;
S    }
S    memcpy (mac_addr, mac, NET_ADDR_ETH_LEN);
S  }
S  return (netOK);
S}
S
S/* Accept or deny connection from remote HTTP client */
S#if (HTTP_SERVER_LEGACY != 0)
Sbool netHTTPs_AcceptClient (const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Deny IPv6 clients */
S    return (false);
S  }
S  return (http_accept_client (addr->addr, addr->port));
S}
S/* Default function, when not provided by the user */
S__weak bool http_accept_client (const uint8_t *ip_addr, uint16_t port) {
S  (void)ip_addr;
S  (void)port;
S  return (true);
S}
S#endif /* HTTP_SERVER_LEGACY */
N#endif /* RTE_Network_Web_Server_RO || RTE_Network_Web_Server_FS */
N
N//  ==== SMTP Client ====
N
N#ifdef RTE_Network_SMTP_Client
S/* Start SMTP client to send an email */
SnetStatus smtp_client_connect (const uint8_t *ip_addr, uint16_t port) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr and port to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  addr4.port      = port;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netSMTPc_Connect ((NET_ADDR *)&addr4));
S}
S
S/* Accept or deny authentication requested by SMTP server */
S#if (SMTP_CLIENT_LEGACY != 0)
Sbool netSMTPc_AcceptAuthentication (const NET_ADDR *addr) {
S  if (addr->addr_type != NET_ADDR_IP4) {
S    /* Deny IPv6 servers */
S    return (false);
S  }
S  return (smtp_client_accept_authentication (addr->addr));
S}
S#endif /* SMTP_CLIENT_LEGACY */
N#endif /* RTE_Network_SMTP_Client */
N
N//  ==== SNTP Client ====
N
N#ifdef RTE_Network_SNTP_Client
S/* Determine current time from NTP or SNTP time server */
SnetStatus sntp_get_time (const uint8_t *ip_addr, net_sntp_client_cb_t cb_func) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netSNTPc_GetTime ((NET_ADDR *)&addr4, (netSNTPc_cb_t)cb_func));
S}
N#endif /* RTE_Network_SNTP_Client */
N
N//  ==== SNMP Agent ====
N
N#ifdef RTE_Network_SNMP_Agent
S/* Send a trap message to the Trap Manager */
SnetStatus snmp_trap (const uint8_t *ip_addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list) {
S  NET_ADDR4 addr4;
S
S  /* Convert ip_addr to a structure */
S  addr4.addr_type = NET_ADDR_IP4;
S  memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
S  return (netSNMP_Trap ((NET_ADDR *)&addr4, generic, specific, obj_list));
S}
N#endif /* RTE_Network_SNMP_Agent */
N
N//  ==== Network address conversion ===
N
N/* Convert an IPv4 Network address into an ASCII string */
Nconst char *ip4_ntoa (const uint8_t *ip4_addr) {
N  return (net_addr4_ntoa (ip4_addr));
N}
N
N/* Convert a string containing an IPv4 address into a Network address */
Nbool ip4_aton (const char *cp, uint8_t *ip4_addr) {
X_Bool ip4_aton (const char *cp, uint8_t *ip4_addr) {
N  return (net_addr4_aton (cp, ip4_addr));
N}
N
N/* Convert a MAC address into an ASCII string */
Nconst char *mac_ntoa (const uint8_t *mac_addr) {
N  return (net_mac_ntoa (mac_addr));
N}
