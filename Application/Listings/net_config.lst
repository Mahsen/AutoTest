L 1 "RTE\Network\Net_Config.c"
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Config.c
N * Purpose: Network Configuration
N * Rev.:    V7.1.0
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>Network System Settings
N// <i>Global Network System definitions
N//   <s.15>Local Host Name
N//   <i>This is the name under which embedded host can be
N//   <i>accessed on a local area network.
N//   <i>Default: "my_host"
N#define NET_HOST_NAME           "my_host"
N
N//   <o>Memory Pool Size <1536-262144:4>
N//   <i>This is the size of a memory pool in bytes. Buffers for
N//   <i>network packets are allocated from this memory pool.
N//   <i>Default: 12000 bytes
N#define NET_MEM_POOL_SIZE       12000
N
N//   <q>Start System Services
N//   <i>If enabled, the system will automatically start server services
N//   <i>(HTTP, FTP, TFTP server, ...) when initializing the network system.
N//   <i>Default: Enabled
N#define NET_START_SERVICE       1
N
N//   <h>OS Resource Settings
N//   <i>These settings are used to optimize usage of OS resources.
N//     <o>Core Thread Stack Size <512-65535:4>
N//     <i>Default: 1024 bytes
N#define NET_THREAD_STACK_SIZE   2048
N
N//        Core Thread Priority
N#define NET_THREAD_PRIORITY     osPriorityNormal
N
N//   </h>
N// </h>
N
N//------------- <<< end of configuration section >>> ---------------------------
N
N#include "RTE_Components.h"
L 1 ".\RTE\_Main\RTE_Components.h" 1
N
N
N/*
N
N * Auto generated Run-Time-Environment Configuration File
N
N *      *** Do not modify ! ***
N
N *
N
N * Project: 'main' 
N
N * Target:  'Main' 
N
N */
N
N
N
N#ifndef RTE_COMPONENTS_H
N
N#define RTE_COMPONENTS_H
N
N
N
N
N
N/*
N
N * Define the Device Header File: 
N
N */
N
N#define CMSIS_device_header "LPC17xx.h"
N
N
N
N/* ARM::CMSIS:RTOS:Keil RTX:4.82.0 */
N
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N
N/* Keil.ARM Compiler::Compiler:I/O:File:File System:1.2.0 */
N
N#define RTE_Compiler_IO_File            /* Compiler I/O: File */
N
N          #define RTE_Compiler_IO_File_FS         /* Compiler I/O: File (File System) */
N
N/* Keil.MDK-Plus::File System:CORE:LFN:6.13.8 */
N
N#define RTE_FileSystem_Core             /* File System Core */
N
N          #define RTE_FileSystem_LFN              /* File System with Long Filename support */
N
N          #define RTE_FileSystem_Release          /* File System Release Version */
N
N/* Keil.MDK-Plus::File System:Drive:Memory Card:6.13.8 */
N
N#define RTE_FileSystem_Drive_MC_0       /* File System Memory Card Drive 0 */
N
N
N
N/* Keil.MDK-Plus::Network:CORE:IPv4 Release:7.14.0 */
N
N#define RTE_Network_Core                /* Network Core */
N
N          #define RTE_Network_IPv4                /* Network IPv4 Stack */
N
N          #define RTE_Network_Release             /* Network Release Version */
N
N/* Keil.MDK-Plus::Network:Interface:ETH:7.14.0 */
N
N#define RTE_Network_Interface_ETH_0     /* Network Interface ETH 0 */
N
N
N
N/* Keil.MDK-Plus::Network:Socket:TCP:7.14.0 */
N
N#define RTE_Network_Socket_TCP          /* Network Socket TCP */
N
N/* Keil::CMSIS Driver:Ethernet MAC:2.12.0 */
N
N#define RTE_Drivers_ETH_MAC0            /* Driver ETH_MAC0 */
N
N/* Keil::CMSIS Driver:Ethernet PHY:DP83848C:6.2.0 */
N
N#define RTE_Drivers_PHY_DP83848C        /* Driver PHY DP83848C */
N
N/* Keil::CMSIS Driver:SPI:SSP:2.7.0 */
N
N#define RTE_Drivers_SPI0                /* Driver SPI0 */
N
N        #define RTE_Drivers_SPI1                /* Driver SPI1 */
N
N/* Keil::Device:Startup:1.0.0 */
N
N#define RTE_DEVICE_STARTUP_LPC17XX      /* Device Startup for NXP17XX */
N
N
N
N
N
N#endif /* RTE_COMPONENTS_H */
N
L 47 "RTE\Network\Net_Config.c" 2
N
N#ifdef  RTE_Network_Interface_ETH_0
N#include "Net_Config_ETH_0.h"
L 1 "RTE\Network\Net_Config_ETH_0.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network:Interface
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Config_ETH_0.h
N * Purpose: Network Configuration for ETH Interface
N * Rev.:    V7.3.0
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>Ethernet Network Interface 0
N#define ETH0_ENABLE             1
N
N//   <o>Connect to hardware via Driver_ETH# <0-255>
N//   <i>Select driver control block for MAC and PHY interface
N#define ETH0_DRIVER             0
N
N//   <s.17>MAC Address
N//   <i>Ethernet MAC Address in text representation
N//   <i>Value FF-FF-FF-FF-FF-FF is not allowed,
N//   <i>LSB of first byte must be 0 (an ethernet Multicast bit).
N//   <i>Default: "1E-30-6C-A2-45-5E"
N#define ETH0_MAC_ADDR           "1E-30-6C-A2-45-5E"
N
N//   <e>VLAN
N//   <i>Enable or disable Virtual LAN
N#define ETH0_VLAN_ENABLE        0
N
N//     <o>VLAN Identifier <1-4093>
N//     <i>A unique 12-bit numeric value
N//     <i>Default: 1
N#define ETH0_VLAN_ID            1
N//   </e>
N
N//   <e>IPv4
N//   <i>Enable IPv4 Protocol for Network Interface
N#define ETH0_IP4_ENABLE         1
N
N//     <s.15>IP Address
N//     <i>Static IPv4 Address in text representation
N//     <i>Default: "192.168.0.100"
N#define ETH0_IP4_ADDR           "192.168.88.20"
N
N//     <s.15>Subnet mask
N//     <i>Local Subnet mask in text representation
N//     <i>Default: "255.255.255.0"
N#define ETH0_IP4_MASK           "255.255.255.0"
N
N//     <s.15>Default Gateway
N//     <i>IP Address of Default Gateway in text representation
N//     <i>Default: "192.168.0.254"
N#define ETH0_IP4_GATEWAY        "192.168.88.1"
N
N//     <s.15>Primary DNS Server
N//     <i>IP Address of Primary DNS Server in text representation
N//     <i>Default: "8.8.8.8"
N#define ETH0_IP4_PRIMARY_DNS    "192.168.88.1"
N
N//     <s.15>Secondary DNS Server
N//     <i>IP Address of Secondary DNS Server in text representation
N//     <i>Default: "8.8.4.4"
N#define ETH0_IP4_SECONDARY_DNS  "8.8.8.8"
N
N//     <e>IP Fragmentation
N//     <i>This option enables fragmentation of outgoing IP datagrams,
N//     <i>and reassembling the fragments of incoming IP datagrams.
N//     <i>Default: enabled
N#define ETH0_IP4_FRAG_ENABLE    1
N
N//       <o>MTU size <576-1500>
N//       <i>Maximum Transmission Unit in bytes
N//       <i>Default: 1500
N#define ETH0_IP4_MTU            1500
N//     </e>
N
N//     <h>ARP Address Resolution
N//     <i>ARP cache and node address resolver settings
N//       <o>Cache Table size <5-100>
N//       <i>Number of cached MAC/IP addresses
N//       <i>Default: 10
N#define ETH0_ARP_TAB_SIZE       10
N
N//       <o>Cache Timeout in seconds <5-255>
N//       <i>A timeout for cached hardware/IP addresses
N//       <i>Default: 150
N#define ETH0_ARP_CACHE_TOUT     150
N
N//       <o>Number of Retries <0-20>
N//       <i>Number of Retries to resolve an IP address
N//       <i>before ARP module gives up
N//       <i>Default: 4
N#define ETH0_ARP_MAX_RETRY      4
N
N//       <o>Resend Timeout in seconds <1-10>
N//       <i>A timeout to resend the ARP Request
N//       <i>Default: 2
N#define ETH0_ARP_RESEND_TOUT    2
N
N//       <q>Send Notification on Address changes
N//       <i>When this option is enabled, the embedded host
N//       <i>will send a Gratuitous ARP notification at startup,
N//       <i>or when the device IP address has changed.
N//       <i>Default: Disabled
N#define ETH0_ARP_NOTIFY         0
N//     </h>
N
N//     <e>IGMP Group Management
N//     <i>Enable or disable Internet Group Management Protocol
N#define ETH0_IGMP_ENABLE        0
N
N//       <o>Membership Table size <2-50>
N//       <i>Number of Groups this host can join
N//       <i>Default: 5
N#define ETH0_IGMP_TAB_SIZE      5
N//     </e>
N
N//     <q>NetBIOS Name Service
N//     <i>When this option is enabled, the embedded host can be
N//     <i>accessed by its name on local LAN using NBNS protocol.
N#define ETH0_NBNS_ENABLE        0
N
N//     <e>Dynamic Host Configuration
N//     <i>When this option is enabled, local IP address, Net Mask
N//     <i>and Default Gateway are obtained automatically from
N//     <i>the DHCP Server on local LAN.
N#define ETH0_DHCP_ENABLE        0
N
N//       <s.40>Vendor Class Identifier
N//       <i>This value is optional. If specified, it is added
N//       <i>to DHCP request message, identifying vendor type.
N//       <i>Default: ""
N#define ETH0_DHCP_VCID          ""
N
N//       <q>Bootfile Name
N//       <i>This value is optional. If enabled, the Bootfile Name
N//       <i>(option 67) is also requested from DHCP server.
N//       <i>Default: disabled
N#define ETH0_DHCP_BOOTFILE      0
N
N//       <q>NTP Servers
N//       <i>This value is optional. If enabled, a list of NTP Servers
N//       <i>(option 42) is also requested from DHCP server.
N//       <i>Default: disabled
N#define ETH0_DHCP_NTP_SERVERS   0
N//     </e>
N
N//     Disable ICMP Echo response
N#define ETH0_ICMP_NO_ECHO       0 
N//   </e>
N
N//   <e>IPv6
N//   <i>Enable IPv6 Protocol for Network Interface
N#define ETH0_IP6_ENABLE         0
N
N//     <s.40>IPv6 Address
N//     <i>Static IPv6 Address in text representation
N//     <i>Use unspecified address "::" when static
N//     <i>IPv6 address is not used.
N//     <i>Default: "fec0::2"
N#define ETH0_IP6_ADDR           "fec0::2"
N
N//     <o>Subnet prefix-length <1-128>
N//     <i>Number of bits that define network address
N//     <i>Default: 64
N#define ETH0_IP6_PREFIX_LEN     64
N
N//     <s.40>Default Gateway
N//     <i>Default Gateway IPv6 Address in text representation
N//     <i>Default: "fec0::1"
N#define ETH0_IP6_GATEWAY        "fec0::1"
N
N//     <s.40>Primary DNS Server
N//     <i>Primary DNS Server IPv6 Address in text representation
N//     <i>Default: "2001:4860:4860::8888"
N#define ETH0_IP6_PRIMARY_DNS    "2001:4860:4860::8888"
N
N//     <s.40>Secondary DNS Server
N//     <i>Secondary DNS Server IPv6 Address in text representation
N//     <i>Default: "2001:4860:4860::8844"
N#define ETH0_IP6_SECONDARY_DNS  "2001:4860:4860::8844"
N
N//     <h>Neighbor Discovery
N//     <i>Neighbor cache and node address resolver settings
N//       <o>Cache Table size <5-100>
N//       <i>Number of cached node addresses
N//       <i>Default: 5
N#define ETH0_NDP_TAB_SIZE       5
N
N//       <o>Cache Timeout in seconds <5-255>
N//       <i>Timeout for cached node addresses
N//       <i>Default: 150
N#define ETH0_NDP_CACHE_TOUT     150
N
N//       <o>Number of Retries <0-20>
N//       <i>Number of retries to resolve an IP address
N//       <i>before NDP module gives up
N//       <i>Default: 4
N#define ETH0_NDP_MAX_RETRY      4
N
N//       <o>Resend Timeout in seconds <1-10>
N//       <i>A timeout to resend Neighbor Solicitation
N//       <i>Default: 2
N#define ETH0_NDP_RESEND_TOUT    2
N//     </h>
N
N//     <e>Dynamic Host Configuration
N//     <i>When this option is enabled, local IPv6 address is
N//     <i>automatically configured.
N#define ETH0_DHCP6_ENABLE       1
N
N//       <o>DHCPv6 Client Mode  <0=>Stateless Mode <1=>Statefull Mode
N//       <i>Stateless DHCPv6 Client uses router advertisements
N//       <i>for IPv6 address autoconfiguration (SLAAC).
N//       <i>Statefull DHCPv6 Client connects to DHCPv6 server for a
N//       <i>leased IPv6 address and DNS server IPv6 addresses.
N#define ETH0_DHCP6_MODE         1
N
N//       <e>Vendor Class Option
N//       <i>If enabled, Vendor Class option is added to DHCPv6
N//       <i>request message, identifying vendor type.
N//       <i>Default: disabled
N#define ETH0_DHCP6_VCLASS_ENABLE 0
N
N//         <o>Enterprise ID
N//         <i>Enterprise-number as registered with IANA.
N//         <i>Default: 0 (Reserved)
N#define ETH0_DHCP6_VCLASS_EID   0
N
N//         <s.40>Vendor Class Data
N//         <i>This string identifies vendor type.
N//         <i>Default: ""
N#define ETH0_DHCP6_VCLASS_DATA  ""
N//       </e>
N//     </e>
N
N//     Disable ICMP6 Echo response
N#define ETH0_ICMP6_NO_ECHO      0 
N//   </e>
N
N//   <h>OS Resource Settings
N//   <i>These settings are used to optimize usage of OS resources.
N//     <o>Interface Thread Stack Size <512-65535:4>
N//     <i>Default: 512 bytes
N#define ETH0_THREAD_STACK_SIZE  1024
N
N//        Interface Thread Priority
N#define ETH0_THREAD_PRIORITY    osPriorityAboveNormal
N
N//   </h>
N// </h>
N
N//------------- <<< end of configuration section >>> ---------------------------
L 50 "RTE\Network\Net_Config.c" 2
N#endif
N#ifdef  RTE_Network_Interface_ETH_1
S#include "Net_Config_ETH_1.h"
N#endif
N
N#ifdef  RTE_Network_Interface_WiFi_0
S#include "Net_Config_WiFi_0.h"
N#endif
N
N#ifdef  RTE_Network_Interface_WiFi_1
S#include "Net_Config_WiFi_1.h"
N#endif
N
N#ifdef  RTE_Network_Interface_PPP
S#include "Net_Config_PPP.h"
N#endif
N
N#ifdef  RTE_Network_Interface_SLIP
S#include "Net_Config_SLIP.h"
N#endif
N
N#ifdef  RTE_Network_Socket_UDP
S#include "Net_Config_UDP.h"
N#endif
N#ifdef  RTE_Network_Socket_TCP
N#include "Net_Config_TCP.h"
L 1 "RTE\Network\Net_Config_TCP.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network:Socket
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Config_TCP.h
N * Purpose: Network Configuration for TCP Sockets
N * Rev.:    V7.1.1
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <h>TCP Sockets
N#define TCP_ENABLE              1
N
N//   <o>Number of TCP Sockets <1-20>
N//   <i>Number of available TCP sockets
N//   <i>Default: 6
N#define TCP_NUM_SOCKS           6
N
N//   <o>Number of Retries <0-20>
N//   <i>How many times TCP module will try to retransmit data
N//   <i>before giving up. Increase this value for high-latency
N//   <i>and low throughput networks.
N//   <i>Default: 5
N#define TCP_MAX_RETRY           5
N
N//   <o>Retry Timeout in seconds <1-10>
N//   <i>If data frame not acknowledged within this time frame,
N//   <i>TCP module will try to resend the data again.
N//   <i>Default: 4
N#define TCP_RETRY_TOUT          4
N
N//   <o>Default Connect Timeout in seconds <1-65535>
N//   <i>If no TCP data frame has been exchanged during this time,
N//   <i>the TCP connection is either closed or a keep-alive frame
N//   <i>is sent to verify that the connection still exists.
N//   <i>Default: 120
N#define TCP_DEFAULT_TOUT        120
N
N//   <o>Maximum Segment Size <536-1440>
N//   <i>The Maximum Segment Size specifies the maximum
N//   <i>number of bytes in the TCP segment's Data field.
N//   <i>Default: 1440
N#define TCP_MAX_SEG_SIZE        1440
N
N//   <o>Receive Window Size <536-65535>
N//   <i>Receive Window Size specifies the size of data, 
N//   <i>that the socket is able to buffer in flow-control mode.
N//   <i>Default: 4320
N#define TCP_RECEIVE_WIN_SIZE    4320
N
N// </h>
N
N// TCP Initial Retransmit period in seconds
N#define TCP_INITIAL_RETRY_TOUT  1
N
N// TCP SYN frame retransmit period in seconds
N#define TCP_SYN_RETRY_TOUT      2
N
N// Number of retries to establish a connection
N#define TCP_CONNECT_RETRY       7
N
N// Dynamic port start (default 49152)
N#define TCP_DYN_PORT_START      49152
N
N// Dynamic port end (default 65535)
N#define TCP_DYN_PORT_END        65535
N
N//------------- <<< end of configuration section >>> ---------------------------
L 76 "RTE\Network\Net_Config.c" 2
N#endif
N#ifdef  RTE_Network_Socket_BSD
S#include "Net_Config_BSD.h"
N#endif
N
N#ifdef  RTE_Network_Web_Server_RO
S#include "Net_Config_HTTP_Server.h"
N#endif
N#ifdef  RTE_Network_Web_Server_FS
S#include "Net_Config_HTTP_Server.h"
N#endif
N
N#ifdef  RTE_Network_Telnet_Server
S#include "Net_Config_Telnet_Server.h"
N#endif
N
N#ifdef  RTE_Network_TFTP_Server
S#include "Net_Config_TFTP_Server.h"
N#endif
N#ifdef  RTE_Network_TFTP_Client
S#include "Net_Config_TFTP_Client.h"
N#endif
N
N#ifdef  RTE_Network_FTP_Server
S#include "Net_Config_FTP_Server.h"
N#endif
N#ifdef  RTE_Network_FTP_Client
S#include "Net_Config_FTP_Client.h"
N#endif
N
N#ifdef  RTE_Network_DNS_Client
S#include "Net_Config_DNS_Client.h"
N#endif
N
N#ifdef  RTE_Network_SMTP_Client
S#include "Net_Config_SMTP_Client.h"
N#endif
N
N#ifdef  RTE_Network_SNMP_Agent
S#include "Net_Config_SNMP_Agent.h"
N#endif
N
N#ifdef  RTE_Network_SNTP_Client
S#include "Net_Config_SNTP_Client.h"
N#endif
N
N#include "net_config.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_config.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    net_config.h
N * Purpose: Network Library Configuration
N * Rev.:    V7.13.2
N *----------------------------------------------------------------------------*/
N
N#if   defined(__CC_ARM)
X#if   1L
N  #pragma O3
N#elif defined(__clang__)
S  #pragma clang diagnostic ignored "-Wundef"
S  #pragma clang diagnostic ignored "-Wpadded"
S  #pragma clang diagnostic ignored "-Wmissing-noreturn"
N#endif
N
N#include "rl_net_lib.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_lib.h
N * Purpose: Network Library Definitions
N * Rev.:    V7.13.4
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_LIB_H
N#define __RL_NET_LIB_H
N
N#include "rl_net_ds.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_ds.h
N * Purpose: Network API (Dual-stack IPv4/IPv6)
N * Rev.:    V7.13.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_DS_H
N#define __RL_NET_DS_H
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 15 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 16 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include "RTE_Components.h"
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N#ifdef __clang__
S  #define __weak    __attribute__((weak))
N#endif
N
N/// Network to host byte order conversion.
N#if defined(__BIG_ENDIAN) || defined(__ARM_BIG_ENDIAN)
X#if 0L || 0L
S  #define ntohl(v)              (uint32_t)(v)
S  #define ntohs(v)              (uint16_t)(v)
N#elif defined (__CC_ARM)
X#elif 1L
N  /* ARM Compiler 4/5 */
N  #define ntohl(v)              (uint32_t)(__rev(v))
N  #define ntohs(v)              (uint16_t)(__rev(v) >> 16)
N#else
S  /* ARM Compiler 6 */
S  #define ntohl(v)              __builtin_bswap32((uint32_t)(v))
S  #define ntohs(v)              __builtin_bswap16((uint16_t)(v))
N#endif
N
N/// Host to network byte order conversion.
N#define htons(v)                ntohs(v)
N#define htonl(v)                ntohl(v)
N
N/// General definitions.
N#define NET_ADDR_ETH_LEN        6       ///< Ethernet MAC Address Length in bytes
N#define NET_ADDR_IP4_LEN        4       ///< IPv4 Address Length in bytes
N#define NET_ADDR_IP6_LEN        16      ///< IPv6 Address Length in bytes
N#define NET_HOSTNAME_LEN        16      ///< Hostname Buffer Length in bytes
N#define NET_ROOT_DIR_LEN        80      ///< Service Root Folder Length in bytes
N
N/// Network Address types.
N#define NET_ADDR_ANY           (-1)     ///< IP address any
N#define NET_ADDR_IP4            0       ///< IPv4 Address
N#define NET_ADDR_IP6            1       ///< IPv6 Address
N
N/// Network Address IPv4/IPv6 capable.
Ntypedef struct net_addr {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4 or \ref NET_ADDR_IP6
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP6_LEN];      ///< IPv4 or IPv6 address (array 16 bytes, MSB first)
X  uint8_t  addr[16];      
N} NET_ADDR;
N
N/// Network Address IPv4 only.
Ntypedef struct net_addr4 {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP4_LEN];      ///< IPv4 address (array 4 bytes, MSB first)
X  uint8_t  addr[4];      
N} NET_ADDR4;
N
N/// Service Authentication definitions.
N#define NET_USERNAME_LEN        16      ///< Username Buffer Length in bytes
N#define NET_PASSWORD_LEN        16      ///< Password Buffer Length in bytes
N
N/// Network Access definitions. 
N#define NET_ACCESS_FILE_READ            0x01  ///< File Read is allowed
N#define NET_ACCESS_FILE_WRITE           0x02  ///< File Write is allowed
N#define NET_ACCESS_DIRECTORY_CREATE     0x04  ///< Directory Create is allowed
N#define NET_ACCESS_DIRECTORY_REMOVE     0x08  ///< Directory Remove is allowed
N#define NET_ACCESS_DIRECTORY_LIST       0x10  ///< Directory List is allowed
N
N/// Status code values returned by Network library functions.
Ntypedef enum {
N  netOK                       = 0,      ///< Operation succeeded
N  netBusy,                              ///< Process is busy
N  netError,                             ///< Unspecified error
N  netInvalidParameter,                  ///< Invalid parameter specified
N  netWrongState,                        ///< Wrong state error
N  netDriverError,                       ///< Driver error
N  netServerError,                       ///< Server error
N  netAuthenticationFailed,              ///< User authentication failed
N  netDnsResolverError,                  ///< DNS host resolver failed
N  netFileError,                         ///< File not found or file r/w error
N  netTimeout                            ///< Operation timeout
N} netStatus;
N
N/// UDP Checksum Options.
N#define NET_UDP_CHECKSUM_SEND   0x01    ///< Calculate Checksum for UDP send frames (default)
N#define NET_UDP_CHECKSUM_VERIFY 0x02    ///< Verify Checksum for received UDP frames (default)
N
N/// UDP Socket Options.
Ntypedef enum {
N  netUDP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netUDP_OptionTTL,                     ///< IPv4 Multi-cast Time to Live; val=TTL
N  netUDP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netUDP_OptionHopLimit,                ///< IPv6 Multi-cast Hop Limit; val=HopLimit
N  netUDP_OptionInterface,               ///< IPv4 Broadcast Interface; val=if_id (class and number)
N  netUDP_OptionChecksum                 ///< UDP Checksum Options
N} netUDP_Option;
N
N/// UDP Event callback function.
Ntypedef uint32_t (*netUDP_cb_t)(int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N/// TCP Socket Events.
Ntypedef enum {
N  netTCP_EventConnect         = 0,      ///< Connect request received event
N  netTCP_EventEstablished,              ///< Connection established event
N  netTCP_EventClosed,                   ///< Connection was properly closed
N  netTCP_EventAborted,                  ///< Connection is for some reason aborted
N  netTCP_EventACK,                      ///< Previously send data acknowledged
N  netTCP_EventData                      ///< Data received event
N} netTCP_Event;
N
N/// TCP Socket States.
Ntypedef enum {
N  netTCP_StateINVALID         =-1,      ///< Invalid Socket
N  netTCP_StateUNUSED          = 0,      ///< Entry is free and unused
N  netTCP_StateCLOSED,                   ///< Entry allocated, socket still closed
N  netTCP_StateLISTEN,                   ///< Socket waiting for incoming connection
N  netTCP_StateSYN_RECEIVED,             ///< SYN frame received
N  netTCP_StateSYN_SENT,                 ///< SYN packet sent to establish a connection
N  netTCP_StateFIN_WAIT_1,               ///< Close started FIN packet was sent
N  netTCP_StateFIN_WAIT_2,               ///< Our FIN ACK-ed, waiting for remote FIN
N  netTCP_StateCLOSING,                  ///< Received FIN independently of our FIN
N  netTCP_StateLAST_ACK,                 ///< Waiting for last ACK for our FIN
N  netTCP_StateTIME_WAIT,                ///< Timed waiting for 2MSL
N  netTCP_StateESTABLISHED               ///< TCP Connection established
N} netTCP_State;
N
N/// TCP Socket Options.
Ntypedef enum {
N  netTCP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netTCP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netTCP_OptionTimeout,                 ///< TCP Idle Timeout; val=timeout (in seconds)
N  netTCP_OptionKeepAlive,               ///< TCP Keep Alive; val: 0=disabled (default), 1=enabled
N  netTCP_OptionFlowControl,             ///< TCP Flow Control; val: 0=disabled (default), 1=enabled
N  netTCP_OptionDelayedACK               ///< TCP Delayed Acknowledgment; val: 0=disabled (default), 1=enabled 
N} netTCP_Option;
N
N/// TCP Event callback function.
Ntypedef uint32_t (*netTCP_cb_t)(int32_t socket, netTCP_Event event, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N#ifdef RTE_Network_Socket_BSD
S
S//  ==== BSD Socket definitions ====
S
S/// BSD Socket Address Family.
S#define AF_UNSPEC               0       ///< Unspecified
S#define AF_INET                 1       ///< Internet Address Family
S#define AF_NETBIOS              2       ///< NetBios-style addresses
S#define AF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Protocol families (same as address families).
S#define PF_UNSPEC               0       ///< Unspecified
S#define PF_INET                 1       ///< Internet Address Family
S#define PF_NETBIOS              2       ///< NetBios-style addresses
S#define PF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Socket Type.
S#define SOCK_STREAM             1       ///< Stream Socket (Connection oriented)
S#define SOCK_DGRAM              2       ///< Datagram Socket (Connectionless)
S
S/// BSD Socket Protocol.
S#define IPPROTO_TCP             1       ///< TCP Protocol
S#define IPPROTO_UDP             2       ///< UDP Protocol
S
S/// BSD Internet Addresses IPv4.
S#define INADDR_ANY              0x00000000  ///< All IP addresses accepted
S#define INADDR_NONE             0xffffffff  ///< No IP address accepted
S#define INADDR_LOOPBACK         0x7f000001  ///< Localhost IP address
S
S/// BSD Socket flags parameter.
S#define MSG_DONTWAIT            0x01    ///< Enables non-blocking operation
S#define MSG_PEEK                0x02    ///< Peeks at the incoming data
S#define MSG_TRUNC               0x04    ///< Normal data was truncated
S#define MSG_CTRUNC              0x08    ///< Control data was truncated
S
S/// BSD Socket ioctl commands.
S#define FIONBIO                 1       ///< Set mode (blocking/non-blocking)
S
S/// BSD Socket level.
S#define SOL_SOCKET              1       ///< Socket Level
S#define IPPROTO_IP              2       ///< IPv4 Level
S#define IPPROTO_IPV6            3       ///< IPv6 Level
S
S/// BSD Socket options.
S#define SO_KEEPALIVE            1       ///< Keep Alive
S#define SO_RCVTIMEO             2       ///< Timeout for blocking receive (in milliseconds)
S#define SO_SNDTIMEO             3       ///< Timeout for blocking send (in milliseconds)
S#define SO_TYPE                 4       ///< Socket type (read only)
S
S/// BSD Socket IPv4 options.
S#define IP_TOS                  1       ///< Type of Service (TOS)
S#define IP_TTL                  2       ///< Time to Live (TTL)
S#define IP_RECVDSTADDR          3       ///< Receive destination IPv4 address
S
S/// BSD Socket IPv6 options.
S#define IPV6_TCLASS             1       ///< Traffic Class
S#define IPV6_MULTICAST_HOPS     2       ///< Multi-cast Hop Limit
S#define IPV6_RECVDSTADDR        3       ///< Receive destination IPv6 address
S
S/// BSD Socket Error codes.
S#define BSD_ERROR               (-1)    ///< Unspecified error
S#define BSD_ESOCK               (-2)    ///< Invalid socket descriptor
S#define BSD_EINVAL              (-3)    ///< Invalid parameter
S#define BSD_ENOTSUP             (-11)   ///< Operation or feature not supported
S#define BSD_ENOMEM              (-5)    ///< Not enough memory
S#define BSD_ELOCKED             (-7)    ///< Socket locked by another thread
S#define BSD_EWOULDBLOCK         (-4)    ///< Operation would block
S#define BSD_ETIMEDOUT           (-8)    ///< Operation timed out
S#define BSD_EINPROGRESS         (-9)    ///< Operation in progress
S#define BSD_ENOTCONN            (-6)    ///< Socket not connected
S#define BSD_EISCONN             (-12)   ///< Socket is connected
S#define BSD_ECONNREFUSED        (-13)   ///< Connection rejected by the peer
S#define BSD_ECONNRESET          (-14)   ///< Connection reset by the peer
S#define BSD_ECONNABORTED        (-15)   ///< Connection aborted locally
S#define BSD_EALREADY            (-16)   ///< Connection already in progress
S#define BSD_EADDRINUSE          (-17)   ///< Address already in use
S#define BSD_EDESTADDRREQ        (-18)   ///< Destination address required
S#define BSD_EHOSTNOTFOUND       (-10)   ///< Host not found
S
S/// BSD Socket legacy Error codes.
S#define BSD_SUCCESS             0       ///< Success
S#define BSD_ERROR_SOCKET        BSD_ESOCK
S#define BSD_ERROR_PARAMETER     BSD_EINVAL
S#define BSD_ERROR_WOULDBLOCK    BSD_EWOULDBLOCK
S#define BSD_ERROR_NOMEMORY      BSD_ENOMEM
S#define BSD_ERROR_CLOSED        BSD_ENOTCONN
S#define BSD_ERROR_LOCKED        BSD_ELOCKED
S#define BSD_ERROR_TIMEOUT       BSD_ETIMEDOUT
S#define BSD_ERROR_INPROGRESS    BSD_EINPROGRESS
S#define BSD_ERROR_NONAME        BSD_EHOSTNOTFOUND
S
S//  ==== BSD Socket structures ====
S
S/// Generic Socket Address structure.
Stypedef struct sockaddr {
S  uint16_t sa_family;                   ///< Address family
S  int8_t   sa_data[14];                 ///< Direct address (up to 14 bytes)
S} SOCKADDR;
S
S#if   defined(__CC_ARM)
S  #pragma push
S  #pragma anon_unions
S#elif defined(__clang__)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S#endif
S
S/// Generic IPv4 Address structure.
Stypedef struct in_addr {
S  union {
S    struct {
S      uint8_t s_b1,s_b2,s_b3,s_b4;      ///< IP address, byte access
S    };
S    struct {
S      uint16_t s_w1,s_w2;               ///< IP address, short int access
S    };
S    uint32_t s_addr;                    ///< IP address in network byte order
S  };
S} IN_ADDR;
S
S/// Generic IPv6 Address structure.
Stypedef struct in6_addr {
S  union {
S    uint8_t  s6_b[16];                  ///< IP6 address, byte access
S    uint16_t s6_w[8];                   ///< IP6 address, short int access
S  };
S} IN6_ADDR;
S#define s6_addr     s6_b
S
S#if   defined(__CC_ARM)
S  #pragma pop
S#elif defined(__clang__)
S  #pragma clang diagnostic pop
S#endif
S
S/// IPv4 Socket Address structure.
Stypedef struct sockaddr_in {
S  int16_t  sin_family;                  ///< Socket domain
S  uint16_t sin_port;                    ///< Port
S  IN_ADDR  sin_addr;                    ///< IP address
S  int8_t   sin_zero[8];                 ///< reserved
S} SOCKADDR_IN;
S
S/// IPv6 Socket Address structure.
Stypedef struct sockaddr_in6 {
S  int16_t  sin6_family;                 ///< Socket domain
S  uint16_t sin6_port;                   ///< Port
S  uint32_t sin6_flowinfo;               ///< IP6 flow information
S  IN6_ADDR sin6_addr;                   ///< IP6 address
S} SOCKADDR_IN6;
S
S/// Socket Address storage structure.
Stypedef struct sockaddr_storage {
S  int16_t ss_family;                    ///< Address family
S  int8_t  __ss_pad1[2];                 ///< reserved
S  int32_t __ss_align;                   ///< reserved, structure alignment
S  int8_t  __ss_pad2[16];                ///< reserved
S} SOCKADDR_STORAGE;
S
S/// BSD Host Entry structure.
Stypedef struct hostent {
S  char   *h_name;                       ///< Official name of host
S  char  **h_aliases;                    ///< Pointer to an array of alias names
S  int16_t h_addrtype;                   ///< Address Type: AF_INET, AF_NETBIOS
S  int16_t h_length;                     ///< Length of address in bytes
S  char  **h_addr_list;                  ///< Pointer to an array of IPv4 addresses
S} HOSTENT;
S
S/// BSD address string length.
S#define INET_ADDRSTRLEN         16      ///< IP address string length
S#define INET6_ADDRSTRLEN        46      ///< IP6 address string length
S
S/// BSD fd_set size.
S#define FD_SETSIZE              64      ///< Maximum number of sockets in fd_set structure
S
S/// BSD fd_set structure.
Stypedef struct fd_set {
S  uint32_t fd_bits[(FD_SETSIZE+31)>>5]; ///< Set of sockets bit-mask
S} fd_set;
S
S/// BSD timeval structure.
Stypedef struct timeval {
S  uint32_t tv_sec;                      ///< Time interval: seconds
S  uint32_t tv_usec;                     ///< Time interval: microseconds
S} timeval;
S
S/// BSD safe read/write fd_set macros.
S#define FD_WR(fd,code)          if ((fd > 0) && (fd <= FD_SETSIZE)) { code; }
S#define FD_RD(fd,code)          (((fd > 0) && (fd <= FD_SETSIZE)) ? (code) : 0)
S
S/// BSD initialize and test fd_set macros.
S#define FD_SET(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] |=  (1U << ((fd-1)&0x1F)))
S#define FD_CLR(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] &= ~(1U << ((fd-1)&0x1F)))
S#define FD_ISSET(fd,set)        FD_RD(fd, (set)->fd_bits[(fd-1)>>5] &   (1U << ((fd-1)&0x1F)))
S#define FD_ZERO(set)            memset(set, 0, sizeof(*set))
S
S/// BSD scatter/gather array of items.
Stypedef struct iovec {
S  void    *iov_base;                    ///< Starting address
S  uint32_t iov_len;                     ///< Number of bytes to transfer
S} IOVEC;
S
S/// BSD message header structure.
Stypedef struct msghdr {
S  void    *msg_name;                    ///< Optional pointer to source address
S  uint32_t msg_namelen;                 ///< Size of address buffer
S  IOVEC   *msg_iov;                     ///< An array of iovec buffers for the message
S  int32_t  msg_iovlen;                  ///< Number of elements in msg_iov
S  void    *msg_control;                 ///< Ancillary data
S  uint32_t msg_controllen;              ///< Ancillary data buffer length
S  int32_t  msg_flags;                   ///< Flags on received message
S} MSGHDR;
S
S/// BSD cmsg header structure.
Stypedef struct cmsghdr {
S  uint32_t cmsg_len;                    ///< Data byte count, including the cmsghdr
S  int32_t  cmsg_level;                  ///< Originating protocol
S  int32_t  cmsg_type;                   ///< Protocol-specific type
S} CMSGHDR;
S
S/// BSD access ancillary data macros (RFC 2292).
S#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ? \
S                                 (CMSGHDR *)(mhdr)->msg_control             : \
S                                 (CMSGHDR *)NULL
X#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ?                                  (CMSGHDR *)(mhdr)->msg_control             :                                  (CMSGHDR *)NULL
S#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) > \
S                                 (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ? \
S                                 (CMSGHDR *)NULL                                                   : \
S                                 (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
X#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) >                                  (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ?                                  (CMSGHDR *)NULL                                                   :                                  (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
S#define CMSG_DATA(cmsg)         ((uint8_t *)(cmsg) + sizeof(CMSGHDR))
S#define CMSG_ALIGN(len)         (((len) + 3) & ~3U)
S#define CMSG_LEN(len)           ((len) + sizeof(CMSGHDR))
S#define CMSG_SPACE(len)          CMSG_ALIGN((len) + sizeof(CMSGHDR))
S
N#endif /* RTE_Network_Socket_BSD */
N
N/// Interface Class
N#define NET_IF_CLASS_ETH        (1U << 8)   ///< Ethernet interface
N#define NET_IF_CLASS_WIFI       (2U << 8)   ///< WiFi interface
N#define NET_IF_CLASS_PPP        (3U << 8)   ///< PPP interface
N#define NET_IF_CLASS_SLIP       (4U << 8)   ///< SLIP interface
N
N/// Interface Option codes.
Ntypedef enum {
N  netIF_OptionMAC_Address,              ///< Ethernet MAC Address (6 bytes)
N  netIF_OptionVLAN_Identifier,          ///< Ethernet VLAN Identifier (2 bytes)
N  netIF_OptionIP4_MTU,                  ///< IPv4 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP4_Address,              ///< IPv4 Address (4 bytes)
N  netIF_OptionIP4_SubnetMask,           ///< IPv4 Subnet mask (4 bytes)
N  netIF_OptionIP4_DefaultGateway,       ///< IPv4 Default Gateway (4 bytes)
N  netIF_OptionIP4_PrimaryDNS,           ///< IPv4 Primary DNS (4 bytes)
N  netIF_OptionIP4_SecondaryDNS,         ///< IPv4 Secondary DNS (4 bytes)
N  netIF_OptionIP6_MTU,                  ///< IPv6 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP6_LinkLocalAddress,     ///< IPv6 Link-local Address (16 bytes)
N  netIF_OptionIP6_StaticAddress,        ///< IPv6 Static Address (16 bytes)
N  netIF_OptionIP6_DynamicAddress,       ///< IPv6 Dynamic Address (16 bytes)
N  netIF_OptionIP6_SubnetPrefixLength,   ///< IPv6 Subnet Prefix-length (1 byte)
N  netIF_OptionIP6_DefaultGateway,       ///< IPv6 Default Gateway (16 bytes)
N  netIF_OptionIP6_PrimaryDNS,           ///< IPv6 Primary DNS (16 bytes)
N  netIF_OptionIP6_SecondaryDNS          ///< IPv6 Secondary DNS (16 bytes)
N} netIF_Option;
N
N/// Interface IP Versions.
Ntypedef enum {
N  netIF_VersionIP4,                     ///< IP version 4
N  netIF_VersionIP6                      ///< IP version 6
N} netIF_Version;
N
N/// Ethernet link speed.
N#define NET_ETH_SPEED_10M       0       ///< 10 Mbps link speed
N#define NET_ETH_SPEED_100M      1       ///< 100 Mbps link speed
N#define NET_ETH_SPEED_1G        2       ///< 1 Gpbs link speed
N
N/// Ethernet duplex mode.
N#define NET_ETH_DUPLEX_HALF     0       ///< Half duplex link
N#define NET_ETH_DUPLEX_FULL     1       ///< Full duplex link
N
N/// Ethernet link information.
Ntypedef struct net_eth_link_info {
N  uint32_t speed  : 2;                  ///< Link speed: 0= 10 MBit, 1= 100 MBit, 2= 1 GBit
N  uint32_t duplex : 1;                  ///< Duplex mode: 0= Half, 1= Full
N} NET_ETH_LINK_INFO;
N
N/// Ethernet Callback Events.
Ntypedef enum {
N  netETH_LinkDown             = 0,      ///< Link down
N  netETH_LinkUp,                        ///< Link up; val=link_info
N  netETH_Wakeup,                        ///< Wake-up (on Magic Packet)
N  netETH_TimerAlarm                     ///< Timer Alarm (PTP)
N} netETH_Event;
N
N/// WiFi Security Types.
Ntypedef enum {
N  netWiFi_SecurityOpen        = 0,      ///< Open
N  netWiFi_SecurityWEP,                  ///< Wired Equivalent Privacy
N  netWiFi_SecurityWPA,                  ///< WiFi Protected Access
N  netWiFi_SecurityWPA2,                 ///< WiFi Protected Access 2
N  netWiFi_SecurityUnknown     = 255     ///< Unknown security
N} netWiFi_Security;
N
N/// WiFi Driver Options.
Ntypedef enum {
N  netWiFi_OptionBSSID         = 1,      ///< BSSID of AP
N  netWiFi_OptionTxPower,                ///< Transmit Power
N  netWiFi_OptionLpTimer,                ///< Low Power deep-sleep timer
N  netWiFi_OptionDTIM,                   ///< DTIM interval
N  netWiFi_OptionBeacon                  ///< Beacon interval
N} netWiFi_Option;
N
N/// WiFi WPS Methods.
Ntypedef enum {
N  netWiFi_WPS_None            = 0,      ///< Not used
N  netWiFi_WPS_PBC,                      ///< With Push Button Configuration
N  netWiFi_WPS_PIN                       ///< With PIN
N} netWiFi_WPS;
N
N/// WiFi Configuration.
Ntypedef struct net_wifi_config {
N  const char      *ssid;                ///< Network name, a null-terminated string
N  const char      *password;            ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel (0=auto)
N  uint8_t          reserved;            ///< Reserved
N  netWiFi_WPS      wps_method;          ///< WiFi Protected Setup method
N  const char      *wps_pin;             ///< WPS PIN, a null-terminated string
N} NET_WIFI_CONFIG;
N
N/// WiFi Network information.
Ntypedef struct net_wifi_net_info {
N  char             ssid[32+1];          ///< Network name, a null-terminated string
N  char             password[64+1];      ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_NET_INFO;
N
N/// WiFi Scan information.
Ntypedef struct net_wifi_scan_info {
N  char             ssid[32+1];          ///< Service Set Identifier (null-terminated)
N  uint8_t          bssid[6];            ///< Basic Service Set Identifier
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_SCAN_INFO;
N
N/// ARP Cache Entry types.
Ntypedef enum {
N  netARP_CacheFixedIP,                  ///< Fixed IP address is refreshed after timeout
N  netARP_CacheTemporaryIP               ///< Temporary IP address is removed after timeout
N} netARP_CacheType;
N
N/// DHCP Option Codes.
N#define NET_DHCP_OPTION_IP_ADDRESS     0 ///< IP address change event
N#define NET_DHCP_OPTION_NTP_SERVERS   42 ///< NTP Servers option
N#define NET_DHCP_OPTION_CLIENT_ID     61 ///< Client-identifier option
N#define NET_DHCP_OPTION_BOOTFILE_NAME 67 ///< Bootfile name option
N
N/// DHCPv6 Option Codes.
N#define NET_DHCP6_OPTION_IP_ADDRESS   0 ///< IPv6 address change event
N
N/// DHCP Option Item.
Ntypedef struct net_dhcp_option_item {
N  uint8_t code;                         ///< Option type code
N  uint8_t length;                       ///< Length of Option value
N  uint8_t *value;                       ///< Pointer to Option value
N} NET_DHCP_OPTION_ITEM;
N
N/// DHCP Private Options.
Nextern NET_DHCP_OPTION_ITEM netDHCP_PrivateOptionsTableN[];  ///< DHCP Private Options Table
Nextern uint8_t              netDHCP_PrivateOptionsCountN;    ///< Number of DHCP Private Options
N
N/// DHCPv6 Modes.
Ntypedef enum {
N  netDHCP6_ModeStateless      = 0,      ///< Stateless DHCPv6 mode
N  netDHCP6_ModeStateful                 ///< Stateful DHCPv6 mode
N} netDHCP6_Mode;
N
N/// Ping Callback Events.
Ntypedef enum {
N  netPing_EventSuccess        = 0,      ///< Pinged Host responded
N  netPing_EventTimeout                  ///< Timeout, no ping response received
N} netPing_Event;
N
N/// Ping Control Flags.
N#define NET_PING_IP4_ONLY       0x01    ///< Force using IPv4 only
N#define NET_PING_IP6_ONLY       0x02    ///< Force using IPv6 only
N
N/// ARP Probe Callback Events.
Ntypedef enum {
N  netARP_EventSuccess         = 0,      ///< Probed Host responded
N  netARP_EventTimeout                   ///< Timeout, no response to ARP probe
N} netARP_Event;
N
N/// NDP Probe Callback Events.
Ntypedef enum {
N  netNDP_EventSuccess         = 0,      ///< Probed Host responded
N  netNDP_EventTimeout                   ///< Timeout, no response to NDP probe
N} netNDP_Event;
N
N/// DNS Client Callback Events.
Ntypedef enum {
N  netDNSc_EventSuccess        = 0,      ///< Host name successfully resolved
N  netDNSc_EventTimeout,                 ///< Timeout resolving host
N  netDNSc_EventNotResolved,             ///< DNS Error, no such name
N  netDNSc_EventError                    ///< Erroneous response packet
N} netDNSc_Event;
N
N/// FTP Commands.
Ntypedef enum {
N  netFTP_CommandPUT,                    ///< Puts a file on FTP server
N  netFTP_CommandGET,                    ///< Retrieves a file from FTP server
N  netFTP_CommandAPPEND,                 ///< Append file on FTP server (with create)
N  netFTP_CommandDELETE,                 ///< Deletes a file on FTP server
N  netFTP_CommandLIST,                   ///< Lists files stored on FTP server
N  netFTP_CommandRENAME,                 ///< Renames a file on FTP server
N  netFTP_CommandMKDIR,                  ///< Makes a directory on FTP server
N  netFTP_CommandRMDIR,                  ///< Removes an empty directory on FTP server
N  netFTP_CommandNLIST                   ///< Lists file names only (short format)
N} netFTP_Command;
N
N/// FTP Server Events.
Ntypedef enum {
N  netFTPs_EventLogin,                   ///< User logged in, session is busy
N  netFTPs_EventLogout,                  ///< User logged out, session is idle
N  netFTPs_EventLoginFailed,             ///< User login failed (invalid credentials)
N  netFTPs_EventDownload,                ///< File download ended
N  netFTPs_EventUpload,                  ///< File upload ended
N  netFTPs_EventDelete,                  ///< File deleted
N  netFTPs_EventRename,                  ///< File or directory renamed
N  netFTPs_EventMakeDirectory,           ///< Directory created
N  netFTPs_EventRemoveDirectory,         ///< Directory removed
N  netFTPs_EventOperationDenied,         ///< Requested file operation denied
N  netFTPs_EventLocalFileError,          ///< Local file operation error
N  netFTPs_EventFileError,               ///< Generic file operation error
N  netFTPs_EventError                    ///< Generic FTP server error
N} netFTPs_Event;
N
N/// FTP Client Requests.
Ntypedef enum {
N  netFTPc_RequestUsername,              ///< Username to login to FTP server
N  netFTPc_RequestPassword,              ///< Password to login to FTP server
N  netFTPc_RequestDirectory,             ///< Working directory path on server for all commands
N  netFTPc_RequestName,                  ///< File or Directory name for FTP commands 
N  netFTPc_RequestNewName,               ///< New File or Directory name for RENAME command
N  netFTPc_RequestListMask,              ///< File filter/mask for LIST command (wildcards allowed)
N  netFTPc_RequestList,                  ///< Received data if LIST command is given
N  netFTPc_RequestLocalFilename          ///< Local filename (including path)
N} netFTPc_Request;
N
N/// FTP Client Events.
Ntypedef enum {
N  netFTPc_EventSuccess        = 0,      ///< File operation successful
N  netFTPc_EventTimeout,                 ///< Timeout on file operation
N  netFTPc_EventLoginFailed,             ///< Login error, username/password invalid
N  netFTPc_EventAccessDenied,            ///< File access not allowed
N  netFTPc_EventFileNotFound,            ///< File not found
N  netFTPc_EventInvalidDirectory,        ///< Working directory path not found
N  netFTPc_EventLocalFileError,          ///< Local file read/write error
N  netFTPc_EventError                    ///< Generic FTP client error 
N} netFTPc_Event;
N
N/// TFTP Client Events.
Ntypedef enum {
N  netTFTPc_EventSuccess       = 0,      ///< File operation successful
N  netTFTPc_EventTimeout,                ///< Timeout on file operation
N  netTFTPc_EventAccessDenied,           ///< File access not allowed
N  netTFTPc_EventFileNotFound,           ///< File not found
N  netTFTPc_EventDiskFull,               ///< Disk full
N  netTFTPc_EventLocalFileError,         ///< Local file read/write error
N  netTFTPc_EventError                   ///< Generic TFTP client error
N} netTFTPc_Event;          
N
N/// Telnet Server Messages.
Ntypedef enum {
N  netTELNETs_MessageWelcome,            ///< Initial welcome message
N  netTELNETs_MessageLogin,              ///< Login message, if authentication is enabled
N  netTELNETs_MessageUsername,           ///< Username request login message
N  netTELNETs_MessagePassword,           ///< Password request login message
N  netTELNETs_MessageLoginFailed,        ///< Incorrect login error message
N  netTELNETs_MessageLoginTimeout,       ///< Login timeout error message
N  netTELNETs_MessagePrompt,             ///< Prompt message
N  netTELNETs_MessageUnsolicited         ///< Unsolicited message (triggered by netTELNETs_RequestMessage)
N} netTELNETs_Message;
N
N/// SMTP Client Request.
Ntypedef enum {
N  netSMTPc_RequestUsername,             ///< Username to login to SMTP server
N  netSMTPc_RequestPassword,             ///< Password to login to SMTP server
N  netSMTPc_RequestSender,               ///< Email address of the sender
N  netSMTPc_RequestRecipient,            ///< Email address of the recipient
N  netSMTPc_RequestSubject,              ///< Subject of email
N  netSMTPc_RequestBody                  ///< Email body in plain ASCII format
N} netSMTPc_Request;
N
N/// SMTP Client Events.
Ntypedef enum {
N  netSMTPc_EventSuccess       = 0,      ///< Email successfully sent
N  netSMTPc_EventTimeout,                ///< Timeout sending email
N  netSMTPc_EventAuthenticationFailed,   ///< Authentication failed, username/password invalid
N  netSMTPc_EventError                   ///< Error when sending email
N} netSMTPc_Event;
N
N/// SMTP Mail Transfer Agent Flags.
N#define NET_SMTP_MTA_USETLS     0x01    ///< Use secure TLS mode (Implicit TLS)
N
N/// SMTP Email Descriptor.
Ntypedef struct net_smtp_mail {
N  const char *From;                     ///< Sender address, can be NULL
N  const char *To;                       ///< Recipient(s), can be NULL
N  const char *Cc;                       ///< Carbon copy recipient(s), can be NULL
N  const char *Bcc;                      ///< Blind carbon copy recipient(s), can be NULL
N  const char *Subject;                  ///< Subject of email, can be NULL
N  const char *Message;                  ///< Email message body, can be NULL
N  const char *Attachment;               ///< Email attachment(s), can be NULL
N  const char *Encoding;                 ///< Default encoding type, can be NULL
N} NET_SMTP_MAIL;
N
N/// SMTP Mail Transfer Agent Descriptor.
Ntypedef struct net_smtp_mta {
N  const char *Address;                  ///< Server address (FQDN or IP address)
N  uint16_t    Port;                     ///< Server port number, can be 0
N  uint16_t    Flags;                    ///< Service control flags
N  const char *Username;                 ///< Account user name, can be NULL
N  const char *Password;                 ///< Account password, can be NULL
N} NET_SMTP_MTA;
N
N/// SNTP Client Mode.
Ntypedef enum {
N  netSNTPc_ModeUnicast        = 0,      ///< Unicast mode to access public NTP server
N  netSNTPc_ModeBroadcast                ///< Broadcast mode for local LAN
N} netSNTPc_Mode;
N
N/// Ping Event callback function.
Ntypedef void (*netPing_cb_t)(netPing_Event event);
N
N/// ARP Probe Event callback function.
Ntypedef void (*netARP_cb_t)(netARP_Event event);
N
N/// NDP Probe Event callback function.
Ntypedef void (*netNDP_cb_t)(netNDP_Event event);
N
N/// DNS Client Event callback function.
Ntypedef void (*netDNSc_cb_t)(netDNSc_Event event, const NET_ADDR *addr);
N
N/// SNTP Client callback function.
Ntypedef void (*netSNTPc_cb_t)(uint32_t seconds, uint32_t seconds_fraction);
N
N/// SNMP-MIB definitions.
N#define NET_SNMP_MIB_INTEGER    0x02    ///< MIB entry type INTEGER
N#define NET_SNMP_MIB_OCTET_STR  0x04    ///< MIB entry type OCTET_STRING
N#define NET_SNMP_MIB_OBJECT_ID  0x06    ///< MIB entry type OBJECT_IDENTIFIER
N#define NET_SNMP_MIB_IP_ADDR    0x40    ///< MIB entry type IP ADDRESS (uint8_t[4])
N#define NET_SNMP_MIB_COUNTER    0x41    ///< MIB entry type COUNTER (uint32_t)
N#define NET_SNMP_MIB_GAUGE      0x42    ///< MIB entry type GAUGE (uint32_t)
N#define NET_SNMP_MIB_TIME_TICKS 0x43    ///< MIB entry type TIME_TICKS
N#define NET_SNMP_MIB_ATR_RO     0x80    ///< MIB entry attribute READ_ONLY
N#define NET_SNMP_MIB_OID_SIZE   17      ///< Max.size of Object ID value
N#define NET_SNMP_MIB_STR_SIZE   110     ///< Max.size of Octet String variable
N#define NET_SNMP_MIB_READ       0       ///< MIB entry Read access
N#define NET_SNMP_MIB_WRITE      1       ///< MIB entry Write access
N
N/// SNMP-MIB macros.
N#define NET_SNMP_MIB_STR(s)     sizeof(s)-1, s
N#define NET_SNMP_MIB_INT(o)     sizeof(o), (void *)&o
N#define NET_SNMP_MIB_IP(ip)     4, (void *)&ip
N#define NET_SNMP_MIB_OID0(f,s)  (f*40 + s)
N
N/// SNMP-MIB Entry information.
Ntypedef struct net_snmp_mib_info {
N  uint8_t type;                         ///< Object Type
N  uint8_t oid_len;                      ///< Object ID length
N  uint8_t oid[NET_SNMP_MIB_OID_SIZE];   ///< Object ID value
X  uint8_t oid[17];   
N  uint8_t var_size;                     ///< Size of a variable
N  void    *var;                         ///< Pointer to a variable
N  void    (*cb_func)(int32_t mode);     ///< Write/Read event callback function
N} const NET_SNMP_MIB_INFO;
N
N/// FS Interface Time info
Ntypedef struct net_fs_time {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} NET_FS_TIME;
N
N/// FS Interface Attributes
N#define NET_FS_ATTR_FILE        1       ///< File entry
N#define NET_FS_ATTR_DIRECTORY   2       ///< Directory entry
N
N
N//  ==== Network System API ====
N
N/// \brief Initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netInitialize (void);
N
N/// \brief De-initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUninitialize (void);
N
N/// \brief Retrieve localhost name.  [\ref thread-safe]
N/// \return        pointer to localhost name, a null-terminated string.
Nextern const char *netSYS_GetHostName (void);
N
N/// \brief Set localhost name. [\ref thread-safe]
N/// \param[in]     hostname      new localhost name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSYS_SetHostName (const char *hostname);
N
N//  ==== UDP Socket API ====
N
N/// \brief Allocate a free UDP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netUDP_GetSocket (netUDP_cb_t cb_func);
N
N/// \brief Release UDP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_ReleaseSocket (int32_t socket);
N
N/// \brief Open UDP socket for communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     port          local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Open (int32_t socket, uint16_t port);
N
N/// \brief Stop UDP communication and close socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Close (int32_t socket);
N
N/// \brief Allocate memory for UDP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netUDP_GetBuffer (uint32_t size);
N
N/// \brief Send data to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Send (int32_t socket, const NET_ADDR *addr, uint8_t *buf, uint32_t len);
N
N/// \brief Set UDP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netUDP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_SetOption (int32_t socket, netUDP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of UDP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return        local port number.
N///                - 0           = socket invalid or in invalid state.
Nextern uint16_t  netUDP_GetLocalPort (int32_t socket);
N
N//  ==== TCP Socket API ====
N
N/// \brief Allocate a free TCP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netTCP_GetSocket (netTCP_cb_t cb_func);
N
N/// \brief Release TCP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ReleaseSocket (int32_t socket);
N
N/// \brief Open TCP socket for incoming connection. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     port          local port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Listen (int32_t socket, uint16_t port);
N
N/// \brief Initiate a TCP connection to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     local_port    local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Connect (int32_t socket, const NET_ADDR *addr, uint16_t local_port);
N
N/// \brief Stop TCP communication and start closing procedure. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Close (int32_t socket);
N
N/// \brief Instantly stop TCP communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Abort (int32_t socket);
N
N/// \brief Determine maximum number of data bytes that can be sent in TCP packet. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        maximum segment size in bytes.
Nextern uint32_t  netTCP_GetMaxSegmentSize (int32_t socket);
N
N/// \brief Allocate memory for TCP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netTCP_GetBuffer (uint32_t size);
N
N/// \brief Check if TCP socket can send data. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      send status:
N///              - true        = Ready to send data.
N///              - false       = Not ready.
Nextern bool      netTCP_SendReady (int32_t socket);
Xextern _Bool      netTCP_SendReady (int32_t socket);
N
N/// \brief Send a data packet to remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Send (int32_t socket, uint8_t *buf, uint32_t len);
N
N/// \brief Determine current state of a TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      state information as defined with \ref netTCP_State.
Nextern netTCP_State netTCP_GetState (int32_t socket);
N
N/// \brief Reset TCP window size to a default value from the configuration. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ResetReceiveWindow (int32_t socket);
N
N/// \brief Set TCP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netTCP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_SetOption (int32_t socket, netTCP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        local port number.
N///                - 0         = socket invalid or in invalid state.
Nextern uint16_t  netTCP_GetLocalPort (int32_t socket);
N
N/// \brief Retrieve IP address and port number of remote peer. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for remote peer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_GetPeer (int32_t socket, NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Determine TCP socket connection timeout. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        connection timeout timer in seconds.
N///                - 0         = socket invalid or in invalid state.
Nextern uint32_t  netTCP_GetTimer (int32_t socket);
N
N//  ==== BSD Socket API ====
N
N#ifdef RTE_Network_Socket_BSD
S/// \brief Create a communication endpoint called socket. [\ref thread-safe]
S/// \param[in]     family        address family:
S///                              - AF_INET        = address family IPv4.
S///                              - AF_INET6       = address family IPv6.
S/// \param[in]     type          connection type of a socket:
S///                              - SOCK_STREAM    = connection based type.
S///                              - SOCK_DGRAM     = datagram connectionless type.
S/// \param[in]     protocol      protocol type:
S///                              - IPPROTO_TCP    = must be used with SOCK_STREAM type.
S///                              - IPPROTO_UDP    = must be used with SOCK_DGRAM TYPE.
S///                              - 0              = for system auto-select.
S/// \return      status information:
S///              - Socket descriptor (>0).
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOMEM          = No free sockets available.
Sextern int socket (int family, int type, int protocol);
S
S/// \brief Assign a local address and port to a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing local IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or already bound.
S///              - BSD_EADDRINUSE      = Address or port already in use.
S///              - BSD_EISCONN         = Socket already connected.
Sextern int bind (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Set a socket in a listening mode. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     backlog       number of connection requests that can be accepted.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter, socket not bound or already listening.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ERROR           = Failed to create socket backlog.
Sextern int listen (int sock, int backlog);
S
S/// \brief Accept connect request for a listening socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    addr          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - New socket descriptor (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Socket not in listen mode.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int accept (int sock, SOCKADDR *addr, int *addrlen);
S
S/// \brief Connect a socket to a remote host. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing remote IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket in wrong state.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EALREADY        = Connection already in progress.
S///              - BSD_EINPROGRESS     = Operation in progress.
S///              - BSD_EISCONN         = Socket is connected.
S///              - BSD_ECONNREFUSED    = Connection rejected by the peer.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int connect (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Send data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int send (int sock, const char *buf, int len, int flags);
S
S/// \brief Send data to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \param[in]     to            structure containing remote IP address and port.
S/// \param[in]     tolen         length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendto (int sock, const char *buf, int len, int flags, const SOCKADDR *to, int tolen);
S
S/// \brief Send a message to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to target address (NULL for none).
S///                              - array of application buffer(s) containing the message.
S///                              - pointer to the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendmsg (int sock, const MSGHDR *msg, int flags);
S
S/// \brief Receive data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recv (int sock, char *buf, int len, int flags);
S
S/// \brief Receive data from endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \param[out]    from          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] fromlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvfrom (int sock, char *buf, int len, int flags, SOCKADDR *from, int *fromlen);
S
S/// \brief Receive a message from a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in,out] msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to buffer to store the source address to (NULL for none).
S///                              - array of application buffer(s) for the incomming message.
S///                              - pointer to buffer for the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvmsg (int sock, MSGHDR *msg, int flags);
S
S/// \brief Close socket and release socket descriptor. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ERROR           = Unspecified error.
Sextern int closesocket (int sock);
S
S/// \brief Retrieve IP address and port number of the endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTCONN        = Socket not connected.
Sextern int getpeername (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve local IP address and port number. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket not bound.
Sextern int getsockname (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve options for the socket.  [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be retrieved:
S///                              - SO_TYPE             = Type of a socket.
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[out]    optval        pointer to the buffer that will receive the option value.
S/// \param[in,out] optlen        input length of buffer, return length of the data.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int getsockopt (int sock, int level, int optname, char *optval, int *optlen);
S
S/// \brief Manipulate options for the socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be set:
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[in]     optval        pointer to the buffer containing the option value.
S/// \param[in]     optlen        size of the buffer containing the option value.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int setsockopt (int sock, int level, int optname, const char *optval, int optlen);
S
S/// \brief Control IO mode of a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     cmd           command to perform:
S///                              - FIONBIO  = enable non-blocking mode.
S/// \param[in]     argp          command's parameter.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int ioctlsocket (int sock, long cmd, unsigned long *argp);
S
S/// \brief Check the status of one or more sockets. [\ref thread-safe]
S/// \param[in]     nfds          range of sockets to be checked.
S/// \param[in,out] readfds       pointer to the set of sockets to check for read.
S///                              - NULL for none.
S/// \param[in,out] writefds      pointer to the set of sockets to check for write.
S///                              - NULL for none.
S/// \param[in,out] errorfds      pointer to the set of sockets to check for error.
S///                              - NULL for none.
S/// \param[in]     timeout       pointer to maximum time for select to wait.
S///                              - NULL for blocking wait for event.
S/// \return      status information:
S///              - number of ready sockets (>0)
S///              - 0                   = Operation timed out.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ERROR           = Suspend operation failed.
Sextern int select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
S
S/// \brief Retrieve host IP address from host name. [\ref thread-safe]
S/// \param[in]     name          host name.
S/// \param[out]    err           pointer to where to return error code (NULL for none):
S///                              - 0                   = Operation successful.
S///                              - BSD_EINVAL          = Invalid parameter.
S///                              - BSD_ELOCKED         = Resolver locked by another thread.
S///                              - BSD_ETIMEDOUT       = Operation timed out.
S///                              - BSD_EHOSTNOTFOUND   = Host not found.
S///                              - BSD_ERROR           = Unspecified error.
S/// \return      status information:
S///              - \ref HOSTENT result structure.
S///              - NULL in case of error.
Sextern HOSTENT *gethostbyname (const char *name, int *err);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \return      status information:
S///              - Internet address on success.
S///              - INADDR_NONE = on error.
Sextern IN_ADDR inet_addr (const char *cp);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \param[out]    addr          buffer where the converted IPv4 address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_aton (const char *cp, IN_ADDR *addr);
S
S/// \brief Convert from network address to a text string. [\ref not_thread-safe]
S/// \param[in]     in            Internet IPv4 host address to convert.
S/// \return      pointer to the formatted string.
Sextern const char *inet_ntoa (IN_ADDR in);
S
S/// \brief Convert from text address to a binary network address. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           text address to be converted.
S/// \param[out]    dst           buffer where the converted address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_pton (int af, const char *src, void *dst);
S
S/// \brief Convert from binary network address to a text string. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           binary address in network byte order to be converted.
S/// \param[out]    dst           buffer where the converted text address is to be stored.
S/// \param[in]     size          size of the buffer, at least:
S///                              - INET_ADDRSTRLEN for AF_INET.
S///                              - INET6_ADDRSTRLEN for AF_INET6.
S/// \return      pointer to the formatted string.
S///              - NULL in case of error.
Sextern const char *inet_ntop (int af, const void *src, char *dst, int size);
N#endif /* RTE_Network_Socket_BSD */
N
N//  ==== Interface User API ====
N
N/// \brief Get the current value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_GetOption (uint32_t if_id, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetOption (uint32_t if_id, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set default network interface for Internet access. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip_version    IP version as specified by \ref netIF_Version.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetDefault (uint32_t if_id, netIF_Version ip_version);
N
N//  ==== Ethernet Interface User API ====
N
N/// \brief Send raw Ethernet data. [\ref thread-safe]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netETH_SendRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Determine whether the ARP table has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     type          address cache type.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheIP (uint32_t if_id, const uint8_t *ip4_addr, netARP_CacheType type);
N
N/// \brief Determine whether the ARP table has IP address resolved for requested MAC address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheMAC (uint32_t if_id, const uint8_t *mac_addr);
N
N/// \brief Get IP address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip4_addr      resolved IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip4_addr);
N
N/// \brief Get MAC address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetMAC (uint32_t if_id, const uint8_t *ip4_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_Probe (uint32_t if_id, const uint8_t *ip4_addr, netARP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_ProbeX (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Determine whether neighbor cache has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_CacheIP (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Get IP address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip6_addr      resolved IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip6_addr);
N
N/// \brief Get MAC address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetMAC (uint32_t if_id, const uint8_t *ip6_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_Probe (uint32_t if_id, const uint8_t *ip6_addr, netNDP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_ProbeX (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Join this host to a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Join (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Leave a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Leave (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Enable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Enable (uint32_t if_id);
N
N/// \brief Disable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Disable (uint32_t if_id);
N
N/// \brief Set DHCP Option value at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_SetOption (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Enable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mode          DHCPv6 operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Enable (uint32_t if_id, netDHCP6_Mode mode);
N
N/// \brief Disable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Disable (uint32_t if_id);
N
N//  ==== Ethernet Interface Callbacks ====
N
N/// \brief Notify the user of Ethernet link state change event. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     event         Ethernet link state event as defined in \ref netETH_Event.
N/// \param[in]     val           pointer to the event value.
N/// \return        none.
Nextern void      netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val);
N
N/// \brief Receive raw Ethernet data. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the received data.
N/// \param[in]     len           length of received data in bytes.
N/// \return        none.
Nextern void      netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Notify the user of DHCP event or extended DHCP option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Notify the user of DHCPv6 event or extended DHCPv6 option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCPv6 option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP6_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N//  ==== WiFi Interface User API ====
N
N/// \brief Search for available WiFi networks. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    scan_info     array of structures for storing the scan information.
N/// \param[in,out] scan_num      input maximum number, return number of WiFi networks found.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Scan (uint32_t if_num, NET_WIFI_SCAN_INFO scan_info[], uint32_t *scan_num);
N
N/// \brief Get the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetOption (uint32_t if_num, netWiFi_Option option, void *buf, uint32_t buf_len);
N
N/// \brief Set the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_SetOption (uint32_t if_num, netWiFi_Option option, const void *buf, uint32_t buf_len);
N
N/// \brief Activate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     config        pointer to the structure with configuration parameters.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Activate (uint32_t if_num, const NET_WIFI_CONFIG *config);
N
N/// \brief Deactivate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Deactivate (uint32_t if_num);
N
N/// \brief Get the connection state of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      connection state:
N///               - true       = Station connected to access point.
N///               - false      = Station not connected.
Nextern bool      netWiFi_IsConnected (uint32_t if_num);
Xextern _Bool      netWiFi_IsConnected (uint32_t if_num);
N
N/// \brief Get the network information of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    net_info      structure for storing the network information.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetNetInfo (uint32_t if_num, NET_WIFI_NET_INFO *net_info);
N
N//  ==== PPP Interface User API ====
N
N/// \brief Start PPP interface to accept incoming PPP connection. [\ref thread-safe]
N/// \param[in]     username      remote username for authentication.
N/// \param[in]     password      remote password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Listen (const char *username, const char *password);
N
N/// \brief Start a dial-up connection to remote PPP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote PPP server.
N/// \param[in]     username      username for authentication.
N/// \param[in]     password      password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Connect (const char *dial_num, const char *username, const char *password);
N
N/// \brief Disconnect PPP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Close (void);
N
N/// \brief Determine the state of PPP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netPPP_LinkUp (void);
Xextern _Bool      netPPP_LinkUp (void);
N
N//  ==== SLIP Interface User API ====
N
N/// \brief Start SLIP interface to accept incoming SLIP connections. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Listen (void);
N
N/// \brief Start a dial-up connection to remote SLIP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote SLIP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Connect (const char *dial_num);
N
N/// \brief Disconnect SLIP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Close (void);
N
N/// \brief Determine the state of SLIP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netSLIP_LinkUp (void);
Xextern _Bool      netSLIP_LinkUp (void);
N
N//  ==== Ping User API ====
N
N/// \brief Start ICMP ping process. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of remote host.
N/// \param[in]     cb_func       callback function to call, when ping session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_Echo (const NET_ADDR *addr, netPing_cb_t cb_func);
N
N/// \brief Start ICMP ping process in blocking mode. [\ref thread-safe]
N/// \param[in]     target        remote hostname or absolute IP address.
N/// \param[in]     flags         ping process control flags.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_EchoX (const char *target, uint32_t flags);
N
N//  ==== DNS Client User API ====
N
N/// \brief Resolve IP address of a host from a hostname. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     cb_func       callback function to call, when DNS session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByName (const char *name, int16_t addr_type, netDNSc_cb_t cb_func);
N
N/// \brief Resolve IP address of a host from a hostname in blocking mode. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    addr          structure that will receive resolved IP address of the hostname.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByNameX (const char *name, int16_t addr_type, NET_ADDR *addr);
N
N/// \brief Flush or clear the local DNS cache. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_ClearCache (void);
N
N//  ==== FTP Server User API ====
N
N/// \brief Start FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Start (void);
N
N/// \brief Stop FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Stop (void);
N
N/// \brief Check if FTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netFTPs_Running (void);
Xextern _Bool      netFTPs_Running (void);
N
N/// \brief Get port number of FTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netFTPs_GetPort (void);
N
N/// \brief Set port number of FTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of FTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of FTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPassword (const char *password);
N
N/// \brief Determine if FTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netFTPs_LoginActive (void);
Xextern _Bool      netFTPs_LoginActive (void);
N
N/// \brief Enable or disable FTP server authentication. [\ref thread-safe]
N/// \param[in]     login       new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_LoginOnOff (bool login);
Xextern netStatus netFTPs_LoginOnOff (_Bool login);
N
N//  ==== FTP Server Access Interface ====
N
N/// \brief Accept or deny connection from remote FTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote FTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== FTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exists in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netFTPs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Check if remote user is allowed to access a file on FTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         full path of a file to access.
N/// \param[in]     access        access mode as defined with Network Access definitions.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
Xextern _Bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netFTPs_GetUserId (void);
N
N//  ==== FTP Server User Callbacks ====
N
N/// \brief Notify the user application about events in FTP server service. [\ref user-provided]
N/// \param[in]     event         FTP Server notification event as specified in \ref netFTPs_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPs_Notify (netFTPs_Event event);
N
N//  ==== FTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N/// \brief Delete a file in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to delete.
N/// \return
N///              - true        = File successfully deleted.
N///              - false       = Failed to delete a file.
Nextern bool      netFTPs_fdelete (const char *fname);
Xextern _Bool      netFTPs_fdelete (const char *fname);
N
N/// \brief Rename a file or directory in FTP server. [\ref interface]
N/// \param[in]     fname         old name to rename from.
N/// \param[in]     newname       new name to rename to.
N/// \return
N///              - true        = File or directory successfully renamed.
N///              - false       = Failed to rename a file or directory.
Nextern bool      netFTPs_frename (const char *fname, const char *newname);
Xextern _Bool      netFTPs_frename (const char *fname, const char *newname);
N
N/// \brief Make a new directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to create.
N/// \return
N///              - true        = Directory successfully created.
N///              - false       = Failed to create a directory.
Nextern bool      netFTPs_mkdir (const char *path);
Xextern _Bool      netFTPs_mkdir (const char *path);
N
N/// \brief Remove an empty directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to remove.
N/// \return
N///              - true        = Directory successfully removed.
N///              - false       = Failed to remove a directory.
Nextern bool      netFTPs_rmdir (const char *path);
Xextern _Bool      netFTPs_rmdir (const char *path);
N
N/// \brief Search the file system directory for matching files. [\ref interface]
N/// \param[in]     mask          file mask filter.
N/// \param[out]    fname         buffer to write filename to.
N///                              - NULL for none.
N/// \param[out]    fsize         pointer to where to return the file size.
N///                              - NULL for none.
N/// \param[out]    ftime         pointer to where to return the created or last modified time.
N///                              - NULL for none.
N/// \param[in]     first         find first file.
N/// \return      status information:
N///              - NET_FS_ATTR_FILE      = File found.
N///              - NET_FS_ATTR_DIRECTORY = Directory found.
N///              - 0                     = No entry found.
Nextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, bool first);
Xextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, _Bool first);
N
N//  ==== FTP Client User API ====
N
N/// \brief Start FTP client file operation session. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote FTP server.
N/// \param[in]     command       FTP command to perform.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPc_Connect (const NET_ADDR *addr, netFTP_Command command);
N
N//  ==== FTP Client User Callbacks ====
N
N/// \brief Request parameters for FTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netFTPc_Process (netFTPc_Request request, char *buf, uint32_t buf_len);
N
N/// \brief Notify the user application when FTP client operation ends. [\ref user-provided]
N/// \param[in]     event         FTP client notification event as specified in \ref netFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPc_Notify (netFTPc_Event event);
N
N//  ==== FTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in FTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Server User API ====
N
N/// \brief Start the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Start (void);
N
N/// \brief Stop the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Stop (void);
N
N/// \brief Check if the TFTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTFTPs_Running (void);
Xextern _Bool      netTFTPs_Running (void);
N
N/// \brief Get port number of the TFTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTFTPs_GetPort (void);
N
N/// \brief Set port number of the TFTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of TFTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netTFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of TFTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetRootPath (const char *path);
N
N//  ==== TFTP Server Access Interface ====
N
N/// \brief Accept or deny connection from a remote TFTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== TFTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in the TFTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Client User API ====
N
N/// \brief Put a file to a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Put (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N/// \brief Retrieve a file from a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Get (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N//  ==== TFTP Client User Callbacks ====
N
N/// \brief Notify the user application when TFTP client operation ends. [\ref user-provided]
N/// \param[in]     event         TFTP client notification event as specified in \ref netTFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netTFTPc_Notify (netTFTPc_Event event);
N
N//  ==== TFTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in the TFTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== Telnet Server User API ====
N
N/// \brief Start the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Start (void);
N
N/// \brief Stop the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Stop (void);
N
N/// \brief Check if the Telnet server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTELNETs_Running (void);
Xextern _Bool      netTELNETs_Running (void);
N
N/// \brief Get port number of the Telnet server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTELNETs_GetPort (void);
N
N/// \brief Set port number of the Telnet server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPort (uint16_t port);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPassword (const char *password);
N
N/// \brief Determine if Telnet server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netTELNETs_LoginActive (void);
Xextern _Bool      netTELNETs_LoginActive (void);
N
N/// \brief Enable or disable Telnet server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_LoginOnOff (bool login);
Xextern netStatus netTELNETs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected Telnet client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the Telnet server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netTELNETs_GetSession (void);
N
N/// \brief Check command string for a command. [\ref thread-safe]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[in]     user_cmd      user command to check for (in upper case).
N/// \return
N///              - true        = Command found in command string.
N///              - false       = Command not found.
Nextern bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
Xextern _Bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
N
N/// \brief Request a repeated call to netTELNETs_ProcessCommand function. [\ref thread-safe]
N/// \param[in]     delay         time period to wait in number of 100ms ticks.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RepeatCommand (uint32_t delay);
N
N/// \brief Request unsolicited message processing in netTELNETs_ProcessMessage function. [\ref thread-safe]
N/// \param[in]     session       session identification, when multiple connections are active.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RequestMessage (int32_t session);
N
N//  ==== Telnet Server User Callbacks ====
N
N/// \brief Process and execute a command requested by the Telnet client. [\ref user-provided]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[out]    buf           output buffer to write the return message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again for the same command.
N///                - return len | (1u<<30) = disconnect flag, the system disconnects
N///                                          the Telnet client.
Nextern uint32_t  netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Request a message for a Telnet server session. [\ref user-provided]
N/// \param[in]     msg           code of requested message.
N/// \param[out]    buf           output buffer to write the message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len);
N
N//  ==== Telnet Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote Telnet client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote Telnet client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== Telnet Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netTELNETs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netTELNETs_GetUserId (void);
N
N//  ==== HTTP Server User API ====
N
N/// \brief Start the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Start (void);
N
N/// \brief Stop the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Stop (void);
N
N/// \brief Check if the HTTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netHTTPs_Running (void);
Xextern _Bool      netHTTPs_Running (void);
N
N/// \brief Get port number of the HTTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netHTTPs_GetPort (void);
N
N/// \brief Set port number of the HTTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of HTTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netHTTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of HTTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPassword (const char *password);
N
N/// \brief Determine if the HTTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netHTTPs_LoginActive (void);
Xextern _Bool      netHTTPs_LoginActive (void);
N
N/// \brief Enable or disable HTTP server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_LoginOnOff (bool login);
Xextern netStatus netHTTPs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected remote HTTP client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the HTTP server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netHTTPs_GetSession (void);
N
N/// \brief Retrieve the preferred language setting from the browser. [\ref thread-safe]
N/// \return        pointer to the language code, a null-terminated string.
Nextern const char *netHTTPs_GetLanguage (void);
N
N/// \brief Get Content-Type HTML header, received in XML post request. [\ref thread-safe]
N/// \return        pointer to content type header, a null-terminated string.
Nextern const char *netHTTPs_GetContentType (void);
N
N//  ==== HTTP Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote HTTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote HTTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== HTTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \param[in]     password      pointer to password.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netHTTPs_CheckAccount (const char *username, const char *password);
N
N/// \brief Retrieve the secret word for the selected user. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[out]    buf           buffer to store the secret word to.
N/// \param[in]     buf_len       length of buffer.
N/// \return        none.
Nextern void      netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len);
N
N/// \brief Check if remote user is allowed to access a file on HTTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         name of a file to access.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
Xextern _Bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
N
N/// \brief Retrieve the user identification. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netHTTPs_GetUserId (void);
N
N/// \brief Calculate HA1 hash value for the given credentials. [\ref thread-safe]
N/// \param[in]     username      username, a null-terminated string.
N/// \param[in]     password      password, a null-terminated string.
N/// \param[out]    buf           buffer to store the hash value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_CalcHashHA1 (const char *username, const char *password, char *buf, uint32_t buf_len);
N
N//  ==== HTTP Server File System Interface ====
N
N/// \brief Open a file for reading in HTTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netHTTPs_fopen (const char *fname);
N
N/// \brief Close a file previously open in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netHTTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netHTTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Read a string from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           output buffer to write data to.
N/// \param[in]     size          size of output buffer.
N/// \return      status information:
N///              - Pointer to string on success.
N///              - NULL in case of an error.
Nextern char     *netHTTPs_fgets (void *file, char *buf, uint32_t size);
N
N/// \brief Retrieve file size and last modification time. [\ref interface]
N/// \param[in]     fname         name of the file.
N/// \param[out]    fsize         file size in bytes.
N/// \param[out]    ftime         created or last modified time.
N/// \return        none.
Nextern void      netHTTPs_fstat (const char *fname, uint32_t *fsize, uint32_t *ftime);
N
N//  ==== HTTP Server CGI ====
N
N/// \brief Process query string received by GET request. [\ref user-provided]
N/// \param[in]     qstr          pointer to the query string.
N/// \return        none.
Nextern void      netCGI_ProcessQuery (const char *qstr);
N
N/// \brief Process data received by POST request. [\ref user-provided]
N/// \param[in]     code          callback context:
N///                              - 0 = www-url-encoded form data.
N///                              - 1 = filename for file upload (null-terminated string).
N///                              - 2 = file upload raw data.
N///                              - 3 = end of file upload (file close requested).
N///                              - 4 = any other type of POST data (single or last stream).
N///                              - 5 = the same as 4, but with more data to follow.
N/// \param[in]     data          pointer to POST data.
N/// \param[in]     len           length of POST data.
N/// \return        none.
Nextern void      netCGI_ProcessData (uint8_t code, const char *data, uint32_t len);
N
N/// \brief Generate dynamic web data based on a CGI script. [\ref user-provided]
N/// \param[in]     env           environment string.
N/// \param[out]    buf           output data buffer.
N/// \param[in]     buf_len       size of output buffer (from 536 to 1440 bytes).
N/// \param[in,out] pcgi          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1U<<31) = repeat flag, the system calls this function
N///                                          again for the same script line.
N///                - return len | (1U<<30) = force transmit flag, the system transmits
N///                                          current packet immediately.
Nextern uint32_t  netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi);
N
N/// \brief Process environment variables and convert to ANSI format. [\ref thread-safe]
N/// \param[in]     env           pointer to environment variables.
N/// \param[out]    ansi          output buffer to write converted variable to.
N/// \param[in]     max_len       maximum length of environment variable.
N/// \return      status information:
N///              - pointer to the remaining environment variables to process.
N///              - NULL if there are no more environment variables to process.
Nextern const char *netCGI_GetEnvVar (const char *env, char *ansi, uint32_t max_len);
N
N/// \brief Override default character encoding in HTML documents. [\ref user-provided]
N/// \return        pointer to user defined character set type.
Nextern const char *netCGI_Charset (void);
N
N/// \brief Add custom MIME type for unsupported file types. [\ref user-provided]
N/// \param[in]     file_ext      filename extension, a null-terminated string.
N/// \return      MIME type information:
N///                - pointer to user defined Content-Type.
N///                - NULL for unknown type.
Nextern const char *netCGI_ContentType (const char *file_ext);
N
N/// \brief Redirect resource URL address to a new location. [\ref user-provided]
N/// \param[in]     file_name     resource filename, a null-terminated string.
N/// \return      URL redirection information:
N///                - pointer to user defined Location.
N///                - NULL for no URL address redirection.
Nextern const char *netCGI_Redirect (const char *file_name);
N
N/// \brief Override default Content-Type for CGX script files. [\ref user-provided]
N/// \return        pointer to user defined Content-Type.
Nextern const char *netCGX_ContentType (void);
N
N/// \brief Add custom HTTP response header. [\ref user-provided]
N/// \return        pointer to user defined HTTP header.
Nextern const char *netCGI_CustomHeader (void);
N
N//  ==== SMTP Client User API ====
N
N/// \brief Start SMTP client to send an email in legacy mode. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_Connect (const NET_ADDR *addr);
N
N/// \brief Send an email in blocking mode. [\ref thread-safe]
N/// \param[in]     mail          pointer to email content descriptor.
N/// \param[in]     mta           pointer to mail transfer agent descriptor.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_SendMail (const NET_SMTP_MAIL *mail, const NET_SMTP_MTA *mta);
N
N//  ==== SMTP Client User Callbacks ====
N
N/// \brief Request parameters for SMTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again when \a request is \ref netSMTPc_RequestBody.
Nextern uint32_t  netSMTPc_Process (netSMTPc_Request request, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Notify the user application when SMTP client operation ends. [\ref user-provided]
N/// \param[in]     event         SMTP client notification event as specified in \ref netSMTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netSMTPc_Notify (netSMTPc_Event event);
N
N/// \brief Accept or deny authentication requested by SMTP server. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return
N///              - true        = Authentication is accepted.
N///              - false       = Authentication is denied.
Nextern bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
Xextern _Bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
N
N//  ==== SMTP Client File System Interface ====
N
N/// \brief Open a file for reading in SMTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netSMTPc_fopen (const char *fname);
N
N/// \brief Close a file previously open in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netSMTPc_fclose (void *file);
N
N/// \brief Read block of data from a file in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netSMTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N//  ==== SNTP Client User API ====
N
N/// \brief Set mode of operation for SNTP client. [\ref thread-safe]
N/// \param[in]     mode          SNTP client operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_SetMode (netSNTPc_Mode mode);
N
N/// \brief Determine current time from NTP or SNTP time server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of NTP or SNTP server.
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[in]     cb_func       callback function to call, when the session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTime (const NET_ADDR *addr, netSNTPc_cb_t cb_func);
N
N/// \brief Determine current time from NTP or SNTP time server in blocking mode. [\ref thread-safe]
N/// \param[in]     server        server name or absolute IP address (FQDN or IP address).
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[out]    seconds       pointer to the variable to return time in seconds.
N/// \param[out]    seconds_fraction
N///                              pointer to the variable to return fraction of seconds.
N///                              - NULL for none.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTimeX (const char *server, uint32_t *seconds, uint32_t *seconds_fraction);
N
N//  ==== SNMP Agent User API ====
N
N/// \brief Send a trap message to the Trap Manager. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of the Trap server.
N///                              - NULL to use Trap server IP address from system configuration.
N/// \param[in]     generic       generic trap type:
N///                              - 0  = ColdStart trap.
N///                              - 1  = WarmStart trap.
N///                              - 2  = LinkDown trap.
N///                              - 3  = LinkUp trap.
N///                              - 4  = AuthenticationFailure trap.
N///                              - 5  = EgpNeighborLoss trap.
N///                              - 6  = EnterpriseSpecific trap.
N/// \param[in]     specific      specific trap type for generic enterpriseSpecific trap:
N///                              - must be set to 0 for generic traps 0 ... 5
N/// \param[in]     obj_list      object list included in trap message.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_Trap (const NET_ADDR *addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list);
N
N/// \brief Change SNMP community to a new community. [\ref thread-safe]
N/// \param[in]     community     new community, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetCommunity (const char *community);
N
N/// \brief Register MIB table to SNMP Agent. [\ref thread-safe]
N/// \param[in]     info          pointer to MIB table.
N/// \param[in]     size          size of MIB table in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetMIB_Table (const NET_SNMP_MIB_INFO *info, uint32_t size);
N
N// ==== Network Address Conversion ====
N
N/// \brief Convert IP address from binary to text form. [\ref thread-safe]
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     ip_addr       IPv4 or IPv6 address in binary form.
N/// \param[out]    string_buf    buffer to store converted IP address to.
N/// \param[in]     buf_len       length of a string buffer, at least:
N///                              - 16 characters for IPv4 address.
N///                              - 40 characters for IPv6 address.
N/// \return      pointer to \a string_buf with null-terminated IP address string.
N///              - NULL in case of parameter error.
Nextern const char *netIP_ntoa (int16_t addr_type, const uint8_t *ip_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert IP address from text to binary form. [\ref thread-safe]
N/// \param[in]     addr_string   network address string:
N///                              - in dotted-decimal IPv4 notation.
N///                              - in compressed colon-hexadecimal IPv6 notation.
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    ip_addr       IPv6 or IPv6 address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
Xextern _Bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
N
N/// \brief Convert MAC address from binary to text form. [\ref thread-safe]
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \param[out]    string_buf    buffer to store converted MAC address to.
N/// \param[in]     buf_len       length of a string buffer, at least 18 characters.
N/// \return      pointer to \a string_buf with null-terminated MAC address string.
N///              - NULL in case of parameter error.
Nextern const char *netMAC_ntoa (const uint8_t *mac_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert MAC address from text to binary form. [\ref thread-safe]
N/// \param[in]     mac_string    address string in hyphen MAC-address notation.
N/// \param[out]    mac_addr      MAC address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
Xextern _Bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_DS_H */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 2
N
N#ifdef __clang__
S  #pragma clang diagnostic ignored "-Wpadded"
N#endif
N
N/// General definitions
N#define NET_HEADER_LEN      4           ///< Network frame header length
N#define PHY_HEADER_LEN      14          ///< Physical/ethernet header length
N#define ETH_MAX_FRAME_SIZE  1514        ///< Maximum size of ethernet frame
N#define NET_USERNAME_SIZE   16          ///< Authentication username buffer size
N#define NET_PASSWORD_SIZE   16          ///< Authentication password buffer size
N#define NET_HA1_HASH_LEN    32          ///< HTTP Authentication HA1 hash length
N#define NET_ROOT_PATH_SIZE  128         ///< Root path buffer size
N#define NET_TCP_NO_ACK      0xFFFFFFFF  ///< Callback return value for no ACK
N#define NET_IF_CLASS_LOOP   (0 << 8)    ///< Loopback interface class
N
N/// Debug process definitions
N#ifdef RTE_Network_Debug_STDIO
S#define NET_SYSTEM_CORE     0           ///< Main system core
S#define NET_DYNAMIC_MEMORY  1           ///< Dynamic memory management
S#define NET_ETH_INTERFACE   2           ///< Ethernet interface 0
S#define NET_WIFI_INTERFACE  3           ///< WiFi interface
S#define NET_PPP_INTERFACE   4           ///< PPP interface
S#define NET_SLIP_INTERFACE  5           ///< SLIP interface
S#define NET_LOCAL_LOOPBACK  6           ///< Loopback virtual interface
S#define NET_ARP_CACHE       7           ///< Ethernet ARP cache
S#define NET_IP4_CORE        8           ///< IPv4 core and localhost
S#define NET_ICMP_CONTROL    9           ///< ICMP control service for IPv4
S
S#define NET_IGMP_HOST       10          ///< IGMP group managememt host for IPv4
S#define NET_IP6_CORE        11          ///< IPv6 core and localhost
S#define NET_ICMP6_CONTROL   12          ///< ICMP6 control service for IPv6
S#define NET_NDP_CACHE       13          ///< Ethernet Neighbor Discovery for IPv6
S#define NET_UDP_SOCKET      14          ///< UDP native socket
S#define NET_TCP_SOCKET      15          ///< TCP native socket
S#define NET_BSD_SOCKET      16          ///< BSD socket interface
S#define NET_NBNS_CLIENT     17          ///< NBNS client service for IPv4
S#define NET_DHCP_CLIENT     18          ///< DHCP client service for IPv4
S#define NET_DHCP6_CLIENT    19          ///< DHCP client service for IPv6
S
S#define NET_DNS_CLIENT      20          ///< DNS client service
S#define NET_SNMP_AGENT      21          ///< SNMP agent module
S#define NET_HTTP_SERVER     22          ///< HTTP server service
S#define NET_FTP_SERVER      23          ///< FTP server service
S#define NET_FTP_CLIENT      24          ///< FTP client service
S#define NET_TELNET_SERVER   25          ///< Telnet server service
S#define NET_TFTP_SERVER     26          ///< TFTP server service
S#define NET_TFTP_CLIENT     27          ///< TFTP client service
S#define NET_SMTP_CLIENT     28          ///< SMTP client service
S#define NET_SNTP_CLIENT     29          ///< SNTP client service
N#endif /* RTE_Network_Debug_STDIO */
N
N/// Telnet definitions
N#define TELNET_LBUF_SZ      96          ///< Command line buffer size in bytes
N#define TELNET_HIST_SZ      128         ///< Command history buffer size in bytes
N#define TELNET_FIFO_SZ      128         ///< Input character Fifo buffer in bytes
N
N/// BSD Socket ioctl commands
N#define FIONBIO             1           ///< Set mode (blocking/non-blocking)
N#define FIO_DELAY_ACK       2           ///< Set DELAY_ACK mode for stream socket
N#define FIO_KEEP_ALIVE      3           ///< Set KEEP_ALIVE mode for stream socket
N#define FIO_FLOW_CTRL       4           ///< Set FLOW_CTRL mode for stream socket
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// Network OS identifier
Ntypedef void *NETOS_ID;
N
N/// Network scheduler function type
Ntypedef void (*net_sys_fn_t) (void);
N
N/// System Error codes
Ntypedef enum net_error {
N  NET_ERROR_MEM_ALLOC,                  ///< Alloc memory failed, out of memory
N  NET_ERROR_MEM_FREE,                   ///< Free memory failed, memory slot invalid
N  NET_ERROR_MEM_CORRUPT,                ///< Memory corruption detected
N  NET_ERROR_CONFIG,                     ///< Network configuration error detected
N  NET_ERROR_UDP_ALLOC,                  ///< No free UDP sockets available
N  NET_ERROR_TCP_ALLOC,                  ///< No free TCP sockets available
N  NET_ERROR_TCP_STATE                   ///< TCP socket in undefined state
N} NET_ERROR;
N
N/// Frame buffer structure
Ntypedef struct net_frame {
N  uint16_t length;                      ///< Length of data in frame
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[32];                   ///< Buffer data (protocol headers + data)
N	//}
N} NET_FRAME;
N
N/// Buffer queue structure
Ntypedef struct net_buffer {
N  struct net_buffer *next;              ///< Next buffer in the list
N  uint16_t length;                      ///< Length of data in buffer
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[32];                  ///< Buffer data
N	//}
N} NET_BUFFER;
N
N/// Library variant optimization
N#ifdef RTE_Network_IPv6
S  #define  Network_IPv6
S  #define __ADDR            NET_ADDR
S  #define __ADDR_IP_LEN     NET_ADDR_IP6_LEN
N#else
N  #define __ADDR            NET_ADDR4
N  #define __ADDR_IP_LEN     NET_ADDR_IP4_LEN
N#endif
N#define __FRAME(buf)        ((NET_FRAME *)(uint32_t)(buf))
N#define __BUFFER(buf)       ((NET_BUFFER *)(uint32_t)(buf))
N
N/// Local Machine info version 4
Ntypedef struct net_localm {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint16_t Reserved;                    ///< Reserved (used for alignment)
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Local IP address
X  uint8_t  IpAddr[4];    
N  uint8_t  NetMask[NET_ADDR_IP4_LEN];   ///< Netmask
X  uint8_t  NetMask[4];   
N  uint8_t  DefGW[NET_ADDR_IP4_LEN];     ///< Default gateway
X  uint8_t  DefGW[4];     
N  uint8_t  PriDNS[NET_ADDR_IP4_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[4];    
N  uint8_t  SecDNS[NET_ADDR_IP4_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[4];    
N} NET_LOCALM;
N
N/// Local Machine info version 6
Ntypedef struct net_localm6 {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint8_t  HopLimit;                    ///< Hop limit for outging IP packets
N  uint8_t  PrefixLen;                   ///< Subnet prefix length
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  TempAddr[NET_ADDR_IP6_LEN];  ///< Temporary IPv6 address
X  uint8_t  TempAddr[16];  
N  uint8_t  LLAddr[NET_ADDR_IP6_LEN];    ///< Link-local address
X  uint8_t  LLAddr[16];    
N  uint8_t  DefGW[NET_ADDR_IP6_LEN];     ///< Default gateway
X  uint8_t  DefGW[16];     
N  uint8_t  PriDNS[NET_ADDR_IP6_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[16];    
N  uint8_t  SecDNS[NET_ADDR_IP6_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[16];    
N} NET_LOCALM6;
N
N/// ARP Cache Entry info
Ntypedef struct net_arp_info {
N  uint8_t  State;                       ///< Cache entry state
N  uint8_t  Type;                        ///< Cache entry type
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< IPv4 address
X  uint8_t  IpAddr[4];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  Reserved;                    ///< Reserved (not used)
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_ARP_INFO;
N
N/// IGMP Group info
Ntypedef struct net_igmp_info {
N  uint8_t  State;                       ///< Group membership state
N  uint8_t  Tout;                        ///< Timeout timer for reports
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Group IPv4 address
X  uint8_t  IpAddr[4];    
N} NET_IGMP_INFO;
N
N/// NDP Cache Entry info
Ntypedef struct net_ndp_info {
N  uint8_t  State;                       ///< Cache state
N  uint8_t  Flags;                       ///< State flags
N  uint16_t Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Id;                          ///< Entry identification number
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_NDP_INFO;
N
N/// IP4-Frag session info
Ntypedef struct net_ip4_frag_info {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Len;                         ///< Total length of datagram fragments
N  NET_FRAME *frag_list;                 ///< Fragment queue list
N} NET_IP4_FRAG_INFO;
N
N/// UDP Socket info
Ntypedef struct net_udp_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Flags;                       ///< State flags and options
N  uint16_t LocPort;                     ///< Local UDP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  uint8_t  McastTtl;                    ///< Multicast time to live for IPv4
N  uint8_t  HopLimit;                    ///< Multicast hop limit for IPv6
N  const struct net_if_cfg *net_if;      ///< Network interface for broadcast frames
N  netUDP_cb_t cb_func;                  ///< Event callback function
N} NET_UDP_INFO;
N
N/// TCP Socket info
Ntypedef struct net_tcp_info {
N  netTCP_State State;                   ///< Socket state
N  uint8_t  Type;                        ///< Socket type
N  uint8_t  Flags;                       ///< State flags
N  uint16_t LocPort;                     ///< Local TCP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  const uint8_t *LocAddr;               ///< Pointer to local IPv6 address
N  __ADDR   Peer;                        ///< Peer IP address and port
X  NET_ADDR4   Peer;                        
N  uint16_t MaxSegSize;                  ///< Transmit max. segment size
N  uint16_t ConnTout;                    ///< Connection timeout
N  uint16_t AliveTimer;                  ///< Keep alive timer
N  uint16_t RetryTimer;                  ///< Retransmission timer
N  uint8_t  AckTimer;                    ///< Receive delay-ack timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  DupAcks;                     ///< Number of duplicate acks (fast recovery)
N  uint32_t SendUna;                     ///< Send sequence number unacknowledged
N  uint32_t SendNext;                    ///< Next send sequence number
N  uint32_t SendChk;                     ///< Check sequence number for dupacks
N  uint32_t SendWl1;                     ///< Sequence number of last window update
N  uint32_t SendWl2;                     ///< Acknowledge number of last window update
N  uint16_t SendWin;                     ///< Current send window
N  int16_t  RttSa;                       ///< Scaled average for RTT estimator
N  int16_t  RttSv;                       ///< Scaled deviation for RTT estimator
N  uint16_t CWnd;                        ///< Congestion window
N  uint16_t SsThresh;                    ///< Slow start treshold
N  uint16_t RecWin;                      ///< Current receive window
N  uint32_t RecNext;                     ///< Next receive sequence number
N  NET_FRAME *unack_list;                ///< Unacked queue list
N  const struct net_if_cfg *net_if;      ///< Network interface for the route
N  netTCP_cb_t cb_func;                  ///< Event callback function
N} NET_TCP_INFO;
N
N/// BSD Socket info
Ntypedef struct net_bsd_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Socket;                      ///< Assigned TCP/UDP socket
N  uint8_t  Flags;                       ///< Flags for socket option
N  uint8_t  Type;                        ///< Type of socket
N  __ADDR   RemHost;                     ///< Remote IP address and port
X  NET_ADDR4   RemHost;                     
N  __ADDR   LocHost;                     ///< Local IP address and port
X  NET_ADDR4   LocHost;                     
N  uint8_t  AcceptSock;                  ///< Accept socket list
N  uint8_t  ParentSock;                  ///< Parent (server) socket
N  uint16_t RecvTout;                    ///< Blocking receive timeout
N  uint16_t Timer;                       ///< Receiver timer
N  uint8_t  SendTout;                    ///< Blocking send timeout
N  uint8_t  xTimer;                      ///< Sender timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Event;                       ///< Owner wait-for events
N  uint8_t  xEvent;                      ///< Sender wait-for events
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class for IPv6
N  NETOS_ID Thread;                      ///< Socket owner thread
N  NETOS_ID xThread;                     ///< Socket sender thread
N  NET_BUFFER *buf_list;                 ///< Rx data buffer list
N} NET_BSD_INFO;
N
N/// DNS Cache Entry info
Ntypedef struct net_dns_info {
N  uint32_t HostId;                      ///< Host Id (CRC32 value of host name)
N  uint16_t Tout;                        ///< Cache timeout timer
N  int16_t  Type;                        ///< Address type: IPv4 or IPv6
N  uint8_t  IpAddr[__ADDR_IP_LEN];       ///< Internet IP address
X  uint8_t  IpAddr[4];       
N} NET_DNS_INFO;
N
N/// TFTP Server Session info
Ntypedef struct net_tftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned UDP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Retries;                     ///< Retry counter
N  __ADDR   Client;                      ///< Client IP address and port (TID)
X  NET_ADDR4   Client;                      
N  uint16_t BlockSz;                     ///< Transfer block size
N  uint16_t BlockNr;                     ///< Block number
N  uint8_t  Timer;                       ///< Timeout timer
N  uint16_t BufLen;                      ///< Length of retransmit buffer
N  uint8_t  *Buf;                        ///< Transmit/retransmit buffer
N  void     *File;                       ///< File handle pointer
N} NET_TFTP_INFO;
N
N/// Telnet Session info
Ntypedef struct net_telnet_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  BCnt;                        ///< Received data byte count
N  uint16_t Tout;                        ///< Timeout delay timer
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Widx;                        ///< Fifo buffer write index
N  uint8_t  Ridx;                        ///< Fifo buffer read index
N  uint8_t  hNext;                       ///< History command next position
N  uint8_t  hCurr;                       ///< History command current position
N  uint32_t SVar;                        ///< Session private variable
N  char     LBuf[TELNET_LBUF_SZ];        ///< Data line buffer
X  char     LBuf[96];        
N  char     Fifo[TELNET_FIFO_SZ];        ///< Fifo buffer for received line/keycodes
X  char     Fifo[128];        
N  char     Hist[TELNET_HIST_SZ];        ///< Command history buffer
X  char     Hist[128];        
N} NET_TELNET_INFO;
N
N/// FTP Session info
Ntypedef struct net_ftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< TCP control socket
N  uint16_t Flags;                       ///< State flags
N  __ADDR   Client;                      ///< Client IP address and port
X  NET_ADDR4   Client;                      
N  uint16_t DPort;                       ///< Data port (active or passive)
N  uint8_t  DSocket;                     ///< TCP data socket
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Resp;                        ///< Server response code
N  uint8_t  PathLen;                     ///< Size of the path string
N  char    *Path;                        ///< Current working directory
N  char    *Name;                        ///< Absolute file/folder path name
N  void    *File;                        ///< File handle pointer
N} NET_FTP_INFO;
N
N/// HTTP Session info
Ntypedef struct net_http_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint16_t Flags;                       ///< State flags
N  uint8_t  FType;                       ///< File type: html, jpeg, gif,...
N  uint8_t  PostSt;                      ///< POST method processing state
N  uint16_t DelimSz;                     ///< Boundary delimiter size
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  TlsId;                       ///< TLS context identifier
N  uint8_t  Method;                      ///< Request method (GET,POST,...)
N  uint32_t CGIvar;                      ///< CGI session private variable
N  uint32_t DLen;                        ///< Data length (number of bytes to send)
N  uint32_t Count;                       ///< Total number of bytes sent
N  uint16_t BCnt;                        ///< Number of bytes sent in last packet
N  char     Lang[6];                     ///< Selected web language: en-us, de, fr...
N  uint32_t LMDate;                      ///< Last modified date (UTC format)
N  char    *Script;                      ///< Script buffer pointer
N  char    *pDelim;                      ///< Multipart boundary delimiter value
N  char    *pUser;                       ///< User MIME type or Redirect URL
N  void    *sFile;                       ///< Script interpreter file pointer
N  void    *dFile;                       ///< Data file pointer
N} NET_HTTP_INFO;
N
N/// HTTP Nonce Cache Entry info
Ntypedef struct net_http_nonce {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Count;                       ///< Number of references to nonce
N  char     Val[24];                     ///< Nonce value base64 encoded
N} NET_HTTP_NONCE;
N
N/// HTTP Error page info
Ntypedef struct net_http_error {
N  const char *header;                   ///< Common page header
N  const char *footer;                   ///< Common page footer
N  const char *e401;                     ///< 401 Unauthorized
N  const char *e403;                     ///< 403 Forbidden
N  const char *e404;                     ///< 404 Not Found
N  const char *e501;                     ///< 501 Not Implemented
N} const NET_HTTP_ERROR;
N
N/// SYS Configuration info
Ntypedef struct net_sys_cfg {
N  uint32_t   *MemPool;                  ///< Dynamic memory pool buffer
N  uint32_t   MemSize;                   ///< Memory pool size in bytes
N  char       *Path;                     ///< Path buffer for root-enabled services
N  const char *HostName;                 ///< Configured Local host name
N  bool       AutoStart;                 ///< Auto-Start server service
X  _Bool       AutoStart;                 
N  bool       TxQueUsed;                 ///< Tx queue used for PPP or SLIP
X  _Bool       TxQueUsed;                 
N  const net_sys_fn_t *fn_init;          ///< Network Init-function table
N  const net_sys_fn_t *fn_run;           ///< Network Run-function table
N} const NET_SYS_CFG;
N
N/// netIF_GetOption functions
Ntypedef struct {
N  netStatus (*eth_get_option) (uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*wifi_get_option)(uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*ppp_get_option) (netIF_Option,uint8_t*,uint32_t);
N  netStatus (*slip_get_option)(netIF_Option,uint8_t*,uint32_t);
N} const NETIF_GETOPT_FUNC;
N
N/// netIF_SetOption functions
Ntypedef struct {
N  netStatus (*eth_set_option) (uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*wifi_set_option)(uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*ppp_set_option) (netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*slip_set_option)(netIF_Option,const uint8_t*,uint32_t);
N} const NETIF_SETOPT_FUNC;
N
N/// ARP Configuration info
Ntypedef struct net_arp_cfg {
N  struct net_arp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_ARP_INFO *Table;                  ///< Cache table array
N  uint8_t  TabSize;                     ///< Cache table size
N  uint8_t  TimeOut;                     ///< Cache expiration time in seconds
N  uint8_t  MaxRetry;                    ///< Number of retries to resolve MAC address
N  uint8_t  Resend;                      ///< Resend timeout in seconds
N  bool     Notify;                      ///< Notify on IP address changes
X  _Bool     Notify;                      
N} const NET_ARP_CFG;
N
N/// IGMP Configuration info
Ntypedef struct net_igmp_cfg {
N  struct net_igmp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_IGMP_INFO *Table;                 ///< Group table array
N  uint16_t TabSize;                     ///< Group table size
N} const NET_IGMP_CFG;
N
N/// DHCP Client Configuration info
Ntypedef struct net_dhcp_cfg {
N  struct net_dhcp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const char *Vcid;                     ///< Vendor class identifier
N  uint8_t    VcidLen;                   ///< Length of Vendor class identifier
N  uint8_t    OptBootfile:1;             ///< Option bootfile enable
N  uint8_t    OptNtpServ :1;             ///< Option NTP servers enable
N} const NET_DHCP_CFG;
N
N/// IP4 Configuration info
Ntypedef struct net_ip4_cfg {
N  const char  *IpAddr;                  ///< IPv4 address
N  const char  *NetMask;                 ///< IPv4 network mask
N  const char  *DefGW;                   ///< Default gateway IPv4 address
N  const char  *PriDNS;                  ///< Primary DNS server
N  const char  *SecDNS;                  ///< Secondary DNS server
N  uint16_t     Mtu;                     ///< Maximum transmission unit
N  uint8_t      NoEcho  :1;              ///< Disable ping/echo response
N  uint8_t      EnNbns  :1;              ///< Enable NBNS protocol
N  NET_ARP_CFG *ArpCfg;                  ///< ARP configuration
N  NET_IGMP_CFG *IgmpCfg;                ///< IGMP configuration
N  NET_DHCP_CFG *DhcpCfg;                ///< DHCP configuraton
N} const NET_IP4_CFG;
N
N/// NDP Configuration info
Ntypedef struct net_ndp_cfg {
N  struct net_ndp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_NDP_INFO *Table;                  ///< Neighbor cache table
N  uint8_t   TabSize;                    ///< Cache table size
N  uint8_t   TimeOut;                    ///< Cache expiration time in seconds
N  uint8_t   MaxRetry;                   ///< Number of retries to resolve MAC address
N  uint8_t   Resend;                     ///< Resend timeout in seconds
N} const NET_NDP_CFG;
N
N/// DHCP6 Client Configuration info
Ntypedef struct net_dhcp6_cfg {
N  struct net_dhcp6_ctrl   *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  uint8_t    Stateful  :1;              ///< Statefull mode enabled
N  uint8_t    OptVclass :1;              ///< Option Vendor class enabled
N  uint32_t   EnterpId;                  ///< Enterprise-number
N  const char *VcData;                   ///< Vendor class data
N} const NET_DHCP6_CFG;
N
N/// IP6 Configuration info
Ntypedef struct net_ip6_cfg {
N  const char   *IpAddr;                 ///< IPv6 address
N  const char   *DefGW;                  ///< Default gateway IPv6 address
N  const char   *PriDNS;                 ///< Primary DNS server
N  const char   *SecDNS;                 ///< Secondary DNS server
N  uint8_t       PrefixLen;              ///< Address prefix length
N  uint8_t       NoEcho :1;              ///< Disable ping/echo response
N  NET_NDP_CFG  *NdpCfg;                 ///< Neighbor discovery configuration
N  NET_DHCP6_CFG *Dhcp6Cfg;              ///< DHCPv6 configuration
N} const NET_IP6_CFG;
N
N/// Interface status info
Ntypedef struct net_if_state {
N  bool     LinkUp;                      ///< Link up or WiFi connected
X  _Bool     LinkUp;                      
N  bool     MacNew;                      ///< Mac address changed
X  _Bool     MacNew;                      
N  uint16_t Offload;                     ///< Checksum offload flags
N} NET_IF_STATE;
N
N/// General Interface descriptor
Ntypedef struct net_if_cfg {
N  NET_IF_STATE *State;                  ///< Interface Status
N  uint16_t     Id;                      ///< Interface Identifier
N  char         Name[6];                 ///< Interface Name null-terminated
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  NET_LOCALM  *localm;                  ///< Local machine info IPv4
N  NET_IP4_CFG *Ip4Cfg;                  ///< IPv4 configuration
N  NET_LOCALM6 *localm6;                 ///< Local machine info IPv6
N  NET_IP6_CFG *Ip6Cfg;                  ///< IPv6 configuration
N  bool (*send_frame)(uint32_t,          ///< Send frame function
X  _Bool (*send_frame)(uint32_t,          
N                     NET_FRAME*,uint8_t);
N  void (*config_mcast)(uint32_t);       ///< Config Multicast MAC filter for LAN
N  bool (*output_lan)(uint32_t,          ///< Low level output for LAN (Eth, WiFi)
X  _Bool (*output_lan)(uint32_t,          
N                     NET_FRAME*);
N} const NET_IF_CFG;
N
N/// Ethernet Interface descriptor
Ntypedef struct net_eth_cfg {
N  struct net_eth_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvMac;                  ///< Registered MAC driver
N  const void  *DrvPhy;                  ///< Registered PHY driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint16_t     VlanTag;                 ///< Vlan tag identifier
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t);           ///< Driver event notification callback
N} const NET_ETH_CFG;
N
N/// WiFi Interface descriptor
Ntypedef struct net_wifi_cfg {
N  struct net_wifi_ctrl    *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvWifi;                 ///< Registered WiFi driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint8_t      Mode;                    ///< WiFi Mode (Station, AP)
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t,void*);     ///< Driver event notification callback
N} const NET_WIFI_CFG;
N
N/// Serial Device Configuration info
Ntypedef struct net_com_cfg {
N  struct net_com_ctrl   *Ctrl;          ///< Serial control block
N  struct net_modem_ctrl *ModemCtrl;     ///< Modem service control block
N  const void *DrvUsart;                 ///< Registered USART driver
N  const void *DrvModem;                 ///< Registered MODEM driver
N  const char *InitString;               ///< Modem initialization string
N  uint32_t    Speed;                    ///< Connection speed
N  uint8_t     FlowCtrl;                 ///< Flow control
N  uint8_t     MaxDelay;                 ///< Max. thread polling delay in ms
N  uint8_t     RecTout;                  ///< Frame receive timeout in ticks
N  void (*cb_event)  (uint32_t);         ///< USART driver event callback
N  void (*cb_request)(const char*,       ///< Modem driver request callback
N                     const char*,uint32_t,uint32_t);
N} const NET_COM_CFG;
N
N/// PPP Interface descriptor
Ntypedef struct net_ppp_cfg {
N  struct net_ppp_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint32_t     ACCmap;                  ///< Async control character map
N  uint16_t     RetryTout;               ///< Retry timeout in ticks
N  uint16_t     EchoTout;                ///< LCP echo timeout in seconds
N  uint8_t      MaxRetry;                ///< Number of retries
N  uint8_t      EnAuth   :1;             ///< Enable authentication
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      ObtainIp :1;             ///< Obtain client IP address automatically
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  struct net_lcp_ctrl       *LcpCtrl;   ///< LCP Service control block
N  const struct net_ppp_auth *PapAuth;   ///< PAP Authentication service
N  const struct net_ppp_auth *ChapAuth;  ///< CHAP Authentication service
N  struct net_ipcp_ctrl      *IpcpCtrl;  ///< IPCP Service control block
N} const NET_PPP_CFG;
N
N/// PPP PAP/CHAP Configuration info
Ntypedef struct net_ppp_auth {
N  void *Ctrl;                           ///< Authentication control block
N  void (*init)   (NET_PPP_CFG*);        ///< Initialize authentication
N  void (*uninit) (NET_PPP_CFG*);        ///< De-initialize authentication
N  void (*run)    (NET_PPP_CFG*);        ///< Run authentication
N  void (*process)(NET_PPP_CFG*,NET_FRAME*);///< Process authentication frame
N} const NET_PPP_AUTH;
N
N/// SLIP Interface descriptor
Ntypedef struct net_slip_cfg {
N  struct net_slip_ctrl    *Ctrl;        ///< SLIP Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N} const NET_SLIP_CFG;
N
N/// IP4-Frag Configuration info
Ntypedef struct net_ip4_frag_cfg {
N  NET_IP4_FRAG_INFO *Scb;               ///< Reassembly control block array
N  uint8_t  NumSess;                     ///< Max. number of reassembly sessions
N  uint16_t ReassTout;                   ///< Reassembly timeout in ticks
N} const NET_IP4_FRAG_CFG;
N
N/// UDP Socket Configuration info
Ntypedef struct net_udp_cfg {
N  NET_UDP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of UDP sockets
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_UDP_CFG;
N
N/// TCP Socket Configuration info
Ntypedef struct net_tcp_cfg {
N  NET_TCP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of TCP sockets
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint16_t SynRetryTout;                ///< SYN retry timeout in ticks
N  uint16_t InitRetryTout;               ///< Initial retransmit timeout in ticks
N  uint16_t DefTout;                     ///< Default connect timeout in seconds
N  uint16_t MaxSegSize;                  ///< Maximum segment size value
N  uint16_t RecWinSize;                  ///< Receiving window size in bytes
N  uint8_t  ConnRetry;                   ///< Number of retries to connect
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_TCP_CFG;
N
N/// BSD Socket Configuration info
Ntypedef struct net_bsd_cfg {
N  NET_BSD_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of BSD sockets
N  uint16_t RecvTout;                    ///< Blocking recv timeout in ticks
N} const NET_BSD_CFG;
N
N/// DNS Client Configuration info
Ntypedef struct net_dns_cfg {
N  NET_DNS_INFO *Table;                  ///< Cache table array
N  uint8_t   TabSize;                    ///< Cache table size
N} const NET_DNS_CFG;
N
N/// mbedTLS interface functions
Ntypedef struct net_tls_if {
N  uint8_t  (*get_context)(int32_t,netTCP_cb_t);  ///< Allocate secure TLS context
N  void     (*connect)    (uint8_t,const char *); ///< Connect to remote endpoint
N  void     (*listen)     (uint8_t);              ///< Listen for incomming connections
N  uint8_t *(*get_buf)    (uint32_t);             ///< Get memory for send buffer
N  void     (*write)      (uint8_t,const uint8_t*,uint32_t);///< Write data to TLS session
N  void     (*close)      (uint8_t,uint8_t);      ///< Close TLS session
N} const NET_TLS_IF;
N
N/// SMTP Client Attachment functions
Ntypedef struct {
N  uint32_t (*mail_attach)  (char*,uint32_t);     ///< Compose attachment
N  uint32_t (*mime_header)  (char*,const void*);  ///< Add MIME multipart header
N  const char*(*parse_fname)(const char*,void*);  ///< Parse attachment file name(s)
N} const NET_SMTP_ATTACH;
N
N/// SMTP Client Configuration info
Ntypedef struct net_smtp_cfg {
N  uint8_t   DefTout;                    ///< Default inactivity timeout
N  struct {                              ///< File System interface functions
N    void    *(*fopen) (const char*);             ///< Open file for reading
N    uint32_t (*fread) (void*,uint8_t*,uint32_t); ///< Read file data
N    void     (*fclose)(void*);                   ///< Close file
N  } fs_if;
N  NET_SMTP_ATTACH *attach_if;           ///< Attachment support interface
N  NET_TLS_IF      *tls_if;              ///< mbedTLS interface functions
N} const NET_SMTP_CFG;
N
N/// SNMP Agent Configuration info
Ntypedef struct net_snmp_cfg {
N  uint16_t   PortNum;                   ///< Listening port number
N  uint16_t   TrapPort;                  ///< Trap port number
N  const char *TrapIp;                   ///< Trap server IP address
N  const char *Community;                ///< Community name
N} const NET_SNMP_CFG;
N
N/// SNTP Client Configuration info
Ntypedef struct net_sntp_cfg {
N  const char *SrvIp;                    ///< NTP/SNTP server IP address
N  bool       Bcast;                     ///< Broadcast client mode (for LAN only)
X  _Bool       Bcast;                     
N} const NET_SNTP_CFG;
N
N/// TFTP Server Configuration info
Ntypedef struct net_tftp_cfg {
N  NET_TFTP_INFO *Scb;                   ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t PortNum;                     ///< Listening port number
N  uint8_t  DefTout;                     ///< Inactive session timeout in seconds
N  bool     EnFwall;                     ///< Enable firewall support
X  _Bool     EnFwall;                     
N  const char *Root;                     ///< Root folder path
N} const NET_TFTP_CFG;
N
N/// TFTP Client Configuration info
Ntypedef struct net_tftpc_cfg {
N  uint16_t BlockSize;                   ///< Transfer block size
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint8_t  MaxRetry;                    ///< Number of retries
N} const NET_TFTPC_CFG;
N
N/// Telnet Server Configuration info
Ntypedef struct net_telnet_cfg {
N  NET_TELNET_INFO *Scb;                 ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint8_t  NoEcho;                      ///< Disable server echo mode
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_TELNET_CFG;
N
N/// FTP Server Configuration info
Ntypedef struct net_ftp_cfg {
N  NET_FTP_INFO *Scb;                    ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  uint8_t  MsgLen;                      ///< Length of welcome message
N  const char *Msg;                      ///< Server welcome message
N  const char *Root;                     ///< Root folder path
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_FTP_CFG;
N
N/// FTP Client Configuration info
Ntypedef struct net_ftpc_cfg {
N  uint8_t DefTout;                      ///< Default inactivity timeout
N  bool    PasvMode;                     ///< FTP passive mode used
X  _Bool    PasvMode;                     
N} const NET_FTPC_CFG;
N
N/// HTTP Server Authentication functions
Ntypedef struct {
N  void    (*init)      (void);          ///< Initialize HTTP authentication
N  void    (*uninit)    (void);          ///< De-initialize HTTP authentication
N  void    (*run)       (void);          ///< Run HTTP authentication
N  uint32_t(*add_line)  (void*,char*);   ///< Add authentication header line
N  bool    (*parse_line)(void*,char*);   ///< Parse authentication header line
X  _Bool    (*parse_line)(void*,char*);   
N  void    (*calc_hash) (const char*,    ///< Calculate Digest hash HA1 value
N                        const char*,uint8_t*);
N} const NET_HTTP_AUTH;
N
N/// HTTP Server Configuration info
Ntypedef struct net_http_cfg {
N  NET_HTTP_INFO *Scb;                   ///< Session control block array
N  uint8_t   NumSess;                    ///< Max. number of active sessions
N  bool      EnAuth;                     ///< Enable user authentication
X  _Bool      EnAuth;                     
N  uint16_t  PortNum;                    ///< Listening port number
N  const char *SrvId;                    ///< Server-Id http header
N  const char *Root;                     ///< Root folder path
N  const char *Realm;                    ///< Authentication realm space
N  uint8_t    RealmLen;                  ///< Length of realm string
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t   UserLen;                    ///< Length of admin username
N  uint8_t   PasswLen;                   ///< Length of admin password
N  NET_HTTP_NONCE *Nonce;                ///< Nonce cache table array
N  uint8_t   NumNonce;                   ///< Max. number of cache entries
N  uint8_t   NonceTout;                  ///< Cache entry timeout in seconds
N  NET_HTTP_AUTH *auth_if;               ///< Authentication support interface
N  NET_TLS_IF    *tls_if;                ///< mbedTLS interface functions
N} const NET_HTTP_CFG;
N
N/// Generic unspecified address
Nextern const uint8_t net_addr_unspec[];
N
N/// Network configuration data
Nextern NET_SYS_CFG      net_sys_config;
Nextern NET_IF_CFG       net_eth0_if_config;
Nextern NET_IF_CFG       net_eth1_if_config;
Nextern NET_IF_CFG       net_wifi0_if_config;
Nextern NET_IF_CFG       net_wifi1_if_config;
Nextern NET_IF_CFG       net_ppp0_if_config;
Nextern NET_IF_CFG       net_slip0_if_config;
N
Nextern NET_ETH_CFG   *const net_eth_list[];
Nextern NET_WIFI_CFG  *const net_wifi_list[];
Nextern NET_PPP_CFG   *const net_ppp_list[];
Nextern NET_SLIP_CFG  *const net_slip_list[];
Nextern NET_IF_CFG    *const net_if_list_lan[];
Nextern NET_IF_CFG    *const net_if_list_all[];
Nextern NET_IF_CFG    *const net_if_inet_def[];
Nextern NET_IF_CFG    *const net_if_link_def[];
Nextern NET_ARP_CFG   *const net_arp_list[];
Nextern NET_IGMP_CFG  *const net_igmp_list[];
Nextern NET_DHCP_CFG  *const net_dhcp_list[];
Nextern NET_NDP_CFG   *const net_ndp_list[];
Nextern NET_DHCP6_CFG *const net_dhcp6_list[];
N
Nextern NET_IP4_FRAG_CFG net_ip4_frag_config;
Nextern NET_UDP_CFG      net_udp_config;
Nextern NET_TCP_CFG      net_tcp_config;
Nextern NET_BSD_CFG      net_bsd_config;
Nextern NET_HTTP_CFG     net_http_config;
Nextern NET_HTTP_ERROR   net_http_error;
Nextern NET_TELNET_CFG   net_telnet_config;
Nextern NET_TFTP_CFG     net_tftp_config;
Nextern NET_TFTPC_CFG    net_tftpc_config;
Nextern NET_FTP_CFG      net_ftp_config;
Nextern NET_FTPC_CFG     net_ftpc_config;
Nextern NET_DNS_CFG      net_dns_config;
Nextern NET_SMTP_CFG     net_smtp_config;
Nextern NET_SNMP_CFG     net_snmp_config;
Nextern NET_SNTP_CFG     net_sntp_config;
N
N/// Network uninit functions
Nextern const net_sys_fn_t net_sys_fn_uninit[];
N
N/// Network interface functions
Nextern NETIF_GETOPT_FUNC  netif_getopt_func;
Nextern NETIF_SETOPT_FUNC  netif_setopt_func;
N
N/// Network exported functions.
Nextern NET_PPP_AUTH     net_ppp0_pap_auth;
Nextern NET_PPP_AUTH     net_ppp0_chap_auth;
Nextern NET_SMTP_ATTACH  net_smtp_attach_func;
Nextern NET_HTTP_AUTH    net_http_auth_basic_func;
Nextern NET_HTTP_AUTH    net_http_auth_digest_func;
N
N/// Local machine info
N#ifdef RTE_Network_Legacy
Sextern NET_LOCALM  *const net_localm[4];
N#endif
N
N//  ==== Network system ====
N
N/// \brief Network Component core thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netCore_Thread (void const *arg);
N
N/// \brief Network core tick timer callback.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void net_sys_tick (void const *arg);
N
N/// \brief Signal Network Component error.
N/// \param[in]     error         system error code.
N/// \return        None.
Nextern void net_sys_error (NET_ERROR error);
N
N/// \brief Acquire Network core protection mutex.
N/// \return        None.
Nextern void net_sys_lock   (void);
N
N/// \brief Release Network core protection mutex.
N/// \return        None.
Nextern void net_sys_unlock (void);
N
N//  ==== OS abstraction layer ====
N
N/// \brief Initialize OS abstraction layer.
N/// \return        None.
Nextern void netos_init (void);
N
N/// \brief Create network core thread.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_create (void);
N
N/// \brief Delete network core thread.
N/// \param[in]     thread        thread identifier.
N/// \return        None.
Nextern void netos_thread_delete (NETOS_ID thread);
N
N/// \brief Get running thread identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_id (void);
N
N/// \brief Pass control to next ready thread.
N/// \return        None.
Nextern void netos_thread_pass (void);
N
N/// \brief Create network periodic tick timer.
N/// \return        timer identifier.
Nextern NETOS_ID netos_timer_create (void);
N
N/// \brief Delete network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \return        None.
Nextern void netos_timer_delete (NETOS_ID timer);
N
N/// \brief Start network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \param[in]     interval_ms   tick interval in millisec.
N/// \return        None.
Nextern void netos_timer_start (NETOS_ID timer, uint32_t interval_ms);
N
N/// \brief Create network protection mutex.
N/// \param[in]     sys_id        system identifier (0=core, 1=memory).
N/// \return        mutex identifier.
Nextern NETOS_ID netos_mutex_create (uint8_t sys_id);
N
N/// \brief Delete network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_mutex_delete (NETOS_ID mutex);
N
N/// \brief Lock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_lock (NETOS_ID mutex);
N
N/// \brief Unlock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_unlock (NETOS_ID mutex);
N
N/// \brief Delay network thread execution.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_delay (uint32_t ms);
N
N/// \brief Suspend thread until event flag is set.
N/// \param[in]     flag          event flag to wait for.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_flag_wait (uint32_t flag, uint32_t ms);
N
N/// \brief Set thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_set (NETOS_ID thread, uint32_t flag);
N
N/// \brief Clear thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_clear (NETOS_ID thread, uint32_t flag);
N
N/// \brief Create network interface thread and protection semaphore.
N/// \param[in]     if_id         Network interface identification.
N/// \param[out]    semaphore     pointer to semaphore identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netif_create (uint32_t if_id, NETOS_ID *semaphore);
N
N/// \brief Delete network interface thread and protection semaphore.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_delete (NETOS_ID thread, NETOS_ID semaphore);
N
N/// \brief Lock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_lock (NETOS_ID semaphore);
N
N/// \brief Unlock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_unlock (NETOS_ID semaphore);
N
N//  ==== Memory management ====
N
N/// \brief Allocate memory for the network frame.
N/// \param[in]     byte_size     buffer size in bytes.
N/// \return        Pointer to the allocated memory.
Nextern NET_FRAME *net_mem_alloc (uint32_t byte_size);
N
N/// \brief Release allocated memory.
N/// \param[in]     mem_ptr       pointer to the allocated memory.
N/// \return        None.
Nextern void net_mem_free (NET_FRAME *mem_ptr);
N
N//  ==== Ethernet interface ====
N
N/// \brief Ethernet interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netETH_Thread (void const *arg);
N
N/// \brief Initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_init (void);
N
N/// \brief De-initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_uninit (void);
N
N/// \brief Run ethernet interface main function.
N/// \return None.
Nextern void net_eth_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Configure ethernet multicast address filtering.
N/// \param[in]     if_num        Interface number.
N/// \return        None.
Nextern void net_eth_config_mcast (uint32_t if_num);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from eth driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (eth0, eth1).
N/// \return        None.
Nextern void net_eth_callback (uint32_t event, struct net_eth_ctrl *ctx);
N
N/// \brief Get MAC address for the given IP address (legacy).
N/// \param[in]     addr        structure containing IP address of a host.
N/// \return        Pointer to the MAC address in Neighbor cache.
Nextern const uint8_t *net_eth_get_addr (const __ADDR *addr);
Xextern const uint8_t *net_eth_get_addr (const NET_ADDR4 *addr);
N
N/// \brief Get current value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_init (void);
N
N/// \brief De-initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_uninit (void);
N
N/// \brief Run ARP cache main function.
N/// \return None.
Nextern void net_arp_cache_run (void);
N
N/// \brief Send a notification of local IP address change (gratuitous ARP).
N/// \param[in]     net_if        network interface descriptor.
N/// \return        None.
Nextern void net_arp_notify (NET_IF_CFG *net_if);
N
N/// \brief Initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_init (void);
N
N/// \brief De-initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_uninit (void);
N
N/// \brief Run IGMP group management main function.
N/// \return        None.
Nextern void net_igmp_host_run (void);
N
N/// \brief Process IGMP group management frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received IGMP group management frame.
N/// \return        None.
Nextern void net_igmp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Check if local host is a member of provided group.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     ip4_addr      multicast IPv4 address to be checked.
N/// \return
N///              - true        = Local host is member of IGMP group ipadr.
N///              - false       = Local host is not member.
Nextern bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
Xextern _Bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
N
N/// \brief Collect IP addresses of active IGMP groups.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[out]    buf           buffer to copy group IP addresses to.
N/// \return        Number of IPs copied.
Nextern uint32_t net_igmp_collect_mcast (NET_IF_CFG *net_if, uint8_t *buf);
N
N/// \brief Initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_init (void);
N
N/// \brief De-initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_uninit (void);
N
N/// \brief Run NDP cache main function.
N/// \return None.
Nextern void net_ndp_cache_run (void);
N
N/// \brief Process Neighbor Discovery frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received ND frame.
N/// \return        None.
Nextern void net_ndp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_init (void);
N
N/// \brief De-initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_uninit (void);
N
N/// \brief Initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_init (void);
N
N/// \brief De-initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_uninit (void);
N
N/// \brief Run DHCP client main function.
N/// \return        None.
Nextern void net_dhcp_client_run (void);
N
N/// \brief Initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_init (void);
N
N/// \brief De-initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_uninit (void);
N
N/// \brief Run DHCP6 client main function.
N/// \return        None.
Nextern void net_dhcp6_client_run (void);
N
N//  ==== WiFi interface ====
N
N/// \brief WiFi interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netWiFi_Thread (void const *arg);
N
N/// \brief Initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_init (void);
N
N/// \brief De-initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_uninit (void);
N
N/// \brief Run WiFi interface main function.
N/// \return None.
Nextern void net_wifi_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from wifi driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (wifi0, wifi1).
N/// \return        None.
Nextern void net_wifi_callback (uint32_t event, struct net_wifi_ctrl *ctx);
N
N/// \brief Get current value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== PPP interface ====
N
N/// \brief PPP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netPPP_Thread (void const *arg);
N
N/// \brief Initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_init (void);
N
N/// \brief De-initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_uninit (void);
N
N/// \brief Run PPP interface main function.
N/// \return        None.
Nextern void net_ppp_iface_run (void);
N
N/// \brief Construct PPP header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== SLIP interface ====
N
N/// \brief SLIP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netSLIP_Thread (void const *arg);
N
N/// \brief Initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_init (void);
N
N/// \brief De-initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_uninit (void);
N
N/// \brief Run SLIP interface main function.
N/// \return        None.
Nextern void net_slip_iface_run (void);
N
N/// \brief Send a SLIP frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of SLIP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== Serial and Modem interface ====
N
N/// \brief Send event notification from the USART driver.
N/// \param[in]     event         receive USART event.
N/// \param[in]     ctx           serial device context (ppp, slip).
N/// \return        None.
Nextern void net_com_callback (uint32_t event, struct net_com_ctrl *ctx);
N
N/// \brief Request callback from the modem driver.
N/// \param[in]     cmd           command to send to a modem driver.
N/// \param[in]     response      expected response to wait for.
N/// \param[in]     timeout       response timeout.
N/// \param[in]     retries       number of retries on failure.
N/// \param[in]     ctx           modem device context.
N/// \return        None.
Nextern void net_modem_callback (const char *cmd, const char *response, uint32_t timeout,
N                                uint32_t retries, struct net_modem_ctrl *ctx);
N
N//  ==== Network core ====
N
N/// \brief Initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_init (void);
N
N/// \brief De-initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_uninit (void);
N
N/// \brief Run loopback interface main function.
N/// \return        None.
Nextern void net_loop_iface_run (void);
N
N/// \brief Initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_init (void);
N
N/// \brief De-initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_uninit (void);
N
N/// \brief Run IPv4 reassembly main function.
N/// \return        None.
Nextern void net_ip4_frag_run (void);
N
N/// \brief Reassemble incoming IPv4 fragment.
N/// \param[in]     frame         incoming IPv4 datagram fragment.
N/// \return        pointer to assembled frame or NULL if not completed yet.
Nextern NET_FRAME *net_ip4_frag_add (NET_FRAME *frame);
N
N/// \brief Split outgoing IPv4 datagram to small fragments.
N/// \param[in]     frame         outgoing IPv4 datagram.
N/// \param[in]     mtu           maximum transmission unit.
N/// \return        pointer to generated frame fragment.
Nextern NET_FRAME *net_ip4_frag_get (NET_FRAME *frame, uint16_t mtu);
N
N/// \brief Initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_init (void);
N
N/// \brief De-initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_uninit (void);
N
N/// \brief Run Ping client main function.
N/// \return        None.
Nextern void net_ping_client_run (void);
N
N/// \brief Initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_init (void);
N
N/// \brief De-initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_uninit (void);
N
N/// \brief Process UDP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received UDP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_udp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_init (void);
N
N/// \brief De-initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_uninit (void);
N
N/// \brief Run TCP socket main function.
N/// \return        None.
Nextern void net_tcp_socket_run (void);
N
N/// \brief Process TCP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received TCP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_tcp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Set or change TCP socket callback function.
N/// \param[in]     socket        socket handle.
N/// \param[in]     cb_func       event listening callback function.
N/// \return        None.
Nextern void net_tcp_set_cb (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Retrieve TCP socket remote peer address.
N/// \param[in]     socket        socket handle.
N/// \return        pointer to network address structure.
Nextern NET_ADDR *net_tcp_get_peer_ptr (int32_t socket);
N
N/// \brief Convert TCP socket state into a string.
N/// \param[in]     state         socket state as defined with netTCP_State.
N/// \return        pointer to the text representation of a socket state.
Nextern const char *net_tcp_ntoa (netTCP_State state);
N
N/// \brief Initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_init (void);
N
N/// \brief De-initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_uninit (void);
N
N/// \brief Run DNS client main function.
N/// \return        None.
Nextern void net_dns_client_run (void);
N
N/// \brief Initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_init (void);
N
N/// \brief De-initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_uninit (void);
N
N/// \brief Run BSD socket main function.
N/// \return        None.
Nextern void net_bsd_socket_run (void);
N
N/// \brief Initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_init (void);
N
N/// \brief De-initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_uninit (void);
N
N//  ==== FTP server service ====
N
N/// \brief Initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_init (void);
N
N/// \brief De-initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_uninit (void);
N
N/// \brief Run FTP server main function.
N/// \return        None.
Nextern void net_ftp_server_run (void);
N
N//  ==== FTP client application ====
N
N/// \brief Initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_init (void);
N
N/// \brief De-initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_uninit (void);
N
N/// \brief Run FTP client main function.
N/// \return        None.
Nextern void net_ftp_client_run (void);
N
N//  ==== TFTP server service ====
N
N/// \brief Initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_init (void);
N
N/// \brief De-initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_uninit (void);
N
N/// \brief Run TFTP server main function.
N/// \return        None.
Nextern void net_tftp_server_run (void);
N
N//  ==== TFTP client application ====
N
N/// \brief Initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_init (void);
N
N/// \brief De-initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_uninit (void);
N
N/// \brief Run TFTP client main function.
N/// \return        None.
Nextern void net_tftp_client_run (void);
N
N//  ==== SMTP client application ====
N
N/// \brief Initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_init (void);
N
N/// \brief De-initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_uninit (void);
N
N/// \brief Run SMTP client main function.
N/// \return        None.
Nextern void net_smtp_client_run (void);
N
N//  ==== SNMP agent application ====
N
N/// \brief Initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_init (void);
N
N/// \brief De-initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_uninit (void);
N
N/// \brief Run SNMP agent main function.
N/// \return        None.
Nextern void net_snmp_agent_run (void);
N
N//  ==== SNTP client application ====
N
N/// \brief Initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_init (void);
N
N/// \brief De-initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_uninit (void);
N
N/// \brief Run SNTP client main function.
N/// \return        None.
Nextern void net_sntp_client_run (void);
N
N//  ==== Telnet server service ====
N
N/// \brief Initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_init (void);
N
N/// \brief De-initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_uninit (void);
N
N/// \brief Run Telnet server main function.
N/// \return        None.
Nextern void net_telnet_server_run (void);
N
N//  ==== HTTP server service ====
N
N/// \brief Initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_init (void);
N
N/// \brief De-initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_uninit (void);
N
N/// \brief Run HTTP server main function.
N/// \return        None.
Nextern void net_http_server_run (void);
N
N/// \brief Convert generic time to internal HTTP time format.
N/// \param[in]     hr            hours   [0..23].
N/// \param[in]     min           minutes [0..59].
N/// \param[in]     sec           seconds [0..59].
N/// \param[in]     day           day     [1..31].
N/// \param[in]     mon           month   [1..12].
N/// \param[in]     year          year    [1980..2107].
N/// \return        converted time in UTC format.
Nextern uint32_t net_http_time (uint8_t hr, uint8_t min, uint8_t sec, 
N                               uint8_t day, uint8_t mon, uint16_t year);
N
N//  ==== TLS interface ====
N
N/// \brief Initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceInit (void);
N
N/// \brief De-initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceUninit (void);
N
N/// \brief Allocate secure TLS context.
N/// \param[in]     socket        associated TCP socket.
N/// \param[in]     cb_func       event listening TCP callback function.
N/// \return        Secure session identifier or 0=none.
Nextern uint8_t netTLS_GetContext (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Establish encrypted TLS connection to remote endpoint.
N/// \param[in]     tls_id        TLS session id.
N/// \param[in]     srv_name      hostname of the server.
N/// \return        None.
Nextern void netTLS_Connect (uint8_t tls_id, const char *srv_name);
N
N/// \brief Start TLS server listening for encrypted connection.
N/// \param[in]     tls_id        TLS session id.
N/// \return        None.
Nextern void netTLS_Listen (uint8_t tls_id);
N
N/// \brief Allocate memory for TLS send buffer.
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
Nextern uint8_t *netTLS_GetBuffer (uint32_t size);
N
N///  \brief Write data to TLS session.
N///  \param[in]    tls_id        TLS context id.
N///  \param[in]    buf           pointer to data buffer.
N///  \param[in]    len           length of data (in bytes).
N///  \return       None.
Nextern void netTLS_Write (uint8_t tls_id, const uint8_t *buf, uint32_t len);
N
N/// \brief Stop TLS communication and close socket.
N/// \param[in]     tls_id        TLS context id.
N/// \param[in]     sock_mode     socket close mode: 1=normal, 0=abort.
N/// \return        None.
Nextern void netTLS_Close (uint8_t tls_id, uint8_t sock_mode);
N
N//  ==== Network address conversion ====
N
N/// \brief Copy IP address and port.
N/// \param[out]    dst_addr      destination IPv4 or IPv6 address.
N/// \param[in]     src_addr      source IPv4 or IPv6 address.
N/// \return        None.
Nextern void net_addr_copy (__ADDR *dst_addr, const __ADDR *src_addr);
Xextern void net_addr_copy (NET_ADDR4 *dst_addr, const NET_ADDR4 *src_addr);
N
N/// \brief Convert IPv4 address from binary to string.
N/// \param[in]     ip4_addr      IPv4 address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_addr4_ntoa (const uint8_t *ip4_addr);
N
N/// \brief Convert IPv4 address from text to binary form.
N/// \param[in]     cp            IPv4 address string (ie. "192.168.1.100").
N/// \param[out]    ip4_addr      4-byte address in binary form.
N/// \return
N///                - true  = successfull,
N///                - false = failed.
Nextern bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
Xextern _Bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
N
N/// \brief Convert MAC address from binary to string.
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_mac_ntoa (const uint8_t *mac_addr);
N
N//  ==== Network debug ====
N
N/// \brief Initialize STDIO debug interface.
N/// \return        None.
Nextern void net_debug_init (void);
N
N/// \brief Debug print information message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_info (int32_t proc, const char *fmt, ...);
N
N/// \brief Debug print error message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_error (int32_t proc, const char *fmt, ...);
N
N/// \brief Convert process id into a string.
N/// \param[in]     proc          network process id.
N/// \return        pointer to process id string.
Nextern const char *net_dbg_proc (int32_t proc);
N
N/// \brief Get current network time for debug.
N/// \return        pointer to current time string.
Nextern const char *net_dbg_time (void);
N
N/// \brief Initialize Event Recorder debug interface.
N/// \return        None.
Nextern void net_evr_init (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_LIB_H */
L 19 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_config.h" 2
N
N/* Forward declarations */
Nstatic NET_ETH_CFG  eth0_ll_config;
Nstatic NET_ETH_CFG  eth1_ll_config;
Nstatic NET_WIFI_CFG wifi0_ll_config;
Nstatic NET_WIFI_CFG wifi1_ll_config;
Nstatic NET_PPP_CFG  ppp0_ll_config;
Nstatic NET_SLIP_CFG slip0_ll_config;
N
N#if   defined(RTE_CMSIS_RTOS)
X#if   1L
N  #include "net_rtos.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_rtos.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    net_rtos.h
N * Purpose: Network CMSIS-RTOS abstraction layer
N * Rev.:    V7.13.4
N *----------------------------------------------------------------------------*/
N
N#include "cmsis_os.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 1
N/* ----------------------------------------------------------------------
N * $Date:        5. February 2013
N * $Revision:    V1.02
N *
N * Project:      CMSIS-RTOS API
N * Title:        cmsis_os.h RTX header file
N *
N * Version 0.02
N *    Initial Proposal Phase
N * Version 0.03
N *    osKernelStart added, optional feature: main started as thread
N *    osSemaphores have standard behavior
N *    osTimerCreate does not start the timer, added osTimerStart
N *    osThreadPass is renamed to osThreadYield
N * Version 1.01
N *    Support for C++ interface
N *     - const attribute removed from the osXxxxDef_t typedef's
N *     - const attribute added to the osXxxxDef macros
N *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
N *    Added: osKernelInitialize
N * Version 1.02
N *    Control functions for short timeouts in microsecond resolution:
N *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
N *    Removed: osSignalGet 
N *----------------------------------------------------------------------------
N *
N * Copyright (c) 2013-2017 ARM LIMITED. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *---------------------------------------------------------------------------*/
N
N
N#ifndef _CMSIS_OS_H
N#define _CMSIS_OS_H
N
N#define osCMSIS           0x10002U     ///< CMSIS-RTOS API version (main [31:16] .sub [15:0])
N
N#define osCMSIS_RTX     ((4<<16)|82)   ///< RTOS identification and version (main [31:16] .sub [15:0])
N
N#define osKernelSystemId "RTX V4.82"   ///< RTOS identification string
N
N
N#define osFeature_MainThread   1       ///< main can be thread
N#define osFeature_Pool         1       ///< Memory Pools available
N#define osFeature_MailQ        1       ///< Mail Queues available
N#define osFeature_MessageQ     1       ///< Message Queues available
N#define osFeature_Signals      16      ///< 16 Signal Flags available per thread
N#define osFeature_Semaphore    65535   ///< Maximum count for \ref osSemaphoreCreate function
N#define osFeature_Wait         0       ///< osWait not available
N#define osFeature_SysTick      1       ///< osKernelSysTick functions available
N
N#if defined(__CC_ARM)
X#if 1L
N#define os_InRegs __value_in_regs      // Compiler specific: force struct in registers
N#else
S#define os_InRegs
N#endif
N
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N
N#include <stdint.h>
N#include <stddef.h>
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N// ==== Enumeration, structures, defines ====
N
N/// Priority used for thread control.
Ntypedef enum  {
N  osPriorityIdle          = -3,          ///< priority: idle (lowest)
N  osPriorityLow           = -2,          ///< priority: low
N  osPriorityBelowNormal   = -1,          ///< priority: below normal
N  osPriorityNormal        =  0,          ///< priority: normal (default)
N  osPriorityAboveNormal   = +1,          ///< priority: above normal
N  osPriorityHigh          = +2,          ///< priority: high
N  osPriorityRealtime      = +3,          ///< priority: realtime (highest)
N  osPriorityError         =  0x84,       ///< system cannot determine priority or thread has illegal priority
N  os_priority_reserved    =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osPriority;
N
N/// Timeout value.
N#define osWaitForever     0xFFFFFFFFU    ///< wait forever timeout value
N
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum  {
N  osOK                    =     0,       ///< function completed; no error or event occurred.
N  osEventSignal           =  0x08,       ///< function completed; signal event occurred.
N  osEventMessage          =  0x10,       ///< function completed; message event occurred.
N  osEventMail             =  0x20,       ///< function completed; mail event occurred.
N  osEventTimeout          =  0x40,       ///< function completed; timeout occurred.
N  osErrorParameter        =  0x80,       ///< parameter error: a mandatory parameter was missing or specified an incorrect object.
N  osErrorResource         =  0x81,       ///< resource not available: a specified resource was not available.
N  osErrorTimeoutResource  =  0xC1,       ///< resource not available within given time: a specified resource was not available within the timeout period.
N  osErrorISR              =  0x82,       ///< not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osErrorISRRecursive     =  0x83,       ///< function called multiple times from ISR with same object.
N  osErrorPriority         =  0x84,       ///< system cannot determine priority or thread has illegal priority.
N  osErrorNoMemory         =  0x85,       ///< system is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorValue            =  0x86,       ///< value of a parameter is out of range.
N  osErrorOS               =  0xFF,       ///< unspecified RTOS error: run-time error but no other error message fits.
N  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osStatus;
N
N
N/// Timer type value for the timer definition.
Ntypedef enum  {
N  osTimerOnce             =     0,       ///< one-shot timer
N  osTimerPeriodic         =     1        ///< repeating timer
N} os_timer_type;
N
N/// Entry point of a thread.
Ntypedef void (*os_pthread) (void const *argument);
N
N/// Entry point of a timer call back function.
Ntypedef void (*os_ptimer) (void const *argument);
N
N// >>> the following data type definitions may shall adapted towards a specific RTOS
N
N/// Thread ID identifies the thread (pointer to a thread control block).
Ntypedef struct os_thread_cb *osThreadId;
N
N/// Timer ID identifies the timer (pointer to a timer control block).
Ntypedef struct os_timer_cb *osTimerId;
N
N/// Mutex ID identifies the mutex (pointer to a mutex control block).
Ntypedef struct os_mutex_cb *osMutexId;
N
N/// Semaphore ID identifies the semaphore (pointer to a semaphore control block).
Ntypedef struct os_semaphore_cb *osSemaphoreId;
N
N/// Pool ID identifies the memory pool (pointer to a memory pool control block).
Ntypedef struct os_pool_cb *osPoolId;
N
N/// Message ID identifies the message queue (pointer to a message queue control block).
Ntypedef struct os_messageQ_cb *osMessageQId;
N
N/// Mail ID identifies the mail queue (pointer to a mail queue control block).
Ntypedef struct os_mailQ_cb *osMailQId;
N
N
N/// Thread Definition structure contains startup information of a thread.
Ntypedef struct os_thread_def  {
N  os_pthread               pthread;    ///< start address of thread function
N  osPriority             tpriority;    ///< initial thread priority
N  uint32_t               instances;    ///< maximum number of instances of that thread function
N  uint32_t               stacksize;    ///< stack size requirements in bytes; 0 is default stack size
N} osThreadDef_t;
N
N/// Timer Definition structure contains timer parameters.
Ntypedef struct os_timer_def  {
N  os_ptimer                 ptimer;    ///< start address of a timer function
N  void                      *timer;    ///< pointer to internal data
N} osTimerDef_t;
N
N/// Mutex Definition structure contains setup information for a mutex.
Ntypedef struct os_mutex_def  {
N  void                      *mutex;    ///< pointer to internal data
N} osMutexDef_t;
N
N/// Semaphore Definition structure contains setup information for a semaphore.
Ntypedef struct os_semaphore_def  {
N  void                  *semaphore;    ///< pointer to internal data
N} osSemaphoreDef_t;
N
N/// Definition structure for memory block allocation.
Ntypedef struct os_pool_def  {
N  uint32_t                 pool_sz;    ///< number of items (elements) in the pool
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< pointer to memory for pool
N} osPoolDef_t;
N
N/// Definition structure for message queue.
Ntypedef struct os_messageQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  void                       *pool;    ///< memory array for messages
N} osMessageQDef_t;
N
N/// Definition structure for mail queue.
Ntypedef struct os_mailQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< memory array for mail
N} osMailQDef_t;
N
N/// Event structure contains detailed information about an event.
Ntypedef struct  {
N  osStatus                 status;     ///< status code: event or error information
N  union  {
N    uint32_t                    v;     ///< message as 32-bit value
N    void                       *p;     ///< message or mail as void pointer
N    int32_t               signals;     ///< signal flags
N  } value;                             ///< event value
N  union  {
N    osMailQId             mail_id;     ///< mail id obtained by \ref osMailCreate
N    osMessageQId       message_id;     ///< message id obtained by \ref osMessageCreate
N  } def;                               ///< event definition
N} osEvent;
N
N
N//  ==== Kernel Control Functions ====
N
N/// Initialize the RTOS Kernel for creating objects.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelInitialize (void);
N
N/// Start the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelStart (void);
N
N/// Check if the RTOS kernel is already started.
N/// \return 0 RTOS is not started, 1 RTOS is started.
Nint32_t osKernelRunning(void);
N
N#if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
X#if (1L  &&  (1 != 0))     
N
N/// \cond INTERNAL_VARIABLES
Nextern uint32_t const os_tickfreq;
Nextern uint16_t const os_tickus_i;
Nextern uint16_t const os_tickus_f;
N/// \endcond
N
N/// Get the RTOS kernel system timer counter.
N/// \return RTOS kernel system timer as 32-bit value 
Nuint32_t osKernelSysTick (void);
N
N/// The RTOS kernel system timer frequency in Hz.
N/// \note Reflects the system timer setting and is typically defined in a configuration file.
N#define osKernelSysTickFrequency os_tickfreq
N
N/// Convert a microseconds value to a RTOS kernel system timer value.
N/// \param         microsec     time value in microseconds.
N/// \return time value normalized to the \ref osKernelSysTickFrequency
N/*
N#define osKernelSysTickMicroSec(microsec) (((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)
N*/
N#define osKernelSysTickMicroSec(microsec) ((microsec * os_tickus_i) + ((microsec * os_tickus_f) >> 16))
N
N#endif    // System Timer available
N
N//  ==== Thread Management ====
N
N/// Create a Thread Definition with function, priority, and stack requirements.
N/// \param         name         name of the thread function.
N/// \param         priority     initial priority of the thread function.
N/// \param         instances    number of possible thread instances.
N/// \param         stacksz      stack size (in bytes) requirements for the thread function.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osThreadDef(name, priority, instances, stacksz)  \
Sextern const osThreadDef_t os_thread_def_##name
X#define osThreadDef(name, priority, instances, stacksz)  extern const osThreadDef_t os_thread_def_##name
N#else                            // define the object
N#define osThreadDef(name, priority, instances, stacksz)  \
Nconst osThreadDef_t os_thread_def_##name = \
N{ (name), (priority), (instances), (stacksz)  }
X#define osThreadDef(name, priority, instances, stacksz)  const osThreadDef_t os_thread_def_##name = { (name), (priority), (instances), (stacksz)  }
N#endif
N
N/// Access a Thread definition.
N/// \param         name          name of the thread definition object.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#define osThread(name)  \
N&os_thread_def_##name
X#define osThread(name)  &os_thread_def_##name
N
N/// Create a thread and add it to Active Threads and set it to state READY.
N/// \param[in]     thread_def    thread definition referenced with \ref osThread.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument);
N
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadGetId (void);
N
N/// Terminate execution of a thread and remove it from Active Threads.
N/// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadTerminate (osThreadId thread_id);
N
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadYield (void);
N
N/// Change priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadSetPriority (osThreadId thread_id, osPriority priority);
N
N/// Get current priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return current priority value of the thread function.
NosPriority osThreadGetPriority (osThreadId thread_id);
N
N
N//  ==== Generic Wait Functions ====
N
N/// Wait for Timeout (Time Delay).
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value
N/// \return status code that indicates the execution status of the function.
NosStatus osDelay (uint32_t millisec);
N
N#if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available
X#if (1L  &&  (0 != 0))     
S
S/// Wait for Signal, Message, Mail, or Timeout.
S/// \param[in] millisec          \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
S/// \return event that contains signal, message, or mail information or error code.
Sos_InRegs osEvent osWait (uint32_t millisec);
S
N#endif  // Generic Wait available
N
N
N//  ==== Timer Management Functions ====
N/// Define a Timer object.
N/// \param         name          name of the timer object.
N/// \param         function      name of the timer call back function.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osTimerDef(name, function)  \
Sextern const osTimerDef_t os_timer_def_##name
X#define osTimerDef(name, function)  extern const osTimerDef_t os_timer_def_##name
N#else                            // define the object
N#define osTimerDef(name, function)  \
Nuint32_t os_timer_cb_##name[6]; \
Nconst osTimerDef_t os_timer_def_##name = \
N{ (function), (os_timer_cb_##name) }
X#define osTimerDef(name, function)  uint32_t os_timer_cb_##name[6]; const osTimerDef_t os_timer_def_##name = { (function), (os_timer_cb_##name) }
N#endif
N
N/// Access a Timer definition.
N/// \param         name          name of the timer object.
N#define osTimer(name) \
N&os_timer_def_##name
X#define osTimer(name) &os_timer_def_##name
N
N/// Create a timer.
N/// \param[in]     timer_def     timer object referenced with \ref osTimer.
N/// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer call back function.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument);
N
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStart (osTimerId timer_id, uint32_t millisec);
N
N/// Stop the timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStop (osTimerId timer_id);
N
N/// Delete a timer that was created by \ref osTimerCreate.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerDelete (osTimerId timer_id);
N
N
N//  ==== Signal Management ====
N
N/// Set the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that should be set.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
Nint32_t osSignalSet (osThreadId thread_id, int32_t signals);
N
N/// Clear the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that shall be cleared.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters or call from ISR.
Nint32_t osSignalClear (osThreadId thread_id, int32_t signals);
N
N/// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
N/// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flag information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osSignalWait __osSignalWait
SosEvent __osSignalWait (int32_t signals, uint32_t millisec);
N#else
Nos_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec);
X__value_in_regs osEvent osSignalWait (int32_t signals, uint32_t millisec);
N#endif
N
N
N//  ==== Mutex Management ====
N
N/// Define a Mutex.
N/// \param         name          name of the mutex object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMutexDef(name)  \
Sextern const osMutexDef_t os_mutex_def_##name
X#define osMutexDef(name)  extern const osMutexDef_t os_mutex_def_##name
N#else                            // define the object
N#define osMutexDef(name)  \
Nuint32_t os_mutex_cb_##name[4] = { 0 }; \
Nconst osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
X#define osMutexDef(name)  uint32_t os_mutex_cb_##name[4] = { 0 }; const osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
N#endif
N
N/// Access a Mutex definition.
N/// \param         name          name of the mutex object.
N#define osMutex(name)  \
N&os_mutex_def_##name
X#define osMutex(name)  &os_mutex_def_##name
N
N/// Create and Initialize a Mutex object.
N/// \param[in]     mutex_def     mutex definition referenced with \ref osMutex.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId osMutexCreate (const osMutexDef_t *mutex_def);
N
N/// Wait until a Mutex becomes available.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexWait (osMutexId mutex_id, uint32_t millisec);
N
N/// Release a Mutex that was obtained by \ref osMutexWait.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexRelease (osMutexId mutex_id);
N
N/// Delete a Mutex that was created by \ref osMutexCreate.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexDelete (osMutexId mutex_id);
N
N
N//  ==== Semaphore Management Functions ====
N
N#if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))     // Semaphore available
X#if (1L  &&  (65535 != 0))     
N
N/// Define a Semaphore object.
N/// \param         name          name of the semaphore object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osSemaphoreDef(name)  \
Sextern const osSemaphoreDef_t os_semaphore_def_##name
X#define osSemaphoreDef(name)  extern const osSemaphoreDef_t os_semaphore_def_##name
N#else                            // define the object
N#define osSemaphoreDef(name)  \
Nuint32_t os_semaphore_cb_##name[2] = { 0 }; \
Nconst osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
X#define osSemaphoreDef(name)  uint32_t os_semaphore_cb_##name[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
N#endif
N
N/// Access a Semaphore definition.
N/// \param         name          name of the semaphore object.
N#define osSemaphore(name)  \
N&os_semaphore_def_##name
X#define osSemaphore(name)  &os_semaphore_def_##name
N
N/// Create and Initialize a Semaphore object used for managing resources.
N/// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore.
N/// \param[in]     count         number of available resources.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count);
N
N/// Wait until a Semaphore token becomes available.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return number of available tokens, or -1 in case of incorrect parameters.
Nint32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec);
N
N/// Release a Semaphore token.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreRelease (osSemaphoreId semaphore_id);
N
N/// Delete a Semaphore that was created by \ref osSemaphoreCreate.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreDelete (osSemaphoreId semaphore_id);
N
N#endif     // Semaphore available
N
N
N//  ==== Memory Pool Management Functions ====
N
N#if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0))  // Memory Pool Management available
X#if (1L  &&  (1 != 0))  
N
N/// \brief Define a Memory Pool.
N/// \param         name          name of the memory pool.
N/// \param         no            maximum number of blocks (objects) in the memory pool.
N/// \param         type          data type of a single block (object).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osPoolDef(name, no, type)   \
Sextern const osPoolDef_t os_pool_def_##name
X#define osPoolDef(name, no, type)   extern const osPoolDef_t os_pool_def_##name
N#else                            // define the object
N#define osPoolDef(name, no, type)   \
Nuint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; \
Nconst osPoolDef_t os_pool_def_##name = \
N{ (no), sizeof(type), (os_pool_m_##name) }
X#define osPoolDef(name, no, type)   uint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; const osPoolDef_t os_pool_def_##name = { (no), sizeof(type), (os_pool_m_##name) }
N#endif
N
N/// \brief Access a Memory Pool definition.
N/// \param         name          name of the memory pool
N#define osPool(name) \
N&os_pool_def_##name
X#define osPool(name) &os_pool_def_##name
N
N/// Create and Initialize a memory pool.
N/// \param[in]     pool_def      memory pool definition referenced with \ref osPool.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosPoolId osPoolCreate (const osPoolDef_t *pool_def);
N
N/// Allocate a memory block from a memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolAlloc (osPoolId pool_id);
N
N/// Allocate a memory block from a memory pool and set memory block to zero.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolCAlloc (osPoolId pool_id);
N
N/// Return an allocated memory block back to a specific memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \param[in]     block         address of the allocated memory block that is returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus osPoolFree (osPoolId pool_id, void *block);
N
N#endif   // Memory Pool Management available
N
N
N//  ==== Message Queue Management Functions ====
N
N#if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0))     // Message Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Message Queue Definition.
N/// \param         name          name of the queue.
N/// \param         queue_sz      maximum number of messages in the queue.
N/// \param         type          data type of a single message element (for debugger).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMessageQDef(name, queue_sz, type)   \
Sextern const osMessageQDef_t os_messageQ_def_##name
X#define osMessageQDef(name, queue_sz, type)   extern const osMessageQDef_t os_messageQ_def_##name
N#else                            // define the object
N#define osMessageQDef(name, queue_sz, type)   \
Nuint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; \
Nconst osMessageQDef_t os_messageQ_def_##name = \
N{ (queue_sz), (os_messageQ_q_##name) }
X#define osMessageQDef(name, queue_sz, type)   uint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; const osMessageQDef_t os_messageQ_def_##name = { (queue_sz), (os_messageQ_q_##name) }
N#endif
N
N/// \brief Access a Message Queue Definition.
N/// \param         name          name of the queue
N#define osMessageQ(name) \
N&os_messageQ_def_##name
X#define osMessageQ(name) &os_messageQ_def_##name
N
N/// Create and Initialize a Message Queue.
N/// \param[in]     queue_def     queue definition referenced with \ref osMessageQ.
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);
N
N/// Put a Message to a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     info          message information.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);
N
N/// Get a Message or Wait for a Message from a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event information that includes status code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osMessageGet __osMessageGet
SosEvent __osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#endif
N
N#endif     // Message Queues available
N
N
N//  ==== Mail Queue Management Functions ====
N
N#if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))     // Mail Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Mail Queue Definition.
N/// \param         name          name of the queue
N/// \param         queue_sz      maximum number of messages in queue
N/// \param         type          data type of a single message element
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMailQDef(name, queue_sz, type) \
Sextern const osMailQDef_t os_mailQ_def_##name
X#define osMailQDef(name, queue_sz, type) extern const osMailQDef_t os_mailQ_def_##name
N#else                            // define the object
N#define osMailQDef(name, queue_sz, type) \
Nuint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; \
Nuint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; \
Nvoid *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; \
Nconst osMailQDef_t os_mailQ_def_##name =  \
N{ (queue_sz), sizeof(type), (os_mailQ_p_##name) }
X#define osMailQDef(name, queue_sz, type) uint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; uint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; void *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; const osMailQDef_t os_mailQ_def_##name =  { (queue_sz), sizeof(type), (os_mailQ_p_##name) }
N#endif
N
N/// \brief Access a Mail Queue Definition.
N/// \param         name          name of the queue
N#define osMailQ(name)  \
N&os_mailQ_def_##name
X#define osMailQ(name)  &os_mailQ_def_##name
N
N/// Create and Initialize mail queue.
N/// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return mail queue ID for reference by other functions or NULL in case of error.
NosMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id);
N
N/// Allocate a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Allocate a memory block from a mail and set memory block to zero.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailCAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Put a mail to a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailPut (osMailQId queue_id, void *mail);
N
N/// Get a mail from a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return event that contains mail information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osMailGet __osMailGet
SosEvent __osMailGet (osMailQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
N#endif
N
N/// Free a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailFree (osMailQId queue_id, void *mail);
N
N#endif  // Mail Queues available
N
N
N//  ==== RTX Extensions ====
N
N/// Suspend the RTX task scheduler.
N/// \return number of ticks, for how long the system can sleep or power-down.
Nuint32_t os_suspend (void);
N
N/// Resume the RTX task scheduler.
N/// \param[in]     sleep_time    specifies how long the system was in sleep or power-down mode.
Nvoid os_resume (uint32_t sleep_time);
N
N/// OS idle demon (running when no other thread is ready to run).
N__NO_RETURN void os_idle_demon (void);
X__declspec(noreturn) void os_idle_demon (void);
N
N/// OS error callback (called when a runtime error is detected).
N/// \param[in]     error_code    actual error code that has been detected.
N__NO_RETURN void os_error (uint32_t error_code);
X__declspec(noreturn) void os_error (uint32_t error_code);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif  // _CMSIS_OS_H
L 11 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_rtos.h" 2
N#include "rl_net_lib.h"
N
N/* Avoid syntax-checker errors in editor */
N#ifndef NET_THREAD_STACK_SIZE
S  #define NET_THREAD_STACK_SIZE 1024
S  #define NET_THREAD_PRIORITY   osPriorityNormal
N#endif
N
N#if (osCMSIS < 0x20000U)
X#if (0x10002U < 0x20000U)
N  #define STATIC        static
N#else
S  #define STATIC
N#endif
N
N/* Network core resources */
Nextern const osMutexDef_t os_mutex_def_net_lock;
Nextern const osMutexDef_t os_mutex_def_mem_lock;
Nextern const osTimerDef_t os_timer_def_net_tick;
Nextern const osThreadDef_t os_thread_def_netCore_Thread;
NSTATIC osMutexDef(net_lock);
Xstatic uint32_t os_mutex_cb_net_lock[4] = { 0 }; const osMutexDef_t os_mutex_def_net_lock = { (os_mutex_cb_net_lock) };
NSTATIC osMutexDef(mem_lock);
Xstatic uint32_t os_mutex_cb_mem_lock[4] = { 0 }; const osMutexDef_t os_mutex_def_mem_lock = { (os_mutex_cb_mem_lock) };
NSTATIC osTimerDef(net_tick, net_sys_tick);
Xstatic uint32_t os_timer_cb_net_tick[6]; const osTimerDef_t os_timer_def_net_tick = { (net_sys_tick), (os_timer_cb_net_tick) };
N       osThreadDef(netCore_Thread, NET_THREAD_PRIORITY, 1, NET_THREAD_STACK_SIZE);
X       const osThreadDef_t os_thread_def_netCore_Thread = { (netCore_Thread), (osPriorityNormal), (1), (2048) };
N
N/* Ethernet interface resources */
N#if (ETH0_ENABLE || ETH1_ENABLE)
X#if (1 || ETH1_ENABLE)
Nstatic void eth_thread (void const *arg) {
N  netETH_Thread (arg);
N}
N#endif
N#if (ETH0_ENABLE)
X#if (1)
Nextern const osThreadDef_t os_thread_def_eth0_thread;
Nextern const osSemaphoreDef_t os_semaphore_def_eth0_lock;
Nstatic void eth0_thread (void const *arg) __attribute__((alias("eth_thread")));
NSTATIC osSemaphoreDef(eth0_lock);
Xstatic uint32_t os_semaphore_cb_eth0_lock[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_eth0_lock = { (os_semaphore_cb_eth0_lock) };
N       osThreadDef(eth0_thread, ETH0_THREAD_PRIORITY, 1, ETH0_THREAD_STACK_SIZE);
X       const osThreadDef_t os_thread_def_eth0_thread = { (eth0_thread), (osPriorityAboveNormal), (1), (1024) };
N#endif
N#if (ETH1_ENABLE)
Sextern const osThreadDef_t os_thread_def_eth1_thread;
Sextern const osSemaphoreDef_t os_semaphore_def_eth1_lock;
Sstatic void eth1_thread (void const *arg) __attribute__((alias("eth_thread")));
SSTATIC osSemaphoreDef(eth1_lock);
S       osThreadDef(eth1_thread, ETH1_THREAD_PRIORITY, 1, ETH1_THREAD_STACK_SIZE);
N#endif
N
N/* WiFi interface resources */
N#if (WIFI0_ENABLE || WIFI1_ENABLE)
Sstatic void wifi_thread (void const *arg) {
S  netWiFi_Thread (arg);
S}
N#endif
N#if (WIFI0_ENABLE)
Sextern const osThreadDef_t os_thread_def_wifi0_thread;
Sextern const osSemaphoreDef_t os_semaphore_def_wifi0_lock;
Sstatic void wifi0_thread (void const *arg) __attribute__((alias("wifi_thread")));
SSTATIC osSemaphoreDef(wifi0_lock);
S       osThreadDef(wifi0_thread, WIFI0_THREAD_PRIORITY, 1, WIFI0_THREAD_STACK_SIZE);
N#endif
N#if (WIFI1_ENABLE)
Sextern const osThreadDef_t os_thread_def_wifi1_thread;
Sextern const osSemaphoreDef_t os_semaphore_def_wifi1_lock;
Sstatic void wifi1_thread (void const *arg) __attribute__((alias("wifi_thread")));
SSTATIC osSemaphoreDef(wifi1_lock);
S       osThreadDef(wifi1_thread, WIFI1_THREAD_PRIORITY, 1, WIFI1_THREAD_STACK_SIZE);
N#endif
N
N/* PPP interface resources */
N#if (PPP_ENABLE)
Sextern const osThreadDef_t os_thread_def_netPPP_Thread;
Sextern const osSemaphoreDef_t os_semaphore_def_ppp0_lock;
SSTATIC osSemaphoreDef(ppp0_lock);
S       osThreadDef(netPPP_Thread, PPP_THREAD_PRIORITY, 1, PPP_THREAD_STACK_SIZE);
N#endif
N
N/* SLIP interface resources */
N#if (SLIP_ENABLE)
Sextern const osThreadDef_t os_thread_def_netSLIP_Thread;
Sextern const osSemaphoreDef_t os_semaphore_def_slip0_lock;
SSTATIC osSemaphoreDef(slip0_lock);
S       osThreadDef(netSLIP_Thread, SLIP_THREAD_PRIORITY, 1, SLIP_THREAD_STACK_SIZE);
N#endif
N
N
N/* Initialize OS abstraction layer */
Nvoid netos_init (void) {
N  return;
N}
N
N/* Create network core thread */
NNETOS_ID netos_thread_create (void) {
N  return (osThreadCreate (osThread(netCore_Thread), NULL));
X  return (osThreadCreate (&os_thread_def_netCore_Thread, 0));
N}
N
N/* Delete network thread */
Nvoid netos_thread_delete (NETOS_ID thread) {
N  osThreadTerminate ((osThreadId)thread);
N}
N
N/* Get running thread identifier */
NNETOS_ID netos_thread_id (void) {
N  return (osThreadGetId ());
N}
N
N/* Pass control to next ready thread */
Nvoid netos_thread_pass (void) {
N  osThreadYield ();
N}
N
N/* Create periodic tick timer */
NNETOS_ID netos_timer_create (void) {
N  return (osTimerCreate (osTimer(net_tick), osTimerPeriodic, NULL));
X  return (osTimerCreate (&os_timer_def_net_tick, osTimerPeriodic, 0));
N}
N
N/* Delete periodic tick timer */
Nvoid netos_timer_delete (NETOS_ID timer) {
N  osTimerDelete ((osTimerId)timer);
N}
N
N/* Start periodic tick timer */
Nvoid netos_timer_start (NETOS_ID timer, uint32_t interval_ms) {
N  osTimerStart ((osTimerId)timer, interval_ms);
N}
N
N/* Create network protection mutex */
NNETOS_ID netos_mutex_create (uint8_t sys_id) {
N  switch (sys_id) {
N    case 0:  return (osMutexCreate (osMutex(net_lock)));
X    case 0:  return (osMutexCreate (&os_mutex_def_net_lock));
N    default: return (osMutexCreate (osMutex(mem_lock)));
X    default: return (osMutexCreate (&os_mutex_def_mem_lock));
N  }
N}
N
N/* Delete network protection mutex */
Nvoid netos_mutex_delete (NETOS_ID mutex) {
N  osMutexDelete ((osMutexId)mutex);
N}
N
N/* Lock network protection mutex */
Nvoid netos_lock (NETOS_ID mutex) {
N  osMutexWait ((osMutexId)mutex, osWaitForever);
X  osMutexWait ((osMutexId)mutex, 0xFFFFFFFFU);
N}
N
N/* Unlock network protection mutex */
Nvoid netos_unlock (NETOS_ID mutex) {
N  osMutexRelease ((osMutexId)mutex);
N}
N
N/* Wait for thread signal/event flag */
Nvoid netos_flag_wait (uint32_t flag, uint32_t ms) {
N  osSignalWait ((int32_t)flag, ms);
N}
N
N/* Set thread signal/event flag */
Nvoid netos_flag_set (NETOS_ID thread, uint32_t flag) {
N  osSignalSet ((osThreadId)thread, (int32_t)flag);
N}
N
N/* Clear thread signal/event flag */
Nvoid netos_flag_clear (NETOS_ID thread, uint32_t flag) {
N  osSignalClear ((osThreadId)thread, (int32_t)flag);
N}
N
N/* Delay thread execution */
Nvoid netos_delay (uint32_t ms) {
N  osDelay (ms);
N}
N
N/* Create network interface (thread and semaphore) */
NNETOS_ID netif_create (uint32_t if_id, NETOS_ID *semaphore) {
N  switch (if_id) {
N#if (ETH0_ENABLE)
X#if (1)
N    case NET_IF_CLASS_ETH:
X    case (1U << 8):
N      *semaphore = osSemaphoreCreate (osSemaphore(eth0_lock), 1);
X      *semaphore = osSemaphoreCreate (&os_semaphore_def_eth0_lock, 1);
N      return (osThreadCreate (osThread(eth0_thread), (void *)(uint32_t)&eth0_ll_config));
X      return (osThreadCreate (&os_thread_def_eth0_thread, (void *)(uint32_t)&eth0_ll_config));
N#endif
N#if (ETH1_ENABLE)
S    case NET_IF_CLASS_ETH+1:
S      *semaphore = osSemaphoreCreate (osSemaphore(eth1_lock), 1);
S      return (osThreadCreate (osThread(eth1_thread), (void *)(uint32_t)&eth1_ll_config));
N#endif
N#if (WIFI0_ENABLE)
S    case NET_IF_CLASS_WIFI:
S      *semaphore = osSemaphoreCreate (osSemaphore(wifi0_lock), 1);
S      return (osThreadCreate (osThread(wifi0_thread), (void *)(uint32_t)&wifi0_ll_config));
N#endif
N#if (WIFI1_ENABLE)
S    case NET_IF_CLASS_WIFI+1:
S      *semaphore = osSemaphoreCreate (osSemaphore(wifi1_lock), 1);
S      return (osThreadCreate (osThread(wifi1_thread), (void *)(uint32_t)&wifi1_ll_config));
N#endif
N#if (PPP_ENABLE)
S    case NET_IF_CLASS_PPP:
S      *semaphore = osSemaphoreCreate (osSemaphore(ppp0_lock), 1);
S      return (osThreadCreate (osThread(netPPP_Thread), (void *)(uint32_t)&ppp0_ll_config));
N#endif
N#if (SLIP_ENABLE)
S    case NET_IF_CLASS_SLIP:
S      *semaphore = osSemaphoreCreate (osSemaphore(slip0_lock), 1);
S      return (osThreadCreate (osThread(netSLIP_Thread), (void *)(uint32_t)&slip0_ll_config));
N#endif
N  }
N  return (NULL);
X  return (0);
N}
N
N/* Delete network interface (thread and semaphore) */
Nvoid netif_delete (NETOS_ID thread, NETOS_ID semaphore) {
N  osSemaphoreDelete ((osSemaphoreId)semaphore);
N  osThreadTerminate ((osThreadId)thread);
N}
N
N/* Lock interface protection semaphore */
Nvoid netif_lock (NETOS_ID semaphore) {
N  osSemaphoreWait ((osSemaphoreId)semaphore, osWaitForever);
X  osSemaphoreWait ((osSemaphoreId)semaphore, 0xFFFFFFFFU);
N}
N
N/* Unlock interface protection semaphore */
Nvoid netif_unlock (NETOS_ID semaphore) {
N  osSemaphoreRelease ((osSemaphoreId)semaphore);
N}
N
L 30 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_config.h" 2
N#elif defined(RTE_CMSIS_RTOS2)
S  #include "net_rtos2.h"
S#else
S  #error "::CMSIS:RTOS selection invalid"
N#endif
N
N#if (ETH0_ENABLE || ETH1_ENABLE)
X#if (1 || ETH1_ENABLE)
N  #include "Driver_ETH_MAC.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH_MAC.h" 1
N/*
N * Copyright (c) 2013-2020 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        24. January 2020
N * $Revision:    V2.2
N *
N * Project:      Ethernet MAC (Media Access Control) Driver definitions
N */
N
N/* History:
N *  Version 2.2
N *    Removed volatile from ARM_ETH_LINK_INFO
N *  Version 2.1
N *    Added ARM_ETH_MAC_SLEEP Control
N *  Version 2.0
N *    Changed MAC Address handling:
N *      moved from ARM_ETH_MAC_Initialize
N *      to new functions ARM_ETH_MAC_GetMacAddress and ARM_ETH_MAC_SetMacAddress
N *    Replaced ARM_ETH_MAC_SetMulticastAddr function with ARM_ETH_MAC_SetAddressFilter
N *    Extended ARM_ETH_MAC_SendFrame function with flags
N *    Added ARM_ETH_MAC_Control function:
N *      more control options (Broadcast, Multicast, Checksum offload, VLAN, ...)
N *      replaces ARM_ETH_MAC_SetMode
N *      replaces ARM_ETH_MAC_EnableTx, ARM_ETH_MAC_EnableRx
N *    Added optional event on transmitted frame
N *    Added support for PTP (Precision Time Protocol) through new functions:
N *       ARM_ETH_MAC_ControlTimer
N *       ARM_ETH_MAC_GetRxFrameTime
N *       ARM_ETH_MAC_GetTxFrameTime
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Changed return values of some functions to int32_t
N *  Version 1.10
N *    Name space prefix ARM_ added
N *  Version 1.01
N *    Renamed capabilities items for checksum offload
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_ETH_MAC_H_
N#define DRIVER_ETH_MAC_H_
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N#include "Driver_ETH.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH.h" 1
N/*
N * Copyright (c) 2013-2020 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        24. January 2020
N * $Revision:    V2.2
N *
N * Project:      Ethernet PHY and MAC Driver common definitions
N */
N
N/* History:
N *  Version 2.2
N *    Removed volatile from ARM_ETH_LINK_INFO
N *  Version 2.1
N *    ARM_ETH_LINK_INFO made volatile
N *  Version 2.0
N *    Removed ARM_ETH_STATUS enumerator
N *    Removed ARM_ETH_MODE enumerator
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_ETH_H_
N#define DRIVER_ETH_H_
N
N#include "Driver_Common.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_Common.h" 1
N/*
N * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        2. Feb 2017
N * $Revision:    V2.0
N *
N * Project:      Common Driver definitions
N */
N
N/* History:
N *  Version 2.0
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_COMMON_H_
N#define DRIVER_COMMON_H_
N
N#include <stddef.h>
N#include <stdint.h>
N#include <stdbool.h>
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* DRIVER_COMMON_H_ */
L 42 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH.h" 2
N
N/**
N\brief Ethernet Media Interface type
N*/
N#define ARM_ETH_INTERFACE_MII           (0U)    ///< Media Independent Interface (MII)
N#define ARM_ETH_INTERFACE_RMII          (1U)    ///< Reduced Media Independent Interface (RMII)
N#define ARM_ETH_INTERFACE_SMII          (2U)    ///< Serial Media Independent Interface (SMII)
N
N/**
N\brief Ethernet link speed
N*/
N#define ARM_ETH_SPEED_10M               (0U)    ///< 10 Mbps link speed
N#define ARM_ETH_SPEED_100M              (1U)    ///< 100 Mbps link speed
N#define ARM_ETH_SPEED_1G                (2U)    ///< 1 Gpbs link speed
N
N/**
N\brief Ethernet duplex mode
N*/
N#define ARM_ETH_DUPLEX_HALF             (0U)    ///< Half duplex link
N#define ARM_ETH_DUPLEX_FULL             (1U)    ///< Full duplex link
N
N/**
N\brief Ethernet link state
N*/
Ntypedef enum _ARM_ETH_LINK_STATE {
N  ARM_ETH_LINK_DOWN,                    ///< Link is down
N  ARM_ETH_LINK_UP                       ///< Link is up
N} ARM_ETH_LINK_STATE;
N
N/**
N\brief Ethernet link information
N*/
Ntypedef struct _ARM_ETH_LINK_INFO {
N  uint32_t speed    : 2;                ///< Link speed: 0= 10 MBit, 1= 100 MBit, 2= 1 GBit
N  uint32_t duplex   : 1;                ///< Duplex mode: 0= Half, 1= Full
N  uint32_t reserved : 29;
N} ARM_ETH_LINK_INFO;
N
N/**
N\brief Ethernet MAC Address
N*/
Ntypedef struct _ARM_ETH_MAC_ADDR {
N  uint8_t b[6];                         ///< MAC Address (6 bytes), MSB first
N} ARM_ETH_MAC_ADDR;
N
N#endif /* DRIVER_ETH_H_ */
L 63 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH_MAC.h" 2
N
N#define ARM_ETH_MAC_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,2)  /* API version */
N
N
N#define _ARM_Driver_ETH_MAC_(n)      Driver_ETH_MAC##n
N#define  ARM_Driver_ETH_MAC_(n) _ARM_Driver_ETH_MAC_(n)
N
N
N/****** Ethernet MAC Control Codes *****/
N
N#define ARM_ETH_MAC_CONFIGURE           (0x01UL)    ///< Configure MAC; arg = configuration
N#define ARM_ETH_MAC_CONTROL_TX          (0x02UL)    ///< Transmitter; arg: 0=disabled (default), 1=enabled
N#define ARM_ETH_MAC_CONTROL_RX          (0x03UL)    ///< Receiver; arg: 0=disabled (default), 1=enabled
N#define ARM_ETH_MAC_FLUSH               (0x04UL)    ///< Flush buffer; arg = ARM_ETH_MAC_FLUSH_...
N#define ARM_ETH_MAC_SLEEP               (0x05UL)    ///< Sleep mode; arg: 1=enter and wait for Magic packet, 0=exit
N#define ARM_ETH_MAC_VLAN_FILTER         (0x06UL)    ///< VLAN Filter for received frames; arg15..0: VLAN Tag; arg16: optional ARM_ETH_MAC_VLAN_FILTER_ID_ONLY; 0=disabled (default)
N
N/*----- Ethernet MAC Configuration -----*/
N#define ARM_ETH_MAC_SPEED_Pos            0
N#define ARM_ETH_MAC_SPEED_Msk           (3UL                 << ARM_ETH_MAC_SPEED_Pos)
N#define ARM_ETH_MAC_SPEED_10M           (ARM_ETH_SPEED_10M   << ARM_ETH_MAC_SPEED_Pos)  ///< 10 Mbps link speed
N#define ARM_ETH_MAC_SPEED_100M          (ARM_ETH_SPEED_100M  << ARM_ETH_MAC_SPEED_Pos)  ///< 100 Mbps link speed
N#define ARM_ETH_MAC_SPEED_1G            (ARM_ETH_SPEED_1G    << ARM_ETH_MAC_SPEED_Pos)  ///< 1 Gpbs link speed
N#define ARM_ETH_MAC_DUPLEX_Pos           2
N#define ARM_ETH_MAC_DUPLEX_Msk          (1UL                 << ARM_ETH_MAC_DUPLEX_Pos)
N#define ARM_ETH_MAC_DUPLEX_HALF         (ARM_ETH_DUPLEX_HALF << ARM_ETH_MAC_DUPLEX_Pos) ///< Half duplex link
N#define ARM_ETH_MAC_DUPLEX_FULL         (ARM_ETH_DUPLEX_FULL << ARM_ETH_MAC_DUPLEX_Pos) ///< Full duplex link
N#define ARM_ETH_MAC_LOOPBACK            (1UL << 4)  ///< Loop-back test mode
N#define ARM_ETH_MAC_CHECKSUM_OFFLOAD_RX (1UL << 5)  ///< Receiver Checksum offload
N#define ARM_ETH_MAC_CHECKSUM_OFFLOAD_TX (1UL << 6)  ///< Transmitter Checksum offload
N#define ARM_ETH_MAC_ADDRESS_BROADCAST   (1UL << 7)  ///< Accept frames with Broadcast address
N#define ARM_ETH_MAC_ADDRESS_MULTICAST   (1UL << 8)  ///< Accept frames with any Multicast address
N#define ARM_ETH_MAC_ADDRESS_ALL         (1UL << 9)  ///< Accept frames with any address (Promiscuous Mode)
N
N/*----- Ethernet MAC Flush Flags -----*/
N#define ARM_ETH_MAC_FLUSH_RX            (1UL << 0)  ///< Flush Receive buffer
N#define ARM_ETH_MAC_FLUSH_TX            (1UL << 1)  ///< Flush Transmit buffer
N
N/*----- Ethernet MAC VLAN Filter Flag -----*/
N#define ARM_ETH_MAC_VLAN_FILTER_ID_ONLY (1UL << 16) ///< Compare only the VLAN Identifier (12-bit)
N
N
N/****** Ethernet MAC Frame Transmit Flags *****/
N#define ARM_ETH_MAC_TX_FRAME_FRAGMENT   (1UL << 0)  ///< Indicate frame fragment
N#define ARM_ETH_MAC_TX_FRAME_EVENT      (1UL << 1)  ///< Generate event when frame is transmitted
N#define ARM_ETH_MAC_TX_FRAME_TIMESTAMP  (1UL << 2)  ///< Capture frame time stamp
N
N
N/****** Ethernet MAC Timer Control Codes *****/
N#define ARM_ETH_MAC_TIMER_GET_TIME      (0x01UL)    ///< Get current time
N#define ARM_ETH_MAC_TIMER_SET_TIME      (0x02UL)    ///< Set new time
N#define ARM_ETH_MAC_TIMER_INC_TIME      (0x03UL)    ///< Increment current time
N#define ARM_ETH_MAC_TIMER_DEC_TIME      (0x04UL)    ///< Decrement current time
N#define ARM_ETH_MAC_TIMER_SET_ALARM     (0x05UL)    ///< Set alarm time
N#define ARM_ETH_MAC_TIMER_ADJUST_CLOCK  (0x06UL)    ///< Adjust clock frequency; time->ns: correction factor * 2^31
N
N
N/**
N\brief Ethernet MAC Time
N*/
Ntypedef struct _ARM_ETH_MAC_TIME {
N  uint32_t ns;                          ///< Nano seconds
N  uint32_t sec;                         ///< Seconds
N} ARM_ETH_MAC_TIME;
N
N
N/****** Ethernet MAC Event *****/
N#define ARM_ETH_MAC_EVENT_RX_FRAME      (1UL << 0)  ///< Frame Received
N#define ARM_ETH_MAC_EVENT_TX_FRAME      (1UL << 1)  ///< Frame Transmitted
N#define ARM_ETH_MAC_EVENT_WAKEUP        (1UL << 2)  ///< Wake-up (on Magic Packet)
N#define ARM_ETH_MAC_EVENT_TIMER_ALARM   (1UL << 3)  ///< Timer Alarm
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_ETH_MAC_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N*/
N/**
N  \fn          ARM_ETH_MAC_CAPABILITIES ARM_ETH_MAC_GetCapabilities (void)
N  \brief       Get driver capabilities.
N  \return      \ref ARM_ETH_MAC_CAPABILITIES
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Initialize (ARM_ETH_MAC_SignalEvent_t cb_event)
N  \brief       Initialize Ethernet MAC Device.
N  \param[in]   cb_event  Pointer to \ref ARM_ETH_MAC_SignalEvent
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Uninitialize (void)
N  \brief       De-initialize Ethernet MAC Device.
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PowerControl (ARM_POWER_STATE state)
N  \brief       Control Ethernet MAC Device Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetMacAddress (ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Get Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SetMacAddress (const ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Set Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SetAddressFilter (const ARM_ETH_MAC_ADDR *ptr_addr,
N                                                           uint32_t          num_addr)
N  \brief       Configure Address Filter.
N  \param[in]   ptr_addr  Pointer to addresses
N  \param[in]   num_addr  Number of addresses to configure
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags)
N  \brief       Send Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer with data to send
N  \param[in]   len    Frame buffer length in bytes
N  \param[in]   flags  Frame transmit flags (see ARM_ETH_MAC_TX_FRAME_...)
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_ReadFrame (uint8_t *frame, uint32_t len)
N  \brief       Read data of received Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer for data to read into
N  \param[in]   len    Frame buffer length in bytes
N  \return      number of data bytes read or execution status
N                 - value >= 0: number of data bytes read
N                 - value < 0: error occurred, value is execution status as defined with \ref execution_status 
N*/
N/**
N  \fn          uint32_t ARM_ETH_MAC_GetRxFrameSize (void)
N  \brief       Get size of received Ethernet frame.
N  \return      number of bytes in received frame
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetRxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of received Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetTxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of transmitted Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Control (uint32_t control, uint32_t arg)
N  \brief       Control Ethernet Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_ControlTimer (uint32_t control, ARM_ETH_MAC_TIME *time)
N  \brief       Control Precision Timer.
N  \param[in]   control  Operation
N  \param[in]   time     Pointer to time structure
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PHY_Read (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data)
N  \brief       Read Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[out]  data      Pointer where the result is written to
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PHY_Write (uint8_t phy_addr, uint8_t reg_addr, uint16_t data)
N  \brief       Write Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[in]   data      16-bit data to write
N  \return      \ref execution_status
N*/
N
N/**
N  \fn          void ARM_ETH_MAC_SignalEvent (uint32_t event)
N  \brief       Callback function that signals a Ethernet Event.
N  \param[in]   event  event notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_ETH_MAC_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_ETH_MAC_SignalEvent : Signal Ethernet Event.
N
N
N/**
N\brief Ethernet MAC Capabilities
N*/
Ntypedef struct _ARM_ETH_MAC_CAPABILITIES {
N  uint32_t checksum_offload_rx_ip4  : 1;        ///< 1 = IPv4 header checksum verified on receive
N  uint32_t checksum_offload_rx_ip6  : 1;        ///< 1 = IPv6 checksum verification supported on receive
N  uint32_t checksum_offload_rx_udp  : 1;        ///< 1 = UDP payload checksum verified on receive
N  uint32_t checksum_offload_rx_tcp  : 1;        ///< 1 = TCP payload checksum verified on receive
N  uint32_t checksum_offload_rx_icmp : 1;        ///< 1 = ICMP payload checksum verified on receive
N  uint32_t checksum_offload_tx_ip4  : 1;        ///< 1 = IPv4 header checksum generated on transmit
N  uint32_t checksum_offload_tx_ip6  : 1;        ///< 1 = IPv6 checksum generation supported on transmit
N  uint32_t checksum_offload_tx_udp  : 1;        ///< 1 = UDP payload checksum generated on transmit
N  uint32_t checksum_offload_tx_tcp  : 1;        ///< 1 = TCP payload checksum generated on transmit
N  uint32_t checksum_offload_tx_icmp : 1;        ///< 1 = ICMP payload checksum generated on transmit
N  uint32_t media_interface          : 2;        ///< Ethernet Media Interface type
N  uint32_t mac_address              : 1;        ///< 1 = driver provides initial valid MAC address
N  uint32_t event_rx_frame           : 1;        ///< 1 = callback event \ref ARM_ETH_MAC_EVENT_RX_FRAME generated
N  uint32_t event_tx_frame           : 1;        ///< 1 = callback event \ref ARM_ETH_MAC_EVENT_TX_FRAME generated
N  uint32_t event_wakeup             : 1;        ///< 1 = wakeup event \ref ARM_ETH_MAC_EVENT_WAKEUP generated
N  uint32_t precision_timer          : 1;        ///< 1 = Precision Timer supported
N  uint32_t reserved                 : 15;       ///< Reserved (must be zero)
N} ARM_ETH_MAC_CAPABILITIES;
N
N
N/**
N\brief Access structure of the Ethernet MAC Driver
N*/
Ntypedef struct _ARM_DRIVER_ETH_MAC {
N  ARM_DRIVER_VERSION       (*GetVersion)      (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetVersion : Get driver version.
N  ARM_ETH_MAC_CAPABILITIES (*GetCapabilities) (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetCapabilities : Get driver capabilities.
N  int32_t                  (*Initialize)      (ARM_ETH_MAC_SignalEvent_t cb_event);                  ///< Pointer to \ref ARM_ETH_MAC_Initialize : Initialize Ethernet MAC Device.
N  int32_t                  (*Uninitialize)    (void);                                                ///< Pointer to \ref ARM_ETH_MAC_Uninitialize : De-initialize Ethernet MAC Device.
N  int32_t                  (*PowerControl)    (ARM_POWER_STATE state);                               ///< Pointer to \ref ARM_ETH_MAC_PowerControl : Control Ethernet MAC Device Power.
N  int32_t                  (*GetMacAddress)   (      ARM_ETH_MAC_ADDR *ptr_addr);                    ///< Pointer to \ref ARM_ETH_MAC_GetMacAddress : Get Ethernet MAC Address.
N  int32_t                  (*SetMacAddress)   (const ARM_ETH_MAC_ADDR *ptr_addr);                    ///< Pointer to \ref ARM_ETH_MAC_SetMacAddress : Set Ethernet MAC Address.
N  int32_t                  (*SetAddressFilter)(const ARM_ETH_MAC_ADDR *ptr_addr, uint32_t num_addr); ///< Pointer to \ref ARM_ETH_MAC_SetAddressFilter : Configure Address Filter.
N  int32_t                  (*SendFrame)       (const uint8_t *frame, uint32_t len, uint32_t flags);  ///< Pointer to \ref ARM_ETH_MAC_SendFrame : Send Ethernet frame.
N  int32_t                  (*ReadFrame)       (      uint8_t *frame, uint32_t len);                  ///< Pointer to \ref ARM_ETH_MAC_ReadFrame : Read data of received Ethernet frame.
N  uint32_t                 (*GetRxFrameSize)  (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetRxFrameSize : Get size of received Ethernet frame.
N  int32_t                  (*GetRxFrameTime)  (ARM_ETH_MAC_TIME *time);                              ///< Pointer to \ref ARM_ETH_MAC_GetRxFrameTime : Get time of received Ethernet frame.
N  int32_t                  (*GetTxFrameTime)  (ARM_ETH_MAC_TIME *time);                              ///< Pointer to \ref ARM_ETH_MAC_GetTxFrameTime : Get time of transmitted Ethernet frame.
N  int32_t                  (*ControlTimer)    (uint32_t control, ARM_ETH_MAC_TIME *time);            ///< Pointer to \ref ARM_ETH_MAC_ControlTimer : Control Precision Timer.
N  int32_t                  (*Control)         (uint32_t control, uint32_t arg);                      ///< Pointer to \ref ARM_ETH_MAC_Control : Control Ethernet Interface.
N  int32_t                  (*PHY_Read)        (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data);  ///< Pointer to \ref ARM_ETH_MAC_PHY_Read : Read Ethernet PHY Register through Management Interface.
N  int32_t                  (*PHY_Write)       (uint8_t phy_addr, uint8_t reg_addr, uint16_t  data);  ///< Pointer to \ref ARM_ETH_MAC_PHY_Write : Write Ethernet PHY Register through Management Interface.
N} const ARM_DRIVER_ETH_MAC;
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* DRIVER_ETH_MAC_H_ */
L 38 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_config.h" 2
N  #include "Driver_ETH_PHY.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH_PHY.h" 1
N/*
N * Copyright (c) 2013-2020 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        24. January 2020
N * $Revision:    V2.2
N *
N * Project:      Ethernet PHY (Physical Transceiver) Driver definitions
N */
N
N/* History:
N *  Version 2.2
N *    Removed volatile from ARM_ETH_LINK_INFO
N *  Version 2.1
N *    ARM_ETH_LINK_INFO made volatile
N *  Version 2.0
N *    changed parameter "mode" in function ARM_ETH_PHY_SetMode
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Changed return values of some functions to int32_t
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_ETH_PHY_H_
N#define DRIVER_ETH_PHY_H_
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N#include "Driver_ETH.h"
N
N#define ARM_ETH_PHY_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,2)  /* API version */
N
N
N#define _ARM_Driver_ETH_PHY_(n)      Driver_ETH_PHY##n
N#define  ARM_Driver_ETH_PHY_(n) _ARM_Driver_ETH_PHY_(n)
N
N
N/****** Ethernet PHY Mode *****/
N#define ARM_ETH_PHY_SPEED_Pos            0
N#define ARM_ETH_PHY_SPEED_Msk           (3UL                 << ARM_ETH_PHY_SPEED_Pos)
N#define ARM_ETH_PHY_SPEED_10M           (ARM_ETH_SPEED_10M   << ARM_ETH_PHY_SPEED_Pos)  ///< 10 Mbps link speed
N#define ARM_ETH_PHY_SPEED_100M          (ARM_ETH_SPEED_100M  << ARM_ETH_PHY_SPEED_Pos)  ///< 100 Mbps link speed
N#define ARM_ETH_PHY_SPEED_1G            (ARM_ETH_SPEED_1G    << ARM_ETH_PHY_SPEED_Pos)  ///< 1 Gpbs link speed
N#define ARM_ETH_PHY_DUPLEX_Pos           2
N#define ARM_ETH_PHY_DUPLEX_Msk          (1UL                 << ARM_ETH_PHY_DUPLEX_Pos)
N#define ARM_ETH_PHY_DUPLEX_HALF         (ARM_ETH_DUPLEX_HALF << ARM_ETH_PHY_DUPLEX_Pos) ///< Half duplex link
N#define ARM_ETH_PHY_DUPLEX_FULL         (ARM_ETH_DUPLEX_FULL << ARM_ETH_PHY_DUPLEX_Pos) ///< Full duplex link
N#define ARM_ETH_PHY_AUTO_NEGOTIATE      (1UL << 3)                                      ///< Auto Negotiation mode
N#define ARM_ETH_PHY_LOOPBACK            (1UL << 4)                                      ///< Loop-back test mode
N#define ARM_ETH_PHY_ISOLATE             (1UL << 5)                                      ///< Isolate PHY from MII/RMII interface
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_ETH_PHY_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N*/
N/**
N  \fn          int32_t ARM_ETH_PHY_Initialize (ARM_ETH_PHY_Read_t  fn_read,
N                                               ARM_ETH_PHY_Write_t fn_write)
N  \brief       Initialize Ethernet PHY Device.
N  \param[in]   fn_read   Pointer to \ref ARM_ETH_MAC_PHY_Read
N  \param[in]   fn_write  Pointer to \ref ARM_ETH_MAC_PHY_Write
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_PHY_Uninitialize (void)
N  \brief       De-initialize Ethernet PHY Device.
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_PHY_PowerControl (ARM_POWER_STATE state)
N  \brief       Control Ethernet PHY Device Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_PHY_SetInterface (uint32_t interface)
N  \brief       Set Ethernet Media Interface.
N  \param[in]   interface  Media Interface type
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_PHY_SetMode (uint32_t mode)
N  \brief       Set Ethernet PHY Device Operation mode.
N  \param[in]   mode  Operation Mode
N  \return      \ref execution_status
N*/
N/**
N  \fn          ARM_ETH_LINK_STATE ARM_ETH_PHY_GetLinkState (void)
N  \brief       Get Ethernet PHY Device Link state.
N  \return      current link status \ref ARM_ETH_LINK_STATE
N*/
N/**
N  \fn          ARM_ETH_LINK_INFO ARM_ETH_PHY_GetLinkInfo (void)
N  \brief       Get Ethernet PHY Device Link information.
N  \return      current link parameters \ref ARM_ETH_LINK_INFO
N*/
N
N
Ntypedef int32_t (*ARM_ETH_PHY_Read_t)  (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data); ///< Pointer to \ref ARM_ETH_MAC_PHY_Read : Read Ethernet PHY Register.
Ntypedef int32_t (*ARM_ETH_PHY_Write_t) (uint8_t phy_addr, uint8_t reg_addr, uint16_t  data); ///< Pointer to \ref ARM_ETH_MAC_PHY_Write : Write Ethernet PHY Register.
N
N
N/**
N\brief Access structure of the Ethernet PHY Driver
N*/
Ntypedef struct _ARM_DRIVER_ETH_PHY {
N  ARM_DRIVER_VERSION (*GetVersion)   (void);                          ///< Pointer to \ref ARM_ETH_PHY_GetVersion : Get driver version.
N  int32_t            (*Initialize)   (ARM_ETH_PHY_Read_t  fn_read,
N                                      ARM_ETH_PHY_Write_t fn_write);  ///< Pointer to \ref ARM_ETH_PHY_Initialize : Initialize PHY Device.
N  int32_t            (*Uninitialize) (void);                          ///< Pointer to \ref ARM_ETH_PHY_Uninitialize : De-initialize PHY Device.
N  int32_t            (*PowerControl) (ARM_POWER_STATE state);         ///< Pointer to \ref ARM_ETH_PHY_PowerControl : Control PHY Device Power.
N  int32_t            (*SetInterface) (uint32_t interface);            ///< Pointer to \ref ARM_ETH_PHY_SetInterface : Set Ethernet Media Interface.
N  int32_t            (*SetMode)      (uint32_t mode);                 ///< Pointer to \ref ARM_ETH_PHY_SetMode : Set Ethernet PHY Device Operation mode.
N  ARM_ETH_LINK_STATE (*GetLinkState) (void);                          ///< Pointer to \ref ARM_ETH_PHY_GetLinkState : Get Ethernet PHY Device Link state.
N  ARM_ETH_LINK_INFO  (*GetLinkInfo)  (void);                          ///< Pointer to \ref ARM_ETH_PHY_GetLinkInfo : Get Ethernet PHY Device Link information.
N} const ARM_DRIVER_ETH_PHY;
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* DRIVER_ETH_PHY_H_ */
L 39 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_config.h" 2
N#endif
N
N#if (WIFI0_ENABLE || WIFI1_ENABLE)
S  #include "Driver_WiFi.h"
N#endif
N
N#if (PPP_ENABLE || SLIP_ENABLE)
S  #include "Driver_USART.h"
S  #include "net_modem.h"
N#endif
N
N#ifdef RTE_Network_Legacy
S  #include "rl_net_legacy.h"
N#endif
N
N/* Non-Critical configuration upgrade */
N#if (SMTP_CLIENT_ENABLE && !defined(SMTP_CLIENT_ATTACH_ENABLE))
X#if (SMTP_CLIENT_ENABLE && !0L)
S  #define SMTP_CLIENT_ATTACH_ENABLE 0
N#endif
N#if (HTTP_SERVER_ENABLE && !defined(HTTP_SERVER_AUTH_TYPE))
X#if (HTTP_SERVER_ENABLE && !0L)
S  #define HTTP_SERVER_AUTH_TYPE     0
N#endif
N#if (TELNET_SERVER_ENABLE && defined(TELNET_SERVER_NUM_SESSISONS))
X#if (TELNET_SERVER_ENABLE && 0L)
S  #define TELNET_SERVER_NUM_SESSIONS TELNET_SERVER_NUM_SESSISONS
N#endif
N
N/* Check configuration integrity */
N#if (!defined(NET_THREAD_STACK_SIZE))
X#if (!1L)
S  #error "::Network:CORE: Configuration update required"
N#endif
N
N#if (ETH0_ENABLE && !defined(ETH0_THREAD_STACK_SIZE))
X#if (1 && !1L)
S  #error "::Network:Interface:ETH0: Configuration update required"
N#endif
N
N#if (PPP_ENABLE && !defined(PPP_THREAD_STACK_SIZE))
X#if (PPP_ENABLE && !0L)
S  #error "::Network:Interface:PPP: Configuration update required"
N#endif
N
N#if (SLIP_ENABLE && !defined(SLIP_THREAD_STACK_SIZE))
X#if (SLIP_ENABLE && !0L)
S  #error "::Network:Interface:SLIP: Configuration update required"
N#endif
N
N#if (TCP_ENABLE && (TCP_MAX_SEG_SIZE > 1440))
X#if (1 && (1440 > 1440))
S  #error "::Network:Socket:TCP: Configuration update required"
N#endif
N
N#if (HTTP_SERVER_ENABLE && !defined(HTTP_SERVER_AUTH_ADMIN))
X#if (HTTP_SERVER_ENABLE && !0L)
S  #error "::Network:Service:HTTP Server: Configuration update required"
N#endif
N
N#if (FTP_SERVER_ENABLE && !defined(FTP_SERVER_AUTH_ADMIN))
X#if (FTP_SERVER_ENABLE && !0L)
S  #error "::Network:Service:FTP Server: Configuration update required"
N#endif
N
N#if (TELNET_SERVER_ENABLE && !defined(TELNET_SERVER_AUTH_ADMIN))
X#if (TELNET_SERVER_ENABLE && !0L)
S  #error "::Network:Service:Telnet Server: Configuration update required"
N#endif
N
N#if (TFTP_SERVER_ENABLE && !defined(TFTP_SERVER_ROOT_ENABLE))
X#if (TFTP_SERVER_ENABLE && !0L)
S  #error "::Network:Service:TFTP Server: Configuration update required"
N#endif
N
N#if (SNTP_CLIENT_ENABLE && !defined(SNTP_CLIENT_NTP_SERVER))
X#if (SNTP_CLIENT_ENABLE && !0L)
S  #error "::Network:Service:SNTP Client: Configuration update required"
N#endif
N
N#if (SNMP_AGENT_ENABLE && !defined(SNMP_AGENT_TRAP_IP))
X#if (SNMP_AGENT_ENABLE && !0L)
S  #error "::Network:Service:SNMP Agent: Configuration update required"
N#endif
N
N/* Check interfaces and protocols */
N#ifndef RTE_Network_IPv6
N  #undef ETH0_IP6_ENABLE
N  #undef ETH0_DHCP6_ENABLE
N  #undef ETH1_IP6_ENABLE
N  #undef ETH1_DHCP6_ENABLE
N  #undef WIFI0_IP6_ENABLE
N  #undef WIFI0_DHCP6_ENABLE
N  #undef WIFI1_IP6_ENABLE
N  #undef WIFI1_DHCP6_ENABLE
N#endif
N
N#if (!ETH0_IP4_ENABLE)
X#if (!1)
S  #undef ETH0_IP4_FRAG_ENABLE
S  #undef ETH0_IGMP_ENABLE
S  #undef ETH0_NBNS_ENABLE
S  #undef ETH0_DHCP_ENABLE
N#endif
N#if (!ETH1_IP4_ENABLE)
N  #undef ETH1_IP4_FRAG_ENABLE
N  #undef ETH1_IGMP_ENABLE
N  #undef ETH1_NBNS_ENABLE
N  #undef ETH1_DHCP_ENABLE
N#endif
N#if (!WIFI0_IP4_ENABLE)
N  #undef WIFI0_IP4_FRAG_ENABLE
N  #undef WIFI0_IGMP_ENABLE
N  #undef WIFI0_NBNS_ENABLE
N  #undef WIFI0_DHCP_ENABLE
N#endif
N#if (!WIFI1_IP4_ENABLE)
N  #undef WIFI1_IP4_FRAG_ENABLE
N  #undef WIFI1_IGMP_ENABLE
N  #undef WIFI1_NBNS_ENABLE
N  #undef WIFI1_DHCP_ENABLE
N#endif
N
N#if (!ETH0_IP6_ENABLE)
N  #undef ETH0_DHCP6_ENABLE
N#endif
N#if (!ETH1_IP6_ENABLE)
N  #undef ETH1_DHCP6_ENABLE
N#endif
N#if (!WIFI0_IP6_ENABLE)
N  #undef WIFI0_DHCP6_ENABLE
N#endif
N#if (!WIFI1_IP6_ENABLE)
N  #undef WIFI1_DHCP6_ENABLE
N#endif
N
N/* IP version usage definitions */
N#define __IP4_ENA   (ETH0_IP4_ENABLE   + ETH1_IP4_ENABLE   + \
N                     WIFI0_IP4_ENABLE  + WIFI1_IP4_ENABLE  + \
N                     PPP_ENABLE        + SLIP_ENABLE)
X#define __IP4_ENA   (ETH0_IP4_ENABLE   + ETH1_IP4_ENABLE   +                      WIFI0_IP4_ENABLE  + WIFI1_IP4_ENABLE  +                      PPP_ENABLE        + SLIP_ENABLE)
N
N#define __IP6_ENA   (ETH0_IP6_ENABLE   + ETH1_IP6_ENABLE   + \
N                     WIFI0_IP6_ENABLE  + WIFI1_IP6_ENABLE)
X#define __IP6_ENA   (ETH0_IP6_ENABLE   + ETH1_IP6_ENABLE   +                      WIFI0_IP6_ENABLE  + WIFI1_IP6_ENABLE)
N
N/* Ethernet usage definitions */
N#define __ETH_ENA   (ETH0_ENABLE       + ETH1_ENABLE)
N#define __WIFI_ENA  (WIFI0_ENABLE      + WIFI1_ENABLE)
N
N/* Interface protocol usage definitions */
N#define __ARP_ENA   (ETH0_IP4_ENABLE   + ETH1_IP4_ENABLE   + \
N                     WIFI0_IP4_ENABLE  + WIFI1_IP4_ENABLE)
X#define __ARP_ENA   (ETH0_IP4_ENABLE   + ETH1_IP4_ENABLE   +                      WIFI0_IP4_ENABLE  + WIFI1_IP4_ENABLE)
N
N#define __IGMP_ENA  (ETH0_IGMP_ENABLE  + ETH1_IGMP_ENABLE  + \
N                     WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE)
X#define __IGMP_ENA  (ETH0_IGMP_ENABLE  + ETH1_IGMP_ENABLE  +                      WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE)
N
N#define __NBNS_ENA  (ETH0_NBNS_ENABLE  + ETH1_NBNS_ENABLE  + \
N                     WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE)
X#define __NBNS_ENA  (ETH0_NBNS_ENABLE  + ETH1_NBNS_ENABLE  +                      WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE)
N
N#define __DHCP_ENA  (ETH0_DHCP_ENABLE  + ETH1_DHCP_ENABLE  + \
N                     WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE)
X#define __DHCP_ENA  (ETH0_DHCP_ENABLE  + ETH1_DHCP_ENABLE  +                      WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE)
N
N#define __NDP_ENA   (ETH0_IP6_ENABLE   + ETH1_IP6_ENABLE   + \
N                     WIFI0_IP6_ENABLE  + WIFI1_IP6_ENABLE)
X#define __NDP_ENA   (ETH0_IP6_ENABLE   + ETH1_IP6_ENABLE   +                      WIFI0_IP6_ENABLE  + WIFI1_IP6_ENABLE)
N
N#define __DHCP6_ENA (ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + \
N                     WIFI0_DHCP6_ENABLE+ WIFI1_DHCP6_ENABLE)
X#define __DHCP6_ENA (ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE +                      WIFI0_DHCP6_ENABLE+ WIFI1_DHCP6_ENABLE)
N
N/* IPv4 fragmentation usage definitions */
N#define __IP4_FRAG_ENA (                                             \
N                     ETH0_IP4_FRAG_ENABLE  + ETH1_IP4_FRAG_ENABLE  + \
N                     WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + \
N                     PPP_IP4_FRAG_ENABLE   + SLIP_IP4_FRAG_ENABLE)
X#define __IP4_FRAG_ENA (                                                                  ETH0_IP4_FRAG_ENABLE  + ETH1_IP4_FRAG_ENABLE  +                      WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE +                      PPP_IP4_FRAG_ENABLE   + SLIP_IP4_FRAG_ENABLE)
N
N/* Check enabled interfaces */
N#if !(__ETH_ENA || __WIFI_ENA || PPP_ENABLE || SLIP_ENABLE)
X#if !((1 + ETH1_ENABLE) || (WIFI0_ENABLE + WIFI1_ENABLE) || PPP_ENABLE || SLIP_ENABLE)
S  #error "::Network:Interface: No interface enabled in configuration"
N#endif
N
N/* Check interface drivers */
N#if (ETH1_ENABLE && ETH0_ENABLE && (ETH1_DRIVER == ETH0_DRIVER))
X#if (ETH1_ENABLE && 1 && (ETH1_DRIVER == 0))
S  #error "::Network:Interface:ETH1: Driver conflict with ETH0 interface"
N#endif
N
N#if (WIFI1_ENABLE && WIFI0_ENABLE && (WIFI1_DRIVER == WIFI0_DRIVER))
S  #error "::Network:Interface:WIFI1: Driver conflict with WIFI0 interface"
N#endif
N
N#if (SLIP_ENABLE && PPP_ENABLE && (SLIP_USART_DRIVER == PPP_USART_DRIVER))
S  #error "::Network:Interface:SLIP: Driver conflict with PPP interface"
N#endif
N
N
N/* Check ETH enabled protocols */
N#if (ETH0_ENABLE && !(ETH0_IP4_ENABLE || ETH0_IP6_ENABLE))
X#if (1 && !(1 || ETH0_IP6_ENABLE))
S  #error "::Network:Interface:ETH0: IP protocol not enabled"
N#endif
N
N#if (ETH1_ENABLE && !(ETH1_IP4_ENABLE || ETH1_IP6_ENABLE))
S  #error "::Network:Interface:ETH1: IP protocol not enabled"
N#endif
N
N/* Check WIFI enabled protocols */
N#if (WIFI0_ENABLE && !(WIFI0_IP4_ENABLE || WIFI0_IP6_ENABLE))
S  #error "::Network:Interface:WiFi0: IP protocol not enabled"
N#endif
N
N#if (WIFI1_ENABLE && !(WIFI1_IP4_ENABLE || WIFI1_IP6_ENABLE))
S  #error "::Network:Interface:WiFi1: IP protocol not enabled"
N#endif
N
N/* Check TCP socket configuration */
N#define __TCPNS    ((BSD_ENABLE           * BSD_NUM_SOCKS)               + \
N                    (HTTP_SERVER_ENABLE   * HTTP_SERVER_NUM_SESSIONS)    + \
N                    (TELNET_SERVER_ENABLE * TELNET_SERVER_NUM_SESSIONS)  + \
N                    (FTP_SERVER_ENABLE    * FTP_SERVER_NUM_SESSIONS * 2) + \
N                    (FTP_CLIENT_ENABLE    * 2)                           + \
N                    (SMTP_CLIENT_ENABLE   * 1))
X#define __TCPNS    ((BSD_ENABLE           * BSD_NUM_SOCKS)               +                     (HTTP_SERVER_ENABLE   * HTTP_SERVER_NUM_SESSIONS)    +                     (TELNET_SERVER_ENABLE * TELNET_SERVER_NUM_SESSIONS)  +                     (FTP_SERVER_ENABLE    * FTP_SERVER_NUM_SESSIONS * 2) +                     (FTP_CLIENT_ENABLE    * 2)                           +                     (SMTP_CLIENT_ENABLE   * 1))
N
N#if (__TCPNS > 0 && !TCP_ENABLE)
X#if (((BSD_ENABLE * BSD_NUM_SOCKS) + (HTTP_SERVER_ENABLE * HTTP_SERVER_NUM_SESSIONS) + (TELNET_SERVER_ENABLE * TELNET_SERVER_NUM_SESSIONS) + (FTP_SERVER_ENABLE * FTP_SERVER_NUM_SESSIONS * 2) + (FTP_CLIENT_ENABLE * 2) + (SMTP_CLIENT_ENABLE * 1)) > 0 && !1)
S  #error "::Network:Socket:TCP component required"
S#elif (__TCPNS > TCP_NUM_SOCKS)
X#elif (((BSD_ENABLE * BSD_NUM_SOCKS) + (HTTP_SERVER_ENABLE * HTTP_SERVER_NUM_SESSIONS) + (TELNET_SERVER_ENABLE * TELNET_SERVER_NUM_SESSIONS) + (FTP_SERVER_ENABLE * FTP_SERVER_NUM_SESSIONS * 2) + (FTP_CLIENT_ENABLE * 2) + (SMTP_CLIENT_ENABLE * 1)) > 6)
S  #error "::Network:Socket:TCP: Number of TCP Sockets too small"
N#endif
N
N/* Calculate number of UDP sockets required for TFTP server */
N#if (TFTP_SERVER_FIREWALL_ENABLE)
S  #define __TFTPNS  1
N#else
N  #define __TFTPNS (1 + TFTP_SERVER_NUM_SESSIONS)
N#endif
N
N/* Check UDP socket configuration */
N#define __UDPNS    ((BSD_ENABLE         * BSD_NUM_SOCKS) + \
N                    (TFTP_SERVER_ENABLE * __TFTPNS)      + \
N                    (TFTP_CLIENT_ENABLE * 1)             + \
N                    (DNS_CLIENT_ENABLE  * 1)             + \
N                    (SNMP_AGENT_ENABLE  * 1)             + \
N                    (SNTP_CLIENT_ENABLE * 1)             + \
N                    (__DHCP_ENA  ?    1 : 0)             + \
N                    (__NBNS_ENA  ?    1 : 0)             + \
N                    (__DHCP6_ENA ?    1 : 0))
X#define __UDPNS    ((BSD_ENABLE         * BSD_NUM_SOCKS) +                     (TFTP_SERVER_ENABLE * __TFTPNS)      +                     (TFTP_CLIENT_ENABLE * 1)             +                     (DNS_CLIENT_ENABLE  * 1)             +                     (SNMP_AGENT_ENABLE  * 1)             +                     (SNTP_CLIENT_ENABLE * 1)             +                     (__DHCP_ENA  ?    1 : 0)             +                     (__NBNS_ENA  ?    1 : 0)             +                     (__DHCP6_ENA ?    1 : 0))
N
N#if (__UDPNS > 0 && !UDP_ENABLE)
X#if (((BSD_ENABLE * BSD_NUM_SOCKS) + (TFTP_SERVER_ENABLE * (1 + TFTP_SERVER_NUM_SESSIONS)) + (TFTP_CLIENT_ENABLE * 1) + (DNS_CLIENT_ENABLE * 1) + (SNMP_AGENT_ENABLE * 1) + (SNTP_CLIENT_ENABLE * 1) + ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE) ? 1 : 0) + ((0 + ETH1_NBNS_ENABLE + WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE) ? 1 : 0) + ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE) ? 1 : 0)) > 0 && !UDP_ENABLE)
S  #error "::Network:Socket:UDP component required"
S#elif (__UDPNS > UDP_NUM_SOCKS)
X#elif (((BSD_ENABLE * BSD_NUM_SOCKS) + (TFTP_SERVER_ENABLE * (1 + TFTP_SERVER_NUM_SESSIONS)) + (TFTP_CLIENT_ENABLE * 1) + (DNS_CLIENT_ENABLE * 1) + (SNMP_AGENT_ENABLE * 1) + (SNTP_CLIENT_ENABLE * 1) + ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE) ? 1 : 0) + ((0 + ETH1_NBNS_ENABLE + WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE) ? 1 : 0) + ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE) ? 1 : 0)) > UDP_NUM_SOCKS)
S  #error "::Network:Socket:UDP: Number of UDP Sockets too small"
N#endif
N
N/* Check Maximum Segment Size of TCP Socket */
N#if (TCP_ENABLE && ((TCP_MAX_SEG_SIZE < 536) || (TCP_MAX_SEG_SIZE > 1440)))
X#if (1 && ((1440 < 536) || (1440 > 1440)))
S  #error "::Network:Socket:TCP: Maximum Segment Size out of range"
N#endif
N
N/* Check Receive Window Size of TCP Socket */
N#if (TCP_ENABLE && (TCP_RECEIVE_WIN_SIZE < TCP_MAX_SEG_SIZE))
X#if (1 && (4320 < 1440))
S  #error "::Network:Socket:TCP: Receive Window Size too small"
N#endif
N
N/* Check BSD Server sockets */
N#if (BSD_ENABLE && (BSD_SERVER_SOCKS > BSD_NUM_SOCKS))
S  #error "::Network:Socket:BSD: Number of BSD Server sockets too large"
N#endif
N
N/* Check BSD Hostname resolver */
N#if (BSD_ENABLE && BSD_HOSTNAME_ENABLE && !DNS_CLIENT_ENABLE)
S  #error "::Network:Socket:BSD: DNS Client service required"
N#endif
N
N/* Check PPP Authentication protocols */
N#if (PPP_ENABLE && PPP_AUTH_ENABLE && !(PPP_PAP_ENABLE || PPP_CHAP_ENABLE))
S  #error "::Network:Interface:PPP: Authentication needs PAP or/and CHAP enabled"
N#endif
N
N/* Check Block Size of TFTP Client */
N#if (TFTP_CLIENT_ENABLE && ((TFTP_CLIENT_BLOCK_SIZE < 128) || (TFTP_CLIENT_BLOCK_SIZE > 1428)))
S  #error "::Network:Service:TFTP Client: Block Size out of range"
N#endif
N
N/* Check SMTP client attachments */
N#if (SMTP_CLIENT_ENABLE && SMTP_CLIENT_ATTACH_ENABLE && !defined(RTE_FileSystem_Core))
X#if (SMTP_CLIENT_ENABLE && SMTP_CLIENT_ATTACH_ENABLE && !1L)
S  #error "::Network:Service:SMTP Client: File System component required"
N#endif
N
N/* Check SMTP advanced client */
N#if (SMTP_CLIENT_ENABLE && SMTP_CLIENT_ATTACH_ENABLE && !DNS_CLIENT_ENABLE)
S  #error "::Network:Service:SMTP Client: DNS Client service required"
N#endif
N
N/* Avoid syntax-checker errors in editor */
N#ifndef NET_HOST_NAME
S  #define NET_HOST_NAME         "my_host"
S  #define NET_MEM_POOL_SIZE     8000
S  #define NET_START_SERVICE     1
N#endif
N
N#ifndef NET_MEM_POOL_SIZE
S  #define NET_MEM_POOL_SIZE     (NET_MEM_SIZE*4)
N#endif
N
N/* Tick interval is 100 ms */
N#define NET_TICK_RATE       10
N#define STRLEN(str)         sizeof(str)-1
N#define MAX_DELAY(speed)    ((2000000/speed) < 25 ? (2000000/speed) : 25)
N#define MAX_TOUT(speed)     ((speed < 10000) ? 5 : 1)
N
N#define EXPAND_SYMBOL(name, port) name##port
N#define CREATE_SYMBOL(name, port) EXPAND_SYMBOL(name, port)
N
N/* System configuration */
Nstatic uint32_t mem_pool [NET_MEM_POOL_SIZE/4];
Xstatic uint32_t mem_pool [12000/4];
N
N#if ((HTTP_SERVER_ENABLE && HTTP_SERVER_ROOT_ENABLE) || \
N     (FTP_SERVER_ENABLE  && FTP_SERVER_ROOT_ENABLE ) || \
N     (TFTP_SERVER_ENABLE && TFTP_SERVER_ROOT_ENABLE))
X#if ((HTTP_SERVER_ENABLE && HTTP_SERVER_ROOT_ENABLE) ||      (FTP_SERVER_ENABLE  && FTP_SERVER_ROOT_ENABLE ) ||      (TFTP_SERVER_ENABLE && TFTP_SERVER_ROOT_ENABLE))
S  /* Buffer for services with root folder enabled */
S  static char root_path [NET_ROOT_PATH_SIZE];
N#else
N  #define root_path      NULL
N#endif
N
N/* Forward declarations */
Nstatic const net_sys_fn_t sys_fn_init[];
Nstatic const net_sys_fn_t sys_fn_run[];
N
NNET_SYS_CFG net_sys_config = {
N  mem_pool,
N  sizeof (mem_pool),
N  root_path,
X  0,
N  NET_HOST_NAME,
X  "my_host",
N  NET_START_SERVICE,
X  1,
N #if (PPP_ENABLE || SLIP_ENABLE)
S  1,
N #else
N  0,
N #endif
N  sys_fn_init,
N  sys_fn_run
N};
N
N/* mbedTLS interface configuration */
N#if defined(RTE_Network_Web_Server_RO_TLS) || \
N    defined(RTE_Network_Web_Server_FS_TLS) || \
N    defined(RTE_Network_SMTP_Client_TLS)
X#if 0L ||     0L ||     0L
S  /* mbedTLS interface functions */
S  static NET_TLS_IF tls_if_func = {
S    netTLS_GetContext,
S    netTLS_Connect,
S    netTLS_Listen,
S    netTLS_GetBuffer,
S    netTLS_Write,
S    netTLS_Close
S  };
S  #define __TLS_USED        1
N#else
N  #define __TLS_USED        0
N#endif
N
N#if (ETH0_IP4_ENABLE)
X#if (1)
N  /* ETH0: ARP configuration */
N  extern struct net_arp_ctrl net_eth0_arp_control;
N  static NET_ARP_INFO eth0_arp_table[ETH0_ARP_TAB_SIZE];
X  static NET_ARP_INFO eth0_arp_table[10];
N  static NET_ARP_CFG  eth0_arp_config = {
N    &net_eth0_arp_control,
N    &net_eth0_if_config,
N    eth0_arp_table,
N    ETH0_ARP_TAB_SIZE,
X    10,
N    ETH0_ARP_CACHE_TOUT,
X    150,
N    ETH0_ARP_MAX_RETRY,
X    4,
N    ETH0_ARP_RESEND_TOUT * NET_TICK_RATE,
X    2 * 10,
N    ETH0_ARP_NOTIFY
X    0
N  };
N
N  /* ETH0: IGMP configuration */
N #if (ETH0_IGMP_ENABLE)
X #if (0)
S  extern struct net_igmp_ctrl net_eth0_igmp_control;
S  static NET_IGMP_INFO eth0_igmp_table[ETH0_IGMP_TAB_SIZE];
S  static NET_IGMP_CFG  eth0_igmp_config = {  
S    &net_eth0_igmp_control,
S    &net_eth0_if_config,
S    eth0_igmp_table,
S    ETH0_IGMP_TAB_SIZE
S  };
N #endif
N
N  /* ETH0: DHCP configuration */
N #if (ETH0_DHCP_ENABLE)
X #if (0)
S  extern struct net_dhcp_ctrl net_eth0_dhcp_control;
S  static NET_DHCP_CFG eth0_dhcp_config = {
S    &net_eth0_dhcp_control,
S    &net_eth0_if_config,
S    ETH0_DHCP_VCID,
S    STRLEN(ETH0_DHCP_VCID),
S    ETH0_DHCP_BOOTFILE,
S    ETH0_DHCP_NTP_SERVERS
S  };
N #endif
N
N  /* ETH0: IPv4 configuration */
N  static NET_LOCALM eth0_localm __attribute__((aligned(4)));
N  static NET_IP4_CFG eth0_ip4_config = {
N    ETH0_IP4_ADDR,
X    "192.168.88.20",
N    ETH0_IP4_MASK,
X    "255.255.255.0",
N    ETH0_IP4_GATEWAY,
X    "192.168.88.1",
N    ETH0_IP4_PRIMARY_DNS,
X    "192.168.88.1",
N    ETH0_IP4_SECONDARY_DNS,
X    "8.8.8.8",
N  #if (ETH0_IP4_FRAG_ENABLE)
X  #if (1)
N    ETH0_IP4_MTU,
X    1500,
N  #else
S    0,
N  #endif
N  #if (ETH0_ICMP_NO_ECHO)
X  #if (0)
S    1,
N  #else
N    0,
N  #endif
N    ETH0_NBNS_ENABLE,
X    0,
N    &eth0_arp_config,
N  #if (ETH0_IGMP_ENABLE)
X  #if (0)
S    &eth0_igmp_config,
N  #else
N    NULL,
X    0,
N  #endif
N  #if (ETH0_DHCP_ENABLE)
X  #if (0)
S    &eth0_dhcp_config
N  #else
N    NULL
X    0
N  #endif
N  };
N#endif
N
N#if (ETH0_IP6_ENABLE)
S  /* ETH0: NDP configuration */
S  extern struct net_ndp_ctrl net_eth0_ndp_control;
S  static NET_NDP_INFO eth0_ndp_table[ETH0_NDP_TAB_SIZE];
S  static NET_NDP_CFG  eth0_ndp_config = {
S    &net_eth0_ndp_control,
S    &net_eth0_if_config,
S    eth0_ndp_table,
S    ETH0_NDP_TAB_SIZE,
S    ETH0_NDP_CACHE_TOUT,
S    ETH0_NDP_MAX_RETRY,
S    ETH0_NDP_RESEND_TOUT * NET_TICK_RATE
S  };
S
S  /* ETH0: DHCPv6 configuration */
S #if (ETH0_DHCP6_ENABLE)
S  extern struct net_dhcp6_ctrl net_eth0_dhcp6_control;
S  static NET_DHCP6_CFG eth0_dhcp6_config = {
S    &net_eth0_dhcp6_control,
S    &net_eth0_if_config,
S    ETH0_DHCP6_MODE,
S    ETH0_DHCP6_VCLASS_ENABLE,
S    ETH0_DHCP6_VCLASS_ENABLE ? ETH0_DHCP6_VCLASS_EID  : 0,
S    ETH0_DHCP6_VCLASS_ENABLE ? ETH0_DHCP6_VCLASS_DATA : NULL
S  };
S #endif
S
S  /* ETH0: IPv6 configuration */
S  static NET_LOCALM6 eth0_localm6 __attribute__((aligned(4)));
S  static NET_IP6_CFG eth0_ip6_config = {
S    ETH0_IP6_ADDR,
S    ETH0_IP6_GATEWAY,
S    ETH0_IP6_PRIMARY_DNS,
S    ETH0_IP6_SECONDARY_DNS,
S    ETH0_IP6_PREFIX_LEN,
S  #if (ETH0_ICMP6_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    &eth0_ndp_config,
S  #if (ETH0_DHCP6_ENABLE)
S    &eth0_dhcp6_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (ETH0_ENABLE)
X#if (1)
N  static uint8_t eth0_mac_addr[];
N
N  /* ETH0: Interface configuration */
N  static NET_IF_STATE eth0_state;
N  NET_IF_CFG net_eth0_if_config = {
N    &eth0_state,
N    NET_IF_CLASS_ETH+0,
X    (1U << 8)+0,
N    "ETH0",
N    eth0_mac_addr,
N   #if (ETH0_IP4_ENABLE)
X   #if (1)
N    &eth0_localm,
N    &eth0_ip4_config,
N   #else
S    NULL, NULL,
N   #endif
N   #if (ETH0_IP6_ENABLE)
S    &eth0_localm6,
S    &eth0_ip6_config,
N   #else
N    NULL, NULL,
X    0, 0,
N   #endif
N    net_eth_send_frame,
N    net_eth_config_mcast,
N    net_eth_output
N  };
N
N  /* ETH0: low layer configuration */
N  extern ARM_DRIVER_ETH_MAC ARM_Driver_ETH_MAC_(ETH0_DRIVER);
X  extern ARM_DRIVER_ETH_MAC Driver_ETH_MAC0;
N  extern ARM_DRIVER_ETH_PHY ARM_Driver_ETH_PHY_(ETH0_DRIVER);
X  extern ARM_DRIVER_ETH_PHY Driver_ETH_PHY0;
N  extern struct net_eth_ctrl net_eth0_if_control;
N  static uint8_t eth0_mac_addr[NET_ADDR_ETH_LEN];
X  static uint8_t eth0_mac_addr[6];
N  static void eth0_callback (uint32_t event) {
N    net_eth_callback (event, &net_eth0_if_control);
N  }  
N  static NET_ETH_CFG eth0_ll_config = {
N    &net_eth0_if_control,
N    &net_eth0_if_config,
N    &ARM_Driver_ETH_MAC_(ETH0_DRIVER),
X    &Driver_ETH_MAC0,
N    &ARM_Driver_ETH_PHY_(ETH0_DRIVER),
X    &Driver_ETH_PHY0,
N    eth0_mac_addr,
N    ETH0_MAC_ADDR,
X    "1E-30-6C-A2-45-5E",
N  #if (ETH0_VLAN_ENABLE)
X  #if (0)
S    ETH0_VLAN_ID,
N  #else
N    0,
N  #endif
N    0,
N    eth0_callback
N  };
N#endif
N
N#if (ETH1_IP4_ENABLE)
S  /* ETH1: ARP configuration */
S  extern struct net_arp_ctrl net_eth1_arp_control;
S  static NET_ARP_INFO eth1_arp_table[ETH1_ARP_TAB_SIZE];
S  static NET_ARP_CFG  eth1_arp_config = {
S    &net_eth1_arp_control,
S    &net_eth1_if_config,
S    eth1_arp_table,
S    ETH1_ARP_TAB_SIZE,
S    ETH1_ARP_CACHE_TOUT,
S    ETH1_ARP_MAX_RETRY,
S    ETH1_ARP_RESEND_TOUT * NET_TICK_RATE,
S    ETH1_ARP_NOTIFY
S  };
S
S  /* ETH1: IGMP configuration */
S #if (ETH1_IGMP_ENABLE)
S  extern struct net_igmp_ctrl net_eth1_igmp_control;
S  static NET_IGMP_INFO eth1_igmp_table[ETH1_IGMP_TAB_SIZE];
S  static NET_IGMP_CFG  eth1_igmp_config = {
S    &net_eth1_igmp_control,
S    &net_eth1_if_config,
S    eth1_igmp_table,
S    ETH1_IGMP_TAB_SIZE
S  };
S #endif
S
S  /* ETH1: DHCP configuration */
S #if (ETH1_DHCP_ENABLE)
S  extern struct net_dhcp_ctrl net_eth1_dhcp_control;
S  static NET_DHCP_CFG eth1_dhcp_config = {
S    &net_eth1_dhcp_control,
S    &net_eth1_if_config,
S    ETH1_DHCP_VCID,
S    STRLEN(ETH1_DHCP_VCID),
S    ETH1_DHCP_BOOTFILE,
S    ETH1_DHCP_NTP_SERVERS
S  };
S #endif
S
S  /* ETH1: IPv4 configuration */
S  static NET_LOCALM eth1_localm __attribute__((aligned(4)));
S  static NET_IP4_CFG eth1_ip4_config = {
S    ETH1_IP4_ADDR,
S    ETH1_IP4_MASK,
S    ETH1_IP4_GATEWAY,
S    ETH1_IP4_PRIMARY_DNS,
S    ETH1_IP4_SECONDARY_DNS,
S    ETH1_IP4_FRAG_ENABLE ? ETH1_IP4_MTU : 0,
S  #if (ETH1_ICMP_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    ETH1_NBNS_ENABLE,
S    &eth1_arp_config,
S  #if (ETH1_IGMP_ENABLE)
S    &eth1_igmp_config,
S  #else
S    NULL,
S  #endif
S  #if (ETH1_DHCP_ENABLE)
S    &eth1_dhcp_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (ETH1_IP6_ENABLE)
S  /* ETH1: NDP configuration */
S  extern struct net_ndp_ctrl net_eth1_ndp_control;
S  static NET_NDP_INFO eth1_ndp_table[ETH1_NDP_TAB_SIZE];
S  static NET_NDP_CFG  eth1_ndp_config = {
S    &net_eth1_ndp_control,
S    &net_eth1_if_config,
S    eth1_ndp_table,
S    ETH1_NDP_TAB_SIZE,
S    ETH1_NDP_CACHE_TOUT,
S    ETH1_NDP_MAX_RETRY,
S    ETH1_NDP_RESEND_TOUT * NET_TICK_RATE
S  };
S
S  /* ETH1: DHCPv6 configuration */
S #if (ETH1_DHCP6_ENABLE)
S  extern struct net_dhcp6_ctrl net_eth1_dhcp6_control;
S  static NET_DHCP6_CFG eth1_dhcp6_config = {
S    &net_eth1_dhcp6_control,
S    &net_eth1_if_config,
S    ETH1_DHCP6_MODE,
S    ETH1_DHCP6_VCLASS_ENABLE,
S    ETH1_DHCP6_VCLASS_ENABLE ? ETH1_DHCP6_VCLASS_EID  : 0,
S    ETH1_DHCP6_VCLASS_ENABLE ? ETH1_DHCP6_VCLASS_DATA : NULL
S  };
S #endif
S
S  /* ETH1: IPv6 configuration */
S  static NET_LOCALM6 eth1_localm6 __attribute__((aligned(4)));
S  static NET_IP6_CFG eth1_ip6_config = {
S    ETH1_IP6_ADDR,
S    ETH1_IP6_GATEWAY,
S    ETH1_IP6_PRIMARY_DNS,
S    ETH1_IP6_SECONDARY_DNS,
S    ETH1_IP6_PREFIX_LEN,
S  #if (ETH1_ICMP6_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    &eth1_ndp_config,
S  #if (ETH1_DHCP6_ENABLE)
S    &eth1_dhcp6_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (ETH1_ENABLE)
S  static uint8_t eth1_mac_addr[];
S
S  /* ETH1: Interface configuration */
S  static NET_IF_STATE eth1_state;
S  NET_IF_CFG net_eth1_if_config = {
S    &eth1_state,
S    NET_IF_CLASS_ETH+1,
S    "ETH1",
S    eth1_mac_addr,
S   #if (ETH1_IP4_ENABLE)
S    &eth1_localm,
S    &eth1_ip4_config,
S   #else
S    NULL, NULL,
S   #endif
S   #if (ETH1_IP6_ENABLE)
S    &eth1_localm6,
S    &eth1_ip6_config,
S   #else
S    NULL, NULL,
S   #endif
S    net_eth_send_frame,
S    net_eth_config_mcast,
S    net_eth_output
S  };
S
S  /* ETH1: low layer configuration */
S  extern ARM_DRIVER_ETH_MAC ARM_Driver_ETH_MAC_(ETH1_DRIVER);
S  extern ARM_DRIVER_ETH_PHY ARM_Driver_ETH_PHY_(ETH1_DRIVER);
S  extern struct net_eth_ctrl net_eth1_if_control;
S  static uint8_t eth1_mac_addr[NET_ADDR_ETH_LEN];
S  static void eth1_callback (uint32_t event) {
S    net_eth_callback (event, &net_eth1_if_control);
S  }  
S  static NET_ETH_CFG eth1_ll_config = {
S    &net_eth1_if_control,
S    &net_eth1_if_config,
S    &ARM_Driver_ETH_MAC_(ETH1_DRIVER),
S    &ARM_Driver_ETH_PHY_(ETH1_DRIVER),
S    eth1_mac_addr,
S    ETH1_MAC_ADDR,
S    ETH1_VLAN_ID * ETH1_VLAN_ENABLE,
S    1,
S    eth1_callback
S  };
N#endif
N
N#if (WIFI0_IP4_ENABLE)
S  /* WIFI0: ARP configuration */
S  extern struct net_arp_ctrl net_wifi0_arp_control;
S  static NET_ARP_INFO wifi0_arp_table[WIFI0_ARP_TAB_SIZE];
S  static NET_ARP_CFG  wifi0_arp_config = {
S    &net_wifi0_arp_control,
S    &net_wifi0_if_config,
S    wifi0_arp_table,
S    WIFI0_ARP_TAB_SIZE,
S    WIFI0_ARP_CACHE_TOUT,
S    WIFI0_ARP_MAX_RETRY,
S    WIFI0_ARP_RESEND_TOUT * NET_TICK_RATE,
S    WIFI0_ARP_NOTIFY
S  };
S
S  /* WIFI0: IGMP configuration */
S #if (WIFI0_IGMP_ENABLE)
S  extern struct net_igmp_ctrl net_wifi0_igmp_control;
S  static NET_IGMP_INFO wifi0_igmp_table[WIFI0_IGMP_TAB_SIZE];
S  static NET_IGMP_CFG  wifi0_igmp_config = {  
S    &net_wifi0_igmp_control,
S    &net_wifi0_if_config,
S    wifi0_igmp_table,
S    WIFI0_IGMP_TAB_SIZE
S  };
S #endif
S
S  /* WIFI0: DHCP configuration */
S #if (WIFI0_DHCP_ENABLE)
S  extern struct net_dhcp_ctrl net_wifi0_dhcp_control;
S  static NET_DHCP_CFG wifi0_dhcp_config = {
S    &net_wifi0_dhcp_control,
S    &net_wifi0_if_config,
S    WIFI0_DHCP_VCID,
S    STRLEN(WIFI0_DHCP_VCID),
S    WIFI0_DHCP_BOOTFILE,
S    WIFI0_DHCP_NTP_SERVERS
S  };
S #endif
S
S  /* WIFI0: IPv4 configuration */
S  static NET_LOCALM wifi0_localm __attribute__((aligned(4)));
S  static NET_IP4_CFG wifi0_ip4_config = {
S    WIFI0_IP4_ADDR,
S    WIFI0_IP4_MASK,
S    WIFI0_IP4_GATEWAY,
S    WIFI0_IP4_PRIMARY_DNS,
S    WIFI0_IP4_SECONDARY_DNS,
S    WIFI0_IP4_FRAG_ENABLE ? WIFI0_IP4_MTU : 0,
S  #if (WIFI0_ICMP_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    WIFI0_NBNS_ENABLE,
S    &wifi0_arp_config,
S  #if (WIFI0_IGMP_ENABLE)
S    &wifi0_igmp_config,
S  #else
S    NULL,
S  #endif
S  #if (WIFI0_DHCP_ENABLE)
S    &wifi0_dhcp_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (WIFI0_IP6_ENABLE)
S  /* WIFI0: NDP configuration */
S  extern struct net_ndp_ctrl net_wifi0_ndp_control;
S  static NET_NDP_INFO wifi0_ndp_table[WIFI0_NDP_TAB_SIZE];
S  static NET_NDP_CFG  wifi0_ndp_config = {
S    &net_wifi0_ndp_control,
S    &net_wifi0_if_config,
S    wifi0_ndp_table,
S    WIFI0_NDP_TAB_SIZE,
S    WIFI0_NDP_CACHE_TOUT,
S    WIFI0_NDP_MAX_RETRY,
S    WIFI0_NDP_RESEND_TOUT * NET_TICK_RATE
S  };
S
S  /* WIFI0: DHCPv6 configuration */
S #if (WIFI0_DHCP6_ENABLE)
S  extern struct net_dhcp6_ctrl net_wifi0_dhcp6_control;
S  static NET_DHCP6_CFG wifi0_dhcp6_config = {
S    &net_wifi0_dhcp6_control,
S    &net_wifi0_if_config,
S    WIFI0_DHCP6_MODE,
S    WIFI0_DHCP6_VCLASS_ENABLE,
S    WIFI0_DHCP6_VCLASS_ENABLE ? WIFI0_DHCP6_VCLASS_EID  : 0,
S    WIFI0_DHCP6_VCLASS_ENABLE ? WIFI0_DHCP6_VCLASS_DATA : NULL
S  };
S #endif
S
S  /* WIFI0: IPv6 configuration */
S  static NET_LOCALM6 wifi0_localm6 __attribute__((aligned(4)));
S  static NET_IP6_CFG wifi0_ip6_config = {
S    WIFI0_IP6_ADDR,
S    WIFI0_IP6_GATEWAY,
S    WIFI0_IP6_PRIMARY_DNS,
S    WIFI0_IP6_SECONDARY_DNS,
S    WIFI0_IP6_PREFIX_LEN,
S  #if (WIFI0_ICMP6_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    &wifi0_ndp_config,
S  #if (WIFI0_DHCP6_ENABLE)
S    &wifi0_dhcp6_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (WIFI0_ENABLE)
S  static uint8_t wifi0_mac_addr[];
S
S  /* WIFI0: Interface configuration */
S  static NET_IF_STATE wifi0_state;
S  NET_IF_CFG net_wifi0_if_config = {
S    &wifi0_state,
S    NET_IF_CLASS_WIFI+0,
S    "WIFI0",
S    wifi0_mac_addr,
S   #if (WIFI0_IP4_ENABLE)
S    &wifi0_localm,
S    &wifi0_ip4_config,
S   #else
S    NULL, NULL,
S   #endif
S   #if (WIFI0_IP6_ENABLE)
S    &wifi0_localm6,
S    &wifi0_ip6_config,
S   #else
S    NULL, NULL,
S   #endif
S    net_wifi_send_frame,
S    NULL,
S    net_wifi_output
S  };
S
S  /* WIFI0: low layer configuration */
S  extern ARM_DRIVER_WIFI ARM_Driver_WiFi_(WIFI0_DRIVER);
S  extern struct net_wifi_ctrl net_wifi0_if_control;
S  static uint8_t wifi0_mac_addr[NET_ADDR_ETH_LEN];
S  static void wifi0_callback (uint32_t event, void *arg) {
S    net_wifi_callback (event, &net_wifi0_if_control); (void)arg;
S  }  
S  static NET_WIFI_CFG wifi0_ll_config = {
S    &net_wifi0_if_control,
S    &net_wifi0_if_config,
S    &ARM_Driver_WiFi_(WIFI0_DRIVER),
S    wifi0_mac_addr,
S    WIFI0_MAC_CONFIG ? WIFI0_MAC_ADDR : NULL,
S    WIFI0_MODE,
S    0,
S    wifi0_callback
S  };
N#endif
N
N#if (WIFI1_IP4_ENABLE)
S  /* WIFI1: ARP configuration */
S  extern struct net_arp_ctrl net_wifi1_arp_control;
S  static NET_ARP_INFO wifi1_arp_table[WIFI1_ARP_TAB_SIZE];
S  static NET_ARP_CFG  wifi1_arp_config = {
S    &net_wifi1_arp_control,
S    &net_wifi1_if_config,
S    wifi1_arp_table,
S    WIFI1_ARP_TAB_SIZE,
S    WIFI1_ARP_CACHE_TOUT,
S    WIFI1_ARP_MAX_RETRY,
S    WIFI1_ARP_RESEND_TOUT * NET_TICK_RATE,
S    WIFI1_ARP_NOTIFY
S  };
S
S  /* WIFI1: IGMP configuration */
S #if (WIFI1_IGMP_ENABLE)
S  extern struct net_igmp_ctrl net_wifi1_igmp_control;
S  static NET_IGMP_INFO wifi1_igmp_table[WIFI1_IGMP_TAB_SIZE];
S  static NET_IGMP_CFG  wifi1_igmp_config = {  
S    &net_wifi1_igmp_control,
S    &net_wifi1_if_config,
S    wifi1_igmp_table,
S    WIFI1_IGMP_TAB_SIZE
S  };
S #endif
S
S  /* WIFI1: DHCP configuration */
S #if (WIFI1_DHCP_ENABLE)
S  extern struct net_dhcp_ctrl net_wifi1_dhcp_control;
S  static NET_DHCP_CFG wifi1_dhcp_config = {
S    &net_wifi1_dhcp_control,
S    &net_wifi1_if_config,
S    WIFI1_DHCP_VCID,
S    STRLEN(WIFI1_DHCP_VCID),
S    WIFI1_DHCP_BOOTFILE,
S    WIFI1_DHCP_NTP_SERVERS
S  };
S #endif
S
S  /* WIFI1: IPv4 configuration */
S  static NET_LOCALM wifi1_localm __attribute__((aligned(4)));
S  static NET_IP4_CFG wifi1_ip4_config = {
S    WIFI1_IP4_ADDR,
S    WIFI1_IP4_MASK,
S    WIFI1_IP4_GATEWAY,
S    WIFI1_IP4_PRIMARY_DNS,
S    WIFI1_IP4_SECONDARY_DNS,
S    WIFI1_IP4_FRAG_ENABLE ? WIFI1_IP4_MTU : 0,
S  #if (WIFI1_ICMP_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    WIFI1_NBNS_ENABLE,
S    &wifi1_arp_config,
S  #if (WIFI1_IGMP_ENABLE)
S    &wifi1_igmp_config,
S  #else
S    NULL,
S  #endif
S  #if (WIFI1_DHCP_ENABLE)
S    &wifi1_dhcp_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (WIFI1_IP6_ENABLE)
S  /* WIFI1: NDP configuration */
S  extern struct net_ndp_ctrl net_wifi1_ndp_control;
S  static NET_NDP_INFO wifi1_ndp_table[WIFI1_NDP_TAB_SIZE];
S  static NET_NDP_CFG  wifi1_ndp_config = {
S    &net_wifi1_ndp_control,
S    &net_wifi1_if_config,
S    wifi1_ndp_table,
S    WIFI1_NDP_TAB_SIZE,
S    WIFI1_NDP_CACHE_TOUT,
S    WIFI1_NDP_MAX_RETRY,
S    WIFI1_NDP_RESEND_TOUT * NET_TICK_RATE
S  };
S
S  /* WIFI1: DHCPv6 configuration */
S #if (WIFI1_DHCP6_ENABLE)
S  extern struct net_dhcp6_ctrl net_wifi1_dhcp6_control;
S  static NET_DHCP6_CFG wifi1_dhcp6_config = {
S    &net_wifi1_dhcp6_control,
S    &net_wifi1_if_config,
S    WIFI1_DHCP6_MODE,
S    WIFI1_DHCP6_VCLASS_ENABLE,
S    WIFI1_DHCP6_VCLASS_ENABLE ? WIFI1_DHCP6_VCLASS_EID  : 0,
S    WIFI1_DHCP6_VCLASS_ENABLE ? WIFI1_DHCP6_VCLASS_DATA : NULL
S  };
S #endif
S
S  /* WIFI1: IPv6 configuration */
S  static NET_LOCALM6 wifi1_localm6 __attribute__((aligned(4)));
S  static NET_IP6_CFG wifi1_ip6_config = {
S    WIFI1_IP6_ADDR,
S    WIFI1_IP6_GATEWAY,
S    WIFI1_IP6_PRIMARY_DNS,
S    WIFI1_IP6_SECONDARY_DNS,
S    WIFI1_IP6_PREFIX_LEN,
S  #if (WIFI1_ICMP6_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    &wifi1_ndp_config,
S  #if (WIFI1_DHCP6_ENABLE)
S    &wifi1_dhcp6_config
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (WIFI1_ENABLE)
S  static uint8_t wifi1_mac_addr[];
S
S  /* WIFI1: Interface configuration */
S  static NET_IF_STATE wifi1_state;
S  NET_IF_CFG net_wifi1_if_config = {
S    &wifi1_state,
S    NET_IF_CLASS_WIFI+1,
S    "WIFI1",
S    wifi1_mac_addr,
S   #if (WIFI1_IP4_ENABLE)
S    &wifi1_localm,
S    &wifi1_ip4_config,
S   #else
S    NULL, NULL,
S   #endif
S   #if (WIFI1_IP6_ENABLE)
S    &wifi1_localm6,
S    &wifi1_ip6_config,
S   #else
S    NULL, NULL,
S   #endif
S    net_wifi_send_frame,
S    NULL,
S    net_wifi_output
S  };
S
S  /* WIFI1: low layer configuration */
S  extern ARM_DRIVER_WIFI ARM_Driver_WiFi_(WIFI1_DRIVER);
S  extern struct net_wifi_ctrl net_wifi0_if_control;
S  static uint8_t wifi1_mac_addr[NET_ADDR_ETH_LEN];
S  static void wifi1_callback (uint32_t event, void *arg) {
S    net_wifi_callback (event, &net_wifi0_if_control); (void)arg;
S  }  
S  static NET_WIFI_CFG wifi1_ll_config = {
S    &net_wifi0_if_control,
S    &net_wifi1_if_config,
S    &ARM_Driver_WiFi_(WIFI1_DRIVER),
S    wifi1_mac_addr,
S    WIFI1_MAC_CONFIG ? WIFI1_MAC_ADDR : NULL,
S    WIFI1_MODE,
S    1,
S    wifi1_callback
S  };
N#endif
N
N#if (PPP_ENABLE)
S  /* PPP: IPv4 configuration */
S  static NET_LOCALM ppp0_localm __attribute__((aligned(4)));
S  static NET_IP4_CFG ppp0_ip4_config = {
S    PPP_IP4_ADDR,
S    NULL,
S    NULL,
S    PPP_IP4_PRIMARY_DNS,
S    PPP_IP4_SECONDARY_DNS,
S  #if (PPP_IP4_FRAG_ENABLE)
S    PPP_IP4_MTU,
S  #else
S    0,
S  #endif
S  #if (PPP_ICMP_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    0,
S    NULL,
S    NULL,
S    NULL
S  };
S
S  /* PPP: Interface configuration */
S  NET_IF_CFG net_ppp0_if_config = {
S    NULL,
S    NET_IF_CLASS_PPP,
S    "PPP0",
S    NULL,
S    &ppp0_localm,
S    &ppp0_ip4_config,
S    NULL,
S    NULL,
S    net_ppp_send_frame,
S    NULL,
S    NULL
S  };
S
S  /* PPP: Communication device */
S  extern ARM_DRIVER_USART CREATE_SYMBOL (Driver_USART, PPP_USART_DRIVER);
S  extern DRIVER_MODEM          Driver_MODEM;
S  extern struct net_com_ctrl   net_ppp0_com_control;
S  extern struct net_modem_ctrl net_ppp0_modem_control;
S  static void ppp0_com_callback (uint32_t event) {
S    net_com_callback (event, &net_ppp0_com_control);
S  }  
S  static void ppp0_modem_callback (const char *cmd, const char *response,
S                                   uint32_t timeout, uint32_t retries) {
S    net_modem_callback (cmd, response, timeout, retries, &net_ppp0_modem_control);
S  }  
S  static NET_COM_CFG ppp0_com_config = {
S    &net_ppp0_com_control,
S    &net_ppp0_modem_control,
S    &CREATE_SYMBOL (Driver_USART, PPP_USART_DRIVER),
S    &Driver_MODEM,
S    PPP_MODEM_INIT_STRING,
S    PPP_MODEM_SPEED,
S    PPP_MODEM_FLOW_CONTROL,
S    MAX_DELAY(PPP_MODEM_SPEED),
S    MAX_TOUT(PPP_MODEM_SPEED) * NET_TICK_RATE,
S    ppp0_com_callback,
S    ppp0_modem_callback
S  };
S 
S  /* PPP: low layer configuration */
S  extern struct net_ppp_ctrl  net_ppp0_if_control;
S  extern struct net_lcp_ctrl  net_ppp0_lcp_control;
S  extern struct net_ipcp_ctrl net_ppp0_ipcp_control;
S  static NET_PPP_CFG ppp0_ll_config = {
S    &net_ppp0_if_control,
S    &net_ppp0_if_config,
S    &ppp0_com_config,
S    PPP_ACCM,
S    PPP_RETRY_TOUT * NET_TICK_RATE,
S    PPP_ECHO_TOUT,
S    PPP_MAX_RETRY,
S    PPP_AUTH_ENABLE,
S    PPP_GET_IP,
S    PPP_DEFAULT_GW,
S    0,
S    &net_ppp0_lcp_control,
S  #if (PPP_AUTH_ENABLE && PPP_PAP_ENABLE)
S    &net_ppp0_pap_auth,
S  #else
S    NULL,
S  #endif
S  #if (PPP_AUTH_ENABLE && PPP_CHAP_ENABLE)
S    &net_ppp0_chap_auth,
S  #else
S    NULL,
S  #endif
S    &net_ppp0_ipcp_control
S  };
N#endif
N
N#if (SLIP_ENABLE)
S  /* SLIP: IPv4 configuration */
S  static NET_LOCALM slip0_localm __attribute__((aligned(4)));
S  static NET_IP4_CFG slip0_ip4_config = {
S    SLIP_IP4_ADDR,
S    NULL,
S    NULL,
S    SLIP_IP4_PRIMARY_DNS,
S    SLIP_IP4_SECONDARY_DNS,
S  #if (SLIP_IP4_FRAG_ENABLE)
S    SLIP_IP4_MTU,
S  #else
S    0,
S  #endif
S  #if (SLIP_ICMP_NO_ECHO)
S    1,
S  #else
S    0,
S  #endif
S    0,
S    NULL,
S    NULL,
S    NULL
S  };
S
S  /* SLIP: Interface configuration */
S  NET_IF_CFG net_slip0_if_config = {
S    NULL,
S    NET_IF_CLASS_SLIP,
S    "SLIP0",
S    NULL,
S    &slip0_localm,
S    &slip0_ip4_config,
S    NULL,
S    NULL,
S    net_slip_send_frame,
S    NULL,
S    NULL
S  };
S
S  /* SLIP: Communication device */
S  extern ARM_DRIVER_USART CREATE_SYMBOL (Driver_USART, SLIP_USART_DRIVER);
S  extern DRIVER_MODEM          Driver_MODEM;
S  extern struct net_com_ctrl   net_slip0_com_control;
S  extern struct net_modem_ctrl net_slip0_modem_control;
S  static void slip0_com_callback (uint32_t event) {
S    net_com_callback (event, &net_slip0_com_control);
S  }  
S  static void slip0_modem_callback (const char *cmd, const char *response,
S                                    uint32_t timeout, uint32_t retries) {
S    net_modem_callback (cmd, response, timeout, retries, &net_slip0_modem_control);
S  }  
S   static NET_COM_CFG slip0_com_config = {
S    &net_slip0_com_control,
S    &net_slip0_modem_control,
S    &CREATE_SYMBOL (Driver_USART, SLIP_USART_DRIVER),
S    &Driver_MODEM,
S    SLIP_MODEM_INIT_STRING,
S    SLIP_MODEM_SPEED,
S    SLIP_MODEM_FLOW_CONTROL,
S    MAX_DELAY(SLIP_MODEM_SPEED),
S    MAX_TOUT(SLIP_MODEM_SPEED) * NET_TICK_RATE,
S    slip0_com_callback,
S    slip0_modem_callback
S  };
S 
S  /* SLIP: low layer configuration */
S  extern struct net_slip_ctrl net_slip0_if_control;
S  static NET_SLIP_CFG slip0_ll_config = {
S    &net_slip0_if_control,
S    &net_slip0_if_config,
S    &slip0_com_config,
S    SLIP_DEFAULT_GW,
S    0
S  };
N#endif
N
N/* List of ETH network interfaces */
N#if (__ETH_ENA)
X#if ((1 + ETH1_ENABLE))
N  NET_ETH_CFG *const net_eth_list[] = {
N  #if (ETH0_ENABLE)
X  #if (1)
N    &eth0_ll_config,
N  #endif
N  #if (ETH1_ENABLE)
S    &eth1_ll_config,
N  #endif
N    NULL
X    0
N  };
N#endif
N
N/* List of WIFI network interfaces */
N#if (__WIFI_ENA)
X#if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  NET_WIFI_CFG *const net_wifi_list[] = {
S  #if (WIFI0_ENABLE)
S    &wifi0_ll_config,
S  #endif
S  #if (WIFI1_ENABLE)
S    &wifi1_ll_config,
S  #endif
S    NULL
S  };
N#endif
N
N/* List of PPP network interfaces */
N#if (PPP_ENABLE)
S  NET_PPP_CFG *const net_ppp_list[] = {
S    &ppp0_ll_config,
S    NULL
S  };
N#endif
N
N/* List of SLIP network interfaces */
N#if (SLIP_ENABLE)
S  NET_SLIP_CFG *const net_slip_list[] = {
S    &slip0_ll_config,
S    NULL
S  };
N#endif
N
N/* List of LAN network interfaces */
NNET_IF_CFG *const net_if_list_lan[] = {
N #if (ETH0_ENABLE)
X #if (1)
N  &net_eth0_if_config,
N #endif
N #if (ETH1_ENABLE)
S  &net_eth1_if_config,
N #endif
N #if (WIFI0_ENABLE)
S  &net_wifi0_if_config,
N #endif
N #if (WIFI1_ENABLE)
S  &net_wifi1_if_config,
N #endif
N  NULL
X  0
N};
N
N/* List of external network interfaces */
NNET_IF_CFG *const net_if_list_all[] = {
N #if (ETH0_ENABLE)
X #if (1)
N  &net_eth0_if_config,
N #endif
N #if (ETH1_ENABLE)
S  &net_eth1_if_config,
N #endif
N #if (WIFI0_ENABLE)
S  &net_wifi0_if_config,
N #endif
N #if (WIFI1_ENABLE)
S  &net_wifi1_if_config,
N #endif
N #if (PPP_ENABLE)
S  &net_ppp0_if_config,
N #endif
N #if (SLIP_ENABLE)
S  &net_slip0_if_config,
N #endif
N  NULL
X  0
N};
N
N/* Default internet access interface(s) */
NNET_IF_CFG *const net_if_inet_def[] = {
N #if   (PPP_DEFAULT_GW) 
S  &net_ppp0_if_config
S #elif (SLIP_DEFAULT_GW)
S  &net_slip0_if_config
N #elif (ETH0_IP4_ENABLE)
X #elif (1)
N  &net_eth0_if_config
N #elif (ETH1_IP4_ENABLE)
S  &net_eth1_if_config
S #elif (WIFI0_IP4_ENABLE)
S  &net_wifi0_if_config
S #elif (WIFI1_IP4_ENABLE)
S  &net_wifi1_if_config
S #else
S  NULL
N #endif
N#ifdef RTE_Network_IPv6
S #if   (ETH0_IP6_ENABLE)
S, &net_eth0_if_config
S #elif (ETH1_IP6_ENABLE)
S, &net_eth1_if_config
S #elif (WIFI0_IP6_ENABLE)
S, &net_wifi0_if_config
S #elif (WIFI1_IP6_ENABLE)
S, &net_wifi1_if_config
S #else
S, NULL
S #endif
N#endif
N};
N
N/* Default link interface(s) */
NNET_IF_CFG *const net_if_link_def[] = {
N #if   (ETH0_IP4_ENABLE)
X #if   (1)
N  &net_eth0_if_config
N #elif (ETH1_IP4_ENABLE)
S  &net_eth1_if_config
S #elif (WIFI0_IP4_ENABLE)
S  &net_wifi0_if_config
S #elif (WIFI1_IP4_ENABLE)
S  &net_wifi1_if_config
S #else
S  NULL
N #endif
N#ifdef RTE_Network_IPv6
S #if   (ETH0_IP6_ENABLE)
S, &net_eth0_if_config
S #elif (ETH1_IP6_ENABLE)
S, &net_eth1_if_config
S #elif (WIFI0_IP6_ENABLE)
S, &net_wifi0_if_config
S #elif (WIFI1_IP6_ENABLE)
S, &net_wifi1_if_config
S #else
S, NULL
S #endif
N#endif
N};
N
N/* List of ARP instances */
NNET_ARP_CFG *const net_arp_list[] = {
N  /* Required in IPv4 */
N #if (ETH0_IP4_ENABLE)
X #if (1)
N  &eth0_arp_config,
N #endif
N #if (ETH1_IP4_ENABLE)
S  &eth1_arp_config,
N #endif
N #if (WIFI0_IP4_ENABLE)
S  &wifi0_arp_config,
N #endif
N #if (WIFI1_IP4_ENABLE)
S  &wifi1_arp_config,
N #endif
N  NULL
X  0
N};
N
N/* List of IGMP instances */
N#if (__IGMP_ENA)
X#if ((0 + ETH1_IGMP_ENABLE + WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE))
S  NET_IGMP_CFG *const net_igmp_list[] = {
S  #if (ETH0_IGMP_ENABLE)
S    &eth0_igmp_config,
S  #endif
S  #if (ETH1_IGMP_ENABLE)
S    &eth1_igmp_config,
S  #endif
S  #if (WIFI0_IGMP_ENABLE)
S    &wifi0_igmp_config,
S  #endif
S  #if (WIFI1_IGMP_ENABLE)
S    &wifi1_igmp_config,
S  #endif
S    NULL
S  };
N#endif
N
N/* List of DHCP instances */
N#if (__DHCP_ENA)
X#if ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE))
S  NET_DHCP_CFG *const net_dhcp_list[] = {
S  #if (ETH0_DHCP_ENABLE)
S    &eth0_dhcp_config,
S  #endif
S  #if (ETH1_DHCP_ENABLE)
S    &eth1_dhcp_config,
S  #endif
S  #if (WIFI0_DHCP_ENABLE)
S    &wifi0_dhcp_config,
S  #endif
S  #if (WIFI1_DHCP_ENABLE)
S    &wifi1_dhcp_config,
S  #endif
S    NULL
S  };
N#endif
N
N/* List of NDP instances */
N#ifdef RTE_Network_IPv6
S  /* Required in IPv6 */
S  NET_NDP_CFG *const net_ndp_list[] = {
S  #if (ETH0_IP6_ENABLE)
S    &eth0_ndp_config,
S  #endif
S  #if (ETH1_IP6_ENABLE)
S    &eth1_ndp_config,
S  #endif
S  #if (WIFI0_IP6_ENABLE)
S    &wifi0_ndp_config,
S  #endif
S  #if (WIFI1_IP6_ENABLE)
S    &wifi1_ndp_config,
S  #endif
S    NULL
S  };
N#endif
N
N#if (__DHCP6_ENA)
X#if ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE))
S  /* List of DHCPv6 instances */
S  NET_DHCP6_CFG *const net_dhcp6_list[] = {
S  #if (ETH0_DHCP6_ENABLE)
S    &eth0_dhcp6_config,
S  #endif
S  #if (ETH1_DHCP6_ENABLE)
S    &eth1_dhcp6_config,
S  #endif
S  #if (WIFI0_DHCP6_ENABLE)
S    &wifi0_dhcp6_config,
S  #endif
S  #if (WIFI1_DHCP6_ENABLE)
S    &wifi1_dhcp6_config,
S  #endif
S    NULL
S  };
N#endif
N
N/* Local Machine info IPv4 */
N#ifdef RTE_Network_Legacy
S  NET_LOCALM *const net_localm[4] = {
S  #if (ETH0_IP4_ENABLE)
S    &eth0_localm,
S  #else
S    NULL,
S  #endif
S  #if (PPP_ENABLE)
S    &ppp0_localm,
S  #else
S    NULL,
S  #endif
S  #if (SLIP_ENABLE)
S    &slip0_localm,
S  #else
S    NULL,
S  #endif
S    NULL
S  };
N#endif
N
N/* IP4 fragmentation and reassembly */
N#if (__IP4_FRAG_ENA)
X#if (( 1 + ETH1_IP4_FRAG_ENABLE + WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + PPP_IP4_FRAG_ENABLE + SLIP_IP4_FRAG_ENABLE))
N #ifndef IP4_FRAG_REASS_NUM
N  /* Number of reassembly sessions */
N  #define IP4_FRAG_REASS_NUM    5
N #endif
N #ifndef IP4_FRAG_REASS_TOUT
N  /* Reassembly timeout in seconds */
N  #define IP4_FRAG_REASS_TOUT   10
N #endif
N  static NET_IP4_FRAG_INFO ip4_frag_scb[IP4_FRAG_REASS_NUM];
X  static NET_IP4_FRAG_INFO ip4_frag_scb[5];
N  NET_IP4_FRAG_CFG net_ip4_frag_config = {
N    ip4_frag_scb,
N    IP4_FRAG_REASS_NUM,
X    5,
N    IP4_FRAG_REASS_TOUT * NET_TICK_RATE
X    10 * 10
N  };
N#endif
N
N#if (UDP_ENABLE)
S  static NET_UDP_INFO udp_scb[UDP_NUM_SOCKS];
S #ifdef RTE_Network_Legacy
S  net_udp_cb_t net_udp_cb_legacy[UDP_NUM_SOCKS];
S #endif
S  NET_UDP_CFG net_udp_config = {
S    udp_scb,
S    UDP_NUM_SOCKS,
S  #ifdef UDP_DYN_PORT_START
S    UDP_DYN_PORT_START,
S    UDP_DYN_PORT_END
S  #else
S    49152,
S    65535
S  #endif
S  };
N#endif
N
N#if (TCP_ENABLE)
X#if (1)
N  static NET_TCP_INFO tcp_scb[TCP_NUM_SOCKS];
X  static NET_TCP_INFO tcp_scb[6];
N #ifdef RTE_Network_Legacy
S  net_tcp_cb_t net_tcp_cb_legacy[TCP_NUM_SOCKS];
N #endif
N  NET_TCP_CFG net_tcp_config = {
N    tcp_scb,
N    TCP_NUM_SOCKS,
X    6,
N    TCP_MAX_RETRY,
X    5,
N    TCP_RETRY_TOUT * NET_TICK_RATE,
X    4 * 10,
N    TCP_SYN_RETRY_TOUT * NET_TICK_RATE,
X    2 * 10,
N    TCP_INITIAL_RETRY_TOUT * NET_TICK_RATE,
X    1 * 10,
N    TCP_DEFAULT_TOUT,
X    120,
N    TCP_MAX_SEG_SIZE,
X    1440,
N    TCP_RECEIVE_WIN_SIZE,
X    4320,
N    TCP_CONNECT_RETRY,
X    7,
N  #ifdef TCP_DYN_PORT_START
N    TCP_DYN_PORT_START,
X    49152,
N    TCP_DYN_PORT_END
X    65535
N  #else
S    49152,
S    65535
N  #endif
N  };
N#endif
N
N#if (BSD_ENABLE)
S  static NET_BSD_INFO bsd_scb[BSD_NUM_SOCKS + BSD_SERVER_SOCKS];
S  NET_BSD_CFG net_bsd_config = {
S    bsd_scb,
S    BSD_NUM_SOCKS + BSD_SERVER_SOCKS,
S    BSD_RECEIVE_TOUT * NET_TICK_RATE
S  };
N#endif
N
N#if (HTTP_SERVER_ENABLE)
S  static NET_HTTP_INFO http_scb[HTTP_SERVER_NUM_SESSIONS];
S /* HTTP Digest authentication */
S #if (HTTP_SERVER_AUTH_ENABLE && HTTP_SERVER_AUTH_TYPE == 1)
S  #ifndef HTTP_NONCE_TAB_SIZE
S   /* Number of cache entries */
S   #define HTTP_NONCE_TAB_SIZE   8
S  #endif
S  #ifndef HTTP_NONCE_CACHE_TOUT
S   /* Nonce cache timeout in seconds */
S   #define HTTP_NONCE_CACHE_TOUT 60
S  #endif
S  static NET_HTTP_NONCE http_nonce[HTTP_NONCE_TAB_SIZE];
S #endif
S  NET_HTTP_CFG net_http_config = {
S    http_scb,
S    HTTP_SERVER_NUM_SESSIONS,
S    HTTP_SERVER_AUTH_ENABLE,
S    HTTP_SERVER_PORT_NUM,
S    HTTP_SERVER_ID,
S  #if (HTTP_SERVER_ROOT_ENABLE && !defined(RTE_Network_Web_Server_RO))
S    HTTP_SERVER_ROOT_FOLDER,
S  #else
S    NULL,
S  #endif
S  #if (HTTP_SERVER_AUTH_ENABLE)
S    HTTP_SERVER_AUTH_REALM,
S    STRLEN(HTTP_SERVER_AUTH_REALM),
S  #else
S    NULL,0,
S  #endif
S  #if (HTTP_SERVER_AUTH_ENABLE && HTTP_SERVER_AUTH_ADMIN)
S    HTTP_SERVER_AUTH_USER,
S    HTTP_SERVER_AUTH_PASS,
S    STRLEN(HTTP_SERVER_AUTH_USER),
S    STRLEN(HTTP_SERVER_AUTH_PASS),
S  #else
S    NULL,NULL,0,0,
S  #endif
S  #if (HTTP_SERVER_AUTH_ENABLE && HTTP_SERVER_AUTH_TYPE == 1)
S    http_nonce,
S    HTTP_NONCE_TAB_SIZE,
S    HTTP_NONCE_CACHE_TOUT,
S  #else
S    NULL,0,0,
S  #endif
S  #if (HTTP_SERVER_AUTH_ENABLE && HTTP_SERVER_AUTH_TYPE == 0)
S    &net_http_auth_basic_func,
S  #elif (HTTP_SERVER_AUTH_ENABLE && HTTP_SERVER_AUTH_TYPE == 1)
S    &net_http_auth_digest_func,
S  #else
S    NULL,
S  #endif
S  #if defined(RTE_Network_Web_Server_RO_TLS) || defined(RTE_Network_Web_Server_FS_TLS)
S    &tls_if_func
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (TELNET_SERVER_ENABLE)
S  static NET_TELNET_INFO telnet_scb[TELNET_SERVER_NUM_SESSIONS];
S  NET_TELNET_CFG net_telnet_config = {
S    telnet_scb,
S    TELNET_SERVER_NUM_SESSIONS,
S    TELNET_SERVER_AUTH_ENABLE,
S    TELNET_SERVER_NO_ECHO,
S    TELNET_SERVER_PORT_NUM,
S    TELNET_SERVER_TOUT,
S  #if (TELNET_SERVER_AUTH_ENABLE && TELNET_SERVER_AUTH_ADMIN)
S    TELNET_SERVER_AUTH_USER,
S    TELNET_SERVER_AUTH_PASS,
S    STRLEN(TELNET_SERVER_AUTH_USER),
S    STRLEN(TELNET_SERVER_AUTH_PASS),
S  #else
S    NULL,NULL,0,0
S  #endif
S  };
N#endif
N
N#if (TFTP_SERVER_ENABLE)
S  static NET_TFTP_INFO tftp_scb[TFTP_SERVER_NUM_SESSIONS];
S  NET_TFTP_CFG net_tftp_config = {
S    tftp_scb,
S    TFTP_SERVER_NUM_SESSIONS,
S    TFTP_SERVER_MAX_RETRY,
S    TFTP_SERVER_PORT_NUM,
S    TFTP_SERVER_TOUT,
S    TFTP_SERVER_FIREWALL_ENABLE,
S  #if (TFTP_SERVER_ROOT_ENABLE)
S    TFTP_SERVER_ROOT_FOLDER
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (TFTP_CLIENT_ENABLE)
S  NET_TFTPC_CFG net_tftpc_config = {
S    TFTP_CLIENT_BLOCK_SIZE,
S    TFTP_CLIENT_RETRY_TOUT,
S    TFTP_CLIENT_MAX_RETRY
S  };
N#endif
N
N#if (FTP_SERVER_ENABLE)
S  static NET_FTP_INFO ftp_scb[FTP_SERVER_NUM_SESSIONS];
S  NET_FTP_CFG net_ftp_config = {
S    ftp_scb,
S    FTP_SERVER_NUM_SESSIONS,
S    FTP_SERVER_AUTH_ENABLE,
S    FTP_SERVER_PORT_NUM,
S    FTP_SERVER_TOUT,
S    STRLEN(FTP_SERVER_MESSAGE),
S    FTP_SERVER_MESSAGE,
S  #if (FTP_SERVER_ROOT_ENABLE)
S    FTP_SERVER_ROOT_FOLDER,
S  #else
S    NULL,
S  #endif
S  #if (FTP_SERVER_AUTH_ENABLE && FTP_SERVER_AUTH_ADMIN)
S    FTP_SERVER_AUTH_USER,
S    FTP_SERVER_AUTH_PASS,
S    STRLEN(FTP_SERVER_AUTH_USER),
S    STRLEN(FTP_SERVER_AUTH_PASS),
S  #else
S    NULL,NULL,0,0
S  #endif
S  };
N#endif
N
N#if (FTP_CLIENT_ENABLE)
S  NET_FTPC_CFG net_ftpc_config = {
S    FTP_CLIENT_TOUT,
S    FTP_CLIENT_PASSIVE_MODE
S  };
N#endif
N
N#if (DNS_CLIENT_ENABLE)
S  static NET_DNS_INFO dns_table[DNS_CLIENT_TAB_SIZE];
S  NET_DNS_CFG net_dns_config = {
S    dns_table,
S    DNS_CLIENT_TAB_SIZE
S  };
N#endif
N
N#if (SMTP_CLIENT_ENABLE)
S  NET_SMTP_CFG net_smtp_config = {
S    SMTP_CLIENT_TOUT,
S  #if (SMTP_CLIENT_ATTACH_ENABLE)
S    /* File system interface */
S    { netSMTPc_fopen,
S      netSMTPc_fread,
S      netSMTPc_fclose
S    },
S    /* Attachment support functions */
S    &net_smtp_attach_func,
S  #else
S    { NULL,NULL,NULL },
S    NULL,
S  #endif
S  #if defined(RTE_Network_SMTP_Client_TLS)
S    &tls_if_func
S  #else
S    NULL
S  #endif
S  };
N#endif
N
N#if (SNMP_AGENT_ENABLE)
S  NET_SNMP_CFG net_snmp_config = {
S    SNMP_AGENT_PORT_NUM,
S    SNMP_AGENT_TRAP_PORT,
S    SNMP_AGENT_TRAP_IP,
S    SNMP_AGENT_COMMUNITY
S  };
N#endif
N
N#if (SNTP_CLIENT_ENABLE)
S  NET_SNTP_CFG net_sntp_config = {
S    SNTP_CLIENT_NTP_SERVER,
S    SNTP_CLIENT_BCAST_MODE
S  };
N#endif
N
N/* Network init functions */
Nstatic const net_sys_fn_t sys_fn_init[] = {
N#if (__ETH_ENA)
X#if ((1 + ETH1_ENABLE))
N  net_eth_iface_init,
N#endif
N#if (__WIFI_ENA)
X#if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  net_wifi_iface_init,
N#endif
N#if (PPP_ENABLE)
S  net_ppp_iface_init,
N#endif
N#if (SLIP_ENABLE)
S  net_slip_iface_init,
N#endif
N  net_loop_iface_init,
N#if (__ARP_ENA)
X#if ((1 + ETH1_IP4_ENABLE + WIFI0_IP4_ENABLE + WIFI1_IP4_ENABLE))
N  net_arp_cache_init,
N#endif
N#if (__NDP_ENA)
X#if ((ETH0_IP6_ENABLE + ETH1_IP6_ENABLE + WIFI0_IP6_ENABLE + WIFI1_IP6_ENABLE))
S  net_ndp_cache_init,
N#endif
N#if (__IP4_FRAG_ENA)
X#if (( 1 + ETH1_IP4_FRAG_ENABLE + WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + PPP_IP4_FRAG_ENABLE + SLIP_IP4_FRAG_ENABLE))
N  net_ip4_frag_init,
N#endif
N  net_ping_client_init,
N#if (__IGMP_ENA)
X#if ((0 + ETH1_IGMP_ENABLE + WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE))
S  net_igmp_host_init,
N#endif
N#if (UDP_ENABLE)
S  net_udp_socket_init,
N#endif
N#if (TCP_ENABLE)
X#if (1)
N  net_tcp_socket_init,
N#endif
N#if (BSD_ENABLE)
S  net_bsd_socket_init,
S #if (BSD_HOSTNAME_ENABLE)
S  net_bsd_host_init,
S #endif
N#endif
N#if (__TLS_USED)
X#if (0)
S  /* Must initialize before services */
S  netTLS_InterfaceInit,
N#endif
N#if (HTTP_SERVER_ENABLE)
S  net_http_server_init,
N#endif
N#if (TELNET_SERVER_ENABLE)
S  net_telnet_server_init,
N#endif
N#if (TFTP_SERVER_ENABLE)
S  net_tftp_server_init,
N#endif
N#if (TFTP_CLIENT_ENABLE)
S  net_tftp_client_init,
N#endif
N#if (FTP_SERVER_ENABLE)
S  net_ftp_server_init,
N#endif
N#if (FTP_CLIENT_ENABLE)
S  net_ftp_client_init,
N#endif
N#if (__NBNS_ENA)
X#if ((0 + ETH1_NBNS_ENABLE + WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE))
S  net_nbns_client_init,
N#endif
N#if (__DHCP_ENA)
X#if ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE))
S  net_dhcp_client_init,
N#endif
N#if (__DHCP6_ENA)
X#if ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE))
S  net_dhcp6_client_init,
N#endif
N#if (DNS_CLIENT_ENABLE)
S  net_dns_client_init,
N#endif
N#if (SMTP_CLIENT_ENABLE)
S  net_smtp_client_init,
N#endif
N#if (SNMP_AGENT_ENABLE)
S  net_snmp_agent_init,
N#endif
N#if (SNTP_CLIENT_ENABLE)
S  net_sntp_client_init,
N#endif
N  /* End of table */
N  NULL
X  0
N};
N
N/* Network run functions */
Nstatic const net_sys_fn_t sys_fn_run[] = {
N#if (__ETH_ENA)
X#if ((1 + ETH1_ENABLE))
N  net_eth_iface_run,
N#endif
N#if (__WIFI_ENA)
X#if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  net_wifi_iface_run,
N#endif
N#if (PPP_ENABLE)
S  net_ppp_iface_run,
N#endif
N#if (SLIP_ENABLE)
S  net_slip_iface_run,
N#endif
N  net_loop_iface_run,
N#if (__ARP_ENA)
X#if ((1 + ETH1_IP4_ENABLE + WIFI0_IP4_ENABLE + WIFI1_IP4_ENABLE))
N  net_arp_cache_run,
N#endif
N#if (__NDP_ENA)
X#if ((ETH0_IP6_ENABLE + ETH1_IP6_ENABLE + WIFI0_IP6_ENABLE + WIFI1_IP6_ENABLE))
S  net_ndp_cache_run,
N#endif
N#if (__IP4_FRAG_ENA)
X#if (( 1 + ETH1_IP4_FRAG_ENABLE + WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + PPP_IP4_FRAG_ENABLE + SLIP_IP4_FRAG_ENABLE))
N  net_ip4_frag_run,
N#endif
N  net_ping_client_run,
N#if (__IGMP_ENA)
X#if ((0 + ETH1_IGMP_ENABLE + WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE))
S  net_igmp_host_run,
N#endif
N#if (UDP_ENABLE)
S  /* No function */
N#endif
N#if (TCP_ENABLE)
X#if (1)
N  net_tcp_socket_run,
N#endif
N#if (BSD_ENABLE)
S  net_bsd_socket_run,
S #if (BSD_HOSTNAME_ENABLE)
S  /* No function */
S #endif
N#endif
N#if (__TLS_USED)
X#if (0)
S  /* No function */
N#endif
N#if (HTTP_SERVER_ENABLE)
S  net_http_server_run,
N#endif
N#if (TELNET_SERVER_ENABLE)
S  net_telnet_server_run,
N#endif
N#if (TFTP_SERVER_ENABLE)
S  net_tftp_server_run,
N#endif
N#if (TFTP_CLIENT_ENABLE)
S  net_tftp_client_run,
N#endif
N#if (FTP_SERVER_ENABLE)
S  net_ftp_server_run,
N#endif
N#if (FTP_CLIENT_ENABLE)
S  net_ftp_client_run,
N#endif
N#if (__NBNS_ENA)
X#if ((0 + ETH1_NBNS_ENABLE + WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE))
S  /* No function */
N#endif
N#if (__DHCP_ENA)
X#if ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE))
S  net_dhcp_client_run,
N#endif
N#if (__DHCP6_ENA)
X#if ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE))
S  net_dhcp6_client_run,
N#endif
N#if (DNS_CLIENT_ENABLE)
S  net_dns_client_run,
N#endif
N#if (SMTP_CLIENT_ENABLE)
S  net_smtp_client_run,
N#endif
N#if (SNMP_AGENT_ENABLE)
S  net_snmp_agent_run,
N#endif
N#if (SNTP_CLIENT_ENABLE)
S  net_sntp_client_run,
N#endif
N  /* End of table */
N  NULL
X  0
N};
N
N/* Network uninit functions */
Nconst net_sys_fn_t net_sys_fn_uninit[] = {
N#if (__ETH_ENA)
X#if ((1 + ETH1_ENABLE))
N  net_eth_iface_uninit,
N#endif
N#if (__WIFI_ENA)
X#if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  net_wifi_iface_uninit,
N#endif
N#if (PPP_ENABLE)
S  net_ppp_iface_uninit,
N#endif
N#if (SLIP_ENABLE)
S  net_slip_iface_uninit,
N#endif
N  net_loop_iface_uninit,
N#if (__ARP_ENA)
X#if ((1 + ETH1_IP4_ENABLE + WIFI0_IP4_ENABLE + WIFI1_IP4_ENABLE))
N  net_arp_cache_uninit,
N#endif
N#if (__NDP_ENA)
X#if ((ETH0_IP6_ENABLE + ETH1_IP6_ENABLE + WIFI0_IP6_ENABLE + WIFI1_IP6_ENABLE))
S  net_ndp_cache_uninit,
N#endif
N#if (__IP4_FRAG_ENA)
X#if (( 1 + ETH1_IP4_FRAG_ENABLE + WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + PPP_IP4_FRAG_ENABLE + SLIP_IP4_FRAG_ENABLE))
N  net_ip4_frag_uninit,
N#endif
N  net_ping_client_uninit,
N#if (__IGMP_ENA)
X#if ((0 + ETH1_IGMP_ENABLE + WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE))
S  net_igmp_host_uninit,
N#endif
N#if (UDP_ENABLE)
S  net_udp_socket_uninit,
N#endif
N#if (TCP_ENABLE)
X#if (1)
N  net_tcp_socket_uninit,
N#endif
N#if (BSD_ENABLE)
S  net_bsd_socket_uninit,
S #if (BSD_HOSTNAME_ENABLE)
S  net_bsd_host_uninit,
S #endif
N#endif
N#if (__TLS_USED)
X#if (0)
S  netTLS_InterfaceUninit,
N#endif
N#if (HTTP_SERVER_ENABLE)
S  net_http_server_uninit,
N#endif
N#if (TELNET_SERVER_ENABLE)
S  net_telnet_server_uninit,
N#endif
N#if (TFTP_SERVER_ENABLE)
S  net_tftp_server_uninit,
N#endif
N#if (TFTP_CLIENT_ENABLE)
S  net_tftp_client_uninit,
N#endif
N#if (FTP_SERVER_ENABLE)
S  net_ftp_server_uninit,
N#endif
N#if (FTP_CLIENT_ENABLE)
S  net_ftp_client_uninit,
N#endif
N#if (__NBNS_ENA)
X#if ((0 + ETH1_NBNS_ENABLE + WIFI0_NBNS_ENABLE + WIFI1_NBNS_ENABLE))
S  net_nbns_client_uninit,
N#endif
N#if (__DHCP_ENA)
X#if ((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE))
S  net_dhcp_client_uninit,
N#endif
N#if (__DHCP6_ENA)
X#if ((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE))
S  net_dhcp6_client_uninit,
N#endif
N#if (DNS_CLIENT_ENABLE)
S  net_dns_client_uninit,
N#endif
N#if (SMTP_CLIENT_ENABLE)
S  net_smtp_client_uninit,
N#endif
N#if (SNMP_AGENT_ENABLE)
S  net_snmp_agent_uninit,
N#endif
N#if (SNTP_CLIENT_ENABLE)
S  net_sntp_client_uninit,
N#endif
N  /* End of table */
N  NULL
X  0
N};
N
N/* netIF_GetOption functions */
NNETIF_GETOPT_FUNC netif_getopt_func = {
N #if (__ETH_ENA)
X #if ((1 + ETH1_ENABLE))
N  net_eth_get_option,
N #else
S  NULL,
N #endif
N #if (__WIFI_ENA)
X #if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  net_wifi_get_option,
N #else
N  NULL,
X  0,
N #endif
N #if (PPP_ENABLE)
S  net_ppp_get_option,
N #else
N  NULL,
X  0,
N #endif
N #if (SLIP_ENABLE)
S  net_slip_get_option
N #else
N  NULL
X  0
N #endif
N};
N
N/* netIF_SetOption functions */
NNETIF_SETOPT_FUNC netif_setopt_func = {
N #if (__ETH_ENA)
X #if ((1 + ETH1_ENABLE))
N  net_eth_set_option,
N #else
S  NULL,
N #endif
N #if (__WIFI_ENA)
X #if ((WIFI0_ENABLE + WIFI1_ENABLE))
S  net_wifi_set_option,
N #else
N  NULL,
X  0,
N #endif
N #if (PPP_ENABLE)
S  net_ppp_set_option,
N #else
N  NULL,
X  0,
N #endif
N #if (SLIP_ENABLE)
S  net_slip_set_option
N #else
N  NULL
X  0
N #endif
N};
N
N/* Executable image size optimization */
N#if !(__ETH_ENA)
X#if !((1 + ETH1_ENABLE))
S/* Empty functions when Ethernet Interface is disabled */
SnetStatus netETH_SendRaw (uint32_t if_num, const uint8_t *buf, uint32_t len) {
S  (void)if_num; (void)buf; (void)len; return (netError); }
Sconst uint8_t *net_eth_get_addr (const __ADDR *addr) {
S  (void)addr; return (NULL); }
N#endif
N#if !(__ETH_ENA || __WIFI_ENA)
X#if !((1 + ETH1_ENABLE) || (WIFI0_ENABLE + WIFI1_ENABLE))
S#ifdef RTE_Network_IPv6
Svoid net_ndp_process (NET_IF_CFG *net_if, NET_FRAME *frame) {
S  (void)net_if; (void)frame; }
S#endif
N#endif
N
N#if !(__IGMP_ENA)
X#if !((0 + ETH1_IGMP_ENABLE + WIFI0_IGMP_ENABLE + WIFI1_IGMP_ENABLE))
N/* Empty functions when IP Multicasting is not enabled */
NnetStatus netIGMP_Join (uint32_t if_id, const uint8_t *ip4_addr) {
N  (void)if_id; (void)ip4_addr; return (netError); }
NnetStatus netIGMP_Leave (uint32_t if_id, const uint8_t *ip4_addr) {
N  (void)if_id; (void)ip4_addr; return (netError); }
Nbool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr) {
X_Bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr) {
N  (void)net_if; (void)ip4_addr; return (false); }
X  (void)net_if; (void)ip4_addr; return (0); }
N#if (__ETH_ENA)
X#if ((1 + ETH1_ENABLE))
Nuint32_t net_igmp_collect_mcast (NET_IF_CFG *net_if, uint8_t *buf) {
N  (void)net_if; (void)buf; return (0); }
N#endif
Nvoid net_igmp_process (NET_IF_CFG *net_if, NET_FRAME *frame) {
N  (void)net_if; (void)frame; }
N#endif
N
N#if !(__DHCP_ENA)
X#if !((0 + ETH1_DHCP_ENABLE + WIFI0_DHCP_ENABLE + WIFI1_DHCP_ENABLE))
N/* Empty functions when DHCP not enabled */
NnetStatus netDHCP_Enable (uint32_t if_id) {
N  (void)if_id; return (netError); }
NnetStatus netDHCP_Disable (uint32_t if_id) {
N  (void)if_id; return (netError); }
NnetStatus netDHCP_SetOption (uint32_t if_id, uint8_t option,
N                             const uint8_t *val, uint32_t len) {
N  (void)if_id; (void)option; (void)val; (void)len; return (netError); }
N#endif
N
N#if !(__DHCP6_ENA)
X#if !((ETH0_DHCP6_ENABLE + ETH1_DHCP6_ENABLE + WIFI0_DHCP6_ENABLE + WIFI1_DHCP6_ENABLE))
N/* Empty functions when DHCPv6 not enabled */
N#ifdef RTE_Network_IPv6
SnetStatus netDHCP6_Enable (uint32_t if_id, netDHCP6_Mode mode) {
S  (void)if_id; (void)mode; return (netError); }
SnetStatus netDHCP6_Disable (uint32_t if_id) {
S  (void)if_id; return (netError); }
N#endif
N#endif
N
N#if !(__IP4_FRAG_ENA)
X#if !(( 1 + ETH1_IP4_FRAG_ENABLE + WIFI0_IP4_FRAG_ENABLE + WIFI1_IP4_FRAG_ENABLE + PPP_IP4_FRAG_ENABLE + SLIP_IP4_FRAG_ENABLE))
S/* Empty functions when IP fragmentation not enabled */
SNET_FRAME *net_ip4_frag_add (NET_FRAME *frame) {
S  return (frame); }
SNET_FRAME *net_ip4_frag_get (NET_FRAME *frame, uint16_t mtu) {
S  (void)mtu; return (frame); }
N#endif
N
N#if !(UDP_ENABLE)
N/* Empty function when UDP socket not enabled */
Nvoid net_udp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver) {
N  (void)net_if; (void)frame; (void)ip_ver; }
N#endif
N
N#if !(TCP_ENABLE)
X#if !(1)
S/* Empty function when TCP socket not enabled */
Svoid net_tcp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver) {
S  (void)net_if; (void)frame; (void)ip_ver; }
N#endif
N
N#if !(SNTP_CLIENT_ENABLE)
N/* Empty function when SNTP not enabled */
NnetStatus netSNTPc_GetTime (const NET_ADDR *addr, netSNTPc_cb_t cb_func) {
N  (void)addr; (void)cb_func; return (netError); }
N#endif
N
N#if (HTTP_SERVER_ENABLE && defined(RTE_Network_Web_Server_RO))
X#if (HTTP_SERVER_ENABLE && 0L)
S/* Empty interface functions for Compact Web server */
S__weak void *netHTTPs_fopen (const char *fname) {
S  (void)fname; return (NULL); }
S__weak void netHTTPs_fclose (void *file) {
S  (void)file; }
S__weak uint32_t netHTTPs_fread (void *file, uint8_t *buf, uint32_t len) {
S  (void)file; (void)buf; (void)len; return (0); }
S__weak char *netHTTPs_fgets (void *file, char *buf, uint32_t size) {
S  (void)file; (void)buf; (void)size; return (NULL); }
S__weak void netHTTPs_fstat (const char *fname, uint32_t *fsize, uint32_t *ftime) {
S  (void)fname; (void)fsize; (void)ftime; }
N#endif
L 123 "RTE\Network\Net_Config.c" 2
N
N/**
N\addtogroup net_genFunc
N@{
N*/
N/**
N  \fn          void net_sys_error (NET_ERROR error)
N  \ingroup     net_cores
N  \brief       Network system error handler.
N*/
Nvoid net_sys_error (NET_ERROR error) {
N  /* This function is called when a fatal error is encountered. */
N  /* The normal program execution is not possible anymore.      */
N  switch (error) {
N    case NET_ERROR_MEM_ALLOC:
N      /* Out of memory */
N      break;
N
N    case NET_ERROR_MEM_FREE:
N      /* Trying to release non existing memory block */
N      break;
N
N    case NET_ERROR_MEM_CORRUPT:
N      /* Memory Link pointer corrupted */
N      /* More data written than the size of allocated memory block */
N      break;
N
N    case NET_ERROR_CONFIG:
N      /* Network configuration error detected */
N      break;
N
N    case NET_ERROR_UDP_ALLOC:
N      /* Out of UDP Sockets */
N      break;
N
N    case NET_ERROR_TCP_ALLOC:
N      /* Out of TCP Sockets */
N      break;
N
N    case NET_ERROR_TCP_STATE:
N      /* TCP State machine in undefined state */
N      break;
N  }
N
N  /* End-less loop */
N  while (1);
N}
N/**
N@}
N*/
