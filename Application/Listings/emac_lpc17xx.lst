L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.c"
N/* -------------------------------------------------------------------------- 
N * Copyright (c) 2013-2019 Arm Limited (or its affiliates). All 
N * rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N *
N * $Date:        01. August 2019
N * $Revision:    V2.12
N *
N * Driver:       Driver_ETH_MAC0
N * Configured:   via RTE_Device.h configuration file
N * Project:      Ethernet Media Access (MAC) Driver for NXP LPC17xx
N * --------------------------------------------------------------------------
N * Use the following configuration settings in the middleware component
N * to connect to this driver.
N *
N *   Configuration Setting                     Value
N *   ---------------------                     -----
N *   Connect to hardware via Driver_ETH_MAC# = 0
N * -------------------------------------------------------------------------- */
N
N/* History:
N *  Version 2.12
N *    Added support for ARM Compiler 6
N *  Version 2.11
N      - Corrected timeout implementation for RTOS2
N *  Version 2.10
N *    - Added support for CMSIS-RTOS2
N *  Version 2.9
N *    Corrected PowerControl function for conditional Power full (driver must be initialized)
N *  Version 2.8
N *    - Fixed PHY device addressing when using software controlled MDI
N *    - Corrected return value of the ReadFrame function
N *  Version 2.7
N *    - Updated initialization, uninitialization and power procedures
N *  Version 2.6
N *    - Changed include for renamed RTE_Device_LPC177x_8x.h to RTE_Device.h
N *  Version 2.5
N *    - Corrected return value of PHY_Read function on timeout
N *  Version 2.4
N *    - GetMacAddress function implemented in Ethernet driver
N *  Version 2.3
N *    - Corrected MDC clock divider setting for ethernet PHY
N *  Version 2.2
N *    - Corrected problem (no communication after cable reconnected)
N *  Version 2.1
N *    - Improved robustness and error control
N *  Version 2.0
N *    - Based on API V2.00
N *    - Added multicast MAC address filtering
N *  Version 1.1
N *    - Based on API V1.10 (namespace prefix ARM_ added)
N *  Version 1.0
N *    - Initial release
N */
N
N#include "EMAC_LPC17xx.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 1
N/* -------------------------------------------------------------------------- 
N * Copyright (c) 2013-2019 Arm Limited (or its affiliates). All 
N * rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N *
N * $Date:        01. August 2019
N * $Revision:    V2.12
N *
N * Project:      Ethernet Media Access (MAC) Definitions for NXP LPC17xx
N * -------------------------------------------------------------------------- */
N
N#ifndef __EMAC_LPC17XX_H
N#define __EMAC_LPC17XX_H
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N
N#include "Driver_ETH_MAC.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH_MAC.h" 1
N/*
N * Copyright (c) 2013-2020 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        24. January 2020
N * $Revision:    V2.2
N *
N * Project:      Ethernet MAC (Media Access Control) Driver definitions
N */
N
N/* History:
N *  Version 2.2
N *    Removed volatile from ARM_ETH_LINK_INFO
N *  Version 2.1
N *    Added ARM_ETH_MAC_SLEEP Control
N *  Version 2.0
N *    Changed MAC Address handling:
N *      moved from ARM_ETH_MAC_Initialize
N *      to new functions ARM_ETH_MAC_GetMacAddress and ARM_ETH_MAC_SetMacAddress
N *    Replaced ARM_ETH_MAC_SetMulticastAddr function with ARM_ETH_MAC_SetAddressFilter
N *    Extended ARM_ETH_MAC_SendFrame function with flags
N *    Added ARM_ETH_MAC_Control function:
N *      more control options (Broadcast, Multicast, Checksum offload, VLAN, ...)
N *      replaces ARM_ETH_MAC_SetMode
N *      replaces ARM_ETH_MAC_EnableTx, ARM_ETH_MAC_EnableRx
N *    Added optional event on transmitted frame
N *    Added support for PTP (Precision Time Protocol) through new functions:
N *       ARM_ETH_MAC_ControlTimer
N *       ARM_ETH_MAC_GetRxFrameTime
N *       ARM_ETH_MAC_GetTxFrameTime
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Changed return values of some functions to int32_t
N *  Version 1.10
N *    Name space prefix ARM_ added
N *  Version 1.01
N *    Renamed capabilities items for checksum offload
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_ETH_MAC_H_
N#define DRIVER_ETH_MAC_H_
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N#include "Driver_ETH.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH.h" 1
N/*
N * Copyright (c) 2013-2020 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        24. January 2020
N * $Revision:    V2.2
N *
N * Project:      Ethernet PHY and MAC Driver common definitions
N */
N
N/* History:
N *  Version 2.2
N *    Removed volatile from ARM_ETH_LINK_INFO
N *  Version 2.1
N *    ARM_ETH_LINK_INFO made volatile
N *  Version 2.0
N *    Removed ARM_ETH_STATUS enumerator
N *    Removed ARM_ETH_MODE enumerator
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_ETH_H_
N#define DRIVER_ETH_H_
N
N#include "Driver_Common.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_Common.h" 1
N/*
N * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        2. Feb 2017
N * $Revision:    V2.0
N *
N * Project:      Common Driver definitions
N */
N
N/* History:
N *  Version 2.0
N *    Changed prefix ARM_DRV -> ARM_DRIVER
N *    Added General return codes definitions
N *  Version 1.10
N *    Namespace prefix ARM_ added
N *  Version 1.00
N *    Initial release
N */
N
N#ifndef DRIVER_COMMON_H_
N#define DRIVER_COMMON_H_
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 38 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_Common.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 39 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_Common.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 40 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_Common.h" 2
N
N#define ARM_DRIVER_VERSION_MAJOR_MINOR(major,minor) (((major) << 8) | (minor))
N
N/**
N\brief Driver Version
N*/
Ntypedef struct _ARM_DRIVER_VERSION {
N  uint16_t api;                         ///< API version
N  uint16_t drv;                         ///< Driver version
N} ARM_DRIVER_VERSION;
N
N/* General return codes */
N#define ARM_DRIVER_OK                 0 ///< Operation succeeded 
N#define ARM_DRIVER_ERROR             -1 ///< Unspecified error
N#define ARM_DRIVER_ERROR_BUSY        -2 ///< Driver is busy
N#define ARM_DRIVER_ERROR_TIMEOUT     -3 ///< Timeout occurred
N#define ARM_DRIVER_ERROR_UNSUPPORTED -4 ///< Operation not supported
N#define ARM_DRIVER_ERROR_PARAMETER   -5 ///< Parameter error
N#define ARM_DRIVER_ERROR_SPECIFIC    -6 ///< Start of driver specific errors 
N
N/**
N\brief General power states
N*/ 
Ntypedef enum _ARM_POWER_STATE {
N  ARM_POWER_OFF,                        ///< Power off: no operation possible
N  ARM_POWER_LOW,                        ///< Low Power mode: retain state, detect and signal wake-up events
N  ARM_POWER_FULL                        ///< Power on: full operation at maximum performance
N} ARM_POWER_STATE;
N
N#endif /* DRIVER_COMMON_H_ */
L 42 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH.h" 2
N
N/**
N\brief Ethernet Media Interface type
N*/
N#define ARM_ETH_INTERFACE_MII           (0U)    ///< Media Independent Interface (MII)
N#define ARM_ETH_INTERFACE_RMII          (1U)    ///< Reduced Media Independent Interface (RMII)
N#define ARM_ETH_INTERFACE_SMII          (2U)    ///< Serial Media Independent Interface (SMII)
N
N/**
N\brief Ethernet link speed
N*/
N#define ARM_ETH_SPEED_10M               (0U)    ///< 10 Mbps link speed
N#define ARM_ETH_SPEED_100M              (1U)    ///< 100 Mbps link speed
N#define ARM_ETH_SPEED_1G                (2U)    ///< 1 Gpbs link speed
N
N/**
N\brief Ethernet duplex mode
N*/
N#define ARM_ETH_DUPLEX_HALF             (0U)    ///< Half duplex link
N#define ARM_ETH_DUPLEX_FULL             (1U)    ///< Full duplex link
N
N/**
N\brief Ethernet link state
N*/
Ntypedef enum _ARM_ETH_LINK_STATE {
N  ARM_ETH_LINK_DOWN,                    ///< Link is down
N  ARM_ETH_LINK_UP                       ///< Link is up
N} ARM_ETH_LINK_STATE;
N
N/**
N\brief Ethernet link information
N*/
Ntypedef struct _ARM_ETH_LINK_INFO {
N  uint32_t speed    : 2;                ///< Link speed: 0= 10 MBit, 1= 100 MBit, 2= 1 GBit
N  uint32_t duplex   : 1;                ///< Duplex mode: 0= Half, 1= Full
N  uint32_t reserved : 29;
N} ARM_ETH_LINK_INFO;
N
N/**
N\brief Ethernet MAC Address
N*/
Ntypedef struct _ARM_ETH_MAC_ADDR {
N  uint8_t b[6];                         ///< MAC Address (6 bytes), MSB first
N} ARM_ETH_MAC_ADDR;
N
N#endif /* DRIVER_ETH_H_ */
L 63 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include\Driver_ETH_MAC.h" 2
N
N#define ARM_ETH_MAC_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,2)  /* API version */
N
N
N#define _ARM_Driver_ETH_MAC_(n)      Driver_ETH_MAC##n
N#define  ARM_Driver_ETH_MAC_(n) _ARM_Driver_ETH_MAC_(n)
N
N
N/****** Ethernet MAC Control Codes *****/
N
N#define ARM_ETH_MAC_CONFIGURE           (0x01UL)    ///< Configure MAC; arg = configuration
N#define ARM_ETH_MAC_CONTROL_TX          (0x02UL)    ///< Transmitter; arg: 0=disabled (default), 1=enabled
N#define ARM_ETH_MAC_CONTROL_RX          (0x03UL)    ///< Receiver; arg: 0=disabled (default), 1=enabled
N#define ARM_ETH_MAC_FLUSH               (0x04UL)    ///< Flush buffer; arg = ARM_ETH_MAC_FLUSH_...
N#define ARM_ETH_MAC_SLEEP               (0x05UL)    ///< Sleep mode; arg: 1=enter and wait for Magic packet, 0=exit
N#define ARM_ETH_MAC_VLAN_FILTER         (0x06UL)    ///< VLAN Filter for received frames; arg15..0: VLAN Tag; arg16: optional ARM_ETH_MAC_VLAN_FILTER_ID_ONLY; 0=disabled (default)
N
N/*----- Ethernet MAC Configuration -----*/
N#define ARM_ETH_MAC_SPEED_Pos            0
N#define ARM_ETH_MAC_SPEED_Msk           (3UL                 << ARM_ETH_MAC_SPEED_Pos)
N#define ARM_ETH_MAC_SPEED_10M           (ARM_ETH_SPEED_10M   << ARM_ETH_MAC_SPEED_Pos)  ///< 10 Mbps link speed
N#define ARM_ETH_MAC_SPEED_100M          (ARM_ETH_SPEED_100M  << ARM_ETH_MAC_SPEED_Pos)  ///< 100 Mbps link speed
N#define ARM_ETH_MAC_SPEED_1G            (ARM_ETH_SPEED_1G    << ARM_ETH_MAC_SPEED_Pos)  ///< 1 Gpbs link speed
N#define ARM_ETH_MAC_DUPLEX_Pos           2
N#define ARM_ETH_MAC_DUPLEX_Msk          (1UL                 << ARM_ETH_MAC_DUPLEX_Pos)
N#define ARM_ETH_MAC_DUPLEX_HALF         (ARM_ETH_DUPLEX_HALF << ARM_ETH_MAC_DUPLEX_Pos) ///< Half duplex link
N#define ARM_ETH_MAC_DUPLEX_FULL         (ARM_ETH_DUPLEX_FULL << ARM_ETH_MAC_DUPLEX_Pos) ///< Full duplex link
N#define ARM_ETH_MAC_LOOPBACK            (1UL << 4)  ///< Loop-back test mode
N#define ARM_ETH_MAC_CHECKSUM_OFFLOAD_RX (1UL << 5)  ///< Receiver Checksum offload
N#define ARM_ETH_MAC_CHECKSUM_OFFLOAD_TX (1UL << 6)  ///< Transmitter Checksum offload
N#define ARM_ETH_MAC_ADDRESS_BROADCAST   (1UL << 7)  ///< Accept frames with Broadcast address
N#define ARM_ETH_MAC_ADDRESS_MULTICAST   (1UL << 8)  ///< Accept frames with any Multicast address
N#define ARM_ETH_MAC_ADDRESS_ALL         (1UL << 9)  ///< Accept frames with any address (Promiscuous Mode)
N
N/*----- Ethernet MAC Flush Flags -----*/
N#define ARM_ETH_MAC_FLUSH_RX            (1UL << 0)  ///< Flush Receive buffer
N#define ARM_ETH_MAC_FLUSH_TX            (1UL << 1)  ///< Flush Transmit buffer
N
N/*----- Ethernet MAC VLAN Filter Flag -----*/
N#define ARM_ETH_MAC_VLAN_FILTER_ID_ONLY (1UL << 16) ///< Compare only the VLAN Identifier (12-bit)
N
N
N/****** Ethernet MAC Frame Transmit Flags *****/
N#define ARM_ETH_MAC_TX_FRAME_FRAGMENT   (1UL << 0)  ///< Indicate frame fragment
N#define ARM_ETH_MAC_TX_FRAME_EVENT      (1UL << 1)  ///< Generate event when frame is transmitted
N#define ARM_ETH_MAC_TX_FRAME_TIMESTAMP  (1UL << 2)  ///< Capture frame time stamp
N
N
N/****** Ethernet MAC Timer Control Codes *****/
N#define ARM_ETH_MAC_TIMER_GET_TIME      (0x01UL)    ///< Get current time
N#define ARM_ETH_MAC_TIMER_SET_TIME      (0x02UL)    ///< Set new time
N#define ARM_ETH_MAC_TIMER_INC_TIME      (0x03UL)    ///< Increment current time
N#define ARM_ETH_MAC_TIMER_DEC_TIME      (0x04UL)    ///< Decrement current time
N#define ARM_ETH_MAC_TIMER_SET_ALARM     (0x05UL)    ///< Set alarm time
N#define ARM_ETH_MAC_TIMER_ADJUST_CLOCK  (0x06UL)    ///< Adjust clock frequency; time->ns: correction factor * 2^31
N
N
N/**
N\brief Ethernet MAC Time
N*/
Ntypedef struct _ARM_ETH_MAC_TIME {
N  uint32_t ns;                          ///< Nano seconds
N  uint32_t sec;                         ///< Seconds
N} ARM_ETH_MAC_TIME;
N
N
N/****** Ethernet MAC Event *****/
N#define ARM_ETH_MAC_EVENT_RX_FRAME      (1UL << 0)  ///< Frame Received
N#define ARM_ETH_MAC_EVENT_TX_FRAME      (1UL << 1)  ///< Frame Transmitted
N#define ARM_ETH_MAC_EVENT_WAKEUP        (1UL << 2)  ///< Wake-up (on Magic Packet)
N#define ARM_ETH_MAC_EVENT_TIMER_ALARM   (1UL << 3)  ///< Timer Alarm
N
N
N// Function documentation
N/**
N  \fn          ARM_DRIVER_VERSION ARM_ETH_MAC_GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N*/
N/**
N  \fn          ARM_ETH_MAC_CAPABILITIES ARM_ETH_MAC_GetCapabilities (void)
N  \brief       Get driver capabilities.
N  \return      \ref ARM_ETH_MAC_CAPABILITIES
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Initialize (ARM_ETH_MAC_SignalEvent_t cb_event)
N  \brief       Initialize Ethernet MAC Device.
N  \param[in]   cb_event  Pointer to \ref ARM_ETH_MAC_SignalEvent
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Uninitialize (void)
N  \brief       De-initialize Ethernet MAC Device.
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PowerControl (ARM_POWER_STATE state)
N  \brief       Control Ethernet MAC Device Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetMacAddress (ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Get Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SetMacAddress (const ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Set Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SetAddressFilter (const ARM_ETH_MAC_ADDR *ptr_addr,
N                                                           uint32_t          num_addr)
N  \brief       Configure Address Filter.
N  \param[in]   ptr_addr  Pointer to addresses
N  \param[in]   num_addr  Number of addresses to configure
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags)
N  \brief       Send Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer with data to send
N  \param[in]   len    Frame buffer length in bytes
N  \param[in]   flags  Frame transmit flags (see ARM_ETH_MAC_TX_FRAME_...)
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_ReadFrame (uint8_t *frame, uint32_t len)
N  \brief       Read data of received Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer for data to read into
N  \param[in]   len    Frame buffer length in bytes
N  \return      number of data bytes read or execution status
N                 - value >= 0: number of data bytes read
N                 - value < 0: error occurred, value is execution status as defined with \ref execution_status 
N*/
N/**
N  \fn          uint32_t ARM_ETH_MAC_GetRxFrameSize (void)
N  \brief       Get size of received Ethernet frame.
N  \return      number of bytes in received frame
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetRxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of received Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_GetTxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of transmitted Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_Control (uint32_t control, uint32_t arg)
N  \brief       Control Ethernet Interface.
N  \param[in]   control  Operation
N  \param[in]   arg      Argument of operation (optional)
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_ControlTimer (uint32_t control, ARM_ETH_MAC_TIME *time)
N  \brief       Control Precision Timer.
N  \param[in]   control  Operation
N  \param[in]   time     Pointer to time structure
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PHY_Read (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data)
N  \brief       Read Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[out]  data      Pointer where the result is written to
N  \return      \ref execution_status
N*/
N/**
N  \fn          int32_t ARM_ETH_MAC_PHY_Write (uint8_t phy_addr, uint8_t reg_addr, uint16_t data)
N  \brief       Write Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[in]   data      16-bit data to write
N  \return      \ref execution_status
N*/
N
N/**
N  \fn          void ARM_ETH_MAC_SignalEvent (uint32_t event)
N  \brief       Callback function that signals a Ethernet Event.
N  \param[in]   event  event notification mask
N  \return      none
N*/
N
Ntypedef void (*ARM_ETH_MAC_SignalEvent_t) (uint32_t event);  ///< Pointer to \ref ARM_ETH_MAC_SignalEvent : Signal Ethernet Event.
N
N
N/**
N\brief Ethernet MAC Capabilities
N*/
Ntypedef struct _ARM_ETH_MAC_CAPABILITIES {
N  uint32_t checksum_offload_rx_ip4  : 1;        ///< 1 = IPv4 header checksum verified on receive
N  uint32_t checksum_offload_rx_ip6  : 1;        ///< 1 = IPv6 checksum verification supported on receive
N  uint32_t checksum_offload_rx_udp  : 1;        ///< 1 = UDP payload checksum verified on receive
N  uint32_t checksum_offload_rx_tcp  : 1;        ///< 1 = TCP payload checksum verified on receive
N  uint32_t checksum_offload_rx_icmp : 1;        ///< 1 = ICMP payload checksum verified on receive
N  uint32_t checksum_offload_tx_ip4  : 1;        ///< 1 = IPv4 header checksum generated on transmit
N  uint32_t checksum_offload_tx_ip6  : 1;        ///< 1 = IPv6 checksum generation supported on transmit
N  uint32_t checksum_offload_tx_udp  : 1;        ///< 1 = UDP payload checksum generated on transmit
N  uint32_t checksum_offload_tx_tcp  : 1;        ///< 1 = TCP payload checksum generated on transmit
N  uint32_t checksum_offload_tx_icmp : 1;        ///< 1 = ICMP payload checksum generated on transmit
N  uint32_t media_interface          : 2;        ///< Ethernet Media Interface type
N  uint32_t mac_address              : 1;        ///< 1 = driver provides initial valid MAC address
N  uint32_t event_rx_frame           : 1;        ///< 1 = callback event \ref ARM_ETH_MAC_EVENT_RX_FRAME generated
N  uint32_t event_tx_frame           : 1;        ///< 1 = callback event \ref ARM_ETH_MAC_EVENT_TX_FRAME generated
N  uint32_t event_wakeup             : 1;        ///< 1 = wakeup event \ref ARM_ETH_MAC_EVENT_WAKEUP generated
N  uint32_t precision_timer          : 1;        ///< 1 = Precision Timer supported
N  uint32_t reserved                 : 15;       ///< Reserved (must be zero)
N} ARM_ETH_MAC_CAPABILITIES;
N
N
N/**
N\brief Access structure of the Ethernet MAC Driver
N*/
Ntypedef struct _ARM_DRIVER_ETH_MAC {
N  ARM_DRIVER_VERSION       (*GetVersion)      (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetVersion : Get driver version.
N  ARM_ETH_MAC_CAPABILITIES (*GetCapabilities) (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetCapabilities : Get driver capabilities.
N  int32_t                  (*Initialize)      (ARM_ETH_MAC_SignalEvent_t cb_event);                  ///< Pointer to \ref ARM_ETH_MAC_Initialize : Initialize Ethernet MAC Device.
N  int32_t                  (*Uninitialize)    (void);                                                ///< Pointer to \ref ARM_ETH_MAC_Uninitialize : De-initialize Ethernet MAC Device.
N  int32_t                  (*PowerControl)    (ARM_POWER_STATE state);                               ///< Pointer to \ref ARM_ETH_MAC_PowerControl : Control Ethernet MAC Device Power.
N  int32_t                  (*GetMacAddress)   (      ARM_ETH_MAC_ADDR *ptr_addr);                    ///< Pointer to \ref ARM_ETH_MAC_GetMacAddress : Get Ethernet MAC Address.
N  int32_t                  (*SetMacAddress)   (const ARM_ETH_MAC_ADDR *ptr_addr);                    ///< Pointer to \ref ARM_ETH_MAC_SetMacAddress : Set Ethernet MAC Address.
N  int32_t                  (*SetAddressFilter)(const ARM_ETH_MAC_ADDR *ptr_addr, uint32_t num_addr); ///< Pointer to \ref ARM_ETH_MAC_SetAddressFilter : Configure Address Filter.
N  int32_t                  (*SendFrame)       (const uint8_t *frame, uint32_t len, uint32_t flags);  ///< Pointer to \ref ARM_ETH_MAC_SendFrame : Send Ethernet frame.
N  int32_t                  (*ReadFrame)       (      uint8_t *frame, uint32_t len);                  ///< Pointer to \ref ARM_ETH_MAC_ReadFrame : Read data of received Ethernet frame.
N  uint32_t                 (*GetRxFrameSize)  (void);                                                ///< Pointer to \ref ARM_ETH_MAC_GetRxFrameSize : Get size of received Ethernet frame.
N  int32_t                  (*GetRxFrameTime)  (ARM_ETH_MAC_TIME *time);                              ///< Pointer to \ref ARM_ETH_MAC_GetRxFrameTime : Get time of received Ethernet frame.
N  int32_t                  (*GetTxFrameTime)  (ARM_ETH_MAC_TIME *time);                              ///< Pointer to \ref ARM_ETH_MAC_GetTxFrameTime : Get time of transmitted Ethernet frame.
N  int32_t                  (*ControlTimer)    (uint32_t control, ARM_ETH_MAC_TIME *time);            ///< Pointer to \ref ARM_ETH_MAC_ControlTimer : Control Precision Timer.
N  int32_t                  (*Control)         (uint32_t control, uint32_t arg);                      ///< Pointer to \ref ARM_ETH_MAC_Control : Control Ethernet Interface.
N  int32_t                  (*PHY_Read)        (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data);  ///< Pointer to \ref ARM_ETH_MAC_PHY_Read : Read Ethernet PHY Register through Management Interface.
N  int32_t                  (*PHY_Write)       (uint8_t phy_addr, uint8_t reg_addr, uint16_t  data);  ///< Pointer to \ref ARM_ETH_MAC_PHY_Write : Write Ethernet PHY Register through Management Interface.
N} const ARM_DRIVER_ETH_MAC;
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* DRIVER_ETH_MAC_H_ */
L 32 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N
N#include "RTE_Device.h"
L 1 ".\RTE\Device\LPC1768\RTE_Device.h" 1
N/* -------------------------------------------------------------------------- 
N * Copyright (c) 2013-2016 Arm Limited (or its affiliates). All 
N * rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * $Date:        20. April 2016
N * $Revision:    V2.4.1
N *
N * Project:      RTE Device Configuration for NXP LPC17xx
N * -------------------------------------------------------------------------- */
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N#ifndef __RTE_DEVICE_H
N#define __RTE_DEVICE_H
N
N
N// <e> USB Controller [Driver_USBD and Driver_USBH]
N// <i> Configuration settings for Driver_USBD in component ::Drivers:USB Device
N// <i> Configuration settings for Driver_USBH in component ::Drivers:USB Host
N#define   RTE_USB_USB0                  0
N
N//   <h> Pin Configuration
N//     <o> USB_PPWR (Host) <0=>Not used <1=>P1_19
N//     <i> VBUS drive signal (towards external charge pump or power management unit).
N#define   RTE_USB_PPWR_ID               1
N#if      (RTE_USB_PPWR_ID == 0)
X#if      (1 == 0)
S  #define RTE_USB_PPWR_PIN_EN           0
N#elif    (RTE_USB_PPWR_ID == 1)
X#elif    (1 == 1)
N  #define RTE_USB_PPWR_PIN_EN           1
N#else
S  #error "Invalid RTE_USB_PPWR Pin Configuration!"
N#endif
N
N//     <o> USB_PWRD (Host) <0=>Not used <1=>P1_22
N//     <i> Power Status for USB port.
N#define   RTE_USB_PWRD_ID               1
N#if      (RTE_USB_PWRD_ID == 0)
X#if      (1 == 0)
S  #define RTE_USB_PWRD_PIN_EN           0
N#elif    (RTE_USB_PWRD_ID == 1)
X#elif    (1 == 1)
N  #define RTE_USB_PWRD_PIN_EN           1
N#else
S  #error "Invalid RTE_USB_PWRD Pin Configuration!"
N#endif
N
N//     <o> USB_OVRCR (Host) <0=>Not used <1=>P1_27
N//     <i> Port power fault signal indicating overcurrent condition.
N//     <i> This signal monitors over-current on the USB bus
N//        (external circuitry required to detect over-current condition).
N#define   RTE_USB_OVRCR_ID              0
N#if      (RTE_USB_OVRCR_ID == 0)
X#if      (0 == 0)
N  #define RTE_USB_OVRCR_PIN_EN          0
N#elif    (RTE_USB_OVRCR_ID == 1)
S  #define RTE_USB_OVRCR_PIN_EN          1
S#else
S  #error "Invalid RTE_USB_OVRCR Pin Configuration!"
N#endif
N
N//     <o> USB_CONNECT (Device) <0=>Not used <1=>P2_9
N//     <i> SoftConnect control signal
N#define   RTE_USB_CONNECT_ID            1
N#if      (RTE_USB_CONNECT_ID == 0)
X#if      (1 == 0)
S  #define RTE_USB_CONNECT_PIN_EN        0
N#elif    (RTE_USB_CONNECT_ID == 1)
X#elif    (1 == 1)
N  #define RTE_USB_CONNECT_PIN_EN        1
N#else
S  #error "Invalid RTE_USB_CONNECT Pin Configuration!"
N#endif
N
N//     <o> USB_VBUS (Device) <0=>Not used <1=>P1_30
N//     <i> VBUS status input.
N//     <i> When this function is not enabled via its corresponding PINSEL register, it is driven HIGH internally.
N#define   RTE_USB_VBUS_ID               1
N#if      (RTE_USB_VBUS_ID == 0)
X#if      (1 == 0)
S  #define RTE_USB_VBUS_PIN_EN           0
N#elif    (RTE_USB_VBUS_ID == 1)
X#elif    (1 == 1)
N  #define RTE_USB_VBUS_PIN_EN           1
N#else
S  #error "Invalid RTE_USB_VBUS Pin Configuration!"
N#endif
N
N//     <o> USB_UP_LED <0=>Not used <1=>P1_18
N//     <i> GoodLink LED control signal.
N#define   RTE_USB_UP_LED_ID             1
N#if      (RTE_USB_UP_LED_ID == 0)
X#if      (1 == 0)
S  #define RTE_USB_UP_LED_PIN_EN         0
N#elif    (RTE_USB_UP_LED_ID == 1)
X#elif    (1 == 1)
N  #define RTE_USB_UP_LED_PIN_EN         1
N#else
S  #error "Invalid RTE_USB_UP_LED Pin Configuration!"
N#endif
N
N//  </h> Pin Configuration
N// </e> USB Controller [Driver_USBD and Driver_USBH]
N
N
N// <e> ENET (Ethernet Interface) [Driver_ETH_MAC0]
N// <i> Configuration settings for Driver_ETH_MAC0 in component ::Drivers:Ethernet MAC
N#define RTE_ENET                        1
N
N
N//   <h> RMII (Reduced Media Independent Interface)
N#define RTE_ENET_RMII                   1
N
N//     <o> ENET_TXD0 Pin <0=>P1_0
N#define RTE_ENET_RMII_TXD0_PORT_ID      0
N#if    (RTE_ENET_RMII_TXD0_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_TXD0_PORT         1
N#define RTE_ENET_RMII_TXD0_PIN          0
N#define RTE_ENET_RMII_TXD0_FUNC         1
N#else
S#error "Invalid ENET_TXD0 Pin Configuration!"
N#endif
N//     <o> ENET_TXD1 Pin <0=>P1_1
N#define RTE_ENET_RMII_TXD1_PORT_ID      0
N#if    (RTE_ENET_RMII_TXD1_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_TXD1_PORT         1
N#define RTE_ENET_RMII_TXD1_PIN          1
N#define RTE_ENET_RMII_TXD1_FUNC         1
N#else
S#error "Invalid ENET_TXD1 Pin Configuration!"
N#endif
N//     <o> ENET_REF_CLK Pin <0=>P1_15
N#define RTE_ENET_RMII_REF_CLK_PORT_ID   0
N#if    (RTE_ENET_RMII_REF_CLK_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_REF_CLK_PORT      1
N#define RTE_ENET_RMII_REF_CLK_PIN       15
N#define RTE_ENET_RMII_REF_CLK_FUNC      1
N#else
S#error "Invalid ENET_REF_CLK Pin Configuration!"
N#endif
N//     <o> ENET_TX_EN Pin <0=>P1_4
N#define RTE_ENET_RMII_TX_EN_PORT_ID     0
N#if    (RTE_ENET_RMII_TX_EN_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_TX_EN_PORT        1
N#define RTE_ENET_RMII_TX_EN_PIN         4
N#define RTE_ENET_RMII_TX_EN_FUNC        1
N#else
S#error "Invalid ENET_TX_EN Pin Configuration!"
N#endif
N//     <o> ENET_CRS Pin <0=>P1_8
N#define RTE_ENET_RMII_CRS_PORT_ID       0
N#if    (RTE_ENET_RMII_CRS_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_CRS_PORT          1
N#define RTE_ENET_RMII_CRS_PIN           8
N#define RTE_ENET_RMII_CRS_FUNC          1
N#else
S#error "Invalid ENET_CRS Pin Configuration!"
N#endif
N//     <o> ENET_RXD0 Pin <0=>P1_9
N#define RTE_ENET_RMII_RXD0_PORT_ID      0
N#if    (RTE_ENET_RMII_RXD0_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_RXD0_PORT         1
N#define RTE_ENET_RMII_RXD0_PIN          9
N#define RTE_ENET_RMII_RXD0_FUNC         1
N#else
S#error "Invalid ENET_RXD0 Pin Configuration!"
N#endif
N//     <o> ENET_RXD1 Pin <0=>P1_10
N#define RTE_ENET_RMII_RXD1_PORT_ID      0
N#if    (RTE_ENET_RMII_RXD1_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_RXD1_PORT         1
N#define RTE_ENET_RMII_RXD1_PIN          10
N#define RTE_ENET_RMII_RXD1_FUNC         1
N#else
S#error "Invalid ENET_RXD1 Pin Configuration!"
N#endif
N//     <o> ENET_RX_ER Pin <0=>P1_14
N#define RTE_ENET_RMII_RX_ER_PORT_ID     0
N#if    (RTE_ENET_RMII_RX_ER_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_RMII_RX_ER_PORT        1
N#define RTE_ENET_RMII_RX_ER_PIN         14
N#define RTE_ENET_RMII_RX_ER_FUNC        1
N#else
S#error "Invalid ENET_REF_CLK Pin Configuration!"
N#endif
N//   </h>
N
N//   <h> MIIM (Management Data Interface)
N//     <o> ENET_MDC Pin <0=>P1_16 <1=>P2_8
N#define RTE_ENET_MDI_MDC_PORT_ID        0
N#if    (RTE_ENET_MDI_MDC_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_MDI_MDC_PORT           1
N#define RTE_ENET_MDI_MDC_PIN            16
N#define RTE_ENET_MDI_MDC_FUNC           1
N#elif  (RTE_ENET_MDI_MDC_PORT_ID == 1)  
S#define RTE_ENET_MDI_MDC_PORT           2
S#define RTE_ENET_MDI_MDC_PIN            8
S#define RTE_ENET_MDI_MDC_FUNC           3
S#else
S#error "Invalid ENET_MDC Pin Configuration!"
N#endif
N//     <o> ENET_MDIO Pin <0=>P1_17 <1=>P2_9
N#define RTE_ENET_MDI_MDIO_PORT_ID       0
N#if    (RTE_ENET_MDI_MDIO_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_ENET_MDI_MDIO_PORT          1
N#define RTE_ENET_MDI_MDIO_PIN           17
N#define RTE_ENET_MDI_MDIO_FUNC          1
N#elif  (RTE_ENET_MDI_MDIO_PORT_ID == 1)
S#define RTE_ENET_MDI_MDIO_PORT          2
S#define RTE_ENET_MDI_MDIO_PIN           9
S#define RTE_ENET_MDI_MDIO_FUNC          3
S#else
S#error "Invalid ENET_MDIO Pin Configuration!"
N#endif
N//   </h>
N
N// </e>
N
N
N// <e> I2C0 (Inter-integrated Circuit Interface 0) [Driver_I2C0]
N// <i> Configuration settings for Driver_I2C0 in component ::Drivers:I2C
N#define RTE_I2C0                        0
N
N//   <o> I2C0_SCL Pin <0=>P0_28
N#define RTE_I2C0_SCL_PORT_ID            0
N#if    (RTE_I2C0_SCL_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C0_SCL_PORT               0
N#define RTE_I2C0_SCL_PIN                28
N#define RTE_I2C0_SCL_FUNC               1
N#else
S#error "Invalid I2C0_SCL Pin Configuration!"
N#endif
N
N//   <o> I2C0_SDA Pin <0=>P0_27
N#define RTE_I2C0_SDA_PORT_ID            0
N#if    (RTE_I2C0_SDA_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C0_SDA_PORT               0
N#define RTE_I2C0_SDA_PIN                27
N#define RTE_I2C0_SDA_FUNC               1
N#else
S#error "Invalid I2C0_SDA Pin Configuration!"
N#endif
N
N// </e>
N
N
N// <e> I2C1 (Inter-integrated Circuit Interface 1) [Driver_I2C1]
N// <i> Configuration settings for Driver_I2C1 in component ::Drivers:I2C
N#define RTE_I2C1                        0
N
N//   <o> I2C1_SCL Pin <0=>P0_1 <1=>P0_20
N#define RTE_I2C1_SCL_PORT_ID            0
N#if    (RTE_I2C1_SCL_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C1_SCL_PORT               0
N#define RTE_I2C1_SCL_PIN                1
N#define RTE_I2C1_SCL_FUNC               3
N#elif  (RTE_I2C1_SCL_PORT_ID == 1)
S#define RTE_I2C1_SCL_PORT               0
S#define RTE_I2C1_SCL_PIN                20
S#define RTE_I2C1_SCL_FUNC               3
S#else
S#error "Invalid I2C1_SCL Pin Configuration!"
N#endif
N
N//   <o> I2C1_SDA Pin <0=>P0_0 <1=>P0_19
N#define RTE_I2C1_SDA_PORT_ID            0
N#if    (RTE_I2C1_SDA_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C1_SDA_PORT               0
N#define RTE_I2C1_SDA_PIN                0
N#define RTE_I2C1_SDA_FUNC               3
N#elif  (RTE_I2C1_SDA_PORT_ID == 1)
S#define RTE_I2C1_SDA_PORT               0
S#define RTE_I2C1_SDA_PIN                19
S#define RTE_I2C1_SDA_FUNC               3
S#else
S#error "Invalid I2C1_SDA Pin Configuration!"
N#endif
N
N// </e>
N
N
N// <e> I2C2 (Inter-integrated Circuit Interface 2) [Driver_I2C2]
N// <i> Configuration settings for Driver_I2C2 in component ::Drivers:I2C
N#define RTE_I2C2                        0
N
N//   <o> I2C2_SCL Pin <0=>P0_11
N#define RTE_I2C2_SCL_PORT_ID            0
N#if    (RTE_I2C2_SCL_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C2_SCL_PORT               0
N#define RTE_I2C2_SCL_PIN                11
N#define RTE_I2C2_SCL_FUNC               2
N#else
S#error "Invalid I2C2_SCL Pin Configuration!"
N#endif
N
N//   <o> I2C2_SDA Pin <0=>P0_10
N#define RTE_I2C2_SDA_PORT_ID            0
N#if    (RTE_I2C2_SDA_PORT_ID == 0)
X#if    (0 == 0)
N#define RTE_I2C2_SDA_PORT               0
N#define RTE_I2C2_SDA_PIN                10
N#define RTE_I2C2_SDA_FUNC               2
N#else
S#error "Invalid I2C2_SDA Pin Configuration!"
N#endif
N
N// </e>
N
N// <e> UART0 (Universal asynchronous receiver transmitter)
N#define RTE_UART0                       0
N
N//   <o> UART0_TX Pin <0=>Not used <1=>P0_2
N//   <i> UART0 Serial Output pin
N#define RTE_UART0_TX_ID                 0
N#if    (RTE_UART0_TX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART0_TX_PIN_EN             0
N#elif  (RTE_UART0_TX_ID == 1)
S#define RTE_UART0_TX_PORT               0
S#define RTE_UART0_TX_BIT                2
S#define RTE_UART0_TX_FUNC               1
S#else
S#error "Invalid UART0_TX Pin Configuration!"
N#endif
N#ifndef RTE_UART0_TX_PIN_EN
S#define RTE_UART0_TX_PIN_EN             1
N#endif
N
N//   <o> UART0_RX Pin <0=>Not used <1=>P0_3
N//   <i> UART0 Serial Input pin
N#define RTE_UART0_RX_ID                 0
N#if    (RTE_UART0_RX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART0_RX_PIN_EN             0
N#elif  (RTE_UART0_RX_ID == 1)
S#define RTE_UART0_RX_PORT               0
S#define RTE_UART0_RX_BIT                3
S#define RTE_UART0_RX_FUNC               1
S#else
S#error "Invalid UART0_RX Pin Configuration!"
N#endif
N#ifndef RTE_UART0_RX_PIN_EN
S#define RTE_UART0_RX_PIN_EN             1
N#endif
N
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART0_DMA_TX_EN           1
N#define   RTE_UART0_DMA_TX_CH           0
N//     <e> Rx
N//       <o1> Channel    <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART0_DMA_RX_EN           1
N#define   RTE_UART0_DMA_RX_CH           1
N//   </h> DMA
N
N//     </e>
N// <e> UART1 (Universal asynchronous receiver transmitter)
N#define RTE_UART1                       0
N
N//   <o> U1_TX Pin <0=>Not used <1=>P0_15 <2=>P2_0
N//   <i> UART1 Serial Output pin
N#define RTE_UART1_TX_ID                 1
N#if    (RTE_UART1_TX_ID == 0)
X#if    (1 == 0)
S#define RTE_UART1_TX_PIN_EN             0
N#elif  (RTE_UART1_TX_ID == 1)
X#elif  (1 == 1)
N#define RTE_UART1_TX_PORT               0
N#define RTE_UART1_TX_BIT                15
N#define RTE_UART1_TX_FUNC               1
N#elif  (RTE_UART1_TX_ID == 2)
S#define RTE_UART1_TX_PORT               2
S#define RTE_UART1_TX_BIT                0
S#define RTE_UART1_TX_FUNC               2
S#else
S#error "Invalid U1_TX Pin Configuration!"
N#endif
N#ifndef RTE_UART1_TX_PIN_EN
N#define RTE_UART1_TX_PIN_EN             1
N#endif
N
N//   <o> U1_RX Pin <0=>Not used <1=>P0_16 <2=>P2_1
N//   <i> UART1 Serial Input pin
N#define RTE_UART1_RX_ID                 1
N#if    (RTE_UART1_RX_ID == 0)
X#if    (1 == 0)
S#define RTE_UART1_RX_PIN_EN             0
N#elif  (RTE_UART1_RX_ID == 1)
X#elif  (1 == 1)
N#define RTE_UART1_RX_PORT               0
N#define RTE_UART1_RX_BIT                16
N#define RTE_UART1_RX_FUNC               1
N#elif  (RTE_UART1_RX_ID == 2)
S#define RTE_UART1_RX_PORT               2
S#define RTE_UART1_RX_BIT                1
S#define RTE_UART1_RX_FUNC               2
S#else
S#error "Invalid U1_RX Pin Configuration!"
N#endif
N#ifndef RTE_UART1_RX_PIN_EN
N#define RTE_UART1_RX_PIN_EN             1
N#endif
N
N//     <h> Modem Lines
N//      <o> CTS <0=>Not used <1=>P0_17 <2=>P2_2
N#define RTE_UART1_CTS_ID                0
N#if    (RTE_UART1_CTS_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_CTS_PIN_EN            0
N#elif  (RTE_UART1_CTS_ID == 1)
S#define RTE_UART1_CTS_PORT              0
S#define RTE_UART1_CTS_BIT               17
S#define RTE_UART1_CTS_FUNC              1
S#elif  (RTE_UART1_CTS_ID == 2)
S#define RTE_UART1_CTS_PORT              2
S#define RTE_UART1_CTS_BIT               2
S#define RTE_UART1_CTS_FUNC              2
S#else
S#error "Invalid U1_CTS Pin Configuration!"
N#endif
N#ifndef RTE_UART1_CTS_PIN_EN
S#define RTE_UART1_CTS_PIN_EN            1
N#endif
N
N//       
N//      <o> DCD <0=>Not used <1=>P0_18 <2=>P2_3
N#define RTE_UART1_DCD_ID                0
N#if    (RTE_UART1_DCD_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_DCD_PIN_EN            0
N#elif  (RTE_UART1_DCD_ID == 1)
S#define RTE_UART1_DCD_PORT              0
S#define RTE_UART1_DCD_BIT               18
S#define RTE_UART1_DCD_FUNC              1
S#elif  (RTE_UART1_DCD_ID == 2)
S#define RTE_UART1_DCD_PORT              2
S#define RTE_UART1_DCD_BIT               3
S#define RTE_UART1_DCD_FUNC              2
S#else
S#error "Invalid UART1_DCD Pin Configuration!"
N#endif
N#ifndef RTE_UART1_DCD_PIN_EN
S#define RTE_UART1_DCD_PIN_EN            1
N#endif
N
N//      <o> DSR <0=>Not used <1=>P0_19  <2=>P2_4
N#define RTE_UART1_DSR_ID                0
N#if    (RTE_UART1_DSR_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_DSR_PIN_EN            0
N#elif  (RTE_UART1_DSR_ID == 1)
S#define RTE_UART1_DSR_PORT              0
S#define RTE_UART1_DSR_BIT               19
S#define RTE_UART1_DSR_FUNC              1
S#elif  (RTE_UART1_DSR_ID == 2)
S#define RTE_UART1_DSR_PORT              2
S#define RTE_UART1_DSR_BIT               4
S#define RTE_UART1_DSR_FUNC              2
S#else
S#error "Invalid UART1_DSR Pin Configuration!"
N#endif
N#ifndef RTE_UART1_DSR_PIN_EN
S#define RTE_UART1_DSR_PIN_EN            1
N#endif
N
N//      <o> DTR <0=>Not used <1=>P0_20  <2=>P2_5
N#define RTE_UART1_DTR_ID                0
N#if    (RTE_UART1_DTR_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_DTR_PIN_EN            0
N#elif  (RTE_UART1_DTR_ID == 1)
S#define RTE_UART1_DTR_PORT              0
S#define RTE_UART1_DTR_BIT               20
S#define RTE_UART1_DTR_FUNC              1
S#elif  (RTE_UART1_DTR_ID == 2)
S#define RTE_UART1_DTR_PORT              2
S#define RTE_UART1_DTR_BIT               5
S#define RTE_UART1_DTR_FUNC              2
S#else
S#error "Invalid UART1_DTR Pin Configuration!"
N#endif
N#ifndef RTE_UART1_DTR_PIN_EN
S#define RTE_UART1_DTR_PIN_EN            1
N#endif
N
N//       <o> RI <0=>Not used <1=>P0_21 <2=>P2_6
N#define RTE_UART1_RI_ID                 0
N#if    (RTE_UART1_RI_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_RI_PIN_EN             0
N#elif  (RTE_UART1_RI_ID == 1)
S#define RTE_UART1_RI_PORT               0
S#define RTE_UART1_RI_BIT                21
S#define RTE_UART1_RI_FUNC               1
S#elif  (RTE_UART1_RI_ID == 2)
S#define RTE_UART1_RI_PORT               2
S#define RTE_UART1_RI_BIT                6
S#define RTE_UART1_RI_FUNC               2
S#else
S#error "Invalid UART1_RI Pin Configuration!"
N#endif
N#ifndef RTE_UART1_RI_PIN_EN
S#define RTE_UART1_RI_PIN_EN             1
N#endif
N
N//       <o> RTS <0=>Not used <1=>P0_22  <2=>P2_7
N#define RTE_UART1_RTS_ID                0
N#if    (RTE_UART1_RTS_ID == 0)
X#if    (0 == 0)
N#define RTE_UART1_RTS_PIN_EN            0
N#elif  (RTE_UART1_RTS_ID == 1)
S#define RTE_UART1_RTS_PORT              0
S#define RTE_UART1_RTS_BIT               22
S#define RTE_UART1_RTS_FUNC              1
S#elif  (RTE_UART1_RTS_ID == 2)
S#define RTE_UART1_RTS_PORT              2
S#define RTE_UART1_RTS_BIT               7
S#define RTE_UART1_RTS_FUNC              2
S#else
S#error "Invalid UART1_RTS Pin Configuration!"
N#endif
N#ifndef RTE_UART1_RTS_PIN_EN
S#define RTE_UART1_RTS_PIN_EN            1
N#endif
N
N//     </h>
N
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART1_DMA_TX_EN           1
N#define   RTE_UART1_DMA_TX_CH           0
N//     <e> Rx
N//       <o1> Channel    <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART1_DMA_RX_EN           1
N#define   RTE_UART1_DMA_RX_CH           1
N//   </h> DMA
N
N// </e>
N
N// <e> UART2 (Universal asynchronous receiver transmitter)
N#define RTE_UART2                       0
N
N//   <o> UART2_TX Pin <0=>Not used <1=>P0_10 <2=>P2_8
N//   <i> UART2 Serial Output pin
N#define RTE_UART2_TX_ID                 0
N#if    (RTE_UART2_TX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART2_TX_PIN_EN             0
N#elif  (RTE_UART2_TX_ID == 1)
S#define RTE_UART2_TX_PORT               0
S#define RTE_UART2_TX_BIT                10
S#define RTE_UART2_TX_FUNC               1
S#elif  (RTE_UART2_TX_ID == 2)
S#define RTE_UART2_TX_PORT               2
S#define RTE_UART2_TX_BIT                8
S#define RTE_UART2_TX_FUNC               2
S#else
S#error "Invalid UART2_TX Pin Configuration!"
N#endif
N#ifndef RTE_UART2_TX_PIN_EN
S#define RTE_UART2_TX_PIN_EN             1
N#endif
N
N//   <o> UART2_RX Pin <0=>Not used <1=>P0_11 <2=>P2_9
N//   <i> UART2 Serial Input pin
N#define RTE_UART2_RX_ID                 0
N#if    (RTE_UART2_RX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART2_RX_PIN_EN             0
N#elif  (RTE_UART2_RX_ID == 1)
S#define RTE_UART2_RX_PORT               0
S#define RTE_UART2_RX_BIT                11
S#define RTE_UART2_RX_FUNC               1
S#elif  (RTE_UART2_RX_ID == 2)
S#define RTE_UART2_RX_PORT               2
S#define RTE_UART2_RX_BIT                9
S#define RTE_UART2_RX_FUNC               2
S#else
S#error "Invalid UART2_RX Pin Configuration!"
N#endif
N#ifndef RTE_UART2_RX_PIN_EN
S#define RTE_UART2_RX_PIN_EN             1
N#endif
N
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART2_DMA_TX_EN           1
N#define   RTE_UART2_DMA_TX_CH           0
N//     <e> Rx
N//       <o1> Channel    <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART2_DMA_RX_EN           1
N#define   RTE_UART2_DMA_RX_CH           1
N//   </h> DMA
N
N//     </e>
N
N// <e> UART3 (Universal asynchronous receiver transmitter)
N#define RTE_UART3                       0
N
N//   <o> UART3_TX Pin <0=>Not used <1=>P0_0 <2=>P0_25 <3=>P4_28
N//   <i> UART3 Serial Output pin
N#define RTE_UART3_TX_ID                 0
N#if    (RTE_UART3_TX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART3_TX_PIN_EN             0
N#elif  (RTE_UART3_TX_ID == 1)
S#define RTE_UART3_TX_PORT               0
S#define RTE_UART3_TX_BIT                0
S#define RTE_UART3_TX_FUNC               2
S#elif  (RTE_UART3_TX_ID == 2)
S#define RTE_UART3_TX_PORT               0
S#define RTE_UART3_TX_BIT                25
S#define RTE_UART3_TX_FUNC               3
S#elif  (RTE_UART3_TX_ID == 3)
S#define RTE_UART3_TX_PORT               4
S#define RTE_UART3_TX_BIT                28
S#define RTE_UART3_TX_FUNC               3
S#else
S#error "Invalid UART3_TX Pin Configuration!"
N#endif
N#ifndef RTE_UART3_TX_PIN_EN
S#define RTE_UART3_TX_PIN_EN             1
N#endif
N
N//   <o> UART3_RX Pin <0=>Not used <1=>P0_1 <2=>P0_26 <3=>P4_29
N//   <i> UART3 Serial Input pin
N#define RTE_UART3_RX_ID                 0
N#if    (RTE_UART3_RX_ID == 0)
X#if    (0 == 0)
N#define RTE_UART3_RX_PIN_EN             0
N#elif  (RTE_UART3_RX_ID == 1)
S#define RTE_UART3_RX_PORT               0
S#define RTE_UART3_RX_BIT                1
S#define RTE_UART3_RX_FUNC               2
S#elif  (RTE_UART3_RX_ID == 2)
S#define RTE_UART3_RX_PORT               0
S#define RTE_UART3_RX_BIT                26
S#define RTE_UART3_RX_FUNC               3
S#elif  (RTE_UART3_RX_ID == 3)
S#define RTE_UART3_RX_PORT               4
S#define RTE_UART3_RX_BIT                29
S#define RTE_UART3_RX_FUNC               3
S#else
S#error "Invalid UART3_RX Pin Configuration!"
N#endif
N#ifndef RTE_UART3_RX_PIN_EN
S#define RTE_UART3_RX_PIN_EN             1
N#endif
N
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART3_DMA_TX_EN           1
N#define   RTE_UART3_DMA_TX_CH           0
N//     <e> Rx
N//       <o1> Channel    <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_UART3_DMA_RX_EN           1
N#define   RTE_UART3_DMA_RX_CH           1
N//   </h> DMA
N
N// </e>
N
N// <e> CAN1 Controller [Driver_CAN1]
N// <i> Configuration settings for Driver_CAN1 in component ::Drivers:CAN
N#define   RTE_CAN_CAN1                  0
N
N//   <h> Pin Configuration
N//     <o> CAN1_RD <0=>Not used <1=>P0_0 <2=>P0_21
N//     <i> CAN1 receiver input.
N#define   RTE_CAN1_RD_ID                0
N#if      (RTE_CAN1_RD_ID == 0)
X#if      (0 == 0)
N  #define RTE_CAN1_RD_PIN_EN            0
N#elif    (RTE_CAN1_RD_ID == 1)
S  #define RTE_CAN1_RD_PORT              0
S  #define RTE_CAN1_RD_BIT               0
S  #define RTE_CAN1_RD_FUNC              1
S#elif    (RTE_CAN1_RD_ID == 2)
S  #define RTE_CAN1_RD_PORT              0
S  #define RTE_CAN1_RD_BIT               21
S  #define RTE_CAN1_RD_FUNC              3
S#else
S  #error "Invalid RTE_CAN1_RD Pin Configuration!"
N#endif
N#ifndef   RTE_CAN1_RD_PIN_EN
S  #define RTE_CAN1_RD_PIN_EN            1
N#endif
N//     <o> CAN1_TD <0=>Not used <1=>P0_1 <2=>P0_22
N//     <i> CAN1 transmitter output.
N#define   RTE_CAN1_TD_ID                0
N#if      (RTE_CAN1_TD_ID == 0)
X#if      (0 == 0)
N  #define RTE_CAN1_TD_PIN_EN            0
N#elif    (RTE_CAN1_TD_ID == 1)
S  #define RTE_CAN1_TD_PORT              0
S  #define RTE_CAN1_TD_BIT               1
S  #define RTE_CAN1_TD_FUNC              1
S#elif    (RTE_CAN1_TD_ID == 2)
S  #define RTE_CAN1_TD_PORT              0
S  #define RTE_CAN1_TD_BIT               22
S  #define RTE_CAN1_TD_FUNC              3
S#else
S  #error "Invalid RTE_CAN1_TD Pin Configuration!"
N#endif
N#ifndef   RTE_CAN1_TD_PIN_EN
S  #define RTE_CAN1_TD_PIN_EN            1
N#endif
N//   </h> Pin Configuration
N// </e> CAN1 Controller [Driver_CAN1]
N
N// <e> CAN2 Controller [Driver_CAN2]
N// <i> Configuration settings for Driver_CAN2 in component ::Drivers:CAN
N#define   RTE_CAN_CAN2                  0
N
N//   <h> Pin Configuration
N//     <o> CAN2_RD <0=>Not used <1=>P0_4 <2=>P2_7
N//     <i> CAN2 receiver input.
N#define   RTE_CAN2_RD_ID                0
N#if      (RTE_CAN2_RD_ID == 0)
X#if      (0 == 0)
N  #define RTE_CAN2_RD_PIN_EN            0
N#elif    (RTE_CAN2_RD_ID == 1)
S  #define RTE_CAN2_RD_PORT              0
S  #define RTE_CAN2_RD_BIT               4
S  #define RTE_CAN2_RD_FUNC              2
S#elif    (RTE_CAN2_RD_ID == 2)
S  #define RTE_CAN2_RD_PORT              2
S  #define RTE_CAN2_RD_BIT               7
S  #define RTE_CAN2_RD_FUNC              1
S#else
S  #error "Invalid RTE_CAN2_RD Pin Configuration!"
N#endif
N#ifndef   RTE_CAN2_RD_PIN_EN
S  #define RTE_CAN2_RD_PIN_EN            1
N#endif
N//     <o> CAN2_TD <0=>Not used <1=>P0_5 <2=>P2_8
N//     <i> CAN2 transmitter output.
N#define   RTE_CAN2_TD_ID                0
N#if      (RTE_CAN2_TD_ID == 0)
X#if      (0 == 0)
N  #define RTE_CAN2_TD_PIN_EN            0
N#elif    (RTE_CAN2_TD_ID == 1)
S  #define RTE_CAN2_TD_PORT              0
S  #define RTE_CAN2_TD_BIT               5
S  #define RTE_CAN2_TD_FUNC              2
S#elif    (RTE_CAN2_TD_ID == 2)
S  #define RTE_CAN2_TD_PORT              2
S  #define RTE_CAN2_TD_BIT               8
S  #define RTE_CAN2_TD_FUNC              1
S#else
S  #error "Invalid RTE_CAN2_TD Pin Configuration!"
N#endif
N#ifndef   RTE_CAN2_TD_PIN_EN
S  #define RTE_CAN2_TD_PIN_EN            1
N#endif
N//   </h> Pin Configuration
N// </e> CAN2 Controller [Driver_CAN2]
N
N
N// <e> SSP0 (Synchronous Serial Port 0) [Driver_SPI0]
N// <i> Configuration settings for Driver_SPI0 in component ::Drivers:SPI
N#define RTE_SSP0                        1
N
N//   <h> Pin Configuration
N//     <o> SSP0_SSEL <0=>Not used <1=>P0_16 <2=>P1_21
N//     <i> Slave Select for SSP0
N#define   RTE_SSP0_SSEL_PIN_SEL         2
N#if      (RTE_SSP0_SSEL_PIN_SEL == 0)
X#if      (2 == 0)
S#define   RTE_SSP0_SSEL_PIN_EN          0
S#elif    (RTE_SSP0_SSEL_PIN_SEL == 1)
X#elif    (2 == 1)
S  #define RTE_SSP0_SSEL_PORT            0
S  #define RTE_SSP0_SSEL_BIT             16
S  #define RTE_SSP0_SSEL_FUNC            2
N#elif    (RTE_SSP0_SSEL_PIN_SEL == 2)
X#elif    (2 == 2)
N  #define RTE_SSP0_SSEL_PORT            1
N  #define RTE_SSP0_SSEL_BIT             21
N  #define RTE_SSP0_SSEL_FUNC            3
N#else
S  #error "Invalid SSP0 SSP0_SSEL Pin Configuration!"
N#endif
N#ifndef   RTE_SSP0_SSEL_PIN_EN
N#define   RTE_SSP0_SSEL_PIN_EN          1
N#endif
N
N//     <o> SSP0_SCK <0=>P0_15 <1=>P1_20
N//     <i> Serial clock for SSP0
N#define   RTE_SSP0_SCK_PIN_SEL          1
N#if      (RTE_SSP0_SCK_PIN_SEL == 0)
X#if      (1 == 0)
S  #define RTE_SSP0_SCK_PORT             0
S  #define RTE_SSP0_SCK_BIT              15
S  #define RTE_SSP0_SCK_FUNC             2
N#elif    (RTE_SSP0_SCK_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_SSP0_SCK_PORT             1
N  #define RTE_SSP0_SCK_BIT              20
N  #define RTE_SSP0_SCK_FUNC             3
N#else
S  #error "Invalid SSP0 SSP0_SCK Pin Configuration!"
N#endif
N
N//     <o> SSP0_MISO <0=>Not used <1=>P0_17 <2=>P1_23
N//     <i> Master In Slave Out for SSP0
N#define   RTE_SSP0_MISO_PIN_SEL         2
N#if      (RTE_SSP0_MISO_PIN_SEL == 0)
X#if      (2 == 0)
S  #define RTE_SSP0_MISO_PIN_EN          0
S#elif    (RTE_SSP0_MISO_PIN_SEL == 1)
X#elif    (2 == 1)
S  #define RTE_SSP0_MISO_PORT            0
S  #define RTE_SSP0_MISO_BIT             17
S  #define RTE_SSP0_MISO_FUNC            2
N#elif    (RTE_SSP0_MISO_PIN_SEL == 2)
X#elif    (2 == 2)
N  #define RTE_SSP0_MISO_PORT            1
N  #define RTE_SSP0_MISO_BIT             23
N  #define RTE_SSP0_MISO_FUNC            3
N#else
S  #error "Invalid SSP0 SSP0_MISO Pin Configuration!"
N#endif
N#ifndef   RTE_SSP0_MISO_PIN_EN
N#define   RTE_SSP0_MISO_PIN_EN          1
N#endif
N
N//     <o> SSP0_MOSI <0=>Not used <1=>P0_18 <2=>P1_24
N//     <i> Master Out Slave In for SSP0
N#define   RTE_SSP0_MOSI_PIN_SEL         2
N#if      (RTE_SSP0_MOSI_PIN_SEL == 0)
X#if      (2 == 0)
S  #define RTE_SSP0_MOSI_PIN_EN          0
S#elif    (RTE_SSP0_MOSI_PIN_SEL == 1)
X#elif    (2 == 1)
S  #define RTE_SSP0_MOSI_PORT            0
S  #define RTE_SSP0_MOSI_BIT             18
S  #define RTE_SSP0_MOSI_FUNC            2
N#elif    (RTE_SSP0_MOSI_PIN_SEL == 2)
X#elif    (2 == 2)
N  #define RTE_SSP0_MOSI_PORT            1
N  #define RTE_SSP0_MOSI_BIT             24
N  #define RTE_SSP0_MOSI_FUNC            3
N#else
S  #error "Invalid SSP0 SSP0_MOSI Pin Configuration!"
N#endif
N#ifndef   RTE_SSP0_MOSI_PIN_EN
N#define   RTE_SSP0_MOSI_PIN_EN          1
N#endif
N
N//   </h>
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N// </e>
N#define   RTE_SSP0_DMA_TX_EN            0
N#define   RTE_SSP0_DMA_TX_CH            0
N//     <e> Rx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_SSP0_DMA_RX_EN            0
N#define   RTE_SSP0_DMA_RX_CH            1
N//   </h> DMA
N// </e>
N
N// <e> SSP1 (Synchronous Serial Port 1) [Driver_SPI1]
N// <i> Configuration settings for Driver_SPI1 in component ::Drivers:SPI
N#define RTE_SSP1                        0
N
N//   <h> Pin Configuration
N//     <o> SSP1_SSEL <0=>Not used <1=>P0_6
N//     <i> Slave Select for SSP1
N#define   RTE_SSP1_SSEL_PIN_SEL         1
N#if      (RTE_SSP1_SSEL_PIN_SEL == 0)
X#if      (1 == 0)
S  #define RTE_SSP1_SSEL_PIN_EN          0
N#elif    (RTE_SSP1_SSEL_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_SSP1_SSEL_PORT            0
N  #define RTE_SSP1_SSEL_BIT             6
N  #define RTE_SSP1_SSEL_FUNC            2
N#else
S  #error "Invalid SSP1 SSP1_SSEL Pin Configuration!"
N#endif
N#ifndef   RTE_SSP1_SSEL_PIN_EN
N#define   RTE_SSP1_SSEL_PIN_EN          1
N#endif
N
N//     <o> SSP1_SCK <0=>P0_7 <1=>P1_31
N//     <i> Serial clock for SSP1
N#define   RTE_SSP1_SCK_PIN_SEL          0
N#if      (RTE_SSP1_SCK_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SSP1_SCK_PORT             0
N  #define RTE_SSP1_SCK_BIT              7
N  #define RTE_SSP1_SCK_FUNC             2
N#elif    (RTE_SSP1_SCK_PIN_SEL == 1)
S  #define RTE_SSP1_SCK_PORT             1
S  #define RTE_SSP1_SCK_BIT              31
S  #define RTE_SSP1_SCK_FUNC             2
S#else
S  #error "Invalid SSP1 SSP1_SCK Pin Configuration!"
N#endif
N
N//     <o> SSP1_MISO <0=>Not used <1=>P0_8
N//     <i> Master In Slave Out for SSP1
N#define   RTE_SSP1_MISO_PIN_SEL         0
N#if      (RTE_SSP1_MISO_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SSP1_MISO_PIN_EN          0
N#elif    (RTE_SSP1_MISO_PIN_SEL == 1)
S  #define RTE_SSP1_MISO_PORT            0
S  #define RTE_SSP1_MISO_BIT             8
S  #define RTE_SSP1_MISO_FUNC            2
S#else
S  #error "Invalid SSP1 SSP1_MISO Pin Configuration!"
N#endif
N#ifndef   RTE_SSP1_MISO_PIN_EN
S#define   RTE_SSP1_MISO_PIN_EN          1
N#endif
N
N//     <o> SSP1_MOSI <0=>Not used <1=>P0_9
N//     <i> Master Out Slave In for SSP1
N#define   RTE_SSP1_MOSI_PIN_SEL         0
N#if      (RTE_SSP1_MOSI_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SSP1_MOSI_PIN_EN          0
N#elif    (RTE_SSP1_MOSI_PIN_SEL == 1)
S  #define RTE_SSP1_MOSI_PORT            0
S  #define RTE_SSP1_MOSI_BIT             9
S  #define RTE_SSP1_MOSI_FUNC            2
S#else
S  #error "Invalid SSP1 SSP1_MOSI Pin Configuration!"
N#endif
N#ifndef   RTE_SSP1_MOSI_PIN_EN
S#define   RTE_SSP1_MOSI_PIN_EN          1
N#endif
N
N//   </h>
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_SSP1_DMA_TX_EN            0
N#define   RTE_SSP1_DMA_TX_CH            2
N//     <e> Rx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//     </e>
N#define   RTE_SSP1_DMA_RX_EN            0
N#define   RTE_SSP1_DMA_RX_CH            3
N//   </h> DMA
N// </e>
N
N
N// <e> SPI (Serial Peripheral Interface) [Driver_SPI2]
N// <i> Configuration settings for Driver_SPI2 in component ::Drivers:SPI
N#define   RTE_SPI                       0
N
N//   <h> Pin Configuration
N//     <o> SPI_SSEL <0=>Not used <1=>P0_16
N//     <i> Slave Select for SPI
N#define   RTE_SPI_SSEL_PIN_SEL          0
N#if      (RTE_SPI_SSEL_PIN_SEL == 0)
X#if      (0 == 0)
N#define   RTE_SPI_SSEL_PIN_EN           0
N#elif    (RTE_SPI_SSEL_PIN_SEL == 1)
S  #define RTE_SPI_SSEL_PORT             0
S  #define RTE_SPI_SSEL_BIT              16
S  #define RTE_SPI_SSEL_FUNC             3
S#else
S  #error "Invalid SPI SPI_SSEL Pin Configuration!"
N#endif
N#ifndef   RTE_SPI_SSEL_PIN_EN
S#define   RTE_SPI_SSEL_PIN_EN           1
N#endif
N//     <o> SPI_SCK <0=>P0_15
N//     <i> Serial clock for SPI
N#define   RTE_SPI_SCK_PIN_SEL           0
N#if      (RTE_SPI_SCK_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SPI_SCK_PORT              0
N  #define RTE_SPI_SCK_BIT               15
N  #define RTE_SPI_SCK_FUNC              3
N#else
S  #error "Invalid SPI SPI_SCK Pin Configuration!"
N#endif
N//     <o> SPI_MISO <0=>Not used <1=>P0_17
N//     <i> Master In Slave Out for SPI
N#define   RTE_SPI_MISO_PIN_SEL          0
N#if      (RTE_SPI_MISO_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SPI_MISO_PIN_EN           0
N#elif    (RTE_SPI_MISO_PIN_SEL == 1)
S  #define RTE_SPI_MISO_PORT             0
S  #define RTE_SPI_MISO_BIT              17
S  #define RTE_SPI_MISO_FUNC             3
S#else
S  #error "Invalid SPI SPI_MISO Pin Configuration!"
N#endif
N#ifndef   RTE_SPI_MISO_PIN_EN
S#define   RTE_SPI_MISO_PIN_EN           1
N#endif
N
N//     <o> SPI_MOSI <0=>Not used <1=>P0_18
N//     <i> Master Out Slave In for SPI
N#define   RTE_SPI_MOSI_PIN_SEL          0
N#if      (RTE_SPI_MOSI_PIN_SEL == 0)
X#if      (0 == 0)
N  #define RTE_SPI_MOSI_PIN_EN           0
N#elif    (RTE_SPI_MOSI_PIN_SEL == 1)
S  #define RTE_SPI_MOSI_PORT             0
S  #define RTE_SPI_MOSI_BIT              18
S  #define RTE_SPI_MOSI_FUNC             3
S#else
S  #error "Invalid SPI SPI_MOSI Pin Configuration!"
N#endif
N#ifndef   RTE_SPI_MOSI_PIN_EN
S#define   RTE_SPI_MOSI_PIN_EN           1
N#endif
N
N//   </h> Pin Configuration
N// </e> SPI (Serial Peripheral Interface) [Driver_SPI2]
N
N
N// <e> I2S0 (Integrated Interchip Sound 0) [Driver_SAI0]
N// <i> Configuration settings for Driver_SAI0 in component ::Drivers:SAI
N#define   RTE_I2S0                      0
N
N//   <h> Pin Configuration
N//     <o> I2S0_RX_SCK <0=>Not used <1=>P0_4 <2=>P0_23
N//     <i> Receive clock for I2S0
N#define   RTE_I2S0_RX_SCK_PIN_SEL       1
N#if      (RTE_I2S0_RX_SCK_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_RX_SCK_PIN_EN        0
N#elif    (RTE_I2S0_RX_SCK_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_RX_SCK_PORT          0
N  #define RTE_I2S0_RX_SCK_BIT           4
N  #define RTE_I2S0_RX_SCK_FUNC          1
N#elif    (RTE_I2S0_RX_SCK_PIN_SEL == 2)
S  #define RTE_I2S0_RX_SCK_PORT          0
S  #define RTE_I2S0_RX_SCK_BIT           23
S  #define RTE_I2S0_RX_SCK_FUNC          2
S#else
S  #error "Invalid I2S0 I2S0_RX_SCK Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_RX_SCK_PIN_EN
N#define   RTE_I2S0_RX_SCK_PIN_EN        1
N#endif
N//     <o> I2S0_RX_WS <0=>Not used <1=>P0_5 <2=>P0_24
N//     <i> Receive word select for I2S0
N#define   RTE_I2S0_RX_WS_PIN_SEL        1
N#if      (RTE_I2S0_RX_WS_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_RX_WS_PIN_EN         0
N#elif    (RTE_I2S0_RX_WS_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_RX_WS_PORT           0
N  #define RTE_I2S0_RX_WS_BIT            5
N  #define RTE_I2S0_RX_WS_FUNC           1
N#elif    (RTE_I2S0_RX_WS_PIN_SEL == 2)
S  #define RTE_I2S0_RX_WS_PORT           0
S  #define RTE_I2S0_RX_WS_BIT            24
S  #define RTE_I2S0_RX_WS_FUNC           2
S#else
S  #error "Invalid I2S0 I2S0_RX_WS Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_RX_WS_PIN_EN
N#define   RTE_I2S0_RX_WS_PIN_EN         1
N#endif
N//     <o> I2S0_RX_SDA <0=>Not used <1=>P0_6 <2=>P0_25
N//     <i> Receive master clock for I2S0
N#define   RTE_I2S0_RX_SDA_PIN_SEL       1
N#if      (RTE_I2S0_RX_SDA_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_RX_SDA_PIN_EN        0
N#elif    (RTE_I2S0_RX_SDA_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_RX_SDA_PORT          0
N  #define RTE_I2S0_RX_SDA_BIT           6
N  #define RTE_I2S0_RX_SDA_FUNC          1
N#elif    (RTE_I2S0_RX_SDA_PIN_SEL == 2)
S  #define RTE_I2S0_RX_SDA_PORT          0
S  #define RTE_I2S0_RX_SDA_BIT           25
S  #define RTE_I2S0_RX_SDA_FUNC          2
S#else
S  #error "Invalid I2S0 I2S0_RX_SDA Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_RX_SDA_PIN_EN
N#define   RTE_I2S0_RX_SDA_PIN_EN       1
N#endif
N//     <o> I2S0_RX_MCLK <0=>Not used <1=>P4_28
N//     <i> Receive master clock for I2S0
N#define   RTE_I2S0_RX_MCLK_PIN_SEL      0
N#if      (RTE_I2S0_RX_MCLK_PIN_SEL == 0)
X#if      (0 == 0)
N#define   RTE_I2S0_RX_MCLK_PIN_EN       0
N#elif    (RTE_I2S0_RX_MCLK_PIN_SEL == 1)
S  #define RTE_I2S0_RX_MCLK_PORT         4
S  #define RTE_I2S0_RX_MCLK_BIT          28
S  #define RTE_I2S0_RX_MCLK_FUNC         1
S#else
S  #error "Invalid I2S0 I2S0_RX_MCLK Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_RX_MCLK_PIN_EN
S#define   RTE_I2S0_RX_MCLK_PIN_EN       1
N#endif
N//     <o> I2S0_TX_SCK <0=>Not used <1=>P0_7 <2=>P2_11
N//     <i> Transmit clock for I2S0
N#define   RTE_I2S0_TX_SCK_PIN_SEL       1
N#if      (RTE_I2S0_TX_SCK_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_TX_SCK_PIN_EN        0
N#elif    (RTE_I2S0_TX_SCK_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_TX_SCK_PORT          0
N  #define RTE_I2S0_TX_SCK_BIT           7
N  #define RTE_I2S0_TX_SCK_FUNC          1
N#elif    (RTE_I2S0_TX_SCK_PIN_SEL == 2)
S  #define RTE_I2S0_TX_SCK_PORT          2
S  #define RTE_I2S0_TX_SCK_BIT           11
S  #define RTE_I2S0_TX_SCK_FUNC          3
S#else
S  #error "Invalid I2S0 I2S0_TX_SCK Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_TX_SCK_PIN_EN
N#define   RTE_I2S0_TX_SCK_PIN_EN        1
N#endif
N//     <o> I2S0_TX_WS <0=>Not used <1=>P0_8 <2=>P2_12
N//     <i> Transmit word select for I2S0
N#define   RTE_I2S0_TX_WS_PIN_SEL        1
N#if      (RTE_I2S0_TX_WS_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_TX_WS_PIN_EN         0
N#elif    (RTE_I2S0_TX_WS_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_TX_WS_PORT           0
N  #define RTE_I2S0_TX_WS_BIT            8
N  #define RTE_I2S0_TX_WS_FUNC           1
N#elif    (RTE_I2S0_TX_WS_PIN_SEL == 2)
S  #define RTE_I2S0_TX_WS_PORT           2
S  #define RTE_I2S0_TX_WS_BIT            12
S  #define RTE_I2S0_TX_WS_FUNC           3
S#else
S  #error "Invalid I2S0 I2S0_TX_WS Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_TX_WS_PIN_EN
N#define   RTE_I2S0_TX_WS_PIN_EN         1
N#endif
N//     <o> I2S0_TX_SDA <0=>Not used <1=>P0_9 <2=>P2_13
N//     <i> Transmit data for I2S0
N#define   RTE_I2S0_TX_SDA_PIN_SEL       1
N#if      (RTE_I2S0_TX_SDA_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_TX_SDA_PIN_EN        0
N#elif    (RTE_I2S0_TX_SDA_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_TX_SDA_PORT          0
N  #define RTE_I2S0_TX_SDA_BIT           9
N  #define RTE_I2S0_TX_SDA_FUNC          1
N#elif    (RTE_I2S0_TX_SDA_PIN_SEL == 2)
S  #define RTE_I2S0_TX_SDA_PORT          2
S  #define RTE_I2S0_TX_SDA_BIT           13
S  #define RTE_I2S0_TX_SDA_FUNC          3
S#else
S  #error "Invalid I2S0 I2S0_TX_SDA Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_TX_SDA_PIN_EN
N#define   RTE_I2S0_TX_SDA_PIN_EN        1
N#endif
N//     <o> I2S0_TX_MCLK <0=>Not used <1=>P4_29
N//     <i> Transmit master clock for I2S0
N#define   RTE_I2S0_TX_MCLK_PIN_SEL      1
N#if      (RTE_I2S0_TX_MCLK_PIN_SEL == 0)
X#if      (1 == 0)
S#define   RTE_I2S0_TX_MCLK_PIN_EN       0
N#elif    (RTE_I2S0_TX_MCLK_PIN_SEL == 1)
X#elif    (1 == 1)
N  #define RTE_I2S0_TX_MCLK_PORT         4
N  #define RTE_I2S0_TX_MCLK_BIT          29
N  #define RTE_I2S0_TX_MCLK_FUNC         1
N#else
S  #error "Invalid I2S0 I2S0_TX_MCLK Pin Configuration!"
N#endif
N#ifndef   RTE_I2S0_TX_MCLK_PIN_EN
N#define   RTE_I2S0_TX_MCLK_PIN_EN       1
N#endif
N//   </h> Pin Configuration
N
N//   <h> DMA
N//     <e> Tx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//       <o2> Peripheral  <0=>9 (DMAMUXPER9)
N//     </e>
N#define   RTE_I2S0_DMA_TX_EN            1
N#define   RTE_I2S0_DMA_TX_CH            0
N//     <e> Rx
N//       <o1> Channel     <0=>0 <1=>1 <2=>2 <3=>3 <4=>4 <5=>5 <6=>6 <7=>7
N//       <o2> Peripheral  <0=>10 (DMAMUXPER10)
N//     </e>
N#define   RTE_I2S0_DMA_RX_EN            1
N#define   RTE_I2S0_DMA_RX_CH            1
N//   </h> DMA
N// </e> I2S0 (Integrated Interchip Sound 0) [Driver_SAI0]
N
N#endif  /* __RTE_DEVICE_H */
L 34 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N#include "RTE_Components.h"
L 1 ".\RTE\_Main\RTE_Components.h" 1
N
N
N/*
N
N * Auto generated Run-Time-Environment Configuration File
N
N *      *** Do not modify ! ***
N
N *
N
N * Project: 'main' 
N
N * Target:  'Main' 
N
N */
N
N
N
N#ifndef RTE_COMPONENTS_H
N
N#define RTE_COMPONENTS_H
N
N
N
N
N
N/*
N
N * Define the Device Header File: 
N
N */
N
N#define CMSIS_device_header "LPC17xx.h"
N
N
N
N/* ARM::CMSIS:RTOS:Keil RTX:4.82.0 */
N
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N
N/* Keil.ARM Compiler::Compiler:I/O:File:File System:1.2.0 */
N
N#define RTE_Compiler_IO_File            /* Compiler I/O: File */
N
N          #define RTE_Compiler_IO_File_FS         /* Compiler I/O: File (File System) */
N
N/* Keil.MDK-Plus::File System:CORE:LFN:6.13.8 */
N
N#define RTE_FileSystem_Core             /* File System Core */
N
N          #define RTE_FileSystem_LFN              /* File System with Long Filename support */
N
N          #define RTE_FileSystem_Release          /* File System Release Version */
N
N/* Keil.MDK-Plus::File System:Drive:Memory Card:6.13.8 */
N
N#define RTE_FileSystem_Drive_MC_0       /* File System Memory Card Drive 0 */
N
N
N
N/* Keil.MDK-Plus::Network:CORE:IPv4 Release:7.14.0 */
N
N#define RTE_Network_Core                /* Network Core */
N
N          #define RTE_Network_IPv4                /* Network IPv4 Stack */
N
N          #define RTE_Network_Release             /* Network Release Version */
N
N/* Keil.MDK-Plus::Network:Interface:ETH:7.14.0 */
N
N#define RTE_Network_Interface_ETH_0     /* Network Interface ETH 0 */
N
N
N
N/* Keil.MDK-Plus::Network:Socket:TCP:7.14.0 */
N
N#define RTE_Network_Socket_TCP          /* Network Socket TCP */
N
N/* Keil::CMSIS Driver:Ethernet MAC:2.12.0 */
N
N#define RTE_Drivers_ETH_MAC0            /* Driver ETH_MAC0 */
N
N/* Keil::CMSIS Driver:Ethernet PHY:DP83848C:6.2.0 */
N
N#define RTE_Drivers_PHY_DP83848C        /* Driver PHY DP83848C */
N
N/* Keil::CMSIS Driver:SPI:SSP:2.7.0 */
N
N#define RTE_Drivers_SPI0                /* Driver SPI0 */
N
N        #define RTE_Drivers_SPI1                /* Driver SPI1 */
N
N/* Keil::Device:Startup:1.0.0 */
N
N#define RTE_DEVICE_STARTUP_LPC17XX      /* Device Startup for NXP17XX */
N
N
N
N
N
N#endif /* RTE_COMPONENTS_H */
N
L 35 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N
N#if       defined(RTE_CMSIS_RTOS2)
X#if       0L
S#include "cmsis_os2.h"
N#elif     defined(RTE_CMSIS_RTOS)
X#elif     1L
N#include "cmsis_os.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\RTOS\RTX\INC\cmsis_os.h" 1
N/* ----------------------------------------------------------------------
N * $Date:        5. February 2013
N * $Revision:    V1.02
N *
N * Project:      CMSIS-RTOS API
N * Title:        cmsis_os.h RTX header file
N *
N * Version 0.02
N *    Initial Proposal Phase
N * Version 0.03
N *    osKernelStart added, optional feature: main started as thread
N *    osSemaphores have standard behavior
N *    osTimerCreate does not start the timer, added osTimerStart
N *    osThreadPass is renamed to osThreadYield
N * Version 1.01
N *    Support for C++ interface
N *     - const attribute removed from the osXxxxDef_t typedef's
N *     - const attribute added to the osXxxxDef macros
N *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
N *    Added: osKernelInitialize
N * Version 1.02
N *    Control functions for short timeouts in microsecond resolution:
N *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
N *    Removed: osSignalGet 
N *----------------------------------------------------------------------------
N *
N * Copyright (c) 2013-2017 ARM LIMITED. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *---------------------------------------------------------------------------*/
N
N
N#ifndef _CMSIS_OS_H
N#define _CMSIS_OS_H
N
N#define osCMSIS           0x10002U     ///< CMSIS-RTOS API version (main [31:16] .sub [15:0])
N
N#define osCMSIS_RTX     ((4<<16)|82)   ///< RTOS identification and version (main [31:16] .sub [15:0])
N
N#define osKernelSystemId "RTX V4.82"   ///< RTOS identification string
N
N
N#define osFeature_MainThread   1       ///< main can be thread
N#define osFeature_Pool         1       ///< Memory Pools available
N#define osFeature_MailQ        1       ///< Mail Queues available
N#define osFeature_MessageQ     1       ///< Message Queues available
N#define osFeature_Signals      16      ///< 16 Signal Flags available per thread
N#define osFeature_Semaphore    65535   ///< Maximum count for \ref osSemaphoreCreate function
N#define osFeature_Wait         0       ///< osWait not available
N#define osFeature_SysTick      1       ///< osKernelSysTick functions available
N
N#if defined(__CC_ARM)
X#if 1L
N#define os_InRegs __value_in_regs      // Compiler specific: force struct in registers
N#else
S#define os_InRegs
N#endif
N
N#if   defined(__CC_ARM)
X#if   1L
N#define __NO_RETURN __declspec(noreturn)
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__GNUC__)
S#define __NO_RETURN __attribute__((noreturn))
S#elif defined(__ICCARM__)
S#define __NO_RETURN __noreturn
S#else
S#define __NO_RETURN
N#endif
N
N#include <stdint.h>
N#include <stddef.h>
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N
N// ==== Enumeration, structures, defines ====
N
N/// Priority used for thread control.
Ntypedef enum  {
N  osPriorityIdle          = -3,          ///< priority: idle (lowest)
N  osPriorityLow           = -2,          ///< priority: low
N  osPriorityBelowNormal   = -1,          ///< priority: below normal
N  osPriorityNormal        =  0,          ///< priority: normal (default)
N  osPriorityAboveNormal   = +1,          ///< priority: above normal
N  osPriorityHigh          = +2,          ///< priority: high
N  osPriorityRealtime      = +3,          ///< priority: realtime (highest)
N  osPriorityError         =  0x84,       ///< system cannot determine priority or thread has illegal priority
N  os_priority_reserved    =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osPriority;
N
N/// Timeout value.
N#define osWaitForever     0xFFFFFFFFU    ///< wait forever timeout value
N
N/// Status code values returned by CMSIS-RTOS functions.
Ntypedef enum  {
N  osOK                    =     0,       ///< function completed; no error or event occurred.
N  osEventSignal           =  0x08,       ///< function completed; signal event occurred.
N  osEventMessage          =  0x10,       ///< function completed; message event occurred.
N  osEventMail             =  0x20,       ///< function completed; mail event occurred.
N  osEventTimeout          =  0x40,       ///< function completed; timeout occurred.
N  osErrorParameter        =  0x80,       ///< parameter error: a mandatory parameter was missing or specified an incorrect object.
N  osErrorResource         =  0x81,       ///< resource not available: a specified resource was not available.
N  osErrorTimeoutResource  =  0xC1,       ///< resource not available within given time: a specified resource was not available within the timeout period.
N  osErrorISR              =  0x82,       ///< not allowed in ISR context: the function cannot be called from interrupt service routines.
N  osErrorISRRecursive     =  0x83,       ///< function called multiple times from ISR with same object.
N  osErrorPriority         =  0x84,       ///< system cannot determine priority or thread has illegal priority.
N  osErrorNoMemory         =  0x85,       ///< system is out of memory: it was impossible to allocate or reserve memory for the operation.
N  osErrorValue            =  0x86,       ///< value of a parameter is out of range.
N  osErrorOS               =  0xFF,       ///< unspecified RTOS error: run-time error but no other error message fits.
N  os_status_reserved      =  0x7FFFFFFF  ///< prevent from enum down-size compiler optimization.
N} osStatus;
N
N
N/// Timer type value for the timer definition.
Ntypedef enum  {
N  osTimerOnce             =     0,       ///< one-shot timer
N  osTimerPeriodic         =     1        ///< repeating timer
N} os_timer_type;
N
N/// Entry point of a thread.
Ntypedef void (*os_pthread) (void const *argument);
N
N/// Entry point of a timer call back function.
Ntypedef void (*os_ptimer) (void const *argument);
N
N// >>> the following data type definitions may shall adapted towards a specific RTOS
N
N/// Thread ID identifies the thread (pointer to a thread control block).
Ntypedef struct os_thread_cb *osThreadId;
N
N/// Timer ID identifies the timer (pointer to a timer control block).
Ntypedef struct os_timer_cb *osTimerId;
N
N/// Mutex ID identifies the mutex (pointer to a mutex control block).
Ntypedef struct os_mutex_cb *osMutexId;
N
N/// Semaphore ID identifies the semaphore (pointer to a semaphore control block).
Ntypedef struct os_semaphore_cb *osSemaphoreId;
N
N/// Pool ID identifies the memory pool (pointer to a memory pool control block).
Ntypedef struct os_pool_cb *osPoolId;
N
N/// Message ID identifies the message queue (pointer to a message queue control block).
Ntypedef struct os_messageQ_cb *osMessageQId;
N
N/// Mail ID identifies the mail queue (pointer to a mail queue control block).
Ntypedef struct os_mailQ_cb *osMailQId;
N
N
N/// Thread Definition structure contains startup information of a thread.
Ntypedef struct os_thread_def  {
N  os_pthread               pthread;    ///< start address of thread function
N  osPriority             tpriority;    ///< initial thread priority
N  uint32_t               instances;    ///< maximum number of instances of that thread function
N  uint32_t               stacksize;    ///< stack size requirements in bytes; 0 is default stack size
N} osThreadDef_t;
N
N/// Timer Definition structure contains timer parameters.
Ntypedef struct os_timer_def  {
N  os_ptimer                 ptimer;    ///< start address of a timer function
N  void                      *timer;    ///< pointer to internal data
N} osTimerDef_t;
N
N/// Mutex Definition structure contains setup information for a mutex.
Ntypedef struct os_mutex_def  {
N  void                      *mutex;    ///< pointer to internal data
N} osMutexDef_t;
N
N/// Semaphore Definition structure contains setup information for a semaphore.
Ntypedef struct os_semaphore_def  {
N  void                  *semaphore;    ///< pointer to internal data
N} osSemaphoreDef_t;
N
N/// Definition structure for memory block allocation.
Ntypedef struct os_pool_def  {
N  uint32_t                 pool_sz;    ///< number of items (elements) in the pool
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< pointer to memory for pool
N} osPoolDef_t;
N
N/// Definition structure for message queue.
Ntypedef struct os_messageQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  void                       *pool;    ///< memory array for messages
N} osMessageQDef_t;
N
N/// Definition structure for mail queue.
Ntypedef struct os_mailQ_def  {
N  uint32_t                queue_sz;    ///< number of elements in the queue
N  uint32_t                 item_sz;    ///< size of an item
N  void                       *pool;    ///< memory array for mail
N} osMailQDef_t;
N
N/// Event structure contains detailed information about an event.
Ntypedef struct  {
N  osStatus                 status;     ///< status code: event or error information
N  union  {
N    uint32_t                    v;     ///< message as 32-bit value
N    void                       *p;     ///< message or mail as void pointer
N    int32_t               signals;     ///< signal flags
N  } value;                             ///< event value
N  union  {
N    osMailQId             mail_id;     ///< mail id obtained by \ref osMailCreate
N    osMessageQId       message_id;     ///< message id obtained by \ref osMessageCreate
N  } def;                               ///< event definition
N} osEvent;
N
N
N//  ==== Kernel Control Functions ====
N
N/// Initialize the RTOS Kernel for creating objects.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelInitialize (void);
N
N/// Start the RTOS Kernel.
N/// \return status code that indicates the execution status of the function.
NosStatus osKernelStart (void);
N
N/// Check if the RTOS kernel is already started.
N/// \return 0 RTOS is not started, 1 RTOS is started.
Nint32_t osKernelRunning(void);
N
N#if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
X#if (1L  &&  (1 != 0))     
N
N/// \cond INTERNAL_VARIABLES
Nextern uint32_t const os_tickfreq;
Nextern uint16_t const os_tickus_i;
Nextern uint16_t const os_tickus_f;
N/// \endcond
N
N/// Get the RTOS kernel system timer counter.
N/// \return RTOS kernel system timer as 32-bit value 
Nuint32_t osKernelSysTick (void);
N
N/// The RTOS kernel system timer frequency in Hz.
N/// \note Reflects the system timer setting and is typically defined in a configuration file.
N#define osKernelSysTickFrequency os_tickfreq
N
N/// Convert a microseconds value to a RTOS kernel system timer value.
N/// \param         microsec     time value in microseconds.
N/// \return time value normalized to the \ref osKernelSysTickFrequency
N/*
N#define osKernelSysTickMicroSec(microsec) (((uint64_t)microsec * (osKernelSysTickFrequency)) / 1000000)
N*/
N#define osKernelSysTickMicroSec(microsec) ((microsec * os_tickus_i) + ((microsec * os_tickus_f) >> 16))
N
N#endif    // System Timer available
N
N//  ==== Thread Management ====
N
N/// Create a Thread Definition with function, priority, and stack requirements.
N/// \param         name         name of the thread function.
N/// \param         priority     initial priority of the thread function.
N/// \param         instances    number of possible thread instances.
N/// \param         stacksz      stack size (in bytes) requirements for the thread function.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osThreadDef(name, priority, instances, stacksz)  \
Sextern const osThreadDef_t os_thread_def_##name
X#define osThreadDef(name, priority, instances, stacksz)  extern const osThreadDef_t os_thread_def_##name
N#else                            // define the object
N#define osThreadDef(name, priority, instances, stacksz)  \
Nconst osThreadDef_t os_thread_def_##name = \
N{ (name), (priority), (instances), (stacksz)  }
X#define osThreadDef(name, priority, instances, stacksz)  const osThreadDef_t os_thread_def_##name = { (name), (priority), (instances), (stacksz)  }
N#endif
N
N/// Access a Thread definition.
N/// \param         name          name of the thread definition object.
N///       macro body is implementation specific in every CMSIS-RTOS.
N#define osThread(name)  \
N&os_thread_def_##name
X#define osThread(name)  &os_thread_def_##name
N
N/// Create a thread and add it to Active Threads and set it to state READY.
N/// \param[in]     thread_def    thread definition referenced with \ref osThread.
N/// \param[in]     argument      pointer that is passed to the thread function as start argument.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument);
N
N/// Return the thread ID of the current running thread.
N/// \return thread ID for reference by other functions or NULL in case of error.
NosThreadId osThreadGetId (void);
N
N/// Terminate execution of a thread and remove it from Active Threads.
N/// \param[in]     thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadTerminate (osThreadId thread_id);
N
N/// Pass control to next thread that is in state \b READY.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadYield (void);
N
N/// Change priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     priority      new priority value for the thread function.
N/// \return status code that indicates the execution status of the function.
NosStatus osThreadSetPriority (osThreadId thread_id, osPriority priority);
N
N/// Get current priority of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \return current priority value of the thread function.
NosPriority osThreadGetPriority (osThreadId thread_id);
N
N
N//  ==== Generic Wait Functions ====
N
N/// Wait for Timeout (Time Delay).
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value
N/// \return status code that indicates the execution status of the function.
NosStatus osDelay (uint32_t millisec);
N
N#if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0))     // Generic Wait available
X#if (1L  &&  (0 != 0))     
S
S/// Wait for Signal, Message, Mail, or Timeout.
S/// \param[in] millisec          \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
S/// \return event that contains signal, message, or mail information or error code.
Sos_InRegs osEvent osWait (uint32_t millisec);
S
N#endif  // Generic Wait available
N
N
N//  ==== Timer Management Functions ====
N/// Define a Timer object.
N/// \param         name          name of the timer object.
N/// \param         function      name of the timer call back function.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osTimerDef(name, function)  \
Sextern const osTimerDef_t os_timer_def_##name
X#define osTimerDef(name, function)  extern const osTimerDef_t os_timer_def_##name
N#else                            // define the object
N#define osTimerDef(name, function)  \
Nuint32_t os_timer_cb_##name[6]; \
Nconst osTimerDef_t os_timer_def_##name = \
N{ (function), (os_timer_cb_##name) }
X#define osTimerDef(name, function)  uint32_t os_timer_cb_##name[6]; const osTimerDef_t os_timer_def_##name = { (function), (os_timer_cb_##name) }
N#endif
N
N/// Access a Timer definition.
N/// \param         name          name of the timer object.
N#define osTimer(name) \
N&os_timer_def_##name
X#define osTimer(name) &os_timer_def_##name
N
N/// Create a timer.
N/// \param[in]     timer_def     timer object referenced with \ref osTimer.
N/// \param[in]     type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
N/// \param[in]     argument      argument to the timer call back function.
N/// \return timer ID for reference by other functions or NULL in case of error.
NosTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument);
N
N/// Start or restart a timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue "Time delay" value of the timer.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStart (osTimerId timer_id, uint32_t millisec);
N
N/// Stop the timer.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerStop (osTimerId timer_id);
N
N/// Delete a timer that was created by \ref osTimerCreate.
N/// \param[in]     timer_id      timer ID obtained by \ref osTimerCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osTimerDelete (osTimerId timer_id);
N
N
N//  ==== Signal Management ====
N
N/// Set the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that should be set.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
Nint32_t osSignalSet (osThreadId thread_id, int32_t signals);
N
N/// Clear the specified Signal Flags of an active thread.
N/// \param[in]     thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
N/// \param[in]     signals       specifies the signal flags of the thread that shall be cleared.
N/// \return previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters or call from ISR.
Nint32_t osSignalClear (osThreadId thread_id, int32_t signals);
N
N/// Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
N/// \param[in]     signals       wait until all specified signal flags set or 0 for any single signal flag.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event flag information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osSignalWait __osSignalWait
SosEvent __osSignalWait (int32_t signals, uint32_t millisec);
N#else
Nos_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec);
X__value_in_regs osEvent osSignalWait (int32_t signals, uint32_t millisec);
N#endif
N
N
N//  ==== Mutex Management ====
N
N/// Define a Mutex.
N/// \param         name          name of the mutex object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMutexDef(name)  \
Sextern const osMutexDef_t os_mutex_def_##name
X#define osMutexDef(name)  extern const osMutexDef_t os_mutex_def_##name
N#else                            // define the object
N#define osMutexDef(name)  \
Nuint32_t os_mutex_cb_##name[4] = { 0 }; \
Nconst osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
X#define osMutexDef(name)  uint32_t os_mutex_cb_##name[4] = { 0 }; const osMutexDef_t os_mutex_def_##name = { (os_mutex_cb_##name) }
N#endif
N
N/// Access a Mutex definition.
N/// \param         name          name of the mutex object.
N#define osMutex(name)  \
N&os_mutex_def_##name
X#define osMutex(name)  &os_mutex_def_##name
N
N/// Create and Initialize a Mutex object.
N/// \param[in]     mutex_def     mutex definition referenced with \ref osMutex.
N/// \return mutex ID for reference by other functions or NULL in case of error.
NosMutexId osMutexCreate (const osMutexDef_t *mutex_def);
N
N/// Wait until a Mutex becomes available.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexWait (osMutexId mutex_id, uint32_t millisec);
N
N/// Release a Mutex that was obtained by \ref osMutexWait.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexRelease (osMutexId mutex_id);
N
N/// Delete a Mutex that was created by \ref osMutexCreate.
N/// \param[in]     mutex_id      mutex ID obtained by \ref osMutexCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osMutexDelete (osMutexId mutex_id);
N
N
N//  ==== Semaphore Management Functions ====
N
N#if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))     // Semaphore available
X#if (1L  &&  (65535 != 0))     
N
N/// Define a Semaphore object.
N/// \param         name          name of the semaphore object.
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osSemaphoreDef(name)  \
Sextern const osSemaphoreDef_t os_semaphore_def_##name
X#define osSemaphoreDef(name)  extern const osSemaphoreDef_t os_semaphore_def_##name
N#else                            // define the object
N#define osSemaphoreDef(name)  \
Nuint32_t os_semaphore_cb_##name[2] = { 0 }; \
Nconst osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
X#define osSemaphoreDef(name)  uint32_t os_semaphore_cb_##name[2] = { 0 }; const osSemaphoreDef_t os_semaphore_def_##name = { (os_semaphore_cb_##name) }
N#endif
N
N/// Access a Semaphore definition.
N/// \param         name          name of the semaphore object.
N#define osSemaphore(name)  \
N&os_semaphore_def_##name
X#define osSemaphore(name)  &os_semaphore_def_##name
N
N/// Create and Initialize a Semaphore object used for managing resources.
N/// \param[in]     semaphore_def semaphore definition referenced with \ref osSemaphore.
N/// \param[in]     count         number of available resources.
N/// \return semaphore ID for reference by other functions or NULL in case of error.
NosSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count);
N
N/// Wait until a Semaphore token becomes available.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return number of available tokens, or -1 in case of incorrect parameters.
Nint32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec);
N
N/// Release a Semaphore token.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreRelease (osSemaphoreId semaphore_id);
N
N/// Delete a Semaphore that was created by \ref osSemaphoreCreate.
N/// \param[in]     semaphore_id  semaphore object referenced with \ref osSemaphoreCreate.
N/// \return status code that indicates the execution status of the function.
NosStatus osSemaphoreDelete (osSemaphoreId semaphore_id);
N
N#endif     // Semaphore available
N
N
N//  ==== Memory Pool Management Functions ====
N
N#if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0))  // Memory Pool Management available
X#if (1L  &&  (1 != 0))  
N
N/// \brief Define a Memory Pool.
N/// \param         name          name of the memory pool.
N/// \param         no            maximum number of blocks (objects) in the memory pool.
N/// \param         type          data type of a single block (object).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osPoolDef(name, no, type)   \
Sextern const osPoolDef_t os_pool_def_##name
X#define osPoolDef(name, no, type)   extern const osPoolDef_t os_pool_def_##name
N#else                            // define the object
N#define osPoolDef(name, no, type)   \
Nuint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; \
Nconst osPoolDef_t os_pool_def_##name = \
N{ (no), sizeof(type), (os_pool_m_##name) }
X#define osPoolDef(name, no, type)   uint32_t os_pool_m_##name[3+((sizeof(type)+3)/4)*(no)]; const osPoolDef_t os_pool_def_##name = { (no), sizeof(type), (os_pool_m_##name) }
N#endif
N
N/// \brief Access a Memory Pool definition.
N/// \param         name          name of the memory pool
N#define osPool(name) \
N&os_pool_def_##name
X#define osPool(name) &os_pool_def_##name
N
N/// Create and Initialize a memory pool.
N/// \param[in]     pool_def      memory pool definition referenced with \ref osPool.
N/// \return memory pool ID for reference by other functions or NULL in case of error.
NosPoolId osPoolCreate (const osPoolDef_t *pool_def);
N
N/// Allocate a memory block from a memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolAlloc (osPoolId pool_id);
N
N/// Allocate a memory block from a memory pool and set memory block to zero.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \return address of the allocated memory block or NULL in case of no memory available.
Nvoid *osPoolCAlloc (osPoolId pool_id);
N
N/// Return an allocated memory block back to a specific memory pool.
N/// \param[in]     pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
N/// \param[in]     block         address of the allocated memory block that is returned to the memory pool.
N/// \return status code that indicates the execution status of the function.
NosStatus osPoolFree (osPoolId pool_id, void *block);
N
N#endif   // Memory Pool Management available
N
N
N//  ==== Message Queue Management Functions ====
N
N#if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0))     // Message Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Message Queue Definition.
N/// \param         name          name of the queue.
N/// \param         queue_sz      maximum number of messages in the queue.
N/// \param         type          data type of a single message element (for debugger).
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMessageQDef(name, queue_sz, type)   \
Sextern const osMessageQDef_t os_messageQ_def_##name
X#define osMessageQDef(name, queue_sz, type)   extern const osMessageQDef_t os_messageQ_def_##name
N#else                            // define the object
N#define osMessageQDef(name, queue_sz, type)   \
Nuint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; \
Nconst osMessageQDef_t os_messageQ_def_##name = \
N{ (queue_sz), (os_messageQ_q_##name) }
X#define osMessageQDef(name, queue_sz, type)   uint32_t os_messageQ_q_##name[4+(queue_sz)] = { 0 }; const osMessageQDef_t os_messageQ_def_##name = { (queue_sz), (os_messageQ_q_##name) }
N#endif
N
N/// \brief Access a Message Queue Definition.
N/// \param         name          name of the queue
N#define osMessageQ(name) \
N&os_messageQ_def_##name
X#define osMessageQ(name) &os_messageQ_def_##name
N
N/// Create and Initialize a Message Queue.
N/// \param[in]     queue_def     queue definition referenced with \ref osMessageQ.
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return message queue ID for reference by other functions or NULL in case of error.
NosMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id);
N
N/// Put a Message to a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     info          message information.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return status code that indicates the execution status of the function.
NosStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec);
N
N/// Get a Message or Wait for a Message from a Queue.
N/// \param[in]     queue_id      message queue ID obtained with \ref osMessageCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out.
N/// \return event information that includes status code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osMessageGet __osMessageGet
SosEvent __osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec);
N#endif
N
N#endif     // Message Queues available
N
N
N//  ==== Mail Queue Management Functions ====
N
N#if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))     // Mail Queues available
X#if (1L  &&  (1 != 0))     
N
N/// \brief Create a Mail Queue Definition.
N/// \param         name          name of the queue
N/// \param         queue_sz      maximum number of messages in queue
N/// \param         type          data type of a single message element
N#if defined (osObjectsExternal)  // object is external
X#if 0L  
S#define osMailQDef(name, queue_sz, type) \
Sextern const osMailQDef_t os_mailQ_def_##name
X#define osMailQDef(name, queue_sz, type) extern const osMailQDef_t os_mailQ_def_##name
N#else                            // define the object
N#define osMailQDef(name, queue_sz, type) \
Nuint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; \
Nuint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; \
Nvoid *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; \
Nconst osMailQDef_t os_mailQ_def_##name =  \
N{ (queue_sz), sizeof(type), (os_mailQ_p_##name) }
X#define osMailQDef(name, queue_sz, type) uint32_t os_mailQ_q_##name[4+(queue_sz)] = { 0 }; uint32_t os_mailQ_m_##name[3+((sizeof(type)+3)/4)*(queue_sz)]; void *   os_mailQ_p_##name[2] = { (os_mailQ_q_##name), os_mailQ_m_##name }; const osMailQDef_t os_mailQ_def_##name =  { (queue_sz), sizeof(type), (os_mailQ_p_##name) }
N#endif
N
N/// \brief Access a Mail Queue Definition.
N/// \param         name          name of the queue
N#define osMailQ(name)  \
N&os_mailQ_def_##name
X#define osMailQ(name)  &os_mailQ_def_##name
N
N/// Create and Initialize mail queue.
N/// \param[in]     queue_def     reference to the mail queue definition obtain with \ref osMailQ
N/// \param[in]     thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
N/// \return mail queue ID for reference by other functions or NULL in case of error.
NosMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id);
N
N/// Allocate a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Allocate a memory block from a mail and set memory block to zero.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return pointer to memory block that can be filled with mail or NULL in case of error.
Nvoid *osMailCAlloc (osMailQId queue_id, uint32_t millisec);
N
N/// Put a mail to a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailPut (osMailQId queue_id, void *mail);
N
N/// Get a mail from a queue.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     millisec      \ref CMSIS_RTOS_TimeOutValue or 0 in case of no time-out
N/// \return event that contains mail information or error code.
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#if 1L && (5060960 >= 6010050)
S#define   osMailGet __osMailGet
SosEvent __osMailGet (osMailQId queue_id, uint32_t millisec);
N#else
Nos_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
X__value_in_regs osEvent osMailGet (osMailQId queue_id, uint32_t millisec);
N#endif
N
N/// Free a memory block from a mail.
N/// \param[in]     queue_id      mail queue ID obtained with \ref osMailCreate.
N/// \param[in]     mail          pointer to the memory block that was obtained with \ref osMailGet.
N/// \return status code that indicates the execution status of the function.
NosStatus osMailFree (osMailQId queue_id, void *mail);
N
N#endif  // Mail Queues available
N
N
N//  ==== RTX Extensions ====
N
N/// Suspend the RTX task scheduler.
N/// \return number of ticks, for how long the system can sleep or power-down.
Nuint32_t os_suspend (void);
N
N/// Resume the RTX task scheduler.
N/// \param[in]     sleep_time    specifies how long the system was in sleep or power-down mode.
Nvoid os_resume (uint32_t sleep_time);
N
N/// OS idle demon (running when no other thread is ready to run).
N__NO_RETURN void os_idle_demon (void);
X__declspec(noreturn) void os_idle_demon (void);
N
N/// OS error callback (called when a runtime error is detected).
N/// \param[in]     error_code    actual error code that has been detected.
N__NO_RETURN void os_error (uint32_t error_code);
X__declspec(noreturn) void os_error (uint32_t error_code);
N
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif  // _CMSIS_OS_H
L 40 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N#endif
N
N#if defined (LPC175x_6x)
X#if 1L
N  #include "LPC17xx.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include\LPC17xx.h" 1
N/**************************************************************************//**
N * @file     LPC17xx.h
N * @brief    CMSIS Cortex-M3 Device Peripheral Access Layer Header File for
N *           NXP LPC17xx Device Series
N * @version  V1.10
N * @date     06. April 2011
N *
N * @note
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N *                                                            modified by Keil
N******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
N/** @addtogroup LPC17xx_System
N * @{
N */
N
N/** @brief IRQ interrupt source definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  Reset_IRQn                    = -15,      /*!< 1 Reset Vector, invoked on PowerUp and warm reset*/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  HardFault_IRQn                = -13,      /*!< 3  Hard Fault, all classes of Fault              */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity Interrupt 						  */
N  CANActivity_IRQn              = 34,       /*!< CAN Activity Interrupt 						  */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V5.1.1
N * @date     27. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M3
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.4
N * @date     23. July 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 4U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm3.h" 2
N
N/* CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM3_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16U) |                                     __CM3_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (3U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.2.1
N * @date     26. March 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (0L && (__TARGET_ARCH_6S_M  == 1))   )
S  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (1L && (1  == 1))
N  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N  /* __ARM_ARCH_8_1M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
S  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   Enable FIQ
N  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/**
N  \brief   Disable FIQ
N  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/**
N  \brief   Get Base Priority
N  \details Returns the current value of the Base Priority register.
N  \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/**
N  \brief   Set Base Priority
N  \details Assigns the given value to the Base Priority register.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Set Base Priority with condition
N  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N           or the new value increases the BASEPRI priority level.
N  \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xFFU);
N}
N
N
N/**
N  \brief   Get Fault Mask
N  \details Returns the current value of the Fault Mask register.
N  \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/**
N  \brief   Set Fault Mask
N  \details Assigns the given value to the Fault Mask register.
N  \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1U);
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
S
S  result = value;                      /* r will be reversed bits of v; first get LSB of v */
S  for (value >>= 1U; value != 0U; value >>= 1U)
S  {
S    result <<= 1U;
S    result |= value & 1U;
S    s--;
S  }
S  result <<= s;                        /* shift when v's highest bits are zero */
S  return result;
S}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((1L && (1  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
N
N/**
N  \brief   LDR Exclusive (8 bit)
N  \details Executes a exclusive LDR instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
N#else
N  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (16 bit)
N  \details Executes a exclusive LDR instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
N#else
N  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   LDR Exclusive (32 bit)
N  \details Executes a exclusive LDR instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
N#else
N  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (8 bit)
N  \details Executes a exclusive STR instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (16 bit)
N  \details Executes a exclusive STR instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   STR Exclusive (32 bit)
N  \details Executes a exclusive STR instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N  \return          0  Function succeeded
N  \return          1  Function failed
N */
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
X#if 1L && (5060960 < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
N#else
N  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
N#endif
N
N
N/**
N  \brief   Remove the exclusive lock
N  \details Removes the exclusive lock which is created by LDREX.
N */
N#define __CLREX                           __clrex
N
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/**
N  \brief   Rotate Right with Extend (32 bit)
N  \details Moves each bit of a bitstring right by one bit.
N           The carry input is shifted in at the left end of the bitstring.
N  \param [in]    value  Value to rotate
N  \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   LDRT Unprivileged (8 bit)
N  \details Executes a Unprivileged LDRT instruction for 8 bit value.
N  \param [in]    ptr  Pointer to data
N  \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (16 bit)
N  \details Executes a Unprivileged LDRT instruction for 16 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/**
N  \brief   LDRT Unprivileged (32 bit)
N  \details Executes a Unprivileged LDRT instruction for 32 bit values.
N  \param [in]    ptr  Pointer to data
N  \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/**
N  \brief   STRT Unprivileged (8 bit)
N  \details Executes a Unprivileged STRT instruction for 8 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (16 bit)
N  \details Executes a Unprivileged STRT instruction for 16 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/**
N  \brief   STRT Unprivileged (32 bit)
N  \details Executes a Unprivileged STRT instruction for 32 bit values.
N  \param [in]  value  Value to store
N  \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
S{
S  if ((sat >= 1U) && (sat <= 32U))
S  {
S    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
S    const int32_t min = -1 - max ;
S    if (val > max)
S    {
S      return max;
S    }
S    else if (val < min)
S    {
S      return min;
S    }
S  }
S  return val;
S}
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
S{
S  if (sat <= 31U)
S  {
S    const uint32_t max = ((1U << sat) - 1U);
S    if (val > (int32_t)max)
S    {
S      return max;
S    }
S    else if (val < 0)
S    {
S      return 0U;
S    }
S  }
S  return (uint32_t)val;
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
S#define __SXTB16_RORn(ARG1, ARG2)        __SXTB16(__ROR(ARG1, ARG2))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm3.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200U
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT             1U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S  
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          3U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
N    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
N    uint32_t _reserved1:8;               /*!< bit: 16..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
N    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
N#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
N#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[8U];                
N        uint32_t RESERVED0[24U];
N  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[8U];                
N        uint32_t RESERVED1[24U];
N  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[8U];                
N        uint32_t RESERVED2[24U];
N  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[8U];                
N        uint32_t RESERVED3[24U];
N  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
X  volatile uint32_t IABR[8U];                
N        uint32_t RESERVED4[56U];
N  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240U];                
N        uint32_t RESERVED5[644U];
N  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
X  volatile  uint32_t STIR;                    
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12U];                
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
X  volatile uint32_t CFSR;                    
N  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
X  volatile uint32_t HFSR;                    
N  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
X  volatile uint32_t DFSR;                    
N  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
X  volatile uint32_t MMFAR;                   
N  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
X  volatile uint32_t BFAR;                    
N  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
X  volatile uint32_t AFSR;                    
N  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
X  volatile const  uint32_t PFR[2U];                 
N  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
X  volatile const  uint32_t DFR;                     
N  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
X  volatile const  uint32_t ADR;                     
N  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
X  volatile const  uint32_t MMFR[4U];                
N  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
X  volatile const  uint32_t ISAR[5U];                
N        uint32_t RESERVED0[5U];
N  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
X  volatile uint32_t CPACR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if defined (__CM3_REV) && (__CM3_REV < 0x0201U)                   /* core r2p1 */
X#if 0L && (__CM3_REV < 0x0201U)                    
S#define SCB_VTOR_TBLBASE_Pos               29U                                            /*!< SCB VTOR: TBLBASE Position */
S#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
S
S#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
N#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Register Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
N#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
N
N#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
N#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
N
N#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
N#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
N
N#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
N#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
N
N#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
N#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
N
N/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
N#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
N
N#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
N#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
N
N#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
N#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
N
N#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
N#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
N
N#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
N#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
N
N#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
N#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
N
N/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
N#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
N#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
N
N#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
N#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
N
N#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
N#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
N
N#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
N#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
N
N#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
N#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
N
N#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
N#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
N
N/* SCB Hard Fault Status Register Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N  \brief    Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N        uint32_t RESERVED0[1U];
N  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
X  volatile const  uint32_t ICTR;                    
N#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
X#if 0L && (__CM3_REV >= 0x200U)
S  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
N#else
N        uint32_t RESERVED1[1U];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#if defined (__CM3_REV) && (__CM3_REV >= 0x200U)
X#if 0L && (__CM3_REV >= 0x200U)
S#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
S#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
S
S#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
S#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N#endif
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __OM  union
X  volatile  union
N  {
N    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
X    volatile  uint8_t    u8;                  
N    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
X    volatile  uint16_t   u16;                 
N    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
X    volatile  uint32_t   u32;                 
N  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
N        uint32_t RESERVED0[864U];
N  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
X  volatile uint32_t TER;                     
N        uint32_t RESERVED1[15U];
N  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
X  volatile uint32_t TPR;                     
N        uint32_t RESERVED2[15U];
N  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
X  volatile uint32_t TCR;                     
N        uint32_t RESERVED3[32U];
N        uint32_t RESERVED4[43U];
N  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
X  volatile  uint32_t LAR;                     
N  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
X  volatile const  uint32_t LSR;                     
N        uint32_t RESERVED5[6U];
N  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                    
N  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                    
N  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                    
N  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                    
N  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                    
N  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                    
N  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                    
N  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                    
N  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                    
N  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                    
N  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                    
N  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                    
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
X  volatile uint32_t CYCCNT;                  
N  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
X  volatile uint32_t CPICNT;                  
N  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
X  volatile uint32_t EXCCNT;                  
N  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
X  volatile uint32_t SLEEPCNT;                
N  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
X  volatile uint32_t LSUCNT;                  
N  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
X  volatile uint32_t FOLDCNT;                 
N  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
X  volatile const  uint32_t PCSR;                    
N  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
X  volatile uint32_t COMP0;                   
N  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
X  volatile uint32_t MASK0;                   
N  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
X  volatile uint32_t FUNCTION0;               
N        uint32_t RESERVED0[1U];
N  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
X  volatile uint32_t COMP1;                   
N  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
X  volatile uint32_t MASK1;                   
N  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
X  volatile uint32_t FUNCTION1;               
N        uint32_t RESERVED1[1U];
N  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
X  volatile uint32_t COMP2;                   
N  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
X  volatile uint32_t MASK2;                   
N  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
X  volatile uint32_t FUNCTION2;               
N        uint32_t RESERVED2[1U];
N  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
X  volatile uint32_t COMP3;                   
N  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
X  volatile uint32_t MASK3;                   
N  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
X  volatile uint32_t FUNCTION3;               
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N  \brief    Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
X  volatile const  uint32_t SSPSR;                   
N  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                   
N        uint32_t RESERVED0[2U];
N  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                    
N        uint32_t RESERVED1[55U];
N  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                    
N        uint32_t RESERVED2[131U];
N  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                    
N  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                    
N  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                    
N        uint32_t RESERVED3[759U];
N  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
X  volatile const  uint32_t TRIGGER;                 
N  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                   
N  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;               
N        uint32_t RESERVED4[1U];
N  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;               
N  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                   
N  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                  
N        uint32_t RESERVED5[39U];
N  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                
N  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                
N        uint32_t RESERVED7[8U];
N  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                   
N  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                 
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY2 Position */
N#define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITATBCTR2: ATREADY2 Mask */
N
N#define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY1 Position */
N#define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITATBCTR2: ATREADY1 Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY2 Position */
N#define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITATBCTR0: ATREADY2 Mask */
N
N#define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY1 Position */
N#define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITATBCTR0: ATREADY1 Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
X  volatile uint32_t RBAR_A1;                 
N  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                 
N  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
X  volatile uint32_t RBAR_A2;                 
N  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                 
N  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
X  volatile uint32_t RBAR_A3;                 
N  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                 
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  4U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Type definitions for the Core Debug Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
X  volatile uint32_t DHCSR;                   
N  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
X  volatile  uint32_t DCRSR;                   
N  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
X  volatile uint32_t DCRDR;                   
N  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                   
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register Definitions */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register Definitions */
N#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register Definitions */
N#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/**
N  \brief   Set Priority Grouping
N  \details Sets the priority grouping field using the required unlock sequence.
N           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N           Only values from 0..7 are used.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16U) |
N                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
X                (PriorityGroupTmp << 8U)  );               
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/**
N  \brief   Get Priority Grouping
N  \details Reads the priority grouping field from the NVIC Interrupt Controller.
N  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
N}
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    __dsb(0xF);
N    __ISB();
X    __isb(0xF);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Active Interrupt
N  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not active.
N  \return             1  Interrupt status is active.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - 5)) & (uint32_t)0xFFUL);
N  }
N  else
N  {
N    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 5)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)IRQn)]               >> (8U - 5)));
N  }
N  else
N  {
N    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - 5)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(5)) ? (uint32_t)(5) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(5)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(5));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(5)) ? (uint32_t)(5) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(5)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(5));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N  /* ARM Application Note 321 states that the M3 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2U)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  __dsb(0xF);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1 == 1U)
N
N#include "mpu_armv7.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.1.1
N * @date     10. February 2020
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  | \
N   (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    | \
N   (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    | \
N   (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  |    (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    |    (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    |    (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)    \
N  ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  | \
N   (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  | \
N   (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | \
N   (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 | \
N   (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                | \
N   (((MPU_RASR_ENABLE_Msk))))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  |    (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  |    (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) |    (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 |    (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                |    (((MPU_RASR_ENABLE_Msk))))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if shareable) or 010b (if non-shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) >> 1U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DMB();
X  __dmb(0xF);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR |= (1UL << 16U);
N#endif
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DMB();
X  __dmb(0xF);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
N  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHCSR &= ~(1UL << 16U);
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N  __DSB();
X  __dsb(0xF);
N  __ISB();
X  __isb(0xF);
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcopy with strictly ordered memory access, e.g. for register targets.
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 4U) {
N    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 4U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 4U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 4U;
N  }
N  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  ARM_MPU_OrderedMemcpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1785 "C:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include\core_cm3.h" 2
N
N#endif
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 5) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_core_DebugFunctions ITM Functions
N  \brief    Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
N#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/**
N  \brief   ITM Send Character
N  \details Transmits a character via the ITM channel 0, and
N           \li Just returns when no debugger is connected that has booked the output.
N           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N  \param [in]     ch  Character to transmit.
N  \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0U].u32 == 0UL)
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
N    {
N      __NOP();
X      __nop();
N    }
N    ITM->PORT[0U].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Receive Character
N  \details Inputs a character via the external variable \ref ITM_RxBuffer.
N  \return             Received character.
N  \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void)
Xstatic __inline int32_t ITM_ReceiveChar (void)
N{
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U))
N  {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = ((int32_t)0x5AA55AA5U);        
N  }
N
N  return (ch);
N}
N
N
N/**
N  \brief   ITM Check Character
N  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N  \return          0  No character available.
N  \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void)
Xstatic __inline int32_t ITM_CheckChar (void)
N{
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
X  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U))
N  {
N    return (0);                              /* no character available */
N  }
N  else
N  {
N    return (1);                              /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 107 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include\LPC17xx.h" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include\system_LPC17xx.h" 1
N/**************************************************************************//**
N * @file     system_LPC17xx.h
N * @brief    CMSIS Device System Header File for
N *           NXP LPC17xx Device Series
N * @version  V1.12
N * @date     05. April 2016
N ******************************************************************************/
N/* Copyright (c) 2011 - 2016 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N/**
N  \brief  System clock frequency (core clock).
N    The system clock frequency supplied to the SysTick timer and the 
N    processor core clock.
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N  \brief  Setup the microcontroller system.
N
N    Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N  \brief  Update SystemCoreClock variable.
N
N    Updates the SystemCoreClock with current core Clock
N    retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC17xx_H */
L 108 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include\LPC17xx.h" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
N/** @brief System Control (SC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
X  volatile uint32_t FLASHCFG;                
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                /* Clocking and Power Control         */
X  volatile uint32_t PLL0CON;                 
N  __IO uint32_t PLL0CFG;
X  volatile uint32_t PLL0CFG;
N  __I  uint32_t PLL0STAT;
X  volatile const  uint32_t PLL0STAT;
N  __O  uint32_t PLL0FEED;
X  volatile  uint32_t PLL0FEED;
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;
X  volatile uint32_t PLL1CON;
N  __IO uint32_t PLL1CFG;
X  volatile uint32_t PLL1CFG;
N  __I  uint32_t PLL1STAT;
X  volatile const  uint32_t PLL1STAT;
N  __O  uint32_t PLL1FEED;
X  volatile  uint32_t PLL1FEED;
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;
X  volatile uint32_t PCON;
N  __IO uint32_t PCONP;
X  volatile uint32_t PCONP;
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;
X  volatile uint32_t CCLKCFG;
N  __IO uint32_t USBCLKCFG;
X  volatile uint32_t USBCLKCFG;
N  __IO uint32_t CLKSRCSEL;
X  volatile uint32_t CLKSRCSEL;
N  __IO uint32_t	CANSLEEPCLR;
X  volatile uint32_t	CANSLEEPCLR;
N  __IO uint32_t	CANWAKEFLAGS;
X  volatile uint32_t	CANWAKEFLAGS;
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                 /* External Interrupts                */
X  volatile uint32_t EXTINT;                  
N       uint32_t RESERVED5;
N  __IO uint32_t EXTMODE;
X  volatile uint32_t EXTMODE;
N  __IO uint32_t EXTPOLAR;
X  volatile uint32_t EXTPOLAR;
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                   /* Reset                              */
X  volatile uint32_t RSID;                    
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                    /* Syscon Miscellaneous Registers     */
X  volatile uint32_t SCS;                     
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;
X  volatile uint32_t PCLKSEL0;
N  __IO uint32_t PCLKSEL1;
X  volatile uint32_t PCLKSEL1;
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
X  volatile uint32_t USBIntSt;                
N  __IO uint32_t DMAREQSEL;
X  volatile uint32_t DMAREQSEL;
N  __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
X  volatile uint32_t CLKOUTCFG;               
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
N/** @brief Pin Connect Block (PINCON) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;
X  volatile uint32_t PINSEL0;
N  __IO uint32_t PINSEL1;
X  volatile uint32_t PINSEL1;
N  __IO uint32_t PINSEL2;
X  volatile uint32_t PINSEL2;
N  __IO uint32_t PINSEL3;
X  volatile uint32_t PINSEL3;
N  __IO uint32_t PINSEL4;
X  volatile uint32_t PINSEL4;
N  __IO uint32_t PINSEL5;
X  volatile uint32_t PINSEL5;
N  __IO uint32_t PINSEL6;
X  volatile uint32_t PINSEL6;
N  __IO uint32_t PINSEL7;
X  volatile uint32_t PINSEL7;
N  __IO uint32_t PINSEL8;
X  volatile uint32_t PINSEL8;
N  __IO uint32_t PINSEL9;
X  volatile uint32_t PINSEL9;
N  __IO uint32_t PINSEL10;
X  volatile uint32_t PINSEL10;
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;
X  volatile uint32_t PINMODE0;
N  __IO uint32_t PINMODE1;
X  volatile uint32_t PINMODE1;
N  __IO uint32_t PINMODE2;
X  volatile uint32_t PINMODE2;
N  __IO uint32_t PINMODE3;
X  volatile uint32_t PINMODE3;
N  __IO uint32_t PINMODE4;
X  volatile uint32_t PINMODE4;
N  __IO uint32_t PINMODE5;
X  volatile uint32_t PINMODE5;
N  __IO uint32_t PINMODE6;
X  volatile uint32_t PINMODE6;
N  __IO uint32_t PINMODE7;
X  volatile uint32_t PINMODE7;
N  __IO uint32_t PINMODE8;
X  volatile uint32_t PINMODE8;
N  __IO uint32_t PINMODE9;
X  volatile uint32_t PINMODE9;
N  __IO uint32_t PINMODE_OD0;
X  volatile uint32_t PINMODE_OD0;
N  __IO uint32_t PINMODE_OD1;
X  volatile uint32_t PINMODE_OD1;
N  __IO uint32_t PINMODE_OD2;
X  volatile uint32_t PINMODE_OD2;
N  __IO uint32_t PINMODE_OD3;
X  volatile uint32_t PINMODE_OD3;
N  __IO uint32_t PINMODE_OD4;
X  volatile uint32_t PINMODE_OD4;
N  __IO uint32_t I2CPADCFG;
X  volatile uint32_t I2CPADCFG;
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
N/** @brief General Purpose Input/Output (GPIO) register structure definition */
Ntypedef struct
N{
N  union {
N    __IO uint32_t FIODIR;
X    volatile uint32_t FIODIR;
N    struct {
N      __IO uint16_t FIODIRL;
X      volatile uint16_t FIODIRL;
N      __IO uint16_t FIODIRH;
X      volatile uint16_t FIODIRH;
N    };
N    struct {
N      __IO uint8_t  FIODIR0;
X      volatile uint8_t  FIODIR0;
N      __IO uint8_t  FIODIR1;
X      volatile uint8_t  FIODIR1;
N      __IO uint8_t  FIODIR2;
X      volatile uint8_t  FIODIR2;
N      __IO uint8_t  FIODIR3;
X      volatile uint8_t  FIODIR3;
N    };
N  };
N  uint32_t RESERVED0[3];
N  union {
N    __IO uint32_t FIOMASK;
X    volatile uint32_t FIOMASK;
N    struct {
N      __IO uint16_t FIOMASKL;
X      volatile uint16_t FIOMASKL;
N      __IO uint16_t FIOMASKH;
X      volatile uint16_t FIOMASKH;
N    };
N    struct {
N      __IO uint8_t  FIOMASK0;
X      volatile uint8_t  FIOMASK0;
N      __IO uint8_t  FIOMASK1;
X      volatile uint8_t  FIOMASK1;
N      __IO uint8_t  FIOMASK2;
X      volatile uint8_t  FIOMASK2;
N      __IO uint8_t  FIOMASK3;
X      volatile uint8_t  FIOMASK3;
N    };
N  };
N  union {
N    __IO uint32_t FIOPIN;
X    volatile uint32_t FIOPIN;
N    struct {
N      __IO uint16_t FIOPINL;
X      volatile uint16_t FIOPINL;
N      __IO uint16_t FIOPINH;
X      volatile uint16_t FIOPINH;
N    };
N    struct {
N      __IO uint8_t  FIOPIN0;
X      volatile uint8_t  FIOPIN0;
N      __IO uint8_t  FIOPIN1;
X      volatile uint8_t  FIOPIN1;
N      __IO uint8_t  FIOPIN2;
X      volatile uint8_t  FIOPIN2;
N      __IO uint8_t  FIOPIN3;
X      volatile uint8_t  FIOPIN3;
N    };
N  };
N  union {
N    __IO uint32_t FIOSET;
X    volatile uint32_t FIOSET;
N    struct {
N      __IO uint16_t FIOSETL;
X      volatile uint16_t FIOSETL;
N      __IO uint16_t FIOSETH;
X      volatile uint16_t FIOSETH;
N    };
N    struct {
N      __IO uint8_t  FIOSET0;
X      volatile uint8_t  FIOSET0;
N      __IO uint8_t  FIOSET1;
X      volatile uint8_t  FIOSET1;
N      __IO uint8_t  FIOSET2;
X      volatile uint8_t  FIOSET2;
N      __IO uint8_t  FIOSET3;
X      volatile uint8_t  FIOSET3;
N    };
N  };
N  union {
N    __O  uint32_t FIOCLR;
X    volatile  uint32_t FIOCLR;
N    struct {
N      __O  uint16_t FIOCLRL;
X      volatile  uint16_t FIOCLRL;
N      __O  uint16_t FIOCLRH;
X      volatile  uint16_t FIOCLRH;
N    };
N    struct {
N      __O  uint8_t  FIOCLR0;
X      volatile  uint8_t  FIOCLR0;
N      __O  uint8_t  FIOCLR1;
X      volatile  uint8_t  FIOCLR1;
N      __O  uint8_t  FIOCLR2;
X      volatile  uint8_t  FIOCLR2;
N      __O  uint8_t  FIOCLR3;
X      volatile  uint8_t  FIOCLR3;
N    };
N  };
N} LPC_GPIO_TypeDef;
N
N/** @brief General Purpose Input/Output interrupt (GPIOINT) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
N/** @brief Timer (TIM) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
N/** @brief Pulse-Width Modulation (PWM) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N  __I  uint32_t CR2;
X  volatile const  uint32_t CR2;
N  __I  uint32_t CR3;
X  volatile const  uint32_t CR3;
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;
X  volatile uint32_t MR4;
N  __IO uint32_t MR5;
X  volatile uint32_t MR5;
N  __IO uint32_t MR6;
X  volatile uint32_t MR6;
N  __IO uint32_t PCR;
X  volatile uint32_t PCR;
N  __IO uint32_t LER;
X  volatile uint32_t LER;
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
N/** @brief  Universal Asynchronous Receiver Transmitter (UART) register structure definition */
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N} LPC_UART_TypeDef;
N
N/** @brief  Universal Asynchronous Receiver Transmitter 1 (UART1) register structure definition */
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
N/** @brief  Serial Peripheral Interface (SPI) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t SPCR;
X  volatile uint32_t SPCR;
N  __I  uint32_t SPSR;
X  volatile const  uint32_t SPSR;
N  __IO uint32_t SPDR;
X  volatile uint32_t SPDR;
N  __IO uint32_t SPCCR;
X  volatile uint32_t SPCCR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;
X  volatile uint32_t SPINT;
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
N/** @brief  Synchronous Serial Communication (SSP) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
N/** @brief  Inter-Integrated Circuit (I2C) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t I2CONSET;
X  volatile uint32_t I2CONSET;
N  __I  uint32_t I2STAT;
X  volatile const  uint32_t I2STAT;
N  __IO uint32_t I2DAT;
X  volatile uint32_t I2DAT;
N  __IO uint32_t I2ADR0;
X  volatile uint32_t I2ADR0;
N  __IO uint32_t I2SCLH;
X  volatile uint32_t I2SCLH;
N  __IO uint32_t I2SCLL;
X  volatile uint32_t I2SCLL;
N  __O  uint32_t I2CONCLR;
X  volatile  uint32_t I2CONCLR;
N  __IO uint32_t MMCTRL;
X  volatile uint32_t MMCTRL;
N  __IO uint32_t I2ADR1;
X  volatile uint32_t I2ADR1;
N  __IO uint32_t I2ADR2;
X  volatile uint32_t I2ADR2;
N  __IO uint32_t I2ADR3;
X  volatile uint32_t I2ADR3;
N  __I  uint32_t I2DATA_BUFFER;
X  volatile const  uint32_t I2DATA_BUFFER;
N  __IO uint32_t I2MASK0;
X  volatile uint32_t I2MASK0;
N  __IO uint32_t I2MASK1;
X  volatile uint32_t I2MASK1;
N  __IO uint32_t I2MASK2;
X  volatile uint32_t I2MASK2;
N  __IO uint32_t I2MASK3;
X  volatile uint32_t I2MASK3;
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
N/** @brief  Inter IC Sound (I2S) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t I2SDAO;
X  volatile uint32_t I2SDAO;
N  __IO uint32_t I2SDAI;
X  volatile uint32_t I2SDAI;
N  __O  uint32_t I2STXFIFO;
X  volatile  uint32_t I2STXFIFO;
N  __I  uint32_t I2SRXFIFO;
X  volatile const  uint32_t I2SRXFIFO;
N  __I  uint32_t I2SSTATE;
X  volatile const  uint32_t I2SSTATE;
N  __IO uint32_t I2SDMA1;
X  volatile uint32_t I2SDMA1;
N  __IO uint32_t I2SDMA2;
X  volatile uint32_t I2SDMA2;
N  __IO uint32_t I2SIRQ;
X  volatile uint32_t I2SIRQ;
N  __IO uint32_t I2STXRATE;
X  volatile uint32_t I2STXRATE;
N  __IO uint32_t I2SRXRATE;
X  volatile uint32_t I2SRXRATE;
N  __IO uint32_t I2STXBITRATE;
X  volatile uint32_t I2STXBITRATE;
N  __IO uint32_t I2SRXBITRATE;
X  volatile uint32_t I2SRXBITRATE;
N  __IO uint32_t I2STXMODE;
X  volatile uint32_t I2STXMODE;
N  __IO uint32_t I2SRXMODE;
X  volatile uint32_t I2SRXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
N/** @brief  Repetitive Interrupt Timer (RIT) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint8_t  RICTRL;
X  volatile uint8_t  RICTRL;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
N/** @brief  Real-Time Clock (RTC) register structure definition */
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
N/** @brief  Watchdog Timer (WDT) register structure definition */
Ntypedef struct
N{
N  __IO uint8_t  WDMOD;
X  volatile uint8_t  WDMOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t WDTC;
X  volatile uint32_t WDTC;
N  __O  uint8_t  WDFEED;
X  volatile  uint8_t  WDFEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t WDTV;
X  volatile const  uint32_t WDTV;
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
N/** @brief  Analog-to-Digital Converter (ADC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ADCR;
X  volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N       uint32_t RESERVED0;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile const  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile const  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile const  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile const  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile const  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile const  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile const  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile const  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile const  uint32_t ADSTAT;
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
N/** @brief  Digital-to-Analog Converter (DAC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DACR;
X  volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
N/** @brief  Motor Control Pulse-Width Modulation (MCPWM) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t MCCON;
X  volatile const  uint32_t MCCON;
N  __O  uint32_t MCCON_SET;
X  volatile  uint32_t MCCON_SET;
N  __O  uint32_t MCCON_CLR;
X  volatile  uint32_t MCCON_CLR;
N  __I  uint32_t MCCAPCON;
X  volatile const  uint32_t MCCAPCON;
N  __O  uint32_t MCCAPCON_SET;
X  volatile  uint32_t MCCAPCON_SET;
N  __O  uint32_t MCCAPCON_CLR;
X  volatile  uint32_t MCCAPCON_CLR;
N  __IO uint32_t MCTIM0;
X  volatile uint32_t MCTIM0;
N  __IO uint32_t MCTIM1;
X  volatile uint32_t MCTIM1;
N  __IO uint32_t MCTIM2;
X  volatile uint32_t MCTIM2;
N  __IO uint32_t MCPER0;
X  volatile uint32_t MCPER0;
N  __IO uint32_t MCPER1;
X  volatile uint32_t MCPER1;
N  __IO uint32_t MCPER2;
X  volatile uint32_t MCPER2;
N  __IO uint32_t MCPW0;
X  volatile uint32_t MCPW0;
N  __IO uint32_t MCPW1;
X  volatile uint32_t MCPW1;
N  __IO uint32_t MCPW2;
X  volatile uint32_t MCPW2;
N  __IO uint32_t MCDEADTIME;
X  volatile uint32_t MCDEADTIME;
N  __IO uint32_t MCCCP;
X  volatile uint32_t MCCCP;
N  __IO uint32_t MCCR0;
X  volatile uint32_t MCCR0;
N  __IO uint32_t MCCR1;
X  volatile uint32_t MCCR1;
N  __IO uint32_t MCCR2;
X  volatile uint32_t MCCR2;
N  __I  uint32_t MCINTEN;
X  volatile const  uint32_t MCINTEN;
N  __O  uint32_t MCINTEN_SET;
X  volatile  uint32_t MCINTEN_SET;
N  __O  uint32_t MCINTEN_CLR;
X  volatile  uint32_t MCINTEN_CLR;
N  __I  uint32_t MCCNTCON;
X  volatile const  uint32_t MCCNTCON;
N  __O  uint32_t MCCNTCON_SET;
X  volatile  uint32_t MCCNTCON_SET;
N  __O  uint32_t MCCNTCON_CLR;
X  volatile  uint32_t MCCNTCON_CLR;
N  __I  uint32_t MCINTFLAG;
X  volatile const  uint32_t MCINTFLAG;
N  __O  uint32_t MCINTFLAG_SET;
X  volatile  uint32_t MCINTFLAG_SET;
N  __O  uint32_t MCINTFLAG_CLR;
X  volatile  uint32_t MCINTFLAG_CLR;
N  __O  uint32_t MCCAP_CLR;
X  volatile  uint32_t MCCAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
N/** @brief  Quadrature Encoder Interface (QEI) register structure definition */
Ntypedef struct
N{
N  __O  uint32_t QEICON;
X  volatile  uint32_t QEICON;
N  __I  uint32_t QEISTAT;
X  volatile const  uint32_t QEISTAT;
N  __IO uint32_t QEICONF;
X  volatile uint32_t QEICONF;
N  __I  uint32_t QEIPOS;
X  volatile const  uint32_t QEIPOS;
N  __IO uint32_t QEIMAXPOS;
X  volatile uint32_t QEIMAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP;
X  volatile uint32_t INXCMP;
N  __IO uint32_t QEILOAD;
X  volatile uint32_t QEILOAD;
N  __I  uint32_t QEITIME;
X  volatile const  uint32_t QEITIME;
N  __I  uint32_t QEIVEL;
X  volatile const  uint32_t QEIVEL;
N  __I  uint32_t QEICAP;
X  volatile const  uint32_t QEICAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t QEIIEC;
X  volatile  uint32_t QEIIEC;
N  __O  uint32_t QEIIES;
X  volatile  uint32_t QEIIES;
N  __I  uint32_t QEIINTSTAT;
X  volatile const  uint32_t QEIINTSTAT;
N  __I  uint32_t QEIIE;
X  volatile const  uint32_t QEIIE;
N  __O  uint32_t QEICLR;
X  volatile  uint32_t QEICLR;
N  __O  uint32_t QEISET;
X  volatile  uint32_t QEISET;
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
N/** @brief  Controller Area Network Acceptance Filter RAM (CANAF_RAM)structure definition */
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
N/** @brief  Controller Area Network Acceptance Filter(CANAF) register structure definition */
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
N/** @brief  Controller Area Network Central (CANCR) register structure definition */
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t CANTxSR;
X  volatile const  uint32_t CANTxSR;
N  __I  uint32_t CANRxSR;
X  volatile const  uint32_t CANRxSR;
N  __I  uint32_t CANMSR;
X  volatile const  uint32_t CANMSR;
N} LPC_CANCR_TypeDef;
N
N/** @brief  Controller Area Network Controller (CAN) register structure definition */
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
N/** @brief  General Purpose Direct Memory Access (GPDMA) register structure definition */
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t DMACIntStat;
X  volatile const  uint32_t DMACIntStat;
N  __I  uint32_t DMACIntTCStat;
X  volatile const  uint32_t DMACIntTCStat;
N  __O  uint32_t DMACIntTCClear;
X  volatile  uint32_t DMACIntTCClear;
N  __I  uint32_t DMACIntErrStat;
X  volatile const  uint32_t DMACIntErrStat;
N  __O  uint32_t DMACIntErrClr;
X  volatile  uint32_t DMACIntErrClr;
N  __I  uint32_t DMACRawIntTCStat;
X  volatile const  uint32_t DMACRawIntTCStat;
N  __I  uint32_t DMACRawIntErrStat;
X  volatile const  uint32_t DMACRawIntErrStat;
N  __I  uint32_t DMACEnbldChns;
X  volatile const  uint32_t DMACEnbldChns;
N  __IO uint32_t DMACSoftBReq;
X  volatile uint32_t DMACSoftBReq;
N  __IO uint32_t DMACSoftSReq;
X  volatile uint32_t DMACSoftSReq;
N  __IO uint32_t DMACSoftLBReq;
X  volatile uint32_t DMACSoftLBReq;
N  __IO uint32_t DMACSoftLSReq;
X  volatile uint32_t DMACSoftLSReq;
N  __IO uint32_t DMACConfig;
X  volatile uint32_t DMACConfig;
N  __IO uint32_t DMACSync;
X  volatile uint32_t DMACSync;
N} LPC_GPDMA_TypeDef;
N
N/** @brief  General Purpose Direct Memory Access Channel (GPDMACH) register structure definition */
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t DMACCSrcAddr;
X  volatile uint32_t DMACCSrcAddr;
N  __IO uint32_t DMACCDestAddr;
X  volatile uint32_t DMACCDestAddr;
N  __IO uint32_t DMACCLLI;
X  volatile uint32_t DMACCLLI;
N  __IO uint32_t DMACCControl;
X  volatile uint32_t DMACCControl;
N  __IO uint32_t DMACCConfig;
X  volatile uint32_t DMACCConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
N/** @brief  Universal Serial Bus (USB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t HcRevision;             /* USB Host Registers                 */
X  volatile const  uint32_t HcRevision;              
N  __IO uint32_t HcControl;
X  volatile uint32_t HcControl;
N  __IO uint32_t HcCommandStatus;
X  volatile uint32_t HcCommandStatus;
N  __IO uint32_t HcInterruptStatus;
X  volatile uint32_t HcInterruptStatus;
N  __IO uint32_t HcInterruptEnable;
X  volatile uint32_t HcInterruptEnable;
N  __IO uint32_t HcInterruptDisable;
X  volatile uint32_t HcInterruptDisable;
N  __IO uint32_t HcHCCA;
X  volatile uint32_t HcHCCA;
N  __I  uint32_t HcPeriodCurrentED;
X  volatile const  uint32_t HcPeriodCurrentED;
N  __IO uint32_t HcControlHeadED;
X  volatile uint32_t HcControlHeadED;
N  __IO uint32_t HcControlCurrentED;
X  volatile uint32_t HcControlCurrentED;
N  __IO uint32_t HcBulkHeadED;
X  volatile uint32_t HcBulkHeadED;
N  __IO uint32_t HcBulkCurrentED;
X  volatile uint32_t HcBulkCurrentED;
N  __I  uint32_t HcDoneHead;
X  volatile const  uint32_t HcDoneHead;
N  __IO uint32_t HcFmInterval;
X  volatile uint32_t HcFmInterval;
N  __I  uint32_t HcFmRemaining;
X  volatile const  uint32_t HcFmRemaining;
N  __I  uint32_t HcFmNumber;
X  volatile const  uint32_t HcFmNumber;
N  __IO uint32_t HcPeriodicStart;
X  volatile uint32_t HcPeriodicStart;
N  __IO uint32_t HcLSTreshold;
X  volatile uint32_t HcLSTreshold;
N  __IO uint32_t HcRhDescriptorA;
X  volatile uint32_t HcRhDescriptorA;
N  __IO uint32_t HcRhDescriptorB;
X  volatile uint32_t HcRhDescriptorB;
N  __IO uint32_t HcRhStatus;
X  volatile uint32_t HcRhStatus;
N  __IO uint32_t HcRhPortStatus1;
X  volatile uint32_t HcRhPortStatus1;
N  __IO uint32_t HcRhPortStatus2;
X  volatile uint32_t HcRhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t OTGIntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t OTGIntSt;                
N  __IO uint32_t OTGIntEn;
X  volatile uint32_t OTGIntEn;
N  __O  uint32_t OTGIntSet;
X  volatile  uint32_t OTGIntSet;
N  __O  uint32_t OTGIntClr;
X  volatile  uint32_t OTGIntClr;
N  __IO uint32_t OTGStCtrl;
X  volatile uint32_t OTGStCtrl;
N  __IO uint32_t OTGTmr;
X  volatile uint32_t OTGTmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t USBDevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t USBDevIntSt;             
N  __IO uint32_t USBDevIntEn;
X  volatile uint32_t USBDevIntEn;
N  __O  uint32_t USBDevIntClr;
X  volatile  uint32_t USBDevIntClr;
N  __O  uint32_t USBDevIntSet;
X  volatile  uint32_t USBDevIntSet;
N
N  __O  uint32_t USBCmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t USBCmdCode;              
N  __I  uint32_t USBCmdData;
X  volatile const  uint32_t USBCmdData;
N
N  __I  uint32_t USBRxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t USBRxData;               
N  __O  uint32_t USBTxData;
X  volatile  uint32_t USBTxData;
N  __I  uint32_t USBRxPLen;
X  volatile const  uint32_t USBRxPLen;
N  __O  uint32_t USBTxPLen;
X  volatile  uint32_t USBTxPLen;
N  __IO uint32_t USBCtrl;
X  volatile uint32_t USBCtrl;
N  __O  uint32_t USBDevIntPri;
X  volatile  uint32_t USBDevIntPri;
N
N  __I  uint32_t USBEpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t USBEpIntSt;              
N  __IO uint32_t USBEpIntEn;
X  volatile uint32_t USBEpIntEn;
N  __O  uint32_t USBEpIntClr;
X  volatile  uint32_t USBEpIntClr;
N  __O  uint32_t USBEpIntSet;
X  volatile  uint32_t USBEpIntSet;
N  __O  uint32_t USBEpIntPri;
X  volatile  uint32_t USBEpIntPri;
N
N  __IO uint32_t USBReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t USBReEp;                 
N  __O  uint32_t USBEpInd;
X  volatile  uint32_t USBEpInd;
N  __IO uint32_t USBMaxPSize;
X  volatile uint32_t USBMaxPSize;
N
N  __I  uint32_t USBDMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t USBDMARSt;               
N  __O  uint32_t USBDMARClr;
X  volatile  uint32_t USBDMARClr;
N  __O  uint32_t USBDMARSet;
X  volatile  uint32_t USBDMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t USBUDCAH;
X  volatile uint32_t USBUDCAH;
N  __I  uint32_t USBEpDMASt;
X  volatile const  uint32_t USBEpDMASt;
N  __O  uint32_t USBEpDMAEn;
X  volatile  uint32_t USBEpDMAEn;
N  __O  uint32_t USBEpDMADis;
X  volatile  uint32_t USBEpDMADis;
N  __I  uint32_t USBDMAIntSt;
X  volatile const  uint32_t USBDMAIntSt;
N  __IO uint32_t USBDMAIntEn;
X  volatile uint32_t USBDMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t USBEoTIntSt;
X  volatile const  uint32_t USBEoTIntSt;
N  __O  uint32_t USBEoTIntClr;
X  volatile  uint32_t USBEoTIntClr;
N  __O  uint32_t USBEoTIntSet;
X  volatile  uint32_t USBEoTIntSet;
N  __I  uint32_t USBNDDRIntSt;
X  volatile const  uint32_t USBNDDRIntSt;
N  __O  uint32_t USBNDDRIntClr;
X  volatile  uint32_t USBNDDRIntClr;
N  __O  uint32_t USBNDDRIntSet;
X  volatile  uint32_t USBNDDRIntSet;
N  __I  uint32_t USBSysErrIntSt;
X  volatile const  uint32_t USBSysErrIntSt;
N  __O  uint32_t USBSysErrIntClr;
X  volatile  uint32_t USBSysErrIntClr;
N  __O  uint32_t USBSysErrIntSet;
X  volatile  uint32_t USBSysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __I  uint32_t I2C_STS;
X  volatile const  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
N/** @brief  Ethernet Media Access Controller (EMAC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __IO uint32_t RxFilterWoLStatus;
X  volatile uint32_t RxFilterWoLStatus;
N  __IO uint32_t RxFilterWoLClear;
X  volatile uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#ifdef __LPC17XX_REV00
S#define LPC_AHBRAM0_BASE      (0x20000000UL)
S#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#else
N#define LPC_AHBRAM0_BASE      (0x2007C000UL)
N#define LPC_AHBRAM1_BASE      (0x20080000UL)
N#endif
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N/**
N * @}
N */
N
N#endif  // __LPC17xx_H__
L 44 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N  #include "PIN_LPC17xx.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\PIN_LPC17xx.h" 1
N/* -------------------------------------------------------------------------- 
N * Copyright (c) 2013-2014 Arm Limited (or its affiliates). All 
N * rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N *
N * $Date:        13. June 2014
N * $Revision:    V1.0
N *
N * Project:      PIN Driver Definitions for NXP LPC17xx
N * -------------------------------------------------------------------------- */
N
N#ifndef __PIN_LPC17XX_H
N#define __PIN_LPC17XX_H
N
N#include <stdint.h>
N#include <stdbool.h>
N
N// Pin Configuration
N
Ntypedef struct _PIN
N{
N  uint8_t Portnum;   // Port Number
N  uint8_t Pinnum;    // Pin Number
N} PIN;
N
N
N//------------------------------------------------------------------------------
N// PINSEL REGISTER BIT DEFINITIONS
N//------------------------------------------------------------------------------
N
N// Pin Function selection
N#define PIN_FUNC_0              ((uint32_t)(0))
N#define PIN_FUNC_1              ((uint32_t)(1))
N#define PIN_FUNC_2              ((uint32_t)(2))
N#define PIN_FUNC_3              ((uint32_t)(3))
N
N// Pin mode
N#define PIN_PINMODE_PULLUP      ((uint32_t)(0))
N#define PIN_PINMODE_REPEATER    ((uint32_t)(1))
N#define PIN_PINMODE_TRISTATE    ((uint32_t)(2))
N#define PIN_PINMODE_PULLDOWN    ((uint32_t)(3))
N
N// Pin mode (normal/open drain)
N#define	PIN_PINMODE_NORMAL      ((uint32_t)(0))
N#define	PIN_PINMODE_OPENDRAIN   ((uint32_t)(1))
N
N// I2C mode
N#define PIN_I2C_Normal_Mode     ((uint32_t)(0))
N#define PIN_I2C_Fast_Mode       ((uint32_t)(1))
N#define PIN_I2C_Fast_Plus_Mode  ((uint32_t)(2))
N
N/**
N  \fn          int32_t PIN_Configure (uint32_t function) {
N  \brief       Set pin function and electrical characteristics
N  \param[in]   port       port number (0..3)
N  \param[in]   pin        pin number  (0..31)
N  \param[in]   function   port pin function
N  \param[in]   mode       port pin input mode
N  \param[in]   open_drain port pin open drain mode
N  \returns
N   - \b  0: function succeeded
N   - \b -1: function failed
N*/
Nextern int32_t PIN_Configure (uint8_t port, uint8_t pin, uint8_t function, uint8_t mode, uint8_t open_drain);
N
N/**
N  \fn          int32_t PIN_ConfigureTPIU (bool enable)
N  \brief       Configure trace function
N  \param[in]   enable Enable or disable
N                - true (1): enable
N                - false(0): disable
N  \returns
N   - \b  0: function succeeded
N   - \b -1: function failed
N*/
Nextern int32_t PIN_ConfigureTPIU (bool enable);
Xextern int32_t PIN_ConfigureTPIU (_Bool enable);
N
N/**
N  \fn          PIN_ConfigureI2C0Pins(uint8_t i2cPinMode, bool enableFilterSlewRate)
N  \brief       Configure I2C0 pins
N  \param[in]   i2cPinMode           I2C pin mode
N                - PIN_I2C_Normal_Mode
N                - PIN_I2C_Fast_Mode
N                - PIN_I2C_Normal_Mode
N  \param[in]   enableFilterSlewRate Enable or disable filter and slew rate
N                - true (1): enable
N                - false(0): disable
N  \returns
N   - \b  0: function succeeded
N   - \b -1: function failed
N*/
Nextern int32_t PIN_ConfigureI2C0Pins (uint8_t i2cPinMode, bool enableFilterSlewRate);
Xextern int32_t PIN_ConfigureI2C0Pins (uint8_t i2cPinMode, _Bool enableFilterSlewRate);
N
N#endif // __PIN_LPC17XX_H
L 45 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N#elif defined (LPC177x_8x)
S  #include "LPC177x_8x.h"
S  #include "PIN_LPC177x_8x.h"
N#endif
N
N#include "GPIO_LPC17xx.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\GPIO_LPC17xx.h" 1
N#ifdef  __cplusplus
Sextern "C" {
N#endif
N/* -------------------------------------------------------------------------- 
N * Copyright (c) 2013-2019 Arm Limited (or its affiliates). All 
N * rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *  
N *
N * $Date:        01. August 2019
N * $Revision:    V1.1
N *
N * Project:      GPIO Driver Definitions for NXP LPC17xx
N * -------------------------------------------------------------------------- */
N
N#ifndef __GPIO_LPC17XX_H
N#define __GPIO_LPC17XX_H
N
N#if defined (LPC175x_6x)
X#if 1L
N  #include "LPC17xx.h"
N#elif defined (LPC177x_8x)
S  #include "LPC177x_8x.h"
N#endif
N
N// GPIO identifier
Ntypedef struct _GPIO_ID {
N  uint8_t       port;
N  uint8_t       num;
N} GPIO_ID;
N
N// GPIO Direction
N#define GPIO_DIR_INPUT     (0U)
N#define GPIO_DIR_OUTPUT    (1U)
N
N
N/**
N  \fn          void GPIO_PortClock (uint32_t clock)
N  \brief       Port Clock Control
N  \param[in]   clock  Enable or disable clock
N*/
Nextern void GPIO_PortClock (uint32_t clock);
N
N/**
N  \fn          void GPIO_SetDir (uint32_t port_num,
N                                 uint32_t pin_num,
N                                 uint32_t dir)
N  \brief       Configure GPIO pin direction
N  \param[in]   port_num   GPIO number (0..4)
N  \param[in]   pin_num    Port pin number
N  \param[in]   dir        GPIO_DIR_INPUT, GPIO_DIR_OUTPUT
N*/
Nextern void GPIO_SetDir (uint32_t port_num, uint32_t pin_num, uint32_t dir);
N
N/**
N  \fn          void GPIO_PinWrite (uint32_t port_num,
N                                   uint32_t pin_num,
N                                   uint32_t val);
N  \brief       Write port pin
N  \param[in]   port_num   GPIO number (0..4)
N  \param[in]   pin_num    Port pin number
N  \param[in]   val        Port pin value (0 or 1)
N*/
Nextern void GPIO_PinWrite (uint32_t port_num,
N                           uint32_t pin_num,
N                           uint32_t val);
N
N/**
N  \fn          uint32_t  GPIO_PinRead (uint32_t port_num, uint32_t pin_num)
N  \brief       Read port pin
N  \param[in]   port_num   GPIO number (0..4)
N  \param[in]   pin_num    Port pin number
N  \return      pin value (0 or 1)
N*/
Nextern uint32_t GPIO_PinRead (uint32_t port_num, uint32_t pin_num);
N
N/**
N  \fn          void GPIO_PortWrite (uint32_t port_num,
N                                    uint32_t mask,
N                                    uint32_t val)
N  \brief       Write port pins
N  \param[in]   port_num   GPIO number (0..4)
N  \param[in]   mask       Selected pins
N  \param[in]   val        Pin values
N*/
Nextern void GPIO_PortWrite (uint32_t port_num, uint32_t mask, uint32_t val);
N
N/**
N  \fn          uint32_t  GPIO_PortRead (uint32_t port_num)
N  \brief       Read port pins
N  \param[in]   port_num   GPIO number (0..4)
N  \return      port pin inputs
N*/
Nextern uint32_t GPIO_PortRead (uint32_t port_num);
N
N#endif // __GPIO_LPC17XX_H
N#ifdef  __cplusplus
S}
N#endif
L 51 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.h" 2
N
N#include "RTE_Device.h"
N#include "RTE_Components.h"
N
N#if (defined(RTE_Drivers_ETH_MAC0) && !RTE_ENET)
X#if (1L && !1)
S#error "Ethernet not configured in RTE_Device.h!"
N#endif
N
N#if (RTE_ENET_MII && RTE_ENET_RMII)
X#if (RTE_ENET_MII && 1)
S#error "Ethernet interface configuration in RTE_Device.h is invalid!"
N#endif
N
N/* EMAC Driver state flags */
N#define EMAC_FLAG_INIT      (1U << 0)       // Driver initialized
N#define EMAC_FLAG_POWER     (1U << 1)       // Driver power on
N
N/* MAC Configuration Register 1 */
N#define MAC1_REC_EN         0x00000001U     // Receive Enable
N#define MAC1_PASS_ALL       0x00000002U     // Pass All Receive Frames
N#define MAC1_RX_FLOWC       0x00000004U     // RX Flow Control
N#define MAC1_TX_FLOWC       0x00000008U     // TX Flow Control
N#define MAC1_LOOPB          0x00000010U     // Loop Back Mode
N#define MAC1_RES_TX         0x00000100U     // Reset TX Logic
N#define MAC1_RES_MCS_TX     0x00000200U     // Reset MAC TX Control Sublayer
N#define MAC1_RES_RX         0x00000400U     // Reset RX Logic
N#define MAC1_RES_MCS_RX     0x00000800U     // Reset MAC RX Control Sublayer
N#define MAC1_SIM_RES        0x00004000U     // Simulation Reset
N#define MAC1_SOFT_RES       0x00008000U     // Soft Reset MAC
N
N/* MAC Configuration Register 2 */
N#define MAC2_FULL_DUP       0x00000001U     // Full Duplex Mode
N#define MAC2_FRM_LEN_CHK    0x00000002U     // Frame Length Checking
N#define MAC2_HUGE_FRM_EN    0x00000004U     // Huge Frame Enable
N#define MAC2_DLY_CRC        0x00000008U     // Delayed CRC Mode
N#define MAC2_CRC_EN         0x00000010U     // Append CRC to every Frame
N#define MAC2_PAD_EN         0x00000020U     // Pad all Short Frames
N#define MAC2_VLAN_PAD_EN    0x00000040U     // VLAN Pad Enable
N#define MAC2_ADET_PAD_EN    0x00000080U     // Auto Detect Pad Enable
N#define MAC2_PPREAM_ENF     0x00000100U     // Pure Preamble Enforcement
N#define MAC2_LPREAM_ENF     0x00000200U     // Long Preamble Enforcement
N#define MAC2_NO_BACKOFF     0x00001000U     // No Backoff Algorithm
N#define MAC2_BACK_PRESSURE  0x00002000U     // Backoff Presurre / No Backoff
N#define MAC2_EXCESS_DEF     0x00004000U     // Excess Defer
N
N/* Back-to-Back Inter-Packet-Gap Register */
N#define IPGT_FULL_DUP       0x00000015U     // Recommended value for Full Duplex
N#define IPGT_HALF_DUP       0x00000012U     // Recommended value for Half Duplex
N
N/* Non Back-to-Back Inter-Packet-Gap Register */
N#define IPGR_DEF            0x00000012U     // Recommended value
N
N/* Collision Window/Retry Register */
N#define CLRT_DEF            0x0000370FU     // Default value
N
N/* PHY Support Register */
N#define SUPP_SPEED          0x00000100U     // Reduced MII Logic Current Speed
N#define SUPP_RES_RMII       0x00000800U     // Reset Reduced MII Logic
N
N/* Test Register */
N#define TEST_SHCUT_PQUANTA  0x00000001U     // Shortcut Pause Quanta
N#define TEST_TST_PAUSE      0x00000002U     // Test Pause
N#define TEST_TST_BACKP      0x00000004U     // Test Back Pressure
N
N/* MII Management Configuration Register */
N#define MCFG_SCAN_INC       0x00000001U     // Scan Increment PHY Address
N#define MCFG_SUPP_PREAM     0x00000002U     // Suppress Preamble
N#define MCFG_CLK_SEL        0x0000003CU     // Clock Select Mask
N#define MCFG_RES_MII        0x00008000U     // Reset MII Management Hardware
N
N/* MII Management Command Register */
N#define MCMD_READ           0x00000001U     // MII Read
N#define MCMD_SCAN           0x00000002U     // MII Scan continuously
N
N#define MII_WR_TOUT         0x00050000U     // MII Write timeout count
N#define MII_RD_TOUT         0x00050000U     // MII Read timeout count
N
N/* MII Management Address Register */
N#define MADR_REG_ADR        0x0000001FU     // MII Register Address Mask
N#define MADR_PHY_ADR        0x00001F00U     // PHY Address Mask
N
N/* MII Management Indicators Register */
N#define MIND_BUSY           0x00000001U     // MII is Busy
N#define MIND_SCAN           0x00000002U     // MII Scanning in Progress
N#define MIND_NOT_VAL        0x00000004U     // MII Read Data not valid
N#define MIND_MII_LINK_FAIL  0x00000008U     // MII Link Failed
N
N/* MII Management Configuration Register */
N#define MCFG_SCAN_INC       0x00000001U     // Scan Increment PHY Address
N#define MCFG_SUPP_PREAM     0x00000002U     // Suppress Preamble
N#define MCFG_CLK_SEL        0x0000003CU     // Clock Select Mask
N#define MCFG_RES_MII        0x00008000U     // Reset MII Management Hardware
N
N/* MII Management Configuration Register Clock Select */
N#define MCFG_CS_Div4        (0x0U << 2)     // Host Clock < 10 MHz
N#define MCFG_CS_Div6        (0x2U << 2)     // Host Clock < 15 MHz
N#define MCFG_CS_Div8        (0x3U << 2)     // Host Clock < 20 MHz
N#define MCFG_CS_Div10       (0x4U << 2)     // Host Clock < 25 MHz
N#define MCFG_CS_Div14       (0x5U << 2)     // Host Clock < 35 MHz
N#define MCFG_CS_Div20       (0x6U << 2)     // Host Clock < 50 MHz
N#define MCFG_CS_Div28       (0x7U << 2)     // Host Clock < 70 MHz
N#define MCFG_CS_Div36       (0x8U << 2)     // Host Clock < 80 MHz
N#define MCFG_CS_Div40       (0x9U << 2)     // Host Clock < 90 MHz
N#define MCFG_CS_Div44       (0xAU << 2)     // Host Clock < 100 MHz
N#define MCFG_CS_Div48       (0xBU << 2)     // Host Clock < 120 MHz
N#define MCFG_CS_Div52       (0xCU << 2)     // Host Clock < 130 MHz
N#define MCFG_CS_Div56       (0xDU << 2)     // Host Clock < 140 MHz
N#define MCFG_CS_Div60       (0xEU << 2)     // Host Clock < 150 MHz
N#define MCFG_CS_Div64       (0xFU << 2)     // Host Clock < 160 MHz
N
N/* Command Register */
N#define CR_RX_EN            0x00000001U     // Enable Receive
N#define CR_TX_EN            0x00000002U     // Enable Transmit
N#define CR_REG_RES          0x00000008U     // Reset Host Registers
N#define CR_TX_RES           0x00000010U     // Reset Transmit Datapath
N#define CR_RX_RES           0x00000020U     // Reset Receive Datapath
N#define CR_PASS_RUNT_FRM    0x00000040U     // Pass Runt Frames
N#define CR_PASS_RX_FILT     0x00000080U     // Pass RX Filter
N#define CR_TX_FLOW_CTRL     0x00000100U     // TX Flow Control
N#define CR_RMII             0x00000200U     // Reduced MII Interface
N#define CR_FULL_DUP         0x00000400U     // Full Duplex
N
N/* Status Register */
N#define SR_RX_EN            0x00000001U     // Enable Receive
N#define SR_TX_EN            0x00000002U     // Enable Transmit
N
N/* Transmit Status Vector 0 Register */
N#define TSV0_CRC_ERR        0x00000001U     // CRC error
N#define TSV0_LEN_CHKERR     0x00000002U     // Length Check Error
N#define TSV0_LEN_OUTRNG     0x00000004U     // Length Out of Range
N#define TSV0_DONE           0x00000008U     // Tramsmission Completed
N#define TSV0_MCAST          0x00000010U     // Multicast Destination
N#define TSV0_BCAST          0x00000020U     // Broadcast Destination
N#define TSV0_PKT_DEFER      0x00000040U     // Packet Deferred
N#define TSV0_EXC_DEFER      0x00000080U     // Excessive Packet Deferral
N#define TSV0_EXC_COLL       0x00000100U     // Excessive Collision
N#define TSV0_LATE_COLL      0x00000200U     // Late Collision Occured
N#define TSV0_GIANT          0x00000400U     // Giant Frame
N#define TSV0_UNDERRUN       0x00000800U     // Buffer Underrun
N#define TSV0_BYTES          0x0FFFF000U     // Total Bytes Transferred
N#define TSV0_CTRL_FRAME     0x10000000U     // Control Frame
N#define TSV0_PAUSE          0x20000000U     // Pause Frame
N#define TSV0_BACK_PRESS     0x40000000U     // Backpressure Method Applied
N#define TSV0_VLAN           0x80000000U     // VLAN Frame
N
N/* Transmit Status Vector 1 Register */
N#define TSV1_BYTE_CNT       0x0000FFFFU     // Transmit Byte Count
N#define TSV1_COLL_CNT       0x000F0000U     // Transmit Collision Count
N
N/* Receive Status Vector Register */
N#define RSV_BYTE_CNT        0x0000FFFFU     // Receive Byte Count
N#define RSV_PKT_IGNORED     0x00010000U     // Packet Previously Ignored
N#define RSV_RXDV_SEEN       0x00020000U     // RXDV Event Previously Seen
N#define RSV_CARR_SEEN       0x00040000U     // Carrier Event Previously Seen
N#define RSV_REC_CODEV       0x00080000U     // Receive Code Violation
N#define RSV_CRC_ERR         0x00100000U     // CRC Error
N#define RSV_LEN_CHKERR      0x00200000U     // Length Check Error
N#define RSV_LEN_OUTRNG      0x00400000U     // Length Out of Range
N#define RSV_REC_OK          0x00800000U     // Frame Received OK
N#define RSV_MCAST           0x01000000U     // Multicast Frame
N#define RSV_BCAST           0x02000000U     // Broadcast Frame
N#define RSV_DRIB_NIBB       0x04000000U     // Dribble Nibble
N#define RSV_CTRL_FRAME      0x08000000U     // Control Frame
N#define RSV_PAUSE           0x10000000U     // Pause Frame
N#define RSV_UNSUPP_OPC      0x20000000U     // Unsupported Opcode
N#define RSV_VLAN            0x40000000U     // VLAN Frame
N
N/* Flow Control Counter Register */
N#define FCC_MIRR_CNT        0x0000FFFFU     // Mirror Counter
N#define FCC_PAUSE_TIM       0xFFFF0000U     // Pause Timer
N
N/* Flow Control Status Register */
N#define FCS_MIRR_CNT        0x0000FFFFU     // Mirror Counter Current
N
N/* Receive Filter Control Register */
N#define RFC_UCAST_EN        0x00000001U     // Accept Unicast Frames Enable
N#define RFC_BCAST_EN        0x00000002U     // Accept Broadcast Frames Enable
N#define RFC_MCAST_EN        0x00000004U     // Accept Multicast Frames Enable
N#define RFC_UCAST_HASH_EN   0x00000008U     // Accept Unicast Hash Filter Frames
N#define RFC_MCAST_HASH_EN   0x00000010U     // Accept Multicast Hash Filter Frames
N#define RFC_PERFECT_EN      0x00000020U     // Accept Perfect Match Enable
N#define RFC_MAGP_WOL_EN     0x00001000U     // Magic Packet Filter WoL Enable
N#define RFC_PFILT_WOL_EN    0x00002000U     // Perfect Filter WoL Enable
N
N/* Receive Filter WoL Status/Clear Registers */
N#define WOL_UCAST           0x00000001U     // Unicast Frame caused WoL
N#define WOL_BCAST           0x00000002U     // Broadcast Frame caused WoL
N#define WOL_MCAST           0x00000004U     // Multicast Frame caused WoL
N#define WOL_UCAST_HASH      0x00000008U     // Unicast Hash Filter Frame WoL
N#define WOL_MCAST_HASH      0x00000010U     // Multicast Hash Filter Frame WoL
N#define WOL_PERFECT         0x00000020U     // Perfect Filter WoL
N#define WOL_RX_FILTER       0x00000080U     // RX Filter caused WoL
N#define WOL_MAG_PACKET      0x00000100U     // Magic Packet Filter caused WoL
N
N/* Interrupt Status/Enable/Clear/Set Registers */
N#define INT_RX_OVERRUN      0x00000001U     // Overrun Error in RX Queue
N#define INT_RX_ERR          0x00000002U     // Receive Error
N#define INT_RX_FIN          0x00000004U     // RX Finished Process Descriptors
N#define INT_RX_DONE         0x00000008U     // Receive Done
N#define INT_TX_UNDERRUN     0x00000010U     // Transmit Underrun
N#define INT_TX_ERR          0x00000020U     // Transmit Error
N#define INT_TX_FIN          0x00000040U     // TX Finished Process Descriptors
N#define INT_TX_DONE         0x00000080U     // Transmit Done
N#define INT_SOFT_INT        0x00001000U     // Software Triggered Interrupt
N#define INT_WAKEUP          0x00002000U     // Wakeup Event Interrupt
N
N/* Power Down Register */
N#define PD_POWER_DOWN       0x80000000U     // Power Down MAC
N
N/* RX Descriptor Control Word */
N#define RCTRL_SIZE          0x000007FFU     // Buffer size mask
N#define RCTRL_INT           0x80000000U     // Generate RxDone Interrupt
N
N/* RX Status Hash CRC Word */
N#define RHASH_SA            0x000001FFU     // Hash CRC for Source Address
N#define RHASH_DA            0x001FF000U     // Hash CRC for Destination Address
N
N/* RX Status Information Word */
N#define RINFO_SIZE          0x000007FFU     // Data size in bytes
N#define RINFO_CTRL_FRAME    0x00040000U     // Control Frame
N#define RINFO_VLAN          0x00080000U     // VLAN Frame
N#define RINFO_FAIL_FILT     0x00100000U     // RX Filter Failed
N#define RINFO_MCAST         0x00200000U     // Multicast Frame
N#define RINFO_BCAST         0x00400000U     // Broadcast Frame
N#define RINFO_CRC_ERR       0x00800000U     // CRC Error in Frame
N#define RINFO_SYM_ERR       0x01000000U     // Symbol Error from PHY
N#define RINFO_LEN_ERR       0x02000000U     // Length Error
N#define RINFO_RANGE_ERR     0x04000000U     // Range Error (exceeded max. size)
N#define RINFO_ALIGN_ERR     0x08000000U     // Alignment Error
N#define RINFO_OVERRUN       0x10000000U     // Receive overrun
N#define RINFO_NO_DESCR      0x20000000U     // No new Descriptor available
N#define RINFO_LAST_FLAG     0x40000000U     // Last Fragment in Frame
N#define RINFO_ERR           0x80000000U     // Error Occured (OR of all errors)
N
N#define RINFO_ERR_MASK     (RINFO_FAIL_FILT | RINFO_CRC_ERR   | RINFO_SYM_ERR | \
N                            RINFO_LEN_ERR   | RINFO_ALIGN_ERR | RINFO_OVERRUN)
X#define RINFO_ERR_MASK     (RINFO_FAIL_FILT | RINFO_CRC_ERR   | RINFO_SYM_ERR |                             RINFO_LEN_ERR   | RINFO_ALIGN_ERR | RINFO_OVERRUN)
N
N/* TX Descriptor Control Word */
N#define TCTRL_SIZE          0x000007FFU     // Size of data buffer in bytes
N#define TCTRL_OVERRIDE      0x04000000U     // Override Default MAC Registers
N#define TCTRL_HUGE          0x08000000U     // Enable Huge Frame
N#define TCTRL_PAD           0x10000000U     // Pad short Frames to 64 bytes
N#define TCTRL_CRC           0x20000000U     // Append a hardware CRC to Frame
N#define TCTRL_LAST          0x40000000U     // Last Descriptor for TX Frame
N#define TCTRL_INT           0x80000000U     // Generate TxDone Interrupt
N
N/* TX Status Information Word */
N#define TINFO_COL_CNT       0x01E00000U     // Collision Count
N#define TINFO_DEFER         0x02000000U     // Packet Deferred (not an error)
N#define TINFO_EXCESS_DEF    0x04000000U     // Excessive Deferral
N#define TINFO_EXCESS_COL    0x08000000U     // Excessive Collision
N#define TINFO_LATE_COL      0x10000000U     // Late Collision Occured
N#define TINFO_UNDERRUN      0x20000000U     // Transmit Underrun
N#define TINFO_NO_DESCR      0x40000000U     // No new Descriptor available
N#define TINFO_ERR           0x80000000U     // Error Occured (OR of all errors)
N
N/* ENET Device Revision ID */
N#define OLD_EMAC_MODULE_ID  0x39022000U     // Rev. ID for first rev '-'
N
N/* DMA RX Descriptor */
Ntypedef struct {
N  uint8_t const    *Packet;                 // Packet data buffer address
N  uint32_t          Ctrl;                   // Packet control information
N} RX_Desc;
N
N/* DMA RX Status */
Ntypedef struct {
N  uint32_t volatile Info;                   // Receive status return flags
N  uint32_t volatile HashCRC;                // Hash CRC of dest. and source address
N} RX_Stat;
N
N/* DMA TX Descriptor */
Ntypedef struct {
N  uint8_t          *Packet;                 // Packet data buffer address
N  uint32_t          Ctrl;                   // Packet control information
N} TX_Desc;
N
N/* DMA TX Status */
Ntypedef struct {
N  uint32_t volatile Info;                   // Transmit status return flags
N} TX_Stat;
N
N/* EMAC Driver Control Information */
Ntypedef struct {
N  ARM_ETH_MAC_SignalEvent_t cb_event;       // Event callback
N  uint8_t           flags;                  // Control and state flags
N  bool              dev_175x;               // Small LPC175x device
X  _Bool              dev_175x;               
N  uint8_t          *frame_end;              // End of assembled frame fragments
N  uint32_t          frame_len;              // Frame length
N} EMAC_CTRL;
N
N#endif        // EMAC_LPC17XX_H
L 71 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver\EMAC_LPC17xx.c" 2
N
N#define ARM_ETH_MAC_DRV_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,12) /* driver version */
N
N/* Timeouts */
N#define PHY_TIMEOUT         500U        /* PHY Register access timeout in us  */
N
N/* EMAC Memory Buffer configuration for 16K Ethernet RAM */
N#define NUM_RX_BUF          4U          /* 0x1800 for Rx (4*1536=6.0K)        */
N#define NUM_TX_BUF          3U          /* 0x1200 for Tx (3*1536=4.6K)        */
N#define ETH_BUF_SIZE        1536U       /* ETH Receive/Transmit buffer size   */
N
N/* Ethernet Pin definitions */
Nstatic PIN eth_pins[] = {
N  { RTE_ENET_MDI_MDC_PORT,     RTE_ENET_MDI_MDC_PIN      },
X  { 1,     16      },
N  { RTE_ENET_MDI_MDIO_PORT,    RTE_ENET_MDI_MDIO_PIN     },
X  { 1,    17     },
N#if (RTE_ENET_RMII)
X#if (1)
N  { RTE_ENET_RMII_TXD0_PORT,   RTE_ENET_RMII_TXD0_PIN    },
X  { 1,   0    },
N  { RTE_ENET_RMII_TXD1_PORT,   RTE_ENET_RMII_TXD1_PIN    },
X  { 1,   1    },
N  { RTE_ENET_RMII_TX_EN_PORT,  RTE_ENET_RMII_TX_EN_PIN   },
X  { 1,  4   },
N  { RTE_ENET_RMII_CRS_PORT,    RTE_ENET_RMII_CRS_PIN     },
X  { 1,    8     },
N  { RTE_ENET_RMII_REF_CLK_PORT,RTE_ENET_RMII_REF_CLK_PIN },
X  { 1,15 },
N  { RTE_ENET_RMII_RXD0_PORT,   RTE_ENET_RMII_RXD0_PIN    },
X  { 1,   9    },
N  { RTE_ENET_RMII_RXD1_PORT,   RTE_ENET_RMII_RXD1_PIN    },
X  { 1,   10    },
N  { RTE_ENET_RMII_RX_ER_PORT,  RTE_ENET_RMII_RX_ER_PIN   }
X  { 1,  14   }
N#endif
N#if (RTE_ENET_MII)
S  { RTE_ENET_MII_TXD0_PORT,    RTE_ENET_MII_TXD0_PIN     },
S  { RTE_ENET_MII_TXD1_PORT,    RTE_ENET_MII_TXD1_PIN     },
S  { RTE_ENET_MII_TXD2_PORT,    RTE_ENET_MII_TXD2_PIN     },
S  { RTE_ENET_MII_TXD3_PORT,    RTE_ENET_MII_TXD3_PIN     },
S  { RTE_ENET_MII_TX_EN_PORT,   RTE_ENET_MII_TX_EN_PIN    },
S  { RTE_ENET_MII_TX_CLK_PORT,  RTE_ENET_MII_TX_CLK_PIN   },
S  { RTE_ENET_MII_RXD0_PORT,    RTE_ENET_MII_RXD0_PIN     },
S  { RTE_ENET_MII_RXD1_PORT,    RTE_ENET_MII_RXD1_PIN     },
S  { RTE_ENET_MII_RXD2_PORT,    RTE_ENET_MII_RXD2_PIN     },
S  { RTE_ENET_MII_RXD3_PORT,    RTE_ENET_MII_RXD3_PIN     },
S  { RTE_ENET_MII_RX_DV_PORT,   RTE_ENET_MII_RX_DV_PIN    },
S  { RTE_ENET_MII_RX_CLK_PORT,  RTE_ENET_MII_RX_CLK_PIN   },
S  { RTE_ENET_MII_RX_ER_PORT,   RTE_ENET_MII_RX_ER_PIN    },
S  { RTE_ENET_MII_COL_PORT,     RTE_ENET_MII_COL_PIN      },
S  { RTE_ENET_MII_CRS_PORT,     RTE_ENET_MII_CRS_PIN      },
S  #if (RTE_ENET_MII_TX_ER_PIN_EN)
S  { RTE_ENET_MII_TX_ER_PORT,   RTE_ENET_MII_TX_ER_PIN    },
S  #endif
N#endif
N};
N
N#define MDIO_MASK           0x00000200U
N#define MDC_MASK            0x00000100U
N
N
N#define EMAC_MDC_PIN        (&eth_pins[0])
N#define EMAC_MDIO_PIN       (&eth_pins[1])
N
N#if (RTE_ENET_RMII)
X#if (1)
N#define EMAC_TXD0_PIN       (&eth_pins[2])
N#define EMAC_TXD1_PIN       (&eth_pins[3])
N#define EMAC_TX_EN_PIN      (&eth_pins[4])
N#define EMAC_CRS_PIN        (&eth_pins[5])
N#define EMAC_REF_PIN        (&eth_pins[6])
N#define EMAC_RXD0_PIN       (&eth_pins[7])
N#define EMAC_RXD1_PIN       (&eth_pins[8])
N#define EMAC_RX_ER_PIN      (&eth_pins[9])
N#endif
N
N#if (RTE_ENET_MII)
S#define EMAC_TXD0_PIN       (&eth_pins[2]) 
S#define EMAC_TXD1_PIN       (&eth_pins[3])
S#define EMAC_TXD2_PIN       (&eth_pins[4]) 
S#define EMAC_TXD3_PIN       (&eth_pins[5])
S#define EMAC_TX_EN_PIN      (&eth_pins[6])
S#define EMAC_TX_CLK_PIN     (&eth_pins[7])
S#define EMAC_RXD0_PIN       (&eth_pins[8])
S#define EMAC_RXD1_PIN       (&eth_pins[9])
S#define EMAC_RXD2_PIN       (&eth_pins[10])
S#define EMAC_RXD3_PIN       (&eth_pins[11])
S#define EMAC_RX_DV_PIN      (&eth_pins[12])
S#define EMAC_REF_PIN        (&eth_pins[13])
S#define EMAC_RX_ER_PIN      (&eth_pins[14])
S#define EMAC_COL_PIN        (&eth_pins[15])
S#define EMAC_CRS_PIN        (&eth_pins[16])
N#endif
N
N/* Driver Version */
Nstatic const ARM_DRIVER_VERSION DriverVersion = {
N  ARM_ETH_MAC_API_VERSION,
X  (((2) << 8) | (2)),
N  ARM_ETH_MAC_DRV_VERSION
X  (((2) << 8) | (12))
N};
N
N/* Driver Capabilities */
Nstatic const ARM_ETH_MAC_CAPABILITIES DriverCapabilities = {
N  0U,                               /* checksum_offload_rx_ip4  */
N  0U,                               /* checksum_offload_rx_ip6  */
N  0U,                               /* checksum_offload_rx_udp  */
N  0U,                               /* checksum_offload_rx_tcp  */
N  0U,                               /* checksum_offload_rx_icmp */
N  0U,                               /* checksum_offload_tx_ip4  */
N  0U,                               /* checksum_offload_tx_ip6  */
N  0U,                               /* checksum_offload_tx_udp  */
N  0U,                               /* checksum_offload_tx_tcp  */
N  0U,                               /* checksum_offload_tx_icmp */
N  ARM_ETH_INTERFACE_RMII,           /* media_interface          */
X  (1U),            
N  0U,                               /* mac_address              */
N  1U,                               /* event_rx_frame           */
N  1U,                               /* event_tx_frame           */
N  1U,                               /* event_wakeup             */
N  0U                                /* precision_timer          */
N};
N
N/* EMAC local DMA Descriptors. */
Nstatic            RX_Desc Rx_Desc[NUM_RX_BUF];
Xstatic            RX_Desc Rx_Desc[4U];
Nstatic __ALIGNED(8) RX_Stat Rx_Stat[NUM_RX_BUF]; /* Must be 8-Byte aligned   */
Xstatic __attribute__((aligned(8))) RX_Stat Rx_Stat[4U];  
Nstatic            TX_Desc Tx_Desc[NUM_TX_BUF];
Xstatic            TX_Desc Tx_Desc[3U];
Nstatic            TX_Stat Tx_Stat[NUM_TX_BUF];
Xstatic            TX_Stat Tx_Stat[3U];
N
N/* EMAC local DMA buffers. */
Nstatic uint32_t rx_buf[NUM_RX_BUF][ETH_BUF_SIZE>>2];
Xstatic uint32_t rx_buf[4U][1536U>>2];
Nstatic uint32_t tx_buf[NUM_TX_BUF][ETH_BUF_SIZE>>2];
Xstatic uint32_t tx_buf[3U][1536U>>2];
N
N/* Local variables */
Nstatic EMAC_CTRL  emac_control = { 0 };
N#define emac     (emac_control)
N
Ntypedef void (*IAP)(uint32_t *cmd, uint32_t *res);
NIAP iap_entry = (IAP)0x1FFF1FF1;
N
N/* Local functions */
Nstatic void init_rx_desc (void);
Nstatic void init_tx_desc (void);
Nstatic uint32_t crc32_8bit_rev (uint32_t crc32, uint8_t val);
Nstatic uint32_t crc32_data (const uint8_t *data, uint32_t len);
N
N/**
N  \fn          void output_MDIO (uint32_t val, uint32_t n)
N  \brief       Output a value to the MII PHY management interface.
N  \param[in]   val  Pointer to buffer containing the data
N  \param[in]   num  Data length in bytes
N  \return      none.
N*/
Nstatic void output_MDIO (uint32_t val, uint32_t num) {
N  for (val <<= (32U - num); num; val <<= 1, num--) {
N    GPIO_PinWrite (EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, ((val & 0x80000000U) ? 1U : 0U));
X    GPIO_PinWrite ((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, ((val & 0x80000000U) ? 1U : 0U));
N    GPIO_PinWrite (EMAC_MDC_PIN->Portnum, EMAC_MDC_PIN->Pinnum, 1U);
X    GPIO_PinWrite ((&eth_pins[0])->Portnum, (&eth_pins[0])->Pinnum, 1U);
N    GPIO_PinWrite (EMAC_MDC_PIN->Portnum, EMAC_MDC_PIN->Pinnum, 0U);
X    GPIO_PinWrite ((&eth_pins[0])->Portnum, (&eth_pins[0])->Pinnum, 0U);
N  }
N}
N
N/**
N  \fn          void turnaround_MDIO (void)
N  \brief       Turnaround MDO is tristated.
N  \return      none.
N*/
Nstatic void turnaround_MDIO (void) {
N  GPIO_SetDir   (EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, GPIO_DIR_INPUT);
X  GPIO_SetDir   ((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, (0U));
N  GPIO_PinWrite (EMAC_MDC_PIN->Portnum,  EMAC_MDC_PIN->Pinnum, 1U);
X  GPIO_PinWrite ((&eth_pins[0])->Portnum,  (&eth_pins[0])->Pinnum, 1U);
N  GPIO_PinWrite (EMAC_MDC_PIN->Portnum,  EMAC_MDC_PIN->Pinnum, 0U);
X  GPIO_PinWrite ((&eth_pins[0])->Portnum,  (&eth_pins[0])->Pinnum, 0U);
N}
N
N/**
N  \fn          vuint32_t input_MDIO (void)
N  \brief       Input a value from the MII PHY management interface.
N  \return      none.
N*/
Nstatic uint32_t input_MDIO (void) {
N  uint32_t i,val = 0U;
N
N  for (i = 0U; i < 16U; i++) {
N    val <<= 1;
N    GPIO_PinWrite (EMAC_MDC_PIN->Portnum, EMAC_MDC_PIN->Pinnum, 1U);
X    GPIO_PinWrite ((&eth_pins[0])->Portnum, (&eth_pins[0])->Pinnum, 1U);
N    GPIO_PinWrite (EMAC_MDC_PIN->Portnum, EMAC_MDC_PIN->Pinnum, 0U);
X    GPIO_PinWrite ((&eth_pins[0])->Portnum, (&eth_pins[0])->Pinnum, 0U);
N    if (GPIO_PortRead(EMAC_MDIO_PIN->Portnum) & MDIO_MASK) {
X    if (GPIO_PortRead((&eth_pins[1])->Portnum) & 0x00000200U) {
N      val |= 1U;
N    }
N  }
N  return (val);
N}
N
N/**
N  \fn          void init_rx_desc (void)
N  \brief       Initialize Rx DMA descriptors.
N  \return      none.
N*/
Nstatic void init_rx_desc (void) {
N  uint32_t i;
N
N  for (i = 0U; i < NUM_RX_BUF; i++) {
X  for (i = 0U; i < 4U; i++) {
N    Rx_Desc[i].Packet  = (uint8_t *)&rx_buf[i];
N    Rx_Desc[i].Ctrl    = RCTRL_INT | (ETH_BUF_SIZE-1);
X    Rx_Desc[i].Ctrl    = 0x80000000U | (1536U-1);
N    Rx_Stat[i].Info    = 0U;
N    Rx_Stat[i].HashCRC = 0U;
N  }
N
N  /* Set EMAC Receive Descriptor Registers */
N  LPC_EMAC->RxDescriptor       = (uint32_t)&Rx_Desc[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxDescriptor       = (uint32_t)&Rx_Desc[0];
N  LPC_EMAC->RxStatus           = (uint32_t)&Rx_Stat[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxStatus           = (uint32_t)&Rx_Stat[0];
N  LPC_EMAC->RxDescriptorNumber = NUM_RX_BUF-1U;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxDescriptorNumber = 4U-1U;
N
N  /* Rx Descriptors Point to 0 */
N  LPC_EMAC->RxConsumeIndex  = 0U;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex  = 0U;
N}
N
N/**
N  \fn          void init_tx_desc (void)
N  \brief       Initialize Tx DMA descriptors.
N  \return      none.
N*/
Nstatic void init_tx_desc (void) {
N  uint32_t i;
N
N  for (i = 0U; i < NUM_TX_BUF; i++) {
X  for (i = 0U; i < 3U; i++) {
N    Tx_Desc[i].Packet = (uint8_t *)&tx_buf[i];
N    Tx_Desc[i].Ctrl   = 0U;
N    Tx_Stat[i].Info   = 0U;
N  }
N
N  /* Set EMAC Transmit Descriptor Registers */
N  LPC_EMAC->TxDescriptor       = (uint32_t)&Tx_Desc[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxDescriptor       = (uint32_t)&Tx_Desc[0];
N  LPC_EMAC->TxStatus           = (uint32_t)&Tx_Stat[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxStatus           = (uint32_t)&Tx_Stat[0];
N  LPC_EMAC->TxDescriptorNumber = NUM_TX_BUF-1;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxDescriptorNumber = 3U-1;
N
N  /* Tx Descriptors Point to 0 */
N  LPC_EMAC->TxProduceIndex  = 0U;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex  = 0U;
N}
N
N/**
N  \fn          uint32_t crc32_8bit_rev (uint32_t crc32, uint8_t val)
N  \brief       Calculate 32-bit CRC (Polynom: 0x04C11DB7, data bit-reversed).
N  \param[in]   crc32  CRC initial value
N  \param[in]   val    Input value
N  \return      Calculated CRC value
N*/
Nstatic uint32_t crc32_8bit_rev (uint32_t crc32, uint8_t val) {
N  uint32_t n;
N
N  crc32 ^= __RBIT(val);
X  crc32 ^= __rbit(val);
N  for (n = 8U; n; n--) {
N    if (crc32 & 0x80000000U) {
N      crc32 <<= 1;
N      crc32  ^= 0x04C11DB7U;
N    } else {
N      crc32 <<= 1;
N    }
N  }
N  return (crc32);
N}
N
N/**
N  \fn          uint32_t crc32_data (const uint8_t *data, uint32_t len)
N  \brief       Calculate standard 32-bit Ethernet CRC.
N  \param[in]   data  Pointer to buffer containing the data
N  \param[in]   len   Data length in bytes
N  \return      Calculated CRC value
N*/
Nstatic uint32_t crc32_data (const uint8_t *data, uint32_t len) {
N  uint32_t crc;
N
N  for (crc = 0xFFFFFFFFU; len; len--) {
N    crc = crc32_8bit_rev (crc, *data++);
N  }
N  return (crc);
N}
N
N/* Ethernet Driver functions */
N
N/**
N  \fn          ARM_DRIVER_VERSION GetVersion (void)
N  \brief       Get driver version.
N  \return      \ref ARM_DRIVER_VERSION
N*/
Nstatic ARM_DRIVER_VERSION GetVersion (void) {
N  return DriverVersion;
N}
N
N
N/**
N  \fn          ARM_ETH_MAC_CAPABILITIES GetCapabilities (void)
N  \brief       Get driver capabilities.
N  \return      \ref ARM_ETH_MAC_CAPABILITIES
N*/
Nstatic ARM_ETH_MAC_CAPABILITIES GetCapabilities (void) {
N  return DriverCapabilities;
N}
N
N/**
N  \fn          int32_t Initialize (ARM_ETH_MAC_SignalEvent_t cb_event)
N  \brief       Initialize Ethernet MAC Device.
N  \param[in]   cb_event  Pointer to \ref ARM_ETH_MAC_SignalEvent
N  \return      \ref execution_status
N*/
Nstatic int32_t Initialize (ARM_ETH_MAC_SignalEvent_t cb_event) {
N  uint32_t pb[2];
N  bool     dev_175x;
X  _Bool     dev_175x;
N#if defined (LPC177x_8x)
X#if 0L
S  uint32_t cfg_val;
N#endif
N
N  if (emac.flags & EMAC_FLAG_INIT) { return ARM_DRIVER_OK; }
X  if ((emac_control).flags & (1U << 0)) { return 0; }
N
N  /* Read device ID with IAP */
N  pb[0] = 54;
N  iap_entry (&pb[0], &pb[0]);
N  if ((pb[1] >> 24) == 0x25U) {
N    /* Use software RMII management routines */
N    dev_175x = true;
X    dev_175x = 1;
N  }
N  else {
N    dev_175x = false;
X    dev_175x = 0;
N  }
N#if defined (LPC175x_6x)
X#if 1L
N  /* Enable Ethernet Pins. */
N  PIN_Configure (EMAC_TXD0_PIN->Portnum,   EMAC_TXD0_PIN->Pinnum,    RTE_ENET_RMII_TXD0_FUNC,   0U,   0U);
X  PIN_Configure ((&eth_pins[2])->Portnum,   (&eth_pins[2])->Pinnum,    1,   0U,   0U);
N  PIN_Configure (EMAC_TXD1_PIN->Portnum,   EMAC_TXD1_PIN->Pinnum,    RTE_ENET_RMII_TXD1_FUNC,   0U,   0U);
X  PIN_Configure ((&eth_pins[3])->Portnum,   (&eth_pins[3])->Pinnum,    1,   0U,   0U);
N  PIN_Configure (EMAC_TX_EN_PIN->Portnum,  EMAC_TX_EN_PIN->Pinnum,   RTE_ENET_RMII_TX_EN_FUNC,  0U,   0U);
X  PIN_Configure ((&eth_pins[4])->Portnum,  (&eth_pins[4])->Pinnum,   1,  0U,   0U);
N  PIN_Configure (EMAC_CRS_PIN->Portnum,    EMAC_CRS_PIN->Pinnum,     RTE_ENET_RMII_CRS_FUNC,    0U,   0U);
X  PIN_Configure ((&eth_pins[5])->Portnum,    (&eth_pins[5])->Pinnum,     1,    0U,   0U);
N  PIN_Configure (EMAC_REF_PIN->Portnum,    EMAC_REF_PIN->Pinnum,     RTE_ENET_RMII_REF_CLK_FUNC,0U,   0U);
X  PIN_Configure ((&eth_pins[6])->Portnum,    (&eth_pins[6])->Pinnum,     1,0U,   0U);
N  PIN_Configure (EMAC_RXD0_PIN->Portnum,   EMAC_RXD0_PIN->Pinnum,    RTE_ENET_RMII_RXD0_FUNC,   0U,   0U);
X  PIN_Configure ((&eth_pins[7])->Portnum,   (&eth_pins[7])->Pinnum,    1,   0U,   0U);
N  PIN_Configure (EMAC_RXD1_PIN->Portnum,   EMAC_RXD1_PIN->Pinnum,    RTE_ENET_RMII_RXD1_FUNC,   0U,   0U);
X  PIN_Configure ((&eth_pins[8])->Portnum,   (&eth_pins[8])->Pinnum,    1,   0U,   0U);
N  PIN_Configure (EMAC_RX_ER_PIN->Portnum,  EMAC_RX_ER_PIN->Pinnum,   RTE_ENET_RMII_RX_ER_FUNC,  0U,   0U);
X  PIN_Configure ((&eth_pins[9])->Portnum,  (&eth_pins[9])->Pinnum,   1,  0U,   0U);
N
N  if (dev_175x == false) {
X  if (dev_175x == 0) {
N    /* LPC176x devices, no MDIO, MDC remap. */
N    PIN_Configure (RTE_ENET_MDI_MDC_PORT,  RTE_ENET_MDI_MDC_PIN,     RTE_ENET_MDI_MDC_FUNC,     0U,   0U);
X    PIN_Configure (1,  16,     1,     0U,   0U);
N    PIN_Configure (RTE_ENET_MDI_MDIO_PORT, RTE_ENET_MDI_MDIO_PIN,    RTE_ENET_MDI_MDIO_FUNC,    0U,   0U);
X    PIN_Configure (1, 17,    1,    0U,   0U);
N  }
N  else {
N    /* LPC175x devices, use software MII management. */  
N    PIN_Configure (RTE_ENET_MDI_MDC_PORT,  RTE_ENET_MDI_MDC_PIN,     0U,                         0U,   0U);
X    PIN_Configure (1,  16,     0U,                         0U,   0U);
N    PIN_Configure (RTE_ENET_MDI_MDIO_PORT, RTE_ENET_MDI_MDIO_PIN,    0U,                         0U,   0U);
X    PIN_Configure (1, 17,    0U,                         0U,   0U);
N    GPIO_SetDir(EMAC_MDC_PIN->Portnum,  EMAC_MDC_PIN->Pinnum,  GPIO_DIR_OUTPUT);
X    GPIO_SetDir((&eth_pins[0])->Portnum,  (&eth_pins[0])->Pinnum,  (1U));
N  }
N  /* Enable P1 Ethernet Pins. */
N  LPC_PINCON->PINSEL2 = 0x50150105U;
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL2 = 0x50150105U;
N  if (dev_175x == false) {
X  if (dev_175x == 0) {
N    /* LPC176x devices, no MDIO, MDC remap. */
N    LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000FU) | 0x00000005U;
X    ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 = (((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 & ~0x0000000FU) | 0x00000005U;
N  }
N  else {
N    /* LPC175x devices, use software MII management. */  
N    LPC_PINCON->PINSEL4 &= ~0x000F0000U;
X    ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL4 &= ~0x000F0000U;
N    LPC_GPIO2->FIODIR   |= MDC_MASK;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR   |= 0x00000100U;
N  }
N#elif defined (LPC177x_8x)
S  cfg_val = IOCON_MODE_PULLUP | IOCON_HYS_ENABLE;
S  /* Enable Ethernet Pins. */
S  #if (RTE_ENET_RMII) 
S  PIN_Configure (EMAC_TXD0_PIN->Portnum,   EMAC_TXD0_PIN->Pinnum,    cfg_val | RTE_ENET_RMII_TXD0_FUNC);
S  PIN_Configure (EMAC_TXD1_PIN->Portnum,   EMAC_TXD1_PIN->Pinnum,    cfg_val | RTE_ENET_RMII_TXD1_FUNC);
S  PIN_Configure (EMAC_TX_EN_PIN->Portnum,  EMAC_TX_EN_PIN->Pinnum,   cfg_val | RTE_ENET_RMII_TX_EN_FUNC);
S  PIN_Configure (EMAC_CRS_PIN->Portnum,    EMAC_CRS_PIN->Pinnum,     cfg_val | RTE_ENET_RMII_CRS_FUNC);
S  PIN_Configure (EMAC_REF_PIN->Portnum,    EMAC_REF_PIN->Pinnum,     cfg_val | RTE_ENET_RMII_REF_CLK_FUNC);
S  PIN_Configure (EMAC_RXD0_PIN->Portnum,   EMAC_RXD0_PIN->Pinnum,    cfg_val | RTE_ENET_RMII_RXD0_FUNC);
S  PIN_Configure (EMAC_RXD1_PIN->Portnum,   EMAC_RXD1_PIN->Pinnum,    cfg_val | RTE_ENET_RMII_RXD1_FUNC);
S  PIN_Configure (EMAC_RX_ER_PIN->Portnum,  EMAC_RX_ER_PIN->Pinnum,   cfg_val | RTE_ENET_RMII_RX_ER_FUNC);
S  #endif
S  #if (RTE_ENET_MII)
S  PIN_Configure (EMAC_TXD0_PIN->Portnum,   EMAC_TXD0_PIN->Pinnum,    cfg_val | RTE_ENET_MII_TXD0_FUNC);
S  PIN_Configure (EMAC_TXD1_PIN->Portnum,   EMAC_TXD1_PIN->Pinnum,    cfg_val | RTE_ENET_MII_TXD1_FUNC);
S  PIN_Configure (EMAC_TXD2_PIN->Portnum,   EMAC_TXD2_PIN->Pinnum,    cfg_val | RTE_ENET_MII_TXD2_FUNC);
S  PIN_Configure (EMAC_TXD3_PIN->Portnum,   EMAC_TXD3_PIN->Pinnum,    cfg_val | RTE_ENET_MII_TXD3_FUNC);
S  PIN_Configure (EMAC_TX_EN_PIN->Portnum,  EMAC_TX_EN_PIN->Pinnum,   cfg_val | RTE_ENET_MII_TX_EN_FUNC);
S  PIN_Configure (EMAC_TX_CLK_PIN->Portnum, EMAC_TX_CLK_PIN->Pinnum,  cfg_val | RTE_ENET_MII_TX_CLK_FUNC);
S  PIN_Configure (EMAC_RXD0_PIN->Portnum,   EMAC_RXD0_PIN->Pinnum,    cfg_val | RTE_ENET_MII_RXD0_FUNC);
S  PIN_Configure (EMAC_RXD1_PIN->Portnum,   EMAC_RXD1_PIN->Pinnum,    cfg_val | RTE_ENET_MII_RXD1_FUNC);
S  PIN_Configure (EMAC_RXD2_PIN->Portnum,   EMAC_RXD2_PIN->Pinnum,    cfg_val | RTE_ENET_MII_RXD2_FUNC);
S  PIN_Configure (EMAC_RXD3_PIN->Portnum,   EMAC_RXD3_PIN->Pinnum,    cfg_val | RTE_ENET_MII_RXD3_FUNC);
S  PIN_Configure (EMAC_RX_DV_PIN->Portnum,  EMAC_RX_DV_PIN->Pinnum,   cfg_val | RTE_ENET_MII_RX_DV_FUNC);
S  PIN_Configure (EMAC_REF_PIN->Portnum,    EMAC_REF_PIN->Pinnum,     cfg_val | RTE_ENET_MII_RX_CLK_FUNC);
S  PIN_Configure (EMAC_RX_ER_PIN->Portnum,  EMAC_RX_ER_PIN->Pinnum,   cfg_val | RTE_ENET_MII_RX_ER_FUNC);
S  PIN_Configure (EMAC_COL_PIN->Portnum,    EMAC_COL_PIN->Pinnum,     cfg_val | RTE_ENET_MII_COL_FUNC);
S  PIN_Configure (EMAC_CRS_PIN->Portnum,    EMAC_CRS_PIN->Pinnum,     cfg_val | RTE_ENET_MII_CRS_FUNC);
S  #endif
S  PIN_Configure (RTE_ENET_MDI_MDC_PORT,     RTE_ENET_MDI_MDC_PIN,    cfg_val | RTE_ENET_MDI_MDC_FUNC);
S  PIN_Configure (RTE_ENET_MDI_MDIO_PORT,    RTE_ENET_MDI_MDIO_PIN,   cfg_val | RTE_ENET_MDI_MDIO_FUNC);
N#endif
N
N  /* Clear control structure */
N  memset (&emac, 0, sizeof (EMAC_CTRL));
X  memset (&(emac_control), 0, sizeof (EMAC_CTRL));
N
N  emac.cb_event = cb_event;
X  (emac_control).cb_event = cb_event;
N  emac.dev_175x = dev_175x;
X  (emac_control).dev_175x = dev_175x;
N  emac.flags    = EMAC_FLAG_INIT;
X  (emac_control).flags    = (1U << 0);
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t Uninitialize (void)
N  \brief       De-initialize Ethernet MAC Device.
N  \return      \ref execution_status
N*/
Nstatic int32_t Uninitialize (void) {
N#if defined (LPC177x_8x)
X#if 0L
S  uint32_t cfg_val;
N#endif 
N
N  emac.flags = 0U;
X  (emac_control).flags = 0U;
N
N#if defined (LPC175x_6x)
X#if 1L
N  /* Disable Ethernet Pins. */
N  PIN_Configure (EMAC_TXD0_PIN->Portnum,  EMAC_TXD0_PIN->Pinnum,  0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[2])->Portnum,  (&eth_pins[2])->Pinnum,  0U, 0U, 0U);
N  PIN_Configure (EMAC_TXD1_PIN->Portnum,  EMAC_TXD1_PIN->Pinnum,  0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[3])->Portnum,  (&eth_pins[3])->Pinnum,  0U, 0U, 0U);
N  PIN_Configure (EMAC_TX_EN_PIN->Portnum, EMAC_TX_EN_PIN->Pinnum, 0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[4])->Portnum, (&eth_pins[4])->Pinnum, 0U, 0U, 0U);
N  PIN_Configure (EMAC_CRS_PIN->Portnum,   EMAC_CRS_PIN->Pinnum,   0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[5])->Portnum,   (&eth_pins[5])->Pinnum,   0U, 0U, 0U);
N  PIN_Configure (EMAC_REF_PIN->Portnum,   EMAC_REF_PIN->Pinnum,   0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[6])->Portnum,   (&eth_pins[6])->Pinnum,   0U, 0U, 0U);
N  PIN_Configure (EMAC_RXD0_PIN->Portnum,  EMAC_RXD0_PIN->Pinnum,  0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[7])->Portnum,  (&eth_pins[7])->Pinnum,  0U, 0U, 0U);
N  PIN_Configure (EMAC_RXD1_PIN->Portnum,  EMAC_RXD1_PIN->Pinnum,  0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[8])->Portnum,  (&eth_pins[8])->Pinnum,  0U, 0U, 0U);
N  PIN_Configure (EMAC_RX_ER_PIN->Portnum, EMAC_RX_ER_PIN->Pinnum, 0U, 0U, 0U);
X  PIN_Configure ((&eth_pins[9])->Portnum, (&eth_pins[9])->Pinnum, 0U, 0U, 0U);
N
N  if (emac.dev_175x == false) {
X  if ((emac_control).dev_175x == 0) {
N    /* LPC176x devices, no MDIO, MDC remap. */
N    PIN_Configure (EMAC_MDC_PIN->Portnum,  EMAC_MDC_PIN->Pinnum,  0U, 0U, 0U);
X    PIN_Configure ((&eth_pins[0])->Portnum,  (&eth_pins[0])->Pinnum,  0U, 0U, 0U);
N    PIN_Configure (EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, 0U, 0U, 0U);
X    PIN_Configure ((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, 0U, 0U, 0U);
N  }
N  else {
N    /* LPC175x devices, use software MII management. */  
N    PIN_Configure (EMAC_MDC_PIN->Portnum,  EMAC_MDC_PIN->Pinnum,  0U, 0U, 0U);
X    PIN_Configure ((&eth_pins[0])->Portnum,  (&eth_pins[0])->Pinnum,  0U, 0U, 0U);
N    PIN_Configure (EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, 0U, 0U, 0U);
X    PIN_Configure ((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, 0U, 0U, 0U);
N
N    GPIO_SetDir (EMAC_MDC_PIN->Portnum, EMAC_MDC_PIN->Pinnum,  0U);
X    GPIO_SetDir ((&eth_pins[0])->Portnum, (&eth_pins[0])->Pinnum,  0U);
N  }
N#elif defined (LPC177x_8x)
S  cfg_val = IOCON_MODE_PULLUP | IOCON_HYS_ENABLE;
S  /* Enable Ethernet Pins. */
S  #if (RTE_ENET_RMII) 
S  PIN_Configure (EMAC_TXD0_PIN->Portnum,   EMAC_TXD0_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TXD1_PIN->Portnum,   EMAC_TXD1_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TX_EN_PIN->Portnum,  EMAC_TX_EN_PIN->Pinnum,   cfg_val);
S  PIN_Configure (EMAC_CRS_PIN->Portnum,    EMAC_CRS_PIN->Pinnum,     cfg_val);
S  PIN_Configure (EMAC_REF_PIN->Portnum,    EMAC_REF_PIN->Pinnum,     cfg_val);
S  PIN_Configure (EMAC_RXD0_PIN->Portnum,   EMAC_RXD0_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RXD1_PIN->Portnum,   EMAC_RXD1_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RX_ER_PIN->Portnum,  EMAC_RX_ER_PIN->Pinnum,   cfg_val);
S  #endif
S  #if (RTE_ENET_MII)
S  PIN_Configure (EMAC_TXD0_PIN->Portnum,   EMAC_TXD0_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TXD1_PIN->Portnum,   EMAC_TXD1_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TXD2_PIN->Portnum,   EMAC_TXD2_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TXD3_PIN->Portnum,   EMAC_TXD3_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_TX_EN_PIN->Portnum,  EMAC_TX_EN_PIN->Pinnum,   cfg_val);
S  PIN_Configure (EMAC_TX_CLK_PIN->Portnum, EMAC_TX_CLK_PIN->Pinnum,  cfg_val);
S  PIN_Configure (EMAC_RXD0_PIN->Portnum,   EMAC_RXD0_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RXD1_PIN->Portnum,   EMAC_RXD1_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RXD2_PIN->Portnum,   EMAC_RXD2_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RXD3_PIN->Portnum,   EMAC_RXD3_PIN->Pinnum,    cfg_val);
S  PIN_Configure (EMAC_RX_DV_PIN->Portnum,  EMAC_RX_DV_PIN->Pinnum,   cfg_val);
S  PIN_Configure (EMAC_REF_PIN->Portnum,    EMAC_REF_PIN->Pinnum,     cfg_val);
S  PIN_Configure (EMAC_RX_ER_PIN->Portnum,  EMAC_RX_ER_PIN->Pinnum,   cfg_val);
S  PIN_Configure (EMAC_COL_PIN->Portnum,    EMAC_COL_PIN->Pinnum,     cfg_val);
S  PIN_Configure (EMAC_CRS_PIN->Portnum,    EMAC_CRS_PIN->Pinnum,     cfg_val);
S  #endif
S  PIN_Configure (RTE_ENET_MDI_MDC_PORT,    RTE_ENET_MDI_MDC_PIN,     cfg_val);
S  PIN_Configure (RTE_ENET_MDI_MDIO_PORT,   RTE_ENET_MDI_MDIO_PIN,    cfg_val);
N#endif
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t PowerControl (ARM_POWER_STATE state)
N  \brief       Control Ethernet MAC Device Power.
N  \param[in]   state  Power state
N  \return      \ref execution_status
N*/
Nstatic int32_t PowerControl (ARM_POWER_STATE state) {
N  uint32_t tout,hclk,div;
N
N  if ((state != ARM_POWER_OFF)  &&
N      (state != ARM_POWER_FULL) &&
N      (state != ARM_POWER_LOW)) {
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  switch (state) {
N    case ARM_POWER_OFF:
N      /* Disable EMAC interrupts */
N      NVIC_DisableIRQ(ENET_IRQn);
X      __NVIC_DisableIRQ(ENET_IRQn);
N
N      /* Power Up the EMAC controller. */
N      LPC_SC->PCONP |= 0x40000000U;
X      ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP |= 0x40000000U;
N
N      /* Reset all EMAC internal modules. */
N      LPC_EMAC->MAC1 = MAC1_SOFT_RES;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1 = 0x00008000U;
N
N      /* A short delay after reset. */
N      for (tout = 10U; tout; tout--);
N
N      /* Power Off the EMAC controller. */
N      LPC_SC->PCONP &= ~(0x40000000U);
X      ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP &= ~(0x40000000U);
N
N      emac.flags &= ~EMAC_FLAG_POWER;
X      (emac_control).flags &= ~(1U << 1);
N      break;
N
N    case ARM_POWER_LOW:
N      return ARM_DRIVER_ERROR_UNSUPPORTED;
X      return -4;
N
N    case ARM_POWER_FULL:
N      if ((emac.flags & EMAC_FLAG_INIT)  == 0U) { return ARM_DRIVER_ERROR; }
X      if (((emac_control).flags & (1U << 0))  == 0U) { return -1; }
N      if ((emac.flags & EMAC_FLAG_POWER) != 0U) { return ARM_DRIVER_OK; }
X      if (((emac_control).flags & (1U << 1)) != 0U) { return 0; }
N
N      /* Power Up the EMAC controller. */
N      LPC_SC->PCONP |= 0x40000000U;
X      ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP |= 0x40000000U;
N
N      /* Reset all EMAC internal modules. */
N      LPC_EMAC->MAC1    = MAC1_RES_TX     | MAC1_RES_MCS_TX | MAC1_RES_RX   |
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    = 0x00000100U     | 0x00000200U | 0x00000400U   |
N                          MAC1_RES_MCS_RX | MAC1_SIM_RES    | MAC1_SOFT_RES;
X                          0x00000800U | 0x00004000U    | 0x00008000U;
N#if defined (LPC175x_6x)
X#if 1L
N      LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = 0x00000008U | 0x00000010U | 0x00000020U | 0x00000040U;
N#elif defined (LPC177x_8x)
S  #if (RTE_ENET_RMII)
S      LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM | CR_RMII;
S  #else
S      LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
S  #endif
N#endif      
N      /* A short delay after reset. */
N      for (tout = 10U; tout; tout--);
N
N      /* Initialize MAC control registers. */
N      LPC_EMAC->MAC1 = MAC1_PASS_ALL;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1 = 0x00000002U;
N      LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN | MAC2_ADET_PAD_EN;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC2 = 0x00000010U | 0x00000020U | 0x00000080U;
N      LPC_EMAC->MAXF = ETH_BUF_SIZE;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAXF = 1536U;
N      LPC_EMAC->CLRT = CLRT_DEF;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->CLRT = 0x0000370FU;
N      LPC_EMAC->IPGR = IPGR_DEF;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGR = 0x00000012U;
N
N      LPC_EMAC->MCFG = MCFG_CLK_SEL | MCFG_RES_MII;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCFG = 0x0000003CU | 0x00008000U;
N      for (tout = 10U; tout; tout--);
N
N      /* MDC clock range selection */
N      hclk = SystemCoreClock;
N      if      (hclk > 150000000U) div = MCFG_CS_Div64;
X      if      (hclk > 150000000U) div = (0xFU << 2);
N      else if (hclk > 100000000U) div = MCFG_CS_Div60;
X      else if (hclk > 100000000U) div = (0xEU << 2);
N      else if (hclk >  60000000U) div = MCFG_CS_Div40;
X      else if (hclk >  60000000U) div = (0x9U << 2);
N      else if (hclk >  35000000U) div = MCFG_CS_Div28;
X      else if (hclk >  35000000U) div = (0x7U << 2);
N      else if (hclk >  20000000U) div = MCFG_CS_Div14;
X      else if (hclk >  20000000U) div = (0x5U << 2);
N      else if (hclk >  10000000U) div = MCFG_CS_Div8;
X      else if (hclk >  10000000U) div = (0x3U << 2);
N      else                       div = MCFG_CS_Div4;
X      else                       div = (0x0U << 2);
N      LPC_EMAC->MCFG = div;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCFG = div;
N
N      /* Enable Reduced MII interface. */
N      LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = 0x00000200U | 0x00000040U;
N      
N      /* Reset Reduced MII Logic. */
N      LPC_EMAC->SUPP = SUPP_RES_RMII;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0x00000800U;
N      for (tout = 10U; tout; tout--);
N      LPC_EMAC->SUPP = 0U;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0U;
N
N      /* Initilaize Ethernet MAC Address registers */
N      LPC_EMAC->SA0 = 0x00000000U;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA0 = 0x00000000U;
N      LPC_EMAC->SA1 = 0x00000000U;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA1 = 0x00000000U;
N      LPC_EMAC->SA2 = 0x00000000U;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA2 = 0x00000000U;
N
N      /* Initialize Tx and Rx DMA Descriptors */
N      init_rx_desc ();
N      init_tx_desc ();
N  
N      /* Receive Perfect Match Packets */
N      LPC_EMAC->RxFilterCtrl = RFC_PERFECT_EN;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl = 0x00000020U;
N
N      /* Enable EMAC interrupts */
N      LPC_EMAC->IntClear  = 0xFFFFU;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntClear  = 0xFFFFU;
N      LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntEnable = 0x00000008U | 0x00000080U;
N
N      /* Enable ethernet interrupts */
N      NVIC_ClearPendingIRQ(ENET_IRQn);
X      __NVIC_ClearPendingIRQ(ENET_IRQn);
N      NVIC_EnableIRQ(ENET_IRQn);
X      __NVIC_EnableIRQ(ENET_IRQn);
N
N      emac.frame_end = NULL;
X      (emac_control).frame_end = 0;
N      emac.flags    |= EMAC_FLAG_POWER;
X      (emac_control).flags    |= (1U << 1);
N      break;
N
N    default:
N      return ARM_DRIVER_ERROR_UNSUPPORTED;
X      return -4;
N  }
N  
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t GetMacAddress (ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Get Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
Nstatic int32_t GetMacAddress (ARM_ETH_MAC_ADDR *ptr_addr) {
N  uint32_t val;
N
N  if (!ptr_addr) {
N    /* Invalid parameters */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  val = LPC_EMAC->SA0;
X  val = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA0;
N  ptr_addr->b[5] = (uint8_t)(val >> 8);
N  ptr_addr->b[4] = (uint8_t)val;
N  val = LPC_EMAC->SA1;
X  val = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA1;
N  ptr_addr->b[3] = (uint8_t)(val >> 8);
N  ptr_addr->b[2] = (uint8_t)val;
N  val = LPC_EMAC->SA2;
X  val = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA2;
N  ptr_addr->b[1] = (uint8_t)(val >> 8);
N  ptr_addr->b[0] = (uint8_t)val;
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t SetMacAddress (const ARM_ETH_MAC_ADDR *ptr_addr)
N  \brief       Set Ethernet MAC Address.
N  \param[in]   ptr_addr  Pointer to address
N  \return      \ref execution_status
N*/
Nstatic int32_t SetMacAddress (const ARM_ETH_MAC_ADDR *ptr_addr) {
N
N  if (!ptr_addr) {
N    /* Invalid parameters */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  /* Set Ethernet MAC Address registers */
N  LPC_EMAC->SA0 = (ptr_addr->b[5] << 8) | ptr_addr->b[4];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA0 = (ptr_addr->b[5] << 8) | ptr_addr->b[4];
N  LPC_EMAC->SA1 = (ptr_addr->b[3] << 8) | ptr_addr->b[2];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA1 = (ptr_addr->b[3] << 8) | ptr_addr->b[2];
N  LPC_EMAC->SA2 = (ptr_addr->b[1] << 8) | ptr_addr->b[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA2 = (ptr_addr->b[1] << 8) | ptr_addr->b[0];
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t SetAddressFilter (const ARM_ETH_MAC_ADDR *ptr_addr,
N                                               uint32_t          num_addr)
N  \brief       Configure Address Filter.
N  \param[in]   ptr_addr  Pointer to addresses
N  \param[in]   num_addr  Number of addresses to configure
N  \return      \ref execution_status
N*/
Nstatic int32_t SetAddressFilter (const ARM_ETH_MAC_ADDR *ptr_addr, uint32_t num_addr) {
N  uint32_t crc;
N
N  if (!ptr_addr && num_addr) {
N    /* Invalid parameters */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  LPC_EMAC->RxFilterCtrl &= ~(RFC_UCAST_HASH_EN | RFC_MCAST_HASH_EN);
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl &= ~(0x00000008U | 0x00000010U);
N  LPC_EMAC->HashFilterH = 0x00000000U;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->HashFilterH = 0x00000000U;
N  LPC_EMAC->HashFilterL = 0x00000000U;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->HashFilterL = 0x00000000U;
N  
N  if (num_addr == 0U) {
N    return ARM_DRIVER_OK;
X    return 0;
N  }
N
N  /* Calculate 64-bit Hash table for MAC addresses */
N  for ( ; num_addr; ptr_addr++, num_addr--) {
N    crc = crc32_data(&ptr_addr->b[0], 6U) >> 23;
N    if (crc & 0x20) {
N      LPC_EMAC->HashFilterH |= (1U << (crc & 0x1FU));
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->HashFilterH |= (1U << (crc & 0x1FU));
N    }
N    else {
N      LPC_EMAC->HashFilterL |= (1U << (crc & 0x1FU));
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->HashFilterL |= (1U << (crc & 0x1FU));
N    }
N  }
N
N  /* Enable Rx Filter */
N  LPC_EMAC->RxFilterCtrl |= (RFC_UCAST_HASH_EN | RFC_MCAST_HASH_EN);
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl |= (0x00000008U | 0x00000010U);
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags)
N  \brief       Send Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer with data to send
N  \param[in]   len    Frame buffer length in bytes
N  \param[in]   flags  Frame transmit flags (see ARM_ETH_MAC_TX_FRAME_...)
N  \return      \ref execution_status
N*/
Nstatic int32_t SendFrame (const uint8_t *frame, uint32_t len, uint32_t flags) {
N  uint8_t *dst;
N  uint32_t idx;
N
N  if (!frame || !len) {
N    /* Invalid parameters */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  dst = emac.frame_end;
X  dst = (emac_control).frame_end;
N  idx = LPC_EMAC->TxProduceIndex;
X  idx = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex;
N  if (dst == NULL) {
X  if (dst == 0) {
N    dst = Tx_Desc[idx].Packet;
N    emac.frame_len = len;
X    (emac_control).frame_len = len;
N  }
N  else {
N    /* Sending data fragments in progress */
N    emac.frame_len += len;
X    (emac_control).frame_len += len;
N  }
N  /* Fast-copy data fragments to EMAC-DMA buffer */
N  for ( ; len > 7U; dst += 8U, frame += 8U, len -= 8U) {
N    __UNALIGNED_UINT32_WRITE(&dst[0], __UNALIGNED_UINT32_READ(&frame[0]));
X    ((*((__packed uint32_t *)(&dst[0]))) = ((*((const __packed uint32_t *)(&frame[0])))));
N    __UNALIGNED_UINT32_WRITE(&dst[4], __UNALIGNED_UINT32_READ(&frame[4]));
X    ((*((__packed uint32_t *)(&dst[4]))) = ((*((const __packed uint32_t *)(&frame[4])))));
N  }
N  /* Copy remaining 7 bytes */
N  for ( ; len > 1U; dst += 2U, frame += 2U, len -= 2U) {
N    __UNALIGNED_UINT16_WRITE(&dst[0], __UNALIGNED_UINT16_READ(&frame[0]));
X    ((*((__packed uint16_t *)(&dst[0]))) = ((*((const __packed uint16_t *)(&frame[0])))));
N  }
N  if (len > 0U) dst++[0] = frame++[0];
N
N  if (flags & ARM_ETH_MAC_TX_FRAME_FRAGMENT) {
X  if (flags & (1UL << 0)) {
N    /* More data to come, remember current write position */
N    emac.frame_end = dst;
X    (emac_control).frame_end = dst;
N    return ARM_DRIVER_OK;
X    return 0;
N  }
N
N  Tx_Desc[idx].Ctrl = (emac.frame_len-1U) | (TCTRL_INT | TCTRL_LAST);
X  Tx_Desc[idx].Ctrl = ((emac_control).frame_len-1U) | (0x80000000U | 0x40000000U);
N
N  emac.frame_end = NULL;
X  (emac_control).frame_end = 0;
N  emac.frame_len = 0U;
X  (emac_control).frame_len = 0U;
N
N  /* Start frame transmission. */
N  if (++idx == NUM_TX_BUF) idx = 0U;
X  if (++idx == 3U) idx = 0U;
N  LPC_EMAC->TxProduceIndex = idx;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex = idx;
N
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t ReadFrame (uint8_t *frame, uint32_t len)
N  \brief       Read data of received Ethernet frame.
N  \param[in]   frame  Pointer to frame buffer for data to read into
N  \param[in]   len    Frame buffer length in bytes
N  \return      number of data bytes read or execution status
N                 - value >= 0: number of data bytes read
N                 - value < 0: error occurred, value is execution status as defined with \ref execution_status 
N*/
Nstatic int32_t ReadFrame (uint8_t *frame, uint32_t len) {
N  uint8_t const *src;
N  uint32_t idx;
N  int32_t cnt = (int32_t)len;
N
N  if (!frame && len) {
N    /* Invalid parameters */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  idx = LPC_EMAC->RxConsumeIndex;
X  idx = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex;
N  src = (uint8_t const *)Rx_Desc[idx].Packet;
N  /* Fast-copy data to packet buffer */
N  for ( ; len > 7U; frame += 8U, src += 8U, len -= 8U) {
N    __UNALIGNED_UINT32_WRITE(&frame[0], __UNALIGNED_UINT32_READ(&src[0]));
X    ((*((__packed uint32_t *)(&frame[0]))) = ((*((const __packed uint32_t *)(&src[0])))));
N    __UNALIGNED_UINT32_WRITE(&frame[4], __UNALIGNED_UINT32_READ(&src[4]));
X    ((*((__packed uint32_t *)(&frame[4]))) = ((*((const __packed uint32_t *)(&src[4])))));
N  }
N  /* Copy remaining 7 bytes */
N  for ( ; len > 1U; frame += 2U, src += 2U, len -= 2U) {
N    __UNALIGNED_UINT16_WRITE(&frame[0], __UNALIGNED_UINT16_READ(&src[0]));
X    ((*((__packed uint16_t *)(&frame[0]))) = ((*((const __packed uint16_t *)(&src[0])))));
N  }
N  if (len > 0U) frame[0] = src[0];
N
N  if (++idx == NUM_RX_BUF) idx = 0U;
X  if (++idx == 4U) idx = 0U;
N  /* Release frame from EMAC buffer */
N  LPC_EMAC->RxConsumeIndex = idx;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex = idx;
N
N  return (cnt);
N}
N
N/**
N  \fn          uint32_t GetRxFrameSize (void)
N  \brief       Get size of received Ethernet frame.
N  \return      number of bytes in received frame
N*/
Nstatic uint32_t GetRxFrameSize (void) {
N  uint32_t info,idx;
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not yet powered */
N    return (0U);
N  }
N
N  idx = LPC_EMAC->RxConsumeIndex;
X  idx = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex;
N  if (idx == LPC_EMAC->RxProduceIndex) {
X  if (idx == ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxProduceIndex) {
N    /* No packet received */
N    return (0U);
N  }
N
N  info = Rx_Stat[idx].Info;
N  if (!(info & RINFO_LAST_FLAG) || (info & RINFO_ERR_MASK)) {
X  if (!(info & 0x40000000U) || (info & (0x00100000U | 0x00800000U | 0x01000000U | 0x02000000U | 0x08000000U | 0x10000000U))) {
N    /* Error, this block is invalid */
N    return (0xFFFFFFFFU);
N  }
N
N  return ((info & RINFO_SIZE) - 3U);
X  return ((info & 0x000007FFU) - 3U);
N}
N
N/* Ethernet IRQ Handler */
Nvoid ENET_IRQHandler (void) {
N  /* EMAC Ethernet Controller Interrupt function. */
N  uint32_t int_stat;
N  uint32_t event = 0U;
N
N  int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable);
X  int_stat = (((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntStatus & ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntEnable);
N  LPC_EMAC->IntClear = int_stat;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntClear = int_stat;
N  
N  if (int_stat & INT_RX_DONE) {
X  if (int_stat & 0x00000008U) {
N    /* Packet received, check if packet is valid. */
N    event |= ARM_ETH_MAC_EVENT_RX_FRAME;
X    event |= (1UL << 0);
N  }
N  if (int_stat & INT_TX_DONE) {
X  if (int_stat & 0x00000080U) {
N    /* Frame transmit completed. */
N    event |= ARM_ETH_MAC_EVENT_TX_FRAME;
X    event |= (1UL << 1);
N  }
N  /* Callback event notification */
N  if (event && emac.cb_event) {
X  if (event && (emac_control).cb_event) {
N    emac.cb_event (event);
X    (emac_control).cb_event (event);
N  }
N}
N
N/**
N  \fn          int32_t GetRxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of received Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
Nstatic int32_t GetRxFrameTime (ARM_ETH_MAC_TIME *time) {
N  return ARM_DRIVER_ERROR_UNSUPPORTED;
X  return -4;
N}
N
N/**
N  \fn          int32_t GetTxFrameTime (ARM_ETH_MAC_TIME *time)
N  \brief       Get time of transmitted Ethernet frame.
N  \param[in]   time  Pointer to time structure for data to read into
N  \return      \ref execution_status
N*/
Nstatic int32_t GetTxFrameTime (ARM_ETH_MAC_TIME *time) {
N  return ARM_DRIVER_ERROR_UNSUPPORTED;
X  return -4;
N}
N
N/**
N  \fn          int32_t Control (uint32_t control, uint32_t arg)
N  \brief       Control Ethernet Interface.
N  \param[in]   control  operation
N  \param[in]   arg      argument of operation (optional)
N  \return      \ref execution_status
N*/
Nstatic int32_t Control (uint32_t control, uint32_t arg) {
N  uint32_t rxfilterctrl;
N  uint32_t command, mac1, mac2, igpt, supp;
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N  
N  switch (control) {
N    case ARM_ETH_MAC_CONFIGURE:
X    case (0x01UL):
N      mac2    = LPC_EMAC->MAC2    & ~(MAC2_FULL_DUP | MAC2_FULL_DUP);
X      mac2    = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC2    & ~(0x00000001U | 0x00000001U);
N      command = LPC_EMAC->Command & ~CR_FULL_DUP;
X      command = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command & ~0x00000400U;
N      igpt    = LPC_EMAC->IPGT    & ~IPGT_FULL_DUP;
X      igpt    = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGT    & ~0x00000015U;
N      mac1    = LPC_EMAC->MAC1    & ~MAC1_LOOPB;
X      mac1    = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    & ~0x00000010U;
N      supp    = LPC_EMAC->SUPP    & ~SUPP_SPEED;
X      supp    = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP    & ~0x00000100U;
N      /* Configure 100MBit/10MBit mode */
N      switch (arg & ARM_ETH_MAC_SPEED_Msk) {
X      switch (arg & (3UL << 0)) {
N        case ARM_ETH_MAC_SPEED_10M:
X        case ((0U) << 0):
N          break;
N        case ARM_ETH_SPEED_100M:
X        case (1U):
N#if (RTE_ENET_RMII)
X#if (1)
N          supp |= SUPP_SPEED;
X          supp |= 0x00000100U;
N#endif
N          break;
N        default:
N          return ARM_DRIVER_ERROR_UNSUPPORTED;
X          return -4;
N      }
N
N      /* Configure Half/Full duplex mode */
N      switch (arg & ARM_ETH_MAC_DUPLEX_Msk) {
X      switch (arg & (1UL << 2)) {
N        case ARM_ETH_MAC_DUPLEX_FULL:
X        case ((1U) << 2):
N          mac2    |= MAC2_FULL_DUP;
X          mac2    |= 0x00000001U;
N          command |= CR_FULL_DUP;
X          command |= 0x00000400U;
N          igpt    |= IPGT_FULL_DUP;
X          igpt    |= 0x00000015U;
N          break;
N      }
N
N      /* Configure loopback mode */
N      if (arg & ARM_ETH_MAC_LOOPBACK) {
X      if (arg & (1UL << 4)) {
N        mac1 |= MAC1_LOOPB;
X        mac1 |= 0x00000010U;
N      }
N
N      if ((arg & ARM_ETH_MAC_CHECKSUM_OFFLOAD_RX) ||
X      if ((arg & (1UL << 5)) ||
N          (arg & ARM_ETH_MAC_CHECKSUM_OFFLOAD_TX)) {
X          (arg & (1UL << 6))) {
N        /* Checksum offload is disabled in the driver */
N        return ARM_DRIVER_ERROR_UNSUPPORTED;
X        return -4;
N      }
N
N      LPC_EMAC->SUPP    = supp;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP    = supp;
N      LPC_EMAC->MAC2    = mac2;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC2    = mac2;
N      LPC_EMAC->Command = command;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = command;
N      LPC_EMAC->IPGT    = igpt;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGT    = igpt;
N      LPC_EMAC->MAC1    = mac1;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    = mac1;
N
N      rxfilterctrl = LPC_EMAC->RxFilterCtrl & ~(RFC_UCAST_EN | RFC_BCAST_EN | RFC_MCAST_EN);
X      rxfilterctrl = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl & ~(0x00000001U | 0x00000002U | 0x00000004U);
N      /* Enable broadcast frame receive */
N      if (arg & ARM_ETH_MAC_ADDRESS_BROADCAST) {
X      if (arg & (1UL << 7)) {
N        rxfilterctrl |= RFC_BCAST_EN;
X        rxfilterctrl |= 0x00000002U;
N      }
N
N      /* Enable all multicast frame receive */
N      if (arg & ARM_ETH_MAC_ADDRESS_MULTICAST) {
X      if (arg & (1UL << 8)) {
N        rxfilterctrl |= RFC_MCAST_EN;
X        rxfilterctrl |= 0x00000004U;
N      }
N
N      /* Enable promiscuous mode (no filtering) */
N      if (arg & ARM_ETH_MAC_ADDRESS_ALL) {
X      if (arg & (1UL << 9)) {
N        rxfilterctrl |= (RFC_BCAST_EN | RFC_UCAST_EN | RFC_MCAST_EN);
X        rxfilterctrl |= (0x00000002U | 0x00000001U | 0x00000004U);
N      }
N      LPC_EMAC->RxFilterCtrl = rxfilterctrl;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl = rxfilterctrl;
N      break;
N
N    case ARM_ETH_MAC_CONTROL_TX:
X    case (0x02UL):
N      /* Enable/disable MAC transmitter */
N      command = LPC_EMAC->Command & ~CR_TX_EN;
X      command = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command & ~0x00000002U;
N
N      if (arg != 0U) {
N        command |= CR_TX_EN;
X        command |= 0x00000002U;
N      }
N      LPC_EMAC->Command = command;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = command;
N      break;
N
N    case ARM_ETH_MAC_CONTROL_RX:
X    case (0x03UL):
N      /* Enable/disable MAC receiver */
N      command = LPC_EMAC->Command & ~CR_RX_EN;
X      command = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command & ~0x00000001U;
N      mac1    = LPC_EMAC->MAC1    & ~MAC1_REC_EN;
X      mac1    = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    & ~0x00000001U;
N      if (arg != 0U) {
N        command |= CR_RX_EN;
X        command |= 0x00000001U;
N        mac1    |= MAC1_REC_EN;
X        mac1    |= 0x00000001U;
N      }
N      LPC_EMAC->Command = command;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = command;
N      LPC_EMAC->MAC1    = mac1;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    = mac1;
N      break;
N
N    case ARM_ETH_MAC_FLUSH:
X    case (0x04UL):
N      /* Flush Tx and Rx buffers */
N      if (arg & ARM_ETH_MAC_FLUSH_RX) {
X      if (arg & (1UL << 0)) {
N        /* Stop/Start DMA Receive */
N        command = LPC_EMAC->Command;
X        command = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command;
N        LPC_EMAC->Command &= ~CR_RX_EN;
X        ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command &= ~0x00000001U;
N        init_rx_desc ();
N        LPC_EMAC->Command = command;
X        ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = command;
N      }
N      if (arg & ARM_ETH_MAC_FLUSH_TX) {
X      if (arg & (1UL << 1)) {
N        /* Stop/Start DMA Transmit */
N        command = LPC_EMAC->Command;
X        command = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command;
N        LPC_EMAC->Command &= ~CR_TX_EN;
X        ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command &= ~0x00000002U;
N        init_tx_desc ();
N        LPC_EMAC->Command = command;
X        ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = command;
N      }
N      break;
N
N    case ARM_ETH_MAC_VLAN_FILTER:
X    case (0x06UL):
N      /* Configure VLAN filter */
N    default:
N      return ARM_DRIVER_ERROR_UNSUPPORTED;
X      return -4;
N  }
N  return ARM_DRIVER_OK;
X  return 0;
N}
N
N/**
N  \fn          int32_t ControlTimer (uint32_t control, ARM_ETH_MAC_TIME *time)
N  \brief       Control Precision Timer.
N  \param[in]   control  Operation
N  \param[in]   time     Pointer to time structure
N  \return      \ref execution_status
N*/
Nstatic int32_t ControlTimer (uint32_t control, ARM_ETH_MAC_TIME *time) {
N
N  return ARM_DRIVER_ERROR_UNSUPPORTED;
X  return -4;
N}
N
N/**
N  \fn          int32_t PHY_Read (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data)
N  \brief       Read Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[out]  data      Pointer where the result is written to
N  \return      \ref execution_status
N*/
Nstatic int32_t PHY_Read (uint8_t phy_addr, uint8_t reg_addr, uint16_t *data) {
N  uint32_t tick;
N
N  if (!data) {
N    /* Invalid parameter */
N    return ARM_DRIVER_ERROR_PARAMETER;
X    return -5;
N  }
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  if (emac.dev_175x == true) {
X  if ((emac_control).dev_175x == 1) {
N    /* Software MII Management for LPC175x. */
N    /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
N    GPIO_SetDir(EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, GPIO_DIR_OUTPUT);
X    GPIO_SetDir((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, (1U));
N    /* 32 consecutive ones on MDO to establish sync */
N    output_MDIO (0xFFFFFFFFU, 32U);
N
N    /* start code (01), read command (10) */
N    output_MDIO (0x06U, 4U);
N
N    /* write PHY address */
N    output_MDIO (phy_addr, 5U);
N
N    /* write the PHY register to write */
N    output_MDIO (reg_addr, 5U);
N
N    /* turnaround MDO is tristated */
N    turnaround_MDIO ();
N
N    /* read the data value */
N    *data = input_MDIO ();
N
N    /* turnaround MDIO is tristated */
N    turnaround_MDIO ();
N
N    return ARM_DRIVER_OK;
X    return 0;
N  }
N  else {
N    LPC_EMAC->MADR = (phy_addr << 8) | reg_addr;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MADR = (phy_addr << 8) | reg_addr;
N    LPC_EMAC->MCMD = MCMD_READ;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCMD = 0x00000001U;
N
N    /* Wait until operation completed */
N#if   defined(RTE_CMSIS_RTOS2)
X#if   0L
S    tick = osKernelGetSysTimerCount();
N#elif defined(RTE_CMSIS_RTOS)
X#elif 1L
N    tick = osKernelSysTick();
N#endif
N    do {
N      if ((LPC_EMAC->MIND & MIND_BUSY) == 0U) break;
X      if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001U) == 0U) break;
N#if   defined(RTE_CMSIS_RTOS2)
X#if   0L
S    } while ((osKernelGetSysTimerCount() - tick) < (((uint64_t)PHY_TIMEOUT * osKernelGetSysTimerFreq()) / 1000000U));
N#elif defined(RTE_CMSIS_RTOS)
X#elif 1L
N    } while ((osKernelSysTick() - tick) < osKernelSysTickMicroSec(PHY_TIMEOUT));
X    } while ((osKernelSysTick() - tick) < ((500U * os_tickus_i) + ((500U * os_tickus_f) >> 16)));
N#endif
N
N    if ((LPC_EMAC->MIND & MIND_BUSY) == 0U) {
X    if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001U) == 0U) {
N      LPC_EMAC->MCMD = 0U;
X      ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCMD = 0U;
N      *data = LPC_EMAC->MRDD;
X      *data = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MRDD;
N      return ARM_DRIVER_OK;
X      return 0;
N    }
N  }
N  return ARM_DRIVER_ERROR_TIMEOUT;
X  return -3;
N}
N
N/**
N  \fn          int32_t PHY_Write (uint8_t phy_addr, uint8_t reg_addr, uint16_t data)
N  \brief       Write Ethernet PHY Register through Management Interface.
N  \param[in]   phy_addr  5-bit device address
N  \param[in]   reg_addr  5-bit register address
N  \param[in]   data      16-bit data to write
N  \return      \ref execution_status
N*/
Nstatic int32_t PHY_Write (uint8_t phy_addr, uint8_t reg_addr, uint16_t data) {
N  uint32_t tick;
N
N  if (!(emac.flags & EMAC_FLAG_POWER)) {
X  if (!((emac_control).flags & (1U << 1))) {
N    /* Driver not powered */
N    return ARM_DRIVER_ERROR;
X    return -1;
N  }
N
N  if (emac.dev_175x == true) {
X  if ((emac_control).dev_175x == 1) {
N    /* Software MII Management for LPC175x. */
N    /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
N    GPIO_SetDir(EMAC_MDIO_PIN->Portnum, EMAC_MDIO_PIN->Pinnum, GPIO_DIR_OUTPUT);
X    GPIO_SetDir((&eth_pins[1])->Portnum, (&eth_pins[1])->Pinnum, (1U));
N    /* 32 consecutive ones on MDO to establish sync */
N    output_MDIO (0xFFFFFFFFU, 32U);
N
N    /* start code (01), write command (01) */
N    output_MDIO (0x05U, 4U);
N
N    /* write PHY address */
N    output_MDIO (phy_addr, 5U);
N
N    /* write the PHY register to write */
N    output_MDIO (reg_addr, 5U);
N
N    /* turnaround MDIO (1,0)*/
N    output_MDIO (0x02U, 2U);
N
N    /* write the data value */
N    output_MDIO (data, 16U);
N
N    /* turnaround MDO is tristated */
N    turnaround_MDIO ();
N
N    return ARM_DRIVER_OK;
X    return 0;
N  }
N  else {
N    /* Hardware MII Management for LPC176x devices. */
N    LPC_EMAC->MADR = (phy_addr << 8) | reg_addr;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MADR = (phy_addr << 8) | reg_addr;
N    LPC_EMAC->MWTD = data;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MWTD = data;
N
N    /* Wait until operation completed */
N#if   defined(RTE_CMSIS_RTOS2)
X#if   0L
S    tick = osKernelGetSysTimerCount();
N#elif defined(RTE_CMSIS_RTOS)
X#elif 1L
N    tick = osKernelSysTick();
N#endif
N    do {
N      if ((LPC_EMAC->MIND & MIND_BUSY) == 0U) break;
X      if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001U) == 0U) break;
N#if   defined(RTE_CMSIS_RTOS2)
X#if   0L
S    } while ((osKernelGetSysTimerCount() - tick) < (((uint64_t)PHY_TIMEOUT * osKernelGetSysTimerFreq()) / 1000000U));
N#elif defined(RTE_CMSIS_RTOS)
X#elif 1L
N    } while ((osKernelSysTick() - tick) < osKernelSysTickMicroSec(PHY_TIMEOUT));
X    } while ((osKernelSysTick() - tick) < ((500U * os_tickus_i) + ((500U * os_tickus_f) >> 16)));
N#endif
N    
N    if ((LPC_EMAC->MIND & MIND_BUSY) == 0U) {
X    if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001U) == 0U) {
N      return ARM_DRIVER_OK;
X      return 0;
N    }
N  }
N  return ARM_DRIVER_ERROR_TIMEOUT;
X  return -3;
N}
N
N/* MAC Driver Control Block */
NARM_DRIVER_ETH_MAC Driver_ETH_MAC0 = {
N  GetVersion,
N  GetCapabilities,
N  Initialize,
N  Uninitialize,
N  PowerControl,
N  GetMacAddress,
N  SetMacAddress,
N  SetAddressFilter,
N  SendFrame,
N  ReadFrame,
N  GetRxFrameSize,
N  GetRxFrameTime,
N  GetTxFrameTime,
N  ControlTimer,
N  Control,
N  PHY_Read,
N  PHY_Write
N};
