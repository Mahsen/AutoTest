; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\fs_config.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\fs_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\LPC1768 -I.\RTE\File_System -I.\RTE\Network -I.\RTE\_Main -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\RTOS\RTX\INC -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\FileSystem\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include -D__RTX -D__UVISION_VERSION=532 -D_RTE_ -DLPC175x_6x -D_RTE_ --omf_browse=.\objects\fs_config.crf RTE\File_System\FS_Config.c]
                          THUMB

                          AREA ||i.$Sub$$fflush||, CODE, READONLY, ALIGN=1

                  ||$Sub$$fflush|| PROC
;;;1693   
;;;1694   _ARMABI int $Sub$$fflush(FILE *stream) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1695     int *fh;
;;;1696   
;;;1697     if ($Super$$fflush (stream) == 0) {
000004  f7fffffe          BL       ||$Super$$fflush||
000008  b108              CBZ      r0,|L1.14|
;;;1698       fh = (int *)stream;
;;;1699       /* File handle is at offset 5 */
;;;1700       return (__sys_ensure (fh[5]));
;;;1701     }
;;;1702     return (1);
00000a  2001              MOVS     r0,#1
;;;1703   }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  6960              LDR      r0,[r4,#0x14]         ;1700
000010  e8bd4010          POP      {r4,lr}               ;1700
000014  f7ffbffe          B.W      __sys_ensure
;;;1704   
                          ENDP


                          AREA ||i.MC0_SPI_SignalEvent||, CODE, READONLY, ALIGN=2

                  MC0_SPI_SignalEvent PROC
;;;510      #if (MC0_SPI == 1)
;;;511      static void MC0_SPI_SignalEvent (uint32_t event) {
000000  4901              LDR      r1,|L2.8|
;;;512        mc_spi_DrvEvent (event, &fs_mc0_spi);
000002  f7ffbffe          B.W      mc_spi_DrvEvent
;;;513      }
;;;514      #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.efs_analyse||, CODE, READONLY, ALIGN=1

                  efs_analyse PROC
;;;1724    fsStatus efs_delete(const char *p, fsEFS_Volume *v)               { (void)p; (void)v;          return (fsError); }
;;;1725    int32_t  efs_analyse(fsEFS_Volume *v)                             { (void)v;                   return (0);       }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1726    fsStatus efs_check  (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_check||, CODE, READONLY, ALIGN=1

                  efs_check PROC
;;;1725    int32_t  efs_analyse(fsEFS_Volume *v)                             { (void)v;                   return (0);       }
;;;1726    fsStatus efs_check  (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1727    fsStatus efs_format (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_close||, CODE, READONLY, ALIGN=1

                  efs_close PROC
;;;1715    fsStatus efs_open  (int32_t h, const char *p, int32_t a)          { (void)h; (void)p; (void)a; return (fsError); }
;;;1716    fsStatus efs_close (int32_t h)                                    { (void)h;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1717    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (0);       }
                          ENDP


                          AREA ||i.efs_defrag||, CODE, READONLY, ALIGN=1

                  efs_defrag PROC
;;;1728    int64_t  efs_free   (fsEFS_Volume *v)                             { (void)v;                   return (-1);      }
;;;1729    fsStatus efs_defrag (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1730    fsStatus efs_info   (fsDriveInfo *i, fsEFS_Volume *v)             { (void)i; (void)v;          return (fsError); }
                          ENDP


                          AREA ||i.efs_delete||, CODE, READONLY, ALIGN=1

                  efs_delete PROC
;;;1723    fsStatus efs_rename(const char *p, const char *n, fsEFS_Volume *v){ (void)p; (void)n; (void)v; return (fsError); }
;;;1724    fsStatus efs_delete(const char *p, fsEFS_Volume *v)               { (void)p; (void)v;          return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1725    int32_t  efs_analyse(fsEFS_Volume *v)                             { (void)v;                   return (0);       }
                          ENDP


                          AREA ||i.efs_ffind||, CODE, READONLY, ALIGN=1

                  efs_ffind PROC
;;;1721    fsStatus efs_seek  (int32_t h, uint32_t a)                        { (void)h; (void)a;          return (fsError); }
;;;1722    fsStatus efs_ffind (fsFileInfo *i, fsEFS_Volume *v)               { (void)i; (void)v;          return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1723    fsStatus efs_rename(const char *p, const char *n, fsEFS_Volume *v){ (void)p; (void)n; (void)v; return (fsError); }
                          ENDP


                          AREA ||i.efs_flen||, CODE, READONLY, ALIGN=1

                  efs_flen PROC
;;;1719    fsStatus efs_flush (int32_t h)                                    { (void)h;                   return (fsError); }
;;;1720    int32_t  efs_flen  (int32_t h)                                    { (void)h;                   return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1721    fsStatus efs_seek  (int32_t h, uint32_t a)                        { (void)h; (void)a;          return (fsError); }
                          ENDP


                          AREA ||i.efs_flush||, CODE, READONLY, ALIGN=1

                  efs_flush PROC
;;;1718    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (-1);      }
;;;1719    fsStatus efs_flush (int32_t h)                                    { (void)h;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1720    int32_t  efs_flen  (int32_t h)                                    { (void)h;                   return (-1);      }
                          ENDP


                          AREA ||i.efs_format||, CODE, READONLY, ALIGN=1

                  efs_format PROC
;;;1726    fsStatus efs_check  (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
;;;1727    fsStatus efs_format (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1728    int64_t  efs_free   (fsEFS_Volume *v)                             { (void)v;                   return (-1);      }
                          ENDP


                          AREA ||i.efs_free||, CODE, READONLY, ALIGN=1

                  efs_free PROC
;;;1727    fsStatus efs_format (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
;;;1728    int64_t  efs_free   (fsEFS_Volume *v)                             { (void)v;                   return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4601              MOV      r1,r0
000006  4770              BX       lr
;;;1729    fsStatus efs_defrag (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_handle_get||, CODE, READONLY, ALIGN=1

                  efs_handle_get PROC
;;;1709   #if (EFS_USE == 0)
;;;1710    int32_t  efs_handle_get(fsEFS_Volume *v)                          { (void)v;                   return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1711    fsStatus efs_init      (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_info||, CODE, READONLY, ALIGN=1

                  efs_info PROC
;;;1729    fsStatus efs_defrag (fsEFS_Volume *v)                             { (void)v;                   return (fsError); }
;;;1730    fsStatus efs_info   (fsDriveInfo *i, fsEFS_Volume *v)             { (void)i; (void)v;          return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1731   #endif /* EFS_USE */
                          ENDP


                          AREA ||i.efs_init||, CODE, READONLY, ALIGN=1

                  efs_init PROC
;;;1710    int32_t  efs_handle_get(fsEFS_Volume *v)                          { (void)v;                   return (-1);      }
;;;1711    fsStatus efs_init      (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1712    fsStatus efs_uninit    (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_mount||, CODE, READONLY, ALIGN=1

                  efs_mount PROC
;;;1712    fsStatus efs_uninit    (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
;;;1713    fsStatus efs_mount     (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1714    fsStatus efs_unmount   (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_open||, CODE, READONLY, ALIGN=1

                  efs_open PROC
;;;1714    fsStatus efs_unmount   (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
;;;1715    fsStatus efs_open  (int32_t h, const char *p, int32_t a)          { (void)h; (void)p; (void)a; return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1716    fsStatus efs_close (int32_t h)                                    { (void)h;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_read||, CODE, READONLY, ALIGN=1

                  efs_read PROC
;;;1716    fsStatus efs_close (int32_t h)                                    { (void)h;                   return (fsError); }
;;;1717    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (0);       }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1718    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (-1);      }
                          ENDP


                          AREA ||i.efs_rename||, CODE, READONLY, ALIGN=1

                  efs_rename PROC
;;;1722    fsStatus efs_ffind (fsFileInfo *i, fsEFS_Volume *v)               { (void)i; (void)v;          return (fsError); }
;;;1723    fsStatus efs_rename(const char *p, const char *n, fsEFS_Volume *v){ (void)p; (void)n; (void)v; return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1724    fsStatus efs_delete(const char *p, fsEFS_Volume *v)               { (void)p; (void)v;          return (fsError); }
                          ENDP


                          AREA ||i.efs_seek||, CODE, READONLY, ALIGN=1

                  efs_seek PROC
;;;1720    int32_t  efs_flen  (int32_t h)                                    { (void)h;                   return (-1);      }
;;;1721    fsStatus efs_seek  (int32_t h, uint32_t a)                        { (void)h; (void)a;          return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1722    fsStatus efs_ffind (fsFileInfo *i, fsEFS_Volume *v)               { (void)i; (void)v;          return (fsError); }
                          ENDP


                          AREA ||i.efs_uninit||, CODE, READONLY, ALIGN=1

                  efs_uninit PROC
;;;1711    fsStatus efs_init      (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
;;;1712    fsStatus efs_uninit    (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1713    fsStatus efs_mount     (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
                          ENDP


                          AREA ||i.efs_unmount||, CODE, READONLY, ALIGN=1

                  efs_unmount PROC
;;;1713    fsStatus efs_mount     (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
;;;1714    fsStatus efs_unmount   (fsEFS_Volume *v)                          { (void)v;                   return (fsError); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1715    fsStatus efs_open  (int32_t h, const char *p, int32_t a)          { (void)h; (void)p; (void)a; return (fsError); }
                          ENDP


                          AREA ||i.efs_write||, CODE, READONLY, ALIGN=1

                  efs_write PROC
;;;1717    int32_t  efs_read  (int32_t h,       uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (0);       }
;;;1718    int32_t  efs_write (int32_t h, const uint8_t *p, uint32_t a)      { (void)h; (void)p; (void)a; return (-1);      }
000000  f04f30ff          MOV      r0,#0xffffffff
000004  4770              BX       lr
;;;1719    fsStatus efs_flush (int32_t h)                                    { (void)h;                   return (fsError); }
                          ENDP


                          AREA ||i.elink_cmd||, CODE, READONLY, ALIGN=1

                  elink_cmd PROC
;;;1785     uint32_t   elink_dir       (uint32_t i, uint32_t j, void *p) { (void)i; (void)j; (void)p; return (1); }
;;;1786     uint32_t   elink_cmd       (uint32_t i, void *p)             { (void)i; (void)p;          return (0); }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1787     uint32_t   elink_insert    (void *e, void *p)                { (void)e; (void)p;          return (1); }
                          ENDP


                          AREA ||i.elink_delete||, CODE, READONLY, ALIGN=1

                  elink_delete PROC
;;;1787     uint32_t   elink_insert    (void *e, void *p)                { (void)e; (void)p;          return (1); }
;;;1788     uint32_t   elink_delete    (void *e, void *p)                { (void)e; (void)p;          return (0); }
000000  2000              MOVS     r0,#0
000002  4770              BX       lr
;;;1789     uint32_t   elink_scan      (uint32_t i, void **e, void *p)   { (void)i; (void)e; (void)p; return (1); }
                          ENDP


                          AREA ||i.elink_dir||, CODE, READONLY, ALIGN=1

                  elink_dir PROC
;;;1784     uint32_t   elink_init      (void *p)                         { (void)p;                   return (1); }
;;;1785     uint32_t   elink_dir       (uint32_t i, uint32_t j, void *p) { (void)i; (void)j; (void)p; return (1); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1786     uint32_t   elink_cmd       (uint32_t i, void *p)             { (void)i; (void)p;          return (0); }
                          ENDP


                          AREA ||i.elink_init||, CODE, READONLY, ALIGN=1

                  elink_init PROC
;;;1783   
;;;1784     uint32_t   elink_init      (void *p)                         { (void)p;                   return (1); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1785     uint32_t   elink_dir       (uint32_t i, uint32_t j, void *p) { (void)i; (void)j; (void)p; return (1); }
                          ENDP


                          AREA ||i.elink_insert||, CODE, READONLY, ALIGN=1

                  elink_insert PROC
;;;1786     uint32_t   elink_cmd       (uint32_t i, void *p)             { (void)i; (void)p;          return (0); }
;;;1787     uint32_t   elink_insert    (void *e, void *p)                { (void)e; (void)p;          return (1); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1788     uint32_t   elink_delete    (void *e, void *p)                { (void)e; (void)p;          return (0); }
                          ENDP


                          AREA ||i.elink_scan||, CODE, READONLY, ALIGN=1

                  elink_scan PROC
;;;1788     uint32_t   elink_delete    (void *e, void *p)                { (void)e; (void)p;          return (0); }
;;;1789     uint32_t   elink_scan      (uint32_t i, void **e, void *p)   { (void)i; (void)e; (void)p; return (1); }
000000  2001              MOVS     r0,#1
000002  4770              BX       lr
;;;1790   #endif
                          ENDP


                          AREA ||i.fdelete||, CODE, READONLY, ALIGN=1

                  fdelete PROC
;;;1668   /* Use new fdelete() function */
;;;1669   fsStatus fdelete (const char *path, const char *options) {
000000  f7ffbffe          B.W      _fdelete
;;;1670     return (_fdelete (path, options));
;;;1671   }
;;;1672   #endif
                          ENDP


                          AREA ||i.fs_config||, CODE, READONLY, ALIGN=1

                  fs_config PROC
;;;1614    *----------------------------------------------------------------------------*/
;;;1615   void fs_config (const char *drive) {
000000  7801              LDRB     r1,[r0,#0]
;;;1616     switch (drive[0]) {
000002  294d              CMP      r1,#0x4d
000004  d102              BNE      |L31.12|
;;;1617   #if (NOR0_ENABLE || NOR1_ENABLE)
;;;1618       case 'F':
;;;1619         fs_config_flash (drive[1]);
;;;1620         break;
;;;1621   #endif
;;;1622   
;;;1623   #if (MC0_ENABLE || MC1_ENABLE)
;;;1624       case 'M':
;;;1625         fs_config_mc (drive[1]);
000006  7840              LDRB     r0,[r0,#1]
000008  f7ffbffe          B.W      fs_config_mc
                  |L31.12|
;;;1626         break;
;;;1627   #endif
;;;1628   
;;;1629   #if (NAND0_ENABLE || NAND1_ENABLE)
;;;1630       case 'N':
;;;1631         fs_config_nand (drive[1]);
;;;1632         break;
;;;1633   #endif
;;;1634   
;;;1635   #if (RAM0_ENABLE || RAM1_ENABLE)
;;;1636       case 'R':
;;;1637         fs_config_ram (drive[1]);
;;;1638         break;
;;;1639   #endif
;;;1640   
;;;1641   #if (USB0_ENABLE || USB1_ENABLE)
;;;1642       case 'U':
;;;1643         fs_config_usb (drive[1]);
;;;1644         break;
;;;1645   #endif
;;;1646       default:
;;;1647         break;
;;;1648     }
;;;1649   }
00000c  4770              BX       lr
;;;1650   
                          ENDP


                          AREA ||i.fs_config_mc||, CODE, READONLY, ALIGN=2

                  fs_config_mc PROC
;;;1369   
;;;1370   __inline static void fs_config_mc (char num) {
000000  b510              PUSH     {r4,lr}
;;;1371     switch (num) {
000002  2830              CMP      r0,#0x30
000004  d11e              BNE      |L32.68|
;;;1372   #if (MC0_ENABLE)
;;;1373       case '0':
;;;1374         fs_mc0_vol.Mutex         = fs_mutex_new ((const void *)fs_mc0_mtx);
000006  4810              LDR      r0,|L32.72|
000008  f7fffffe          BL       fs_mutex_new
00000c  490f              LDR      r1,|L32.76|
;;;1375         fs_mc0_vol.Drv           = &fs_mc0_drv;
;;;1376         fs_mc0_vol.CaBuf         = mc0_cache;
;;;1377         fs_mc0_vol.CaSize        = MC0_CACHE_SIZE * 2;
;;;1378        #if (MC0_NAME_CACHE_SIZE)
;;;1379         fs_mc0_vol.ncache        = &mc0_ncache;
;;;1380        #else
;;;1381         fs_mc0_vol.ncache        = NULL;
00000e  2300              MOVS     r3,#0
000010  f10102c0          ADD      r2,r1,#0xc0           ;1376
000014  6048              STR      r0,[r1,#4]            ;1375  ; fs_mc0_vol
000016  480c              LDR      r0,|L32.72|
000018  1d00              ADDS     r0,r0,#4              ;1375
00001a  6088              STR      r0,[r1,#8]            ;1377  ; fs_mc0_vol
00001c  2008              MOVS     r0,#8                 ;1377
00001e  624b              STR      r3,[r1,#0x24]  ; fs_mc0_vol
000020  e9c12004          STRD     r2,r0,[r1,#0x10]
;;;1382        #endif
;;;1383   
;;;1384        #if   (MC0_SPI == 0)
;;;1385         /* Register MCI driver for Native mode */
;;;1386         fs_mc0_mci.Instance      = 0;
;;;1387         fs_mc0_mci.ExtCSD        = (uint8_t *)mc0_cache;
;;;1388         fs_mc0_mci.Driver        = &CREATE_SYMBOL (Driver_MCI, MC0_MCI_DRIVER);
;;;1389         fs_mc0_mci.Callback      = MC0_MCI_SignalEvent;
;;;1390        #elif (MC0_SPI == 1)
;;;1391         /* Register SPI driver for SPI mode */
;;;1392         fs_mc0_spi.Instance      = 0;
000024  f10100a0          ADD      r0,r1,#0xa0
000028  7743              STRB     r3,[r0,#0x1d]
;;;1393         fs_mc0_spi.ExtCSD        = (uint8_t *)mc0_cache;
;;;1394         fs_mc0_spi.Driver        = &CREATE_SYMBOL (Driver_SPI, MC0_SPI_DRIVER);
00002a  6082              STR      r2,[r0,#8]  ; fs_mc0_spi
00002c  4a08              LDR      r2,|L32.80|
;;;1395         fs_mc0_spi.Callback      = MC0_SPI_SignalEvent;
00002e  6002              STR      r2,[r0,#0]  ; fs_mc0_spi
000030  4a08              LDR      r2,|L32.84|
;;;1396        #else
;;;1397         #error "Memory Card Interface Mode Invalid in FS_Config_MC_0.h"
;;;1398        #endif
;;;1399   
;;;1400        #if (MC0_FAT_JOURNAL)
;;;1401         /* Register file system journal */
;;;1402         fs_mc0_fsj.buf           = (uint8_t *)&mc0_cache[(MC0_CACHE_SIZE+1) * 256];
000032  6042              STR      r2,[r0,#4]  ; fs_mc0_spi
000034  f50052a1          ADD      r2,r0,#0x1420
000038  381c              SUBS     r0,r0,#0x1c
;;;1403         fs_mc0_vol.fsj           = &fs_mc0_fsj;
00003a  6042              STR      r2,[r0,#4]  ; fs_mc0_fsj
;;;1404         fs_mc0_vol.RsvdS         = FAT_SECT_RSVD;
00003c  6288              STR      r0,[r1,#0x28]  ; fs_mc0_vol
00003e  2040              MOVS     r0,#0x40
000040  f8a10080          STRH     r0,[r1,#0x80]
                  |L32.68|
;;;1405        #else
;;;1406         fs_mc0_vol.fsj           = NULL;
;;;1407         fs_mc0_vol.RsvdS         = 0;
;;;1408        #endif
;;;1409         break;
;;;1410   #endif /* MC0_ENABLE */
;;;1411   
;;;1412   #if (MC1_ENABLE)
;;;1413       case '1':
;;;1414         fs_mc1_vol.Mutex         = fs_mutex_new ((const void *)fs_mc1_mtx);
;;;1415         fs_mc1_vol.Drv           = &fs_mc1_drv;
;;;1416         fs_mc1_vol.CaBuf         = mc1_cache;
;;;1417         fs_mc1_vol.CaSize        = MC1_CACHE_SIZE * 2;
;;;1418        #if (MC1_NAME_CACHE_SIZE)
;;;1419         fs_mc1_vol.ncache        = &mc1_ncache;
;;;1420        #else
;;;1421         fs_mc1_vol.ncache        = NULL;
;;;1422        #endif
;;;1423   
;;;1424        #if   (MC1_SPI == 0)
;;;1425         /* Register MCI driver for Native mode */
;;;1426         fs_mc1_mci.Instance      = 1;
;;;1427         fs_mc1_mci.ExtCSD        = (uint8_t *)mc1_cache;
;;;1428         fs_mc1_mci.Driver        = &CREATE_SYMBOL (Driver_MCI, MC1_MCI_DRIVER);
;;;1429         fs_mc1_mci.Callback      = MC1_MCI_SignalEvent;
;;;1430        #elif (MC1_SPI == 1)
;;;1431         /* Register SPI driver for SPI mode */
;;;1432         fs_mc1_spi.Instance      = 1;
;;;1433         fs_mc1_spi.ExtCSD        = (uint8_t *)mc1_cache;
;;;1434         fs_mc1_spi.Driver        = &CREATE_SYMBOL (Driver_SPI, MC1_SPI_DRIVER);
;;;1435         fs_mc1_spi.Callback      = MC1_SPI_SignalEvent;
;;;1436        #else
;;;1437         #error "Memory Card Interface Mode Invalid in FS_Config_MC_1.h"
;;;1438        #endif
;;;1439   
;;;1440        #if (MC1_FAT_JOURNAL)
;;;1441         /* Register file system journal */
;;;1442         fs_mc1_fsj.buf           = (uint8_t *)&mc1_cache[(MC1_CACHE_SIZE+1) * 256];
;;;1443         fs_mc1_vol.fsj           = &fs_mc1_fsj;
;;;1444         fs_mc1_vol.RsvdS         = FAT_SECT_RSVD;
;;;1445        #else
;;;1446         fs_mc1_vol.fsj           = NULL;
;;;1447         fs_mc1_vol.RsvdS         = 0;
;;;1448        #endif
;;;1449         break;
;;;1450   #endif /* MC1_ENABLE */
;;;1451     }
;;;1452   }
000044  bd10              POP      {r4,pc}
;;;1453   
                          ENDP

000046  0000              DCW      0x0000
                  |L32.72|
                          DCD      ||.constdata||+0x4
                  |L32.76|
                          DCD      ||.bss||+0xbc
                  |L32.80|
                          DCD      Driver_SPI0
                  |L32.84|
                          DCD      MC0_SPI_SignalEvent

                          AREA ||i.fs_get_rtos_tick_freq||, CODE, READONLY, ALIGN=1

                  fs_get_rtos_tick_freq PROC
;;;423    */
;;;424    uint32_t fs_get_rtos_tick_freq (void) {
000000  f44f707a          MOV      r0,#0x3e8
;;;425    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;426      return osKernelGetTickFreq();
;;;427    #else
;;;428      return (1000U);
;;;429    #endif
;;;430    }
000004  4770              BX       lr
;;;431    /*
                          ENDP


                          AREA ||i.fs_get_sys_tick||, CODE, READONLY, ALIGN=1

                  fs_get_sys_tick PROC
;;;448    */
;;;449    uint32_t fs_get_sys_tick (void) {
000000  f7ffbffe          B.W      osKernelSysTick
;;;450    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;451      return (osKernelGetSysTimerCount());
;;;452    #else
;;;453      return (osKernelSysTick());
;;;454    #endif
;;;455    }
;;;456    /*
                          ENDP


                          AREA ||i.fs_get_sys_tick_us||, CODE, READONLY, ALIGN=2

                  fs_get_sys_tick_us PROC
;;;458    */
;;;459    uint32_t fs_get_sys_tick_us (uint32_t microsec) {
000000  4904              LDR      r1,|L35.20|
;;;460    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;461      return ((uint32_t)(((uint64_t)microsec * osKernelGetSysTimerFreq()) / 1000000U));
;;;462    #else
;;;463      return ((uint32_t)(osKernelSysTickMicroSec (microsec)));
000002  4a05              LDR      r2,|L35.24|
000004  8809              LDRH     r1,[r1,#0]  ; os_tickus_i
000006  8812              LDRH     r2,[r2,#0]  ; os_tickus_f
000008  4341              MULS     r1,r0,r1
00000a  4350              MULS     r0,r2,r0
00000c  eb014010          ADD      r0,r1,r0,LSR #16
;;;464    #endif
;;;465    }
000010  4770              BX       lr
;;;356    
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      os_tickus_i
                  |L35.24|
                          DCD      os_tickus_f

                          AREA ||i.fs_mutex_acquire||, CODE, READONLY, ALIGN=1

                  fs_mutex_acquire PROC
;;;375    */
;;;376    uint32_t fs_mutex_acquire (FS_MUTEX mutex) {
000000  b510              PUSH     {r4,lr}
;;;377      uint32_t status = 0U;
000002  2400              MOVS     r4,#0
;;;378    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;379      if (osMutexAcquire ((osMutexId_t)mutex, osWaitForever) != osOK) {
;;;380        status = 1U;
;;;381      }
;;;382    #else
;;;383      if (osMutexWait (mutex, osWaitForever) != osOK) {
000004  1e61              SUBS     r1,r4,#1
000006  f7fffffe          BL       osMutexWait
00000a  b100              CBZ      r0,|L36.14|
;;;384        status = 1U;
00000c  2401              MOVS     r4,#1
                  |L36.14|
;;;385      }
;;;386    #endif
;;;387      return (status);
00000e  4620              MOV      r0,r4
;;;388    }
000010  bd10              POP      {r4,pc}
;;;389    /*
                          ENDP


                          AREA ||i.fs_mutex_delete||, CODE, READONLY, ALIGN=1

                  fs_mutex_delete PROC
;;;407    */
;;;408    uint32_t fs_mutex_delete (FS_MUTEX mutex) {
000000  b510              PUSH     {r4,lr}
;;;409      uint32_t status = 0U;
000002  2400              MOVS     r4,#0
;;;410    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;411      if (osMutexDelete ((osMutexId_t)mutex) != osOK) {
;;;412        status = 1U;
;;;413      }
;;;414    #else
;;;415      if (osMutexDelete (mutex) != osOK) {
000004  f7fffffe          BL       osMutexDelete
000008  b100              CBZ      r0,|L37.12|
;;;416        status = 1U;
00000a  2401              MOVS     r4,#1
                  |L37.12|
;;;417      }
;;;418    #endif
;;;419      return (status);
00000c  4620              MOV      r0,r4
;;;420    }
00000e  bd10              POP      {r4,pc}
;;;421    /*
                          ENDP


                          AREA ||i.fs_mutex_new||, CODE, READONLY, ALIGN=1

                  fs_mutex_new PROC
;;;365    */
;;;366    FS_MUTEX fs_mutex_new (const void *arg) {
000000  f7ffbffe          B.W      osMutexCreate
;;;367    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;368      return ((FS_MUTEX)osMutexNew (arg));
;;;369    #else
;;;370      return ((FS_MUTEX)osMutexCreate (arg));
;;;371    #endif
;;;372    }
;;;373    /*
                          ENDP


                          AREA ||i.fs_mutex_release||, CODE, READONLY, ALIGN=1

                  fs_mutex_release PROC
;;;391    */
;;;392    uint32_t fs_mutex_release (FS_MUTEX mutex) {
000000  b510              PUSH     {r4,lr}
;;;393      uint32_t status = 0U;
000002  2400              MOVS     r4,#0
;;;394    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;395      if (osMutexRelease ((osMutexId_t)mutex) != osOK) {
;;;396        status = 1U;
;;;397      }
;;;398    #else
;;;399      if (osMutexRelease (mutex) != osOK) {
000004  f7fffffe          BL       osMutexRelease
000008  b100              CBZ      r0,|L39.12|
;;;400        status = 1U;
00000a  2401              MOVS     r4,#1
                  |L39.12|
;;;401      }
;;;402    #endif
;;;403      return (status);
00000c  4620              MOV      r0,r4
;;;404    }
00000e  bd10              POP      {r4,pc}
;;;405    /*
                          ENDP


                          AREA ||i.fs_set_rtos_delay||, CODE, READONLY, ALIGN=1

                  fs_set_rtos_delay PROC
;;;437    */
;;;438    uint32_t fs_set_rtos_delay (uint32_t millisec) {
000000  b510              PUSH     {r4,lr}
;;;439    #if defined (RTE_CMSIS_RTOS2) && !defined (RTE_CMSIS_RTOS)
;;;440      osDelay (millisec * fs_ms_rtos_tick);
;;;441    #else
;;;442      osDelay (millisec);
000002  f7fffffe          BL       osDelay
;;;443    #endif
;;;444      return (0);
000006  2000              MOVS     r0,#0
;;;445    }
000008  bd10              POP      {r4,pc}
;;;446    /*
                          ENDP


                          AREA ||i.mc0_DevCtrl||, CODE, READONLY, ALIGN=2

                  mc0_DevCtrl PROC
;;;489      }
;;;490      static fsStatus mc0_DevCtrl (fsDevCtrlCode code, void *p) {
000000  4a01              LDR      r2,|L41.8|
;;;491        return (MC0_DEVCTRL (code, p));
000002  f7ffbffe          B.W      mc_spi_DevCtrl
;;;492      }
;;;493    
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.mc0_Init||, CODE, READONLY, ALIGN=2

                  mc0_Init PROC
;;;474      /* MC0 wrapper functions */
;;;475      static uint32_t mc0_Init (uint32_t mode) {
000000  4901              LDR      r1,|L42.8|
;;;476        return (MC0_INIT (mode));
000002  f7ffbffe          B.W      mc_spi_Init
;;;477      }
;;;478      static uint32_t mc0_UnInit (uint32_t mode) {
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.mc0_RdInfo||, CODE, READONLY, ALIGN=2

                  mc0_RdInfo PROC
;;;486      }
;;;487      static uint32_t mc0_RdInfo (fsMediaInfo *info) {
000000  4901              LDR      r1,|L43.8|
;;;488        return (MC0_RDINFO (info));
000002  f7ffbffe          B.W      mc_spi_ReadInfo
;;;489      }
;;;490      static fsStatus mc0_DevCtrl (fsDevCtrlCode code, void *p) {
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.mc0_RdSect||, CODE, READONLY, ALIGN=2

                  mc0_RdSect PROC
;;;480      }
;;;481      static uint32_t mc0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
000000  4b01              LDR      r3,|L44.8|
;;;482        return (MC0_RDSEC (sect, buf, cnt));
000002  f7ffbffe          B.W      mc_spi_ReadSector
;;;483      }
;;;484      static uint32_t mc0_WrSect (uint32_t sect, const uint8_t *buf, uint32_t cnt) {
                          ENDP

000006  0000              DCW      0x0000
                  |L44.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.mc0_UnInit||, CODE, READONLY, ALIGN=2

                  mc0_UnInit PROC
;;;477      }
;;;478      static uint32_t mc0_UnInit (uint32_t mode) {
000000  4901              LDR      r1,|L45.8|
;;;479        return (MC0_UNINIT (mode));
000002  f7ffbffe          B.W      mc_spi_UnInit
;;;480      }
;;;481      static uint32_t mc0_RdSect (uint32_t sect, uint8_t *buf, uint32_t cnt) {
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      ||.bss||+0x15c

                          AREA ||i.mc0_WrSect||, CODE, READONLY, ALIGN=2

                  mc0_WrSect PROC
;;;483      }
;;;484      static uint32_t mc0_WrSect (uint32_t sect, const uint8_t *buf, uint32_t cnt) {
000000  4b01              LDR      r3,|L46.8|
;;;485        return (MC0_WRSEC (sect, buf, cnt));
000002  f7ffbffe          B.W      mc_spi_WriteSector
;;;486      }
;;;487      static uint32_t mc0_RdInfo (fsMediaInfo *info) {
                          ENDP

000006  0000              DCW      0x0000
                  |L46.8|
                          DCD      ||.bss||+0x15c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  fs_fat_fh
                          %        144
                  fs_efs_fh
                          %        28
                  os_mutex_cb_fs_mc0_mtx_def
                          %        16
                  fs_mc0_vol
                          %        132
                  fs_mc0_fsj
                          %        28
                  fs_mc0_spi
                          %        32
                  mc0_cache
                          %        5632

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  fs_fat_fh_cnt
000000  04                DCB      0x04
                  fs_efs_fh_cnt
000001  00                DCB      0x00
                  fs_ndrv
000002  0100              DCB      0x01,0x00
                  os_mutex_def_fs_mc0_mtx_def
                          DCD      os_mutex_cb_fs_mc0_mtx_def
                  fs_mc0_drv
                          DCD      mc0_Init
                          DCD      mc0_UnInit
                          DCD      mc0_RdSect
                          DCD      mc0_WrSect
                          DCD      mc0_RdInfo
                          DCD      mc0_DevCtrl
                  fs_DevPool
                          DCD      fs_mc0_vol
000024  4d30000d          DCB      0x4d,0x30,0x00,0x0d

                          AREA ||.data||, DATA, ALIGN=2

                  fs_ms_rtos_tick
                          DCD      0x00000000
