; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\net_legacy.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\net_legacy.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\RTE\Device\LPC1768 -I.\RTE\Network -I.\RTE\_Main -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Core\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\Driver\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\ARM\CMSIS\5.7.0\CMSIS\RTOS\RTX\INC -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\Device\Include -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\LPC1700_DFP\2.6.0\RTE_Driver -IC:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include -D__RTX -D__UVISION_VERSION=532 -D_RTE_ -DLPC175x_6x -D_RTE_ --omf_browse=.\objects\net_legacy.crf C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Lib\Net_Legacy.c]
                          THUMB

                          AREA ||i.dhcp_client_notify||, CODE, READONLY, ALIGN=1

                  dhcp_client_notify PROC
;;;197    /* Default function, when not provided by the user */
;;;198    __weak void dhcp_client_notify (uint32_t if_id, dhcpClientOption opt,
000000  4770              BX       lr
;;;199                                    const uint8_t *val, uint32_t len) {
;;;200      (void)if_id;
;;;201      (void)opt;
;;;202      (void)val;
;;;203      (void)len;
;;;204    }
;;;205    #endif /* ETH_LEGACY */
                          ENDP


                          AREA ||i.eth_link_notify||, CODE, READONLY, ALIGN=1

                  eth_link_notify PROC
;;;174    /* Default function, when not provided by the user */
;;;175    __weak void eth_link_notify (uint32_t if_num, ethLinkEvent event) {
000000  4770              BX       lr
;;;176      (void)if_num;
;;;177      (void)event;
;;;178    }
;;;179    #endif /* ETH_LEGACY */
                          ENDP


                          AREA ||i.icmp_ping||, CODE, READONLY, ALIGN=1

                  icmp_ping PROC
;;;210    /* Start ICMP ping process */
;;;211    netStatus icmp_ping (const uint8_t *ip_addr, net_icmp_cb_t cb_func) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;212      NET_ADDR4 addr4;
;;;213    
;;;214      /* Convert ip_addr to a structure */
;;;215      addr4.addr_type = NET_ADDR_IP4;
000006  2000              MOVS     r0,#0
000008  f8ad0000          STRH     r0,[sp,#0]
;;;216      memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
00000c  6820              LDR      r0,[r4,#0]
00000e  9001              STR      r0,[sp,#4]
;;;217      return (netPing_Echo ((NET_ADDR *)&addr4, cb_func));
000010  4629              MOV      r1,r5
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       netPing_Echo
;;;218    }
000018  bd7c              POP      {r2-r6,pc}
;;;219    
                          ENDP


                          AREA ||i.ip4_aton||, CODE, READONLY, ALIGN=1

                  ip4_aton PROC
;;;521    /* Convert a string containing an IPv4 address into a Network address */
;;;522    bool ip4_aton (const char *cp, uint8_t *ip4_addr) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;523      return (net_addr4_aton (cp, ip4_addr));
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       net_addr4_aton
;;;524    }
00000e  bd70              POP      {r4-r6,pc}
;;;525    
                          ENDP


                          AREA ||i.ip4_ntoa||, CODE, READONLY, ALIGN=1

                  ip4_ntoa PROC
;;;516    /* Convert an IPv4 Network address into an ASCII string */
;;;517    const char *ip4_ntoa (const uint8_t *ip4_addr) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;518      return (net_addr4_ntoa (ip4_addr));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       net_addr4_ntoa
;;;519    }
00000a  bd10              POP      {r4,pc}
;;;520    
                          ENDP


                          AREA ||i.mac_ntoa||, CODE, READONLY, ALIGN=1

                  mac_ntoa PROC
;;;526    /* Convert a MAC address into an ASCII string */
;;;527    const char *mac_ntoa (const uint8_t *mac_addr) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;528      return (net_mac_ntoa (mac_addr));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       net_mac_ntoa
;;;529    }
00000a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.netDHCP_Notify||, CODE, READONLY, ALIGN=1

                  netDHCP_Notify PROC
;;;182    #if (ETH_LEGACY != 0)
;;;183    void netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;184      uint32_t if_num = if_id & 0xFF;
00000c  f00408ff          AND      r8,r4,#0xff
;;;185      switch (option) {
000010  b125              CBZ      r5,|L7.28|
000012  2d2a              CMP      r5,#0x2a
000014  d009              BEQ      |L7.42|
000016  2d43              CMP      r5,#0x43
000018  d115              BNE      |L7.70|
00001a  e00d              B        |L7.56|
                  |L7.28|
;;;186        case NET_DHCP_OPTION_IP_ADDRESS:
;;;187          dhcp_client_notify (if_num, dhcpClientIPaddress, val, len);
00001c  463b              MOV      r3,r7
00001e  4632              MOV      r2,r6
000020  2100              MOVS     r1,#0
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       dhcp_client_notify
;;;188          break;
000028  e00d              B        |L7.70|
                  |L7.42|
;;;189        case NET_DHCP_OPTION_NTP_SERVERS:
;;;190          dhcp_client_notify (if_num, dhcpClientNTPservers, val, len);
00002a  463b              MOV      r3,r7
00002c  4632              MOV      r2,r6
00002e  212a              MOVS     r1,#0x2a
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       dhcp_client_notify
;;;191          break;
000036  e006              B        |L7.70|
                  |L7.56|
;;;192        case NET_DHCP_OPTION_BOOTFILE_NAME:
;;;193          dhcp_client_notify (if_num, dhcpClientBootfileName, val, len);
000038  463b              MOV      r3,r7
00003a  4632              MOV      r2,r6
00003c  2143              MOVS     r1,#0x43
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       dhcp_client_notify
;;;194          break;
000044  bf00              NOP      
                  |L7.70|
000046  bf00              NOP                            ;188
;;;195      }
;;;196    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;197    /* Default function, when not provided by the user */
                          ENDP


                          AREA ||i.netETH_Notify||, CODE, READONLY, ALIGN=1

                  netETH_Notify PROC
;;;146    #if (ETH_LEGACY != 0)
;;;147    void netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;148      if (event == netETH_LinkDown) {
000008  b924              CBNZ     r4,|L8.20|
;;;149        eth_link_notify (if_num, ethLinkDown);
00000a  2100              MOVS     r1,#0
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       eth_link_notify
000012  e028              B        |L8.102|
                  |L8.20|
;;;150      }
;;;151      else if (event == netETH_LinkUp) {
000014  2c01              CMP      r4,#1
000016  d126              BNE      |L8.102|
;;;152        switch (val) {
000018  2d07              CMP      r5,#7
00001a  d223              BCS      |L8.100|
00001c  e8dff005          TBB      [pc,r5]
000020  040e1822          DCB      0x04,0x0e,0x18,0x22
000024  09131d00          DCB      0x09,0x13,0x1d,0x00
;;;153          case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_10M:
;;;154            eth_link_notify (if_num, ethLinkUp_10MHalfDuplex);
000028  2101              MOVS     r1,#1
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       eth_link_notify
;;;155            break;
000030  e018              B        |L8.100|
;;;156          case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_10M:
;;;157            eth_link_notify (if_num, ethLinkUp_10MFullDuplex);
000032  2102              MOVS     r1,#2
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       eth_link_notify
;;;158            break;
00003a  e013              B        |L8.100|
;;;159          case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_100M:
;;;160            eth_link_notify (if_num, ethLinkUp_100MHalfDuplex);
00003c  2103              MOVS     r1,#3
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       eth_link_notify
;;;161            break;
000044  e00e              B        |L8.100|
;;;162          case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_100M:
;;;163            eth_link_notify (if_num, ethLinkUp_100MFullDuplex);
000046  2104              MOVS     r1,#4
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       eth_link_notify
;;;164            break;
00004e  e009              B        |L8.100|
;;;165          case (NET_ETH_DUPLEX_HALF << 2) | NET_ETH_SPEED_1G:
;;;166            eth_link_notify (if_num, ethLinkUp_1GHalfDuplex);
000050  2105              MOVS     r1,#5
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       eth_link_notify
;;;167            break;
000058  e004              B        |L8.100|
;;;168          case (NET_ETH_DUPLEX_FULL << 2) | NET_ETH_SPEED_1G:
;;;169            eth_link_notify (if_num, ethLinkUp_1GFullDuplex);
00005a  2106              MOVS     r1,#6
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       eth_link_notify
;;;170            break;
000062  bf00              NOP      
                  |L8.100|
000064  bf00              NOP                            ;155
                  |L8.102|
;;;171        }
;;;172      }
;;;173    }
000066  bd70              POP      {r4-r6,pc}
;;;174    /* Default function, when not provided by the user */
                          ENDP


                          AREA ||i.tcp_cb_wrapper||, CODE, READONLY, ALIGN=2

                  tcp_cb_wrapper PROC
;;;66     /* Convert callback type netTCP_cb_t to net_tcp_cb_t */
;;;67     static uint32_t tcp_cb_wrapper (int32_t socket, netTCP_Event event,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;68                                     const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;69       if (addr->addr_type != NET_ADDR_IP4) {
000010  8820              LDRH     r0,[r4,#0]
000012  b110              CBZ      r0,|L9.26|
;;;70         /* Ignore IPv6 */
;;;71         return (0);
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;72       }
;;;73       if (event != netTCP_EventData) {
;;;74         /* Provide IP4 address and port */
;;;75         buf = addr->addr;
;;;76         len = addr->port;
;;;77       }
;;;78       return (net_tcp_cb_legacy[socket-1] (socket, event, buf, len));
;;;79     }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  2e05              CMP      r6,#5                 ;73
00001c  d002              BEQ      |L9.36|
00001e  1d27              ADDS     r7,r4,#4              ;75
000020  f8b48002          LDRH     r8,[r4,#2]            ;76
                  |L9.36|
000024  1e68              SUBS     r0,r5,#1              ;78
000026  4904              LDR      r1,|L9.56|
000028  f851c020          LDR      r12,[r1,r0,LSL #2]    ;78
00002c  4643              MOV      r3,r8                 ;78
00002e  463a              MOV      r2,r7                 ;78
000030  4631              MOV      r1,r6                 ;78
000032  4628              MOV      r0,r5                 ;78
000034  47e0              BLX      r12                   ;78
000036  e7ee              B        |L9.22|
;;;80     
                          ENDP

                  |L9.56|
                          DCD      net_tcp_cb_legacy

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=1

                  tcp_connect PROC
;;;114    /* Initiate TCP connection to a remote node */
;;;115    netStatus tcp_connect (int32_t socket,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;116                           const uint8_t *ip_addr, uint16_t port, uint16_t local_port) {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;117      NET_ADDR4 addr4;
;;;118    
;;;119      /* Convert ip_addr and port to a structure */
;;;120      addr4.addr_type = NET_ADDR_IP4;
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;121      addr4.port      = port;
000012  f8ad5002          STRH     r5,[sp,#2]
;;;122      memcpy (addr4.addr, ip_addr, NET_ADDR_IP4_LEN);
000016  6820              LDR      r0,[r4,#0]
000018  9001              STR      r0,[sp,#4]
;;;123      return (netTCP_Connect (socket, (NET_ADDR *)&addr4, local_port));
00001a  4632              MOV      r2,r6
00001c  4669              MOV      r1,sp
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       netTCP_Connect
;;;124    }
000024  e8bd81fc          POP      {r2-r8,pc}
;;;125    
                          ENDP


                          AREA ||i.tcp_get_socket||, CODE, READONLY, ALIGN=2

                  tcp_get_socket PROC
;;;81     /* Allocate a free UDP socket */
;;;82     int32_t tcp_get_socket (uint8_t type, uint8_t tos, uint32_t tout, net_tcp_cb_t cb_func) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;83       int32_t sock;
;;;84     
;;;85       /* Use callback wrapper */
;;;86       sock = netTCP_GetSocket (tcp_cb_wrapper);
00000c  4819              LDR      r0,|L11.116|
00000e  f7fffffe          BL       netTCP_GetSocket
000012  4606              MOV      r6,r0
;;;87       if (sock <= 0) {
000014  2e00              CMP      r6,#0
000016  dc02              BGT      |L11.30|
;;;88         return (sock);
000018  4630              MOV      r0,r6
                  |L11.26|
;;;89       }
;;;90       net_tcp_cb_legacy[sock-1] = cb_func;
;;;91       /* Default tos = 0 */
;;;92       if (tos != 0) {
;;;93         netTCP_SetOption (sock, netTCP_OptionTOS, tos);
;;;94       }
;;;95       /* Default tout = 0 (using timeout from Net_Config_TCP.h) */
;;;96       if (tout != 0) {
;;;97         netTCP_SetOption (sock, netTCP_OptionTimeout, tout);
;;;98       }
;;;99       /* Delay ACK: default not enabled */
;;;100      if (type & TCP_TYPE_DELAY_ACK) {
;;;101        netTCP_SetOption (sock, netTCP_OptionDelayedACK, 1);
;;;102      }
;;;103      /* Flow Control: default not enabled */
;;;104      if (type & TCP_TYPE_FLOW_CTRL) {
;;;105        netTCP_SetOption (sock, netTCP_OptionFlowControl, 1);
;;;106      }
;;;107      /* Keep Alive: default not enabled */
;;;108      if (type & TCP_TYPE_KEEP_ALIVE) {
;;;109        netTCP_SetOption (sock, netTCP_OptionKeepAlive, 1);
;;;110      }
;;;111      return (sock);
;;;112    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.30|
00001e  1e70              SUBS     r0,r6,#1              ;90
000020  4915              LDR      r1,|L11.120|
000022  f8418020          STR      r8,[r1,r0,LSL #2]     ;90
000026  b125              CBZ      r5,|L11.50|
000028  462a              MOV      r2,r5                 ;93
00002a  2100              MOVS     r1,#0                 ;93
00002c  4630              MOV      r0,r6                 ;93
00002e  f7fffffe          BL       netTCP_SetOption
                  |L11.50|
000032  b127              CBZ      r7,|L11.62|
000034  463a              MOV      r2,r7                 ;97
000036  2102              MOVS     r1,#2                 ;97
000038  4630              MOV      r0,r6                 ;97
00003a  f7fffffe          BL       netTCP_SetOption
                  |L11.62|
00003e  f0040001          AND      r0,r4,#1              ;100
000042  b120              CBZ      r0,|L11.78|
000044  2201              MOVS     r2,#1                 ;101
000046  2105              MOVS     r1,#5                 ;101
000048  4630              MOV      r0,r6                 ;101
00004a  f7fffffe          BL       netTCP_SetOption
                  |L11.78|
00004e  f0040002          AND      r0,r4,#2              ;104
000052  b120              CBZ      r0,|L11.94|
000054  2201              MOVS     r2,#1                 ;105
000056  2104              MOVS     r1,#4                 ;105
000058  4630              MOV      r0,r6                 ;105
00005a  f7fffffe          BL       netTCP_SetOption
                  |L11.94|
00005e  f0040004          AND      r0,r4,#4              ;108
000062  b120              CBZ      r0,|L11.110|
000064  2201              MOVS     r2,#1                 ;109
000066  2103              MOVS     r1,#3                 ;109
000068  4630              MOV      r0,r6                 ;109
00006a  f7fffffe          BL       netTCP_SetOption
                  |L11.110|
00006e  4630              MOV      r0,r6                 ;111
000070  e7d3              B        |L11.26|
;;;113    
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
                          DCD      tcp_cb_wrapper
                  |L11.120|
                          DCD      net_tcp_cb_legacy

                          AREA ||i.tcp_get_state||, CODE, READONLY, ALIGN=1

                  tcp_get_state PROC
;;;126    /* Determine current state of a TCP socket */
;;;127    tcpState tcp_get_state (int32_t socket) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;128      netTCP_State state = netTCP_GetState (socket);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       netTCP_GetState
00000a  4604              MOV      r4,r0
;;;129      if (state == netTCP_StateINVALID) {
00000c  1c60              ADDS     r0,r4,#1
00000e  b908              CBNZ     r0,|L12.20|
;;;130        /* New state in Network-DS only */
;;;131        return (netTCP_StateUNUSED);
000010  2000              MOVS     r0,#0
                  |L12.18|
;;;132      }
;;;133      return (state);
;;;134    }
000012  bd70              POP      {r4-r6,pc}
                  |L12.20|
000014  4620              MOV      r0,r4                 ;133
000016  e7fc              B        |L12.18|
;;;135    
                          ENDP


                          AREA ||i.tcp_ntoa||, CODE, READONLY, ALIGN=1

                  tcp_ntoa PROC
;;;136    /* Convert TCP socket state into an ASCII string */
;;;137    const char *tcp_ntoa (tcpState state) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;138      return (net_tcp_ntoa (state));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       net_tcp_ntoa
;;;139    }
00000a  bd10              POP      {r4,pc}
;;;140    #endif /* RTE_Network_Socket_TCP */
                          ENDP

