L 1 "RTE\Network\Net_Debug.c"
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    Net_Debug.c
N * Purpose: Network Debug Configuration
N * Rev.:    V7.1.0
N *----------------------------------------------------------------------------*/
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N// <q>Print Time Stamps
N// <i>Enable printing time stamps in debug messages
N#define DBG_TIME                1
N
N// <e>System Debug
N// <i>Enable printing system debug messages
N#define DBG_SYSTEM_EN           1
N
N//   <o>Memory Management  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Dynamic Memory Management debugging
N#define DBG_MEM                 1
N
N//   <o>ETH Interface  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Ethernet Interface debugging
N#define DBG_ETH                 1
N
N//   <o>WiFi Interface  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure WiFi Interface debugging
N#define DBG_WIFI                1
N
N//   <o>PPP Interface  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Serial PPP Interface debugging
N#define DBG_PPP                 0
N
N//   <o>SLIP Interface  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Serial SLIP Interface debugging
N#define DBG_SLIP                0
N
N//   <o>Loopback Interface  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Local Loopback Interface debugging
N#define DBG_LOOP                1
N// </e>
N
N// <e>IPv4 Core Debug
N// <i>Enable printing IPv4 debug messages
N#define DBG_CORE4_EN            0
N
N//   <o>IP4 Core  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure IPv4 Core/localhost debugging
N#define DBG_IP4                 1
N
N//   <o>ICMP Control  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Internet Control Message debugging
N#define DBG_ICMP                1
N
N//   <o>IGMP Management  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure debugging of Multicast Group Management
N#define DBG_IGMP                1
N
N//   <o>NBNS Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure NetBIOS Name Service Client debugging
N#define DBG_NBNS                1
N
N//   <o>DHCP Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Dynamic Host Configuration Client debugging
N#define DBG_DHCP                1
N
N//   <o>ARP Address Resolution  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Ethernet Address Resolution debugging
N#define DBG_ARP                 1
N// </e>
N
N// <e>IPv6 Core Debug
N// <i>Enable printing IPv6 debug messages
N#define DBG_CORE6_EN            0
N
N//   <o>IP6 Core  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure IPv6 Core/localhost debugging
N#define DBG_IP6                 1
N
N//   <o>ICMP6 Control  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Internet Control Message ver.6 debugging
N#define DBG_ICMP6               1
N
N//   <o>DHCP6 Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Dynamic Host Configuration ver.6 Client debugging
N#define DBG_DHCP6               1
N
N//   <o>NDP Neighbor Discovery  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Neighbor Discovery in IPv6 debugging
N#define DBG_NDP6                1
N// </e>
N
N// <e>Socket Debug
N// <i>Enable printing socket debug messages
N#define DBG_SOCKET_EN           0
N
N//   <o>UDP Socket  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure native UDP Socket debugging
N#define DBG_UDP_SOCKET          1
N
N//   <o>TCP Socket  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure native TCP Socket debugging
N#define DBG_TCP_SOCKET          1
N
N//   <o>BSD Socket  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure BSD Socket Interface debugging
N#define DBG_BSD_SOCKET          1
N// </e>
N
N// <e>Service Debug
N// <i>Enable printing service debug messages
N#define DBG_SERVICE_EN          0
N
N//   <o>HTTP Server  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Web Server debugging
N#define DBG_HTTP_SERVER         1
N
N//   <o>FTP Server  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure FTP Server debugging
N#define DBG_FTP_SERVER          1
N
N//   <o>FTP Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure FTP Client debugging
N#define DBG_FTP_CLIENT          1
N
N//   <o>Telnet Server  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Telnet Server debugging
N#define DBG_TELNET_SERVER       1
N
N//   <o>TFTP Server  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure TFTP Server debugging
N#define DBG_TFTP_SERVER         1
N
N//   <o>TFTP Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure TFTP Client debugging
N#define DBG_TFTP_CLIENT         1
N
N//   <o>SMTP Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure SMTP Client debugging
N#define DBG_SMTP_CLIENT         1
N
N//   <o>DNS Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Domain Name Service Client debugging
N#define DBG_DNS_CLIENT          1
N
N//   <o>SNMP Agent  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Simple Network Management debugging
N#define DBG_SNMP_AGENT          1
N
N//   <o>SNTP Client  <0=>Off <1=>Errors only <2=>Full debug
N//   <i>Configure Simple Network Time debugging
N#define DBG_SNTP_CLIENT         1
N// </e>
N
N//------------- <<< end of configuration section >>> ---------------------------
N
N
N#include "net_debug.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_debug.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    net_debug.h
N * Purpose: Network Library Debug Configuration
N * Rev.:    V7.11.0
N *----------------------------------------------------------------------------*/
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 11 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_debug.h" 2
N#include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 12 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_debug.h" 2
N#include "rl_net_lib.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_lib.h
N * Purpose: Network Library Definitions
N * Rev.:    V7.13.4
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_LIB_H
N#define __RL_NET_LIB_H
N
N#include "rl_net_ds.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    rl_net_ds.h
N * Purpose: Network API (Dual-stack IPv4/IPv6)
N * Rev.:    V7.13.3
N *----------------------------------------------------------------------------*/
N
N#ifndef __RL_NET_DS_H
N#define __RL_NET_DS_H
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 15 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 16 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N#include "RTE_Components.h"
L 1 ".\RTE\_Main\RTE_Components.h" 1
N
N
N/*
N
N * Auto generated Run-Time-Environment Configuration File
N
N *      *** Do not modify ! ***
N
N *
N
N * Project: 'main' 
N
N * Target:  'Main' 
N
N */
N
N
N
N#ifndef RTE_COMPONENTS_H
N
N#define RTE_COMPONENTS_H
N
N
N
N
N
N/*
N
N * Define the Device Header File: 
N
N */
N
N#define CMSIS_device_header "LPC17xx.h"
N
N
N
N/* ARM::CMSIS:RTOS:Keil RTX:4.82.0 */
N
N#define RTE_CMSIS_RTOS                  /* CMSIS-RTOS */
N
N        #define RTE_CMSIS_RTOS_RTX              /* CMSIS-RTOS Keil RTX */
N
N/* Keil.ARM Compiler::Compiler:Event Recorder:DAP:1.4.0 */
N
N#define RTE_Compiler_EventRecorder
N
N          #define RTE_Compiler_EventRecorder_DAP
N
N/* Keil.MDK-Plus::Network:CORE:IPv4 Debug:7.14.0 */
N
N#define RTE_Network_Core                /* Network Core */
N
N          #define RTE_Network_IPv4                /* Network IPv4 Stack */
N
N          #define RTE_Network_Debug               /* Network Debug Version */
N
N/* Keil.MDK-Plus::Network:Interface:ETH:7.14.0 */
N
N#define RTE_Network_Interface_ETH_0     /* Network Interface ETH 0 */
N
N
N
N/* Keil.MDK-Plus::Network:Service:Web Server Compact:HTTP:7.14.0 */
N
N#define RTE_Network_Web_Server_RO       /* Network Web Server with Read-only Web Resources */
N
N/* Keil.MDK-Plus::Network:Socket:TCP:7.14.0 */
N
N#define RTE_Network_Socket_TCP          /* Network Socket TCP */
N
N/* Keil::CMSIS Driver:Ethernet MAC:2.12.0 */
N
N#define RTE_Drivers_ETH_MAC0            /* Driver ETH_MAC0 */
N
N/* Keil::CMSIS Driver:Ethernet PHY:DP83848C:6.2.0 */
N
N#define RTE_Drivers_PHY_DP83848C        /* Driver PHY DP83848C */
N
N/* Keil::Device:Startup:1.0.0 */
N
N#define RTE_DEVICE_STARTUP_LPC17XX      /* Device Startup for NXP17XX */
N
N
N
N
N
N#endif /* RTE_COMPONENTS_H */
N
L 17 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_ds.h" 2
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N#ifdef __clang__
S  #define __weak    __attribute__((weak))
N#endif
N
N/// Network to host byte order conversion.
N#if defined(__BIG_ENDIAN) || defined(__ARM_BIG_ENDIAN)
X#if 0L || 0L
S  #define ntohl(v)              (uint32_t)(v)
S  #define ntohs(v)              (uint16_t)(v)
N#elif defined (__CC_ARM)
X#elif 1L
N  /* ARM Compiler 4/5 */
N  #define ntohl(v)              (uint32_t)(__rev(v))
N  #define ntohs(v)              (uint16_t)(__rev(v) >> 16)
N#else
S  /* ARM Compiler 6 */
S  #define ntohl(v)              __builtin_bswap32((uint32_t)(v))
S  #define ntohs(v)              __builtin_bswap16((uint16_t)(v))
N#endif
N
N/// Host to network byte order conversion.
N#define htons(v)                ntohs(v)
N#define htonl(v)                ntohl(v)
N
N/// General definitions.
N#define NET_ADDR_ETH_LEN        6       ///< Ethernet MAC Address Length in bytes
N#define NET_ADDR_IP4_LEN        4       ///< IPv4 Address Length in bytes
N#define NET_ADDR_IP6_LEN        16      ///< IPv6 Address Length in bytes
N#define NET_HOSTNAME_LEN        16      ///< Hostname Buffer Length in bytes
N#define NET_ROOT_DIR_LEN        80      ///< Service Root Folder Length in bytes
N
N/// Network Address types.
N#define NET_ADDR_ANY           (-1)     ///< IP address any
N#define NET_ADDR_IP4            0       ///< IPv4 Address
N#define NET_ADDR_IP6            1       ///< IPv6 Address
N
N/// Network Address IPv4/IPv6 capable.
Ntypedef struct net_addr {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4 or \ref NET_ADDR_IP6
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP6_LEN];      ///< IPv4 or IPv6 address (array 16 bytes, MSB first)
X  uint8_t  addr[16];      
N} NET_ADDR;
N
N/// Network Address IPv4 only.
Ntypedef struct net_addr4 {
N  int16_t  addr_type;                   ///< IP address type: \ref NET_ADDR_IP4
N  uint16_t port;                        ///< Internet socket port number
N  uint8_t  addr[NET_ADDR_IP4_LEN];      ///< IPv4 address (array 4 bytes, MSB first)
X  uint8_t  addr[4];      
N} NET_ADDR4;
N
N/// Service Authentication definitions.
N#define NET_USERNAME_LEN        16      ///< Username Buffer Length in bytes
N#define NET_PASSWORD_LEN        16      ///< Password Buffer Length in bytes
N
N/// Network Access definitions. 
N#define NET_ACCESS_FILE_READ            0x01  ///< File Read is allowed
N#define NET_ACCESS_FILE_WRITE           0x02  ///< File Write is allowed
N#define NET_ACCESS_DIRECTORY_CREATE     0x04  ///< Directory Create is allowed
N#define NET_ACCESS_DIRECTORY_REMOVE     0x08  ///< Directory Remove is allowed
N#define NET_ACCESS_DIRECTORY_LIST       0x10  ///< Directory List is allowed
N
N/// Status code values returned by Network library functions.
Ntypedef enum {
N  netOK                       = 0,      ///< Operation succeeded
N  netBusy,                              ///< Process is busy
N  netError,                             ///< Unspecified error
N  netInvalidParameter,                  ///< Invalid parameter specified
N  netWrongState,                        ///< Wrong state error
N  netDriverError,                       ///< Driver error
N  netServerError,                       ///< Server error
N  netAuthenticationFailed,              ///< User authentication failed
N  netDnsResolverError,                  ///< DNS host resolver failed
N  netFileError,                         ///< File not found or file r/w error
N  netTimeout                            ///< Operation timeout
N} netStatus;
N
N/// UDP Checksum Options.
N#define NET_UDP_CHECKSUM_SEND   0x01    ///< Calculate Checksum for UDP send frames (default)
N#define NET_UDP_CHECKSUM_VERIFY 0x02    ///< Verify Checksum for received UDP frames (default)
N
N/// UDP Socket Options.
Ntypedef enum {
N  netUDP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netUDP_OptionTTL,                     ///< IPv4 Multi-cast Time to Live; val=TTL
N  netUDP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netUDP_OptionHopLimit,                ///< IPv6 Multi-cast Hop Limit; val=HopLimit
N  netUDP_OptionInterface,               ///< IPv4 Broadcast Interface; val=if_id (class and number)
N  netUDP_OptionChecksum                 ///< UDP Checksum Options
N} netUDP_Option;
N
N/// UDP Event callback function.
Ntypedef uint32_t (*netUDP_cb_t)(int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N/// TCP Socket Events.
Ntypedef enum {
N  netTCP_EventConnect         = 0,      ///< Connect request received event
N  netTCP_EventEstablished,              ///< Connection established event
N  netTCP_EventClosed,                   ///< Connection was properly closed
N  netTCP_EventAborted,                  ///< Connection is for some reason aborted
N  netTCP_EventACK,                      ///< Previously send data acknowledged
N  netTCP_EventData                      ///< Data received event
N} netTCP_Event;
N
N/// TCP Socket States.
Ntypedef enum {
N  netTCP_StateINVALID         =-1,      ///< Invalid Socket
N  netTCP_StateUNUSED          = 0,      ///< Entry is free and unused
N  netTCP_StateCLOSED,                   ///< Entry allocated, socket still closed
N  netTCP_StateLISTEN,                   ///< Socket waiting for incoming connection
N  netTCP_StateSYN_RECEIVED,             ///< SYN frame received
N  netTCP_StateSYN_SENT,                 ///< SYN packet sent to establish a connection
N  netTCP_StateFIN_WAIT_1,               ///< Close started FIN packet was sent
N  netTCP_StateFIN_WAIT_2,               ///< Our FIN ACK-ed, waiting for remote FIN
N  netTCP_StateCLOSING,                  ///< Received FIN independently of our FIN
N  netTCP_StateLAST_ACK,                 ///< Waiting for last ACK for our FIN
N  netTCP_StateTIME_WAIT,                ///< Timed waiting for 2MSL
N  netTCP_StateESTABLISHED               ///< TCP Connection established
N} netTCP_State;
N
N/// TCP Socket Options.
Ntypedef enum {
N  netTCP_OptionTOS            = 0,      ///< IPv4 Type of Service; val=TOS
N  netTCP_OptionTrafficClass,            ///< IPv6 Traffic Class; val=TrafficClass
N  netTCP_OptionTimeout,                 ///< TCP Idle Timeout; val=timeout (in seconds)
N  netTCP_OptionKeepAlive,               ///< TCP Keep Alive; val: 0=disabled (default), 1=enabled
N  netTCP_OptionFlowControl,             ///< TCP Flow Control; val: 0=disabled (default), 1=enabled
N  netTCP_OptionDelayedACK               ///< TCP Delayed Acknowledgment; val: 0=disabled (default), 1=enabled 
N} netTCP_Option;
N
N/// TCP Event callback function.
Ntypedef uint32_t (*netTCP_cb_t)(int32_t socket, netTCP_Event event, const NET_ADDR *addr, const uint8_t *buf, uint32_t len);
N
N#ifdef RTE_Network_Socket_BSD
S
S//  ==== BSD Socket definitions ====
S
S/// BSD Socket Address Family.
S#define AF_UNSPEC               0       ///< Unspecified
S#define AF_INET                 1       ///< Internet Address Family
S#define AF_NETBIOS              2       ///< NetBios-style addresses
S#define AF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Protocol families (same as address families).
S#define PF_UNSPEC               0       ///< Unspecified
S#define PF_INET                 1       ///< Internet Address Family
S#define PF_NETBIOS              2       ///< NetBios-style addresses
S#define PF_INET6                3       ///< Internet Address Family version 6
S
S/// BSD Socket Type.
S#define SOCK_STREAM             1       ///< Stream Socket (Connection oriented)
S#define SOCK_DGRAM              2       ///< Datagram Socket (Connectionless)
S
S/// BSD Socket Protocol.
S#define IPPROTO_TCP             1       ///< TCP Protocol
S#define IPPROTO_UDP             2       ///< UDP Protocol
S
S/// BSD Internet Addresses IPv4.
S#define INADDR_ANY              0x00000000  ///< All IP addresses accepted
S#define INADDR_NONE             0xffffffff  ///< No IP address accepted
S#define INADDR_LOOPBACK         0x7f000001  ///< Localhost IP address
S
S/// BSD Socket flags parameter.
S#define MSG_DONTWAIT            0x01    ///< Enables non-blocking operation
S#define MSG_PEEK                0x02    ///< Peeks at the incoming data
S#define MSG_TRUNC               0x04    ///< Normal data was truncated
S#define MSG_CTRUNC              0x08    ///< Control data was truncated
S
S/// BSD Socket ioctl commands.
S#define FIONBIO                 1       ///< Set mode (blocking/non-blocking)
S
S/// BSD Socket level.
S#define SOL_SOCKET              1       ///< Socket Level
S#define IPPROTO_IP              2       ///< IPv4 Level
S#define IPPROTO_IPV6            3       ///< IPv6 Level
S
S/// BSD Socket options.
S#define SO_KEEPALIVE            1       ///< Keep Alive
S#define SO_RCVTIMEO             2       ///< Timeout for blocking receive (in milliseconds)
S#define SO_SNDTIMEO             3       ///< Timeout for blocking send (in milliseconds)
S#define SO_TYPE                 4       ///< Socket type (read only)
S
S/// BSD Socket IPv4 options.
S#define IP_TOS                  1       ///< Type of Service (TOS)
S#define IP_TTL                  2       ///< Time to Live (TTL)
S#define IP_RECVDSTADDR          3       ///< Receive destination IPv4 address
S
S/// BSD Socket IPv6 options.
S#define IPV6_TCLASS             1       ///< Traffic Class
S#define IPV6_MULTICAST_HOPS     2       ///< Multi-cast Hop Limit
S#define IPV6_RECVDSTADDR        3       ///< Receive destination IPv6 address
S
S/// BSD Socket Error codes.
S#define BSD_ERROR               (-1)    ///< Unspecified error
S#define BSD_ESOCK               (-2)    ///< Invalid socket descriptor
S#define BSD_EINVAL              (-3)    ///< Invalid parameter
S#define BSD_ENOTSUP             (-11)   ///< Operation or feature not supported
S#define BSD_ENOMEM              (-5)    ///< Not enough memory
S#define BSD_ELOCKED             (-7)    ///< Socket locked by another thread
S#define BSD_EWOULDBLOCK         (-4)    ///< Operation would block
S#define BSD_ETIMEDOUT           (-8)    ///< Operation timed out
S#define BSD_EINPROGRESS         (-9)    ///< Operation in progress
S#define BSD_ENOTCONN            (-6)    ///< Socket not connected
S#define BSD_EISCONN             (-12)   ///< Socket is connected
S#define BSD_ECONNREFUSED        (-13)   ///< Connection rejected by the peer
S#define BSD_ECONNRESET          (-14)   ///< Connection reset by the peer
S#define BSD_ECONNABORTED        (-15)   ///< Connection aborted locally
S#define BSD_EALREADY            (-16)   ///< Connection already in progress
S#define BSD_EADDRINUSE          (-17)   ///< Address already in use
S#define BSD_EDESTADDRREQ        (-18)   ///< Destination address required
S#define BSD_EHOSTNOTFOUND       (-10)   ///< Host not found
S
S/// BSD Socket legacy Error codes.
S#define BSD_SUCCESS             0       ///< Success
S#define BSD_ERROR_SOCKET        BSD_ESOCK
S#define BSD_ERROR_PARAMETER     BSD_EINVAL
S#define BSD_ERROR_WOULDBLOCK    BSD_EWOULDBLOCK
S#define BSD_ERROR_NOMEMORY      BSD_ENOMEM
S#define BSD_ERROR_CLOSED        BSD_ENOTCONN
S#define BSD_ERROR_LOCKED        BSD_ELOCKED
S#define BSD_ERROR_TIMEOUT       BSD_ETIMEDOUT
S#define BSD_ERROR_INPROGRESS    BSD_EINPROGRESS
S#define BSD_ERROR_NONAME        BSD_EHOSTNOTFOUND
S
S//  ==== BSD Socket structures ====
S
S/// Generic Socket Address structure.
Stypedef struct sockaddr {
S  uint16_t sa_family;                   ///< Address family
S  int8_t   sa_data[14];                 ///< Direct address (up to 14 bytes)
S} SOCKADDR;
S
S#if   defined(__CC_ARM)
S  #pragma push
S  #pragma anon_unions
S#elif defined(__clang__)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S#endif
S
S/// Generic IPv4 Address structure.
Stypedef struct in_addr {
S  union {
S    struct {
S      uint8_t s_b1,s_b2,s_b3,s_b4;      ///< IP address, byte access
S    };
S    struct {
S      uint16_t s_w1,s_w2;               ///< IP address, short int access
S    };
S    uint32_t s_addr;                    ///< IP address in network byte order
S  };
S} IN_ADDR;
S
S/// Generic IPv6 Address structure.
Stypedef struct in6_addr {
S  union {
S    uint8_t  s6_b[16];                  ///< IP6 address, byte access
S    uint16_t s6_w[8];                   ///< IP6 address, short int access
S  };
S} IN6_ADDR;
S#define s6_addr     s6_b
S
S#if   defined(__CC_ARM)
S  #pragma pop
S#elif defined(__clang__)
S  #pragma clang diagnostic pop
S#endif
S
S/// IPv4 Socket Address structure.
Stypedef struct sockaddr_in {
S  int16_t  sin_family;                  ///< Socket domain
S  uint16_t sin_port;                    ///< Port
S  IN_ADDR  sin_addr;                    ///< IP address
S  int8_t   sin_zero[8];                 ///< reserved
S} SOCKADDR_IN;
S
S/// IPv6 Socket Address structure.
Stypedef struct sockaddr_in6 {
S  int16_t  sin6_family;                 ///< Socket domain
S  uint16_t sin6_port;                   ///< Port
S  uint32_t sin6_flowinfo;               ///< IP6 flow information
S  IN6_ADDR sin6_addr;                   ///< IP6 address
S} SOCKADDR_IN6;
S
S/// Socket Address storage structure.
Stypedef struct sockaddr_storage {
S  int16_t ss_family;                    ///< Address family
S  int8_t  __ss_pad1[2];                 ///< reserved
S  int32_t __ss_align;                   ///< reserved, structure alignment
S  int8_t  __ss_pad2[16];                ///< reserved
S} SOCKADDR_STORAGE;
S
S/// BSD Host Entry structure.
Stypedef struct hostent {
S  char   *h_name;                       ///< Official name of host
S  char  **h_aliases;                    ///< Pointer to an array of alias names
S  int16_t h_addrtype;                   ///< Address Type: AF_INET, AF_NETBIOS
S  int16_t h_length;                     ///< Length of address in bytes
S  char  **h_addr_list;                  ///< Pointer to an array of IPv4 addresses
S} HOSTENT;
S
S/// BSD address string length.
S#define INET_ADDRSTRLEN         16      ///< IP address string length
S#define INET6_ADDRSTRLEN        46      ///< IP6 address string length
S
S/// BSD fd_set size.
S#define FD_SETSIZE              64      ///< Maximum number of sockets in fd_set structure
S
S/// BSD fd_set structure.
Stypedef struct fd_set {
S  uint32_t fd_bits[(FD_SETSIZE+31)>>5]; ///< Set of sockets bit-mask
S} fd_set;
S
S/// BSD timeval structure.
Stypedef struct timeval {
S  uint32_t tv_sec;                      ///< Time interval: seconds
S  uint32_t tv_usec;                     ///< Time interval: microseconds
S} timeval;
S
S/// BSD safe read/write fd_set macros.
S#define FD_WR(fd,code)          if ((fd > 0) && (fd <= FD_SETSIZE)) { code; }
S#define FD_RD(fd,code)          (((fd > 0) && (fd <= FD_SETSIZE)) ? (code) : 0)
S
S/// BSD initialize and test fd_set macros.
S#define FD_SET(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] |=  (1U << ((fd-1)&0x1F)))
S#define FD_CLR(fd,set)          FD_WR(fd, (set)->fd_bits[(fd-1)>>5] &= ~(1U << ((fd-1)&0x1F)))
S#define FD_ISSET(fd,set)        FD_RD(fd, (set)->fd_bits[(fd-1)>>5] &   (1U << ((fd-1)&0x1F)))
S#define FD_ZERO(set)            memset(set, 0, sizeof(*set))
S
S/// BSD scatter/gather array of items.
Stypedef struct iovec {
S  void    *iov_base;                    ///< Starting address
S  uint32_t iov_len;                     ///< Number of bytes to transfer
S} IOVEC;
S
S/// BSD message header structure.
Stypedef struct msghdr {
S  void    *msg_name;                    ///< Optional pointer to source address
S  uint32_t msg_namelen;                 ///< Size of address buffer
S  IOVEC   *msg_iov;                     ///< An array of iovec buffers for the message
S  int32_t  msg_iovlen;                  ///< Number of elements in msg_iov
S  void    *msg_control;                 ///< Ancillary data
S  uint32_t msg_controllen;              ///< Ancillary data buffer length
S  int32_t  msg_flags;                   ///< Flags on received message
S} MSGHDR;
S
S/// BSD cmsg header structure.
Stypedef struct cmsghdr {
S  uint32_t cmsg_len;                    ///< Data byte count, including the cmsghdr
S  int32_t  cmsg_level;                  ///< Originating protocol
S  int32_t  cmsg_type;                   ///< Protocol-specific type
S} CMSGHDR;
S
S/// BSD access ancillary data macros (RFC 2292).
S#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ? \
S                                 (CMSGHDR *)(mhdr)->msg_control             : \
S                                 (CMSGHDR *)NULL
X#define CMSG_FIRSTHDR(mhdr)     ((mhdr)->msg_controllen >= sizeof(CMSGHDR)) ?                                  (CMSGHDR *)(mhdr)->msg_control             :                                  (CMSGHDR *)NULL
S#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) > \
S                                 (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ? \
S                                 (CMSGHDR *)NULL                                                   : \
S                                 (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
X#define CMSG_NXTHDR(mhdr,cmsg)  (CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len) + sizeof(CMSGHDR) >                                  (uint32_t)(mhdr)->msg_control + (mhdr)->msg_controllen)           ?                                  (CMSGHDR *)NULL                                                   :                                  (CMSGHDR *)CMSG_ALIGN((uint32_t)(cmsg) + (cmsg)->cmsg_len)
S#define CMSG_DATA(cmsg)         ((uint8_t *)(cmsg) + sizeof(CMSGHDR))
S#define CMSG_ALIGN(len)         (((len) + 3) & ~3U)
S#define CMSG_LEN(len)           ((len) + sizeof(CMSGHDR))
S#define CMSG_SPACE(len)          CMSG_ALIGN((len) + sizeof(CMSGHDR))
S
N#endif /* RTE_Network_Socket_BSD */
N
N/// Interface Class
N#define NET_IF_CLASS_ETH        (1U << 8)   ///< Ethernet interface
N#define NET_IF_CLASS_WIFI       (2U << 8)   ///< WiFi interface
N#define NET_IF_CLASS_PPP        (3U << 8)   ///< PPP interface
N#define NET_IF_CLASS_SLIP       (4U << 8)   ///< SLIP interface
N
N/// Interface Option codes.
Ntypedef enum {
N  netIF_OptionMAC_Address,              ///< Ethernet MAC Address (6 bytes)
N  netIF_OptionVLAN_Identifier,          ///< Ethernet VLAN Identifier (2 bytes)
N  netIF_OptionIP4_MTU,                  ///< IPv4 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP4_Address,              ///< IPv4 Address (4 bytes)
N  netIF_OptionIP4_SubnetMask,           ///< IPv4 Subnet mask (4 bytes)
N  netIF_OptionIP4_DefaultGateway,       ///< IPv4 Default Gateway (4 bytes)
N  netIF_OptionIP4_PrimaryDNS,           ///< IPv4 Primary DNS (4 bytes)
N  netIF_OptionIP4_SecondaryDNS,         ///< IPv4 Secondary DNS (4 bytes)
N  netIF_OptionIP6_MTU,                  ///< IPv6 Maximum Transmission Unit (2 bytes)
N  netIF_OptionIP6_LinkLocalAddress,     ///< IPv6 Link-local Address (16 bytes)
N  netIF_OptionIP6_StaticAddress,        ///< IPv6 Static Address (16 bytes)
N  netIF_OptionIP6_DynamicAddress,       ///< IPv6 Dynamic Address (16 bytes)
N  netIF_OptionIP6_SubnetPrefixLength,   ///< IPv6 Subnet Prefix-length (1 byte)
N  netIF_OptionIP6_DefaultGateway,       ///< IPv6 Default Gateway (16 bytes)
N  netIF_OptionIP6_PrimaryDNS,           ///< IPv6 Primary DNS (16 bytes)
N  netIF_OptionIP6_SecondaryDNS          ///< IPv6 Secondary DNS (16 bytes)
N} netIF_Option;
N
N/// Interface IP Versions.
Ntypedef enum {
N  netIF_VersionIP4,                     ///< IP version 4
N  netIF_VersionIP6                      ///< IP version 6
N} netIF_Version;
N
N/// Ethernet link speed.
N#define NET_ETH_SPEED_10M       0       ///< 10 Mbps link speed
N#define NET_ETH_SPEED_100M      1       ///< 100 Mbps link speed
N#define NET_ETH_SPEED_1G        2       ///< 1 Gpbs link speed
N
N/// Ethernet duplex mode.
N#define NET_ETH_DUPLEX_HALF     0       ///< Half duplex link
N#define NET_ETH_DUPLEX_FULL     1       ///< Full duplex link
N
N/// Ethernet link information.
Ntypedef struct net_eth_link_info {
N  uint32_t speed  : 2;                  ///< Link speed: 0= 10 MBit, 1= 100 MBit, 2= 1 GBit
N  uint32_t duplex : 1;                  ///< Duplex mode: 0= Half, 1= Full
N} NET_ETH_LINK_INFO;
N
N/// Ethernet Callback Events.
Ntypedef enum {
N  netETH_LinkDown             = 0,      ///< Link down
N  netETH_LinkUp,                        ///< Link up; val=link_info
N  netETH_Wakeup,                        ///< Wake-up (on Magic Packet)
N  netETH_TimerAlarm                     ///< Timer Alarm (PTP)
N} netETH_Event;
N
N/// WiFi Security Types.
Ntypedef enum {
N  netWiFi_SecurityOpen        = 0,      ///< Open
N  netWiFi_SecurityWEP,                  ///< Wired Equivalent Privacy
N  netWiFi_SecurityWPA,                  ///< WiFi Protected Access
N  netWiFi_SecurityWPA2,                 ///< WiFi Protected Access 2
N  netWiFi_SecurityUnknown     = 255     ///< Unknown security
N} netWiFi_Security;
N
N/// WiFi Driver Options.
Ntypedef enum {
N  netWiFi_OptionBSSID         = 1,      ///< BSSID of AP
N  netWiFi_OptionTxPower,                ///< Transmit Power
N  netWiFi_OptionLpTimer,                ///< Low Power deep-sleep timer
N  netWiFi_OptionDTIM,                   ///< DTIM interval
N  netWiFi_OptionBeacon                  ///< Beacon interval
N} netWiFi_Option;
N
N/// WiFi WPS Methods.
Ntypedef enum {
N  netWiFi_WPS_None            = 0,      ///< Not used
N  netWiFi_WPS_PBC,                      ///< With Push Button Configuration
N  netWiFi_WPS_PIN                       ///< With PIN
N} netWiFi_WPS;
N
N/// WiFi Configuration.
Ntypedef struct net_wifi_config {
N  const char      *ssid;                ///< Network name, a null-terminated string
N  const char      *password;            ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel (0=auto)
N  uint8_t          reserved;            ///< Reserved
N  netWiFi_WPS      wps_method;          ///< WiFi Protected Setup method
N  const char      *wps_pin;             ///< WPS PIN, a null-terminated string
N} NET_WIFI_CONFIG;
N
N/// WiFi Network information.
Ntypedef struct net_wifi_net_info {
N  char             ssid[32+1];          ///< Network name, a null-terminated string
N  char             password[64+1];      ///< Password, a null-terminated string
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_NET_INFO;
N
N/// WiFi Scan information.
Ntypedef struct net_wifi_scan_info {
N  char             ssid[32+1];          ///< Service Set Identifier (null-terminated)
N  uint8_t          bssid[6];            ///< Basic Service Set Identifier
N  netWiFi_Security security;            ///< Security type
N  uint8_t          channel;             ///< WiFi Channel
N  uint8_t          rssi;                ///< Received Signal Strength Indicator
N} NET_WIFI_SCAN_INFO;
N
N/// ARP Cache Entry types.
Ntypedef enum {
N  netARP_CacheFixedIP,                  ///< Fixed IP address is refreshed after timeout
N  netARP_CacheTemporaryIP               ///< Temporary IP address is removed after timeout
N} netARP_CacheType;
N
N/// DHCP Option Codes.
N#define NET_DHCP_OPTION_IP_ADDRESS     0 ///< IP address change event
N#define NET_DHCP_OPTION_NTP_SERVERS   42 ///< NTP Servers option
N#define NET_DHCP_OPTION_CLIENT_ID     61 ///< Client-identifier option
N#define NET_DHCP_OPTION_BOOTFILE_NAME 67 ///< Bootfile name option
N
N/// DHCPv6 Option Codes.
N#define NET_DHCP6_OPTION_IP_ADDRESS   0 ///< IPv6 address change event
N
N/// DHCP Option Item.
Ntypedef struct net_dhcp_option_item {
N  uint8_t code;                         ///< Option type code
N  uint8_t length;                       ///< Length of Option value
N  uint8_t *value;                       ///< Pointer to Option value
N} NET_DHCP_OPTION_ITEM;
N
N/// DHCP Private Options.
Nextern NET_DHCP_OPTION_ITEM netDHCP_PrivateOptionsTableN[];  ///< DHCP Private Options Table
Nextern uint8_t              netDHCP_PrivateOptionsCountN;    ///< Number of DHCP Private Options
N
N/// DHCPv6 Modes.
Ntypedef enum {
N  netDHCP6_ModeStateless      = 0,      ///< Stateless DHCPv6 mode
N  netDHCP6_ModeStateful                 ///< Stateful DHCPv6 mode
N} netDHCP6_Mode;
N
N/// Ping Callback Events.
Ntypedef enum {
N  netPing_EventSuccess        = 0,      ///< Pinged Host responded
N  netPing_EventTimeout                  ///< Timeout, no ping response received
N} netPing_Event;
N
N/// Ping Control Flags.
N#define NET_PING_IP4_ONLY       0x01    ///< Force using IPv4 only
N#define NET_PING_IP6_ONLY       0x02    ///< Force using IPv6 only
N
N/// ARP Probe Callback Events.
Ntypedef enum {
N  netARP_EventSuccess         = 0,      ///< Probed Host responded
N  netARP_EventTimeout                   ///< Timeout, no response to ARP probe
N} netARP_Event;
N
N/// NDP Probe Callback Events.
Ntypedef enum {
N  netNDP_EventSuccess         = 0,      ///< Probed Host responded
N  netNDP_EventTimeout                   ///< Timeout, no response to NDP probe
N} netNDP_Event;
N
N/// DNS Client Callback Events.
Ntypedef enum {
N  netDNSc_EventSuccess        = 0,      ///< Host name successfully resolved
N  netDNSc_EventTimeout,                 ///< Timeout resolving host
N  netDNSc_EventNotResolved,             ///< DNS Error, no such name
N  netDNSc_EventError                    ///< Erroneous response packet
N} netDNSc_Event;
N
N/// FTP Commands.
Ntypedef enum {
N  netFTP_CommandPUT,                    ///< Puts a file on FTP server
N  netFTP_CommandGET,                    ///< Retrieves a file from FTP server
N  netFTP_CommandAPPEND,                 ///< Append file on FTP server (with create)
N  netFTP_CommandDELETE,                 ///< Deletes a file on FTP server
N  netFTP_CommandLIST,                   ///< Lists files stored on FTP server
N  netFTP_CommandRENAME,                 ///< Renames a file on FTP server
N  netFTP_CommandMKDIR,                  ///< Makes a directory on FTP server
N  netFTP_CommandRMDIR,                  ///< Removes an empty directory on FTP server
N  netFTP_CommandNLIST                   ///< Lists file names only (short format)
N} netFTP_Command;
N
N/// FTP Server Events.
Ntypedef enum {
N  netFTPs_EventLogin,                   ///< User logged in, session is busy
N  netFTPs_EventLogout,                  ///< User logged out, session is idle
N  netFTPs_EventLoginFailed,             ///< User login failed (invalid credentials)
N  netFTPs_EventDownload,                ///< File download ended
N  netFTPs_EventUpload,                  ///< File upload ended
N  netFTPs_EventDelete,                  ///< File deleted
N  netFTPs_EventRename,                  ///< File or directory renamed
N  netFTPs_EventMakeDirectory,           ///< Directory created
N  netFTPs_EventRemoveDirectory,         ///< Directory removed
N  netFTPs_EventOperationDenied,         ///< Requested file operation denied
N  netFTPs_EventLocalFileError,          ///< Local file operation error
N  netFTPs_EventFileError,               ///< Generic file operation error
N  netFTPs_EventError                    ///< Generic FTP server error
N} netFTPs_Event;
N
N/// FTP Client Requests.
Ntypedef enum {
N  netFTPc_RequestUsername,              ///< Username to login to FTP server
N  netFTPc_RequestPassword,              ///< Password to login to FTP server
N  netFTPc_RequestDirectory,             ///< Working directory path on server for all commands
N  netFTPc_RequestName,                  ///< File or Directory name for FTP commands 
N  netFTPc_RequestNewName,               ///< New File or Directory name for RENAME command
N  netFTPc_RequestListMask,              ///< File filter/mask for LIST command (wildcards allowed)
N  netFTPc_RequestList,                  ///< Received data if LIST command is given
N  netFTPc_RequestLocalFilename          ///< Local filename (including path)
N} netFTPc_Request;
N
N/// FTP Client Events.
Ntypedef enum {
N  netFTPc_EventSuccess        = 0,      ///< File operation successful
N  netFTPc_EventTimeout,                 ///< Timeout on file operation
N  netFTPc_EventLoginFailed,             ///< Login error, username/password invalid
N  netFTPc_EventAccessDenied,            ///< File access not allowed
N  netFTPc_EventFileNotFound,            ///< File not found
N  netFTPc_EventInvalidDirectory,        ///< Working directory path not found
N  netFTPc_EventLocalFileError,          ///< Local file read/write error
N  netFTPc_EventError                    ///< Generic FTP client error 
N} netFTPc_Event;
N
N/// TFTP Client Events.
Ntypedef enum {
N  netTFTPc_EventSuccess       = 0,      ///< File operation successful
N  netTFTPc_EventTimeout,                ///< Timeout on file operation
N  netTFTPc_EventAccessDenied,           ///< File access not allowed
N  netTFTPc_EventFileNotFound,           ///< File not found
N  netTFTPc_EventDiskFull,               ///< Disk full
N  netTFTPc_EventLocalFileError,         ///< Local file read/write error
N  netTFTPc_EventError                   ///< Generic TFTP client error
N} netTFTPc_Event;          
N
N/// Telnet Server Messages.
Ntypedef enum {
N  netTELNETs_MessageWelcome,            ///< Initial welcome message
N  netTELNETs_MessageLogin,              ///< Login message, if authentication is enabled
N  netTELNETs_MessageUsername,           ///< Username request login message
N  netTELNETs_MessagePassword,           ///< Password request login message
N  netTELNETs_MessageLoginFailed,        ///< Incorrect login error message
N  netTELNETs_MessageLoginTimeout,       ///< Login timeout error message
N  netTELNETs_MessagePrompt,             ///< Prompt message
N  netTELNETs_MessageUnsolicited         ///< Unsolicited message (triggered by netTELNETs_RequestMessage)
N} netTELNETs_Message;
N
N/// SMTP Client Request.
Ntypedef enum {
N  netSMTPc_RequestUsername,             ///< Username to login to SMTP server
N  netSMTPc_RequestPassword,             ///< Password to login to SMTP server
N  netSMTPc_RequestSender,               ///< Email address of the sender
N  netSMTPc_RequestRecipient,            ///< Email address of the recipient
N  netSMTPc_RequestSubject,              ///< Subject of email
N  netSMTPc_RequestBody                  ///< Email body in plain ASCII format
N} netSMTPc_Request;
N
N/// SMTP Client Events.
Ntypedef enum {
N  netSMTPc_EventSuccess       = 0,      ///< Email successfully sent
N  netSMTPc_EventTimeout,                ///< Timeout sending email
N  netSMTPc_EventAuthenticationFailed,   ///< Authentication failed, username/password invalid
N  netSMTPc_EventError                   ///< Error when sending email
N} netSMTPc_Event;
N
N/// SMTP Mail Transfer Agent Flags.
N#define NET_SMTP_MTA_USETLS     0x01    ///< Use secure TLS mode (Implicit TLS)
N
N/// SMTP Email Descriptor.
Ntypedef struct net_smtp_mail {
N  const char *From;                     ///< Sender address, can be NULL
N  const char *To;                       ///< Recipient(s), can be NULL
N  const char *Cc;                       ///< Carbon copy recipient(s), can be NULL
N  const char *Bcc;                      ///< Blind carbon copy recipient(s), can be NULL
N  const char *Subject;                  ///< Subject of email, can be NULL
N  const char *Message;                  ///< Email message body, can be NULL
N  const char *Attachment;               ///< Email attachment(s), can be NULL
N  const char *Encoding;                 ///< Default encoding type, can be NULL
N} NET_SMTP_MAIL;
N
N/// SMTP Mail Transfer Agent Descriptor.
Ntypedef struct net_smtp_mta {
N  const char *Address;                  ///< Server address (FQDN or IP address)
N  uint16_t    Port;                     ///< Server port number, can be 0
N  uint16_t    Flags;                    ///< Service control flags
N  const char *Username;                 ///< Account user name, can be NULL
N  const char *Password;                 ///< Account password, can be NULL
N} NET_SMTP_MTA;
N
N/// SNTP Client Mode.
Ntypedef enum {
N  netSNTPc_ModeUnicast        = 0,      ///< Unicast mode to access public NTP server
N  netSNTPc_ModeBroadcast                ///< Broadcast mode for local LAN
N} netSNTPc_Mode;
N
N/// Ping Event callback function.
Ntypedef void (*netPing_cb_t)(netPing_Event event);
N
N/// ARP Probe Event callback function.
Ntypedef void (*netARP_cb_t)(netARP_Event event);
N
N/// NDP Probe Event callback function.
Ntypedef void (*netNDP_cb_t)(netNDP_Event event);
N
N/// DNS Client Event callback function.
Ntypedef void (*netDNSc_cb_t)(netDNSc_Event event, const NET_ADDR *addr);
N
N/// SNTP Client callback function.
Ntypedef void (*netSNTPc_cb_t)(uint32_t seconds, uint32_t seconds_fraction);
N
N/// SNMP-MIB definitions.
N#define NET_SNMP_MIB_INTEGER    0x02    ///< MIB entry type INTEGER
N#define NET_SNMP_MIB_OCTET_STR  0x04    ///< MIB entry type OCTET_STRING
N#define NET_SNMP_MIB_OBJECT_ID  0x06    ///< MIB entry type OBJECT_IDENTIFIER
N#define NET_SNMP_MIB_IP_ADDR    0x40    ///< MIB entry type IP ADDRESS (uint8_t[4])
N#define NET_SNMP_MIB_COUNTER    0x41    ///< MIB entry type COUNTER (uint32_t)
N#define NET_SNMP_MIB_GAUGE      0x42    ///< MIB entry type GAUGE (uint32_t)
N#define NET_SNMP_MIB_TIME_TICKS 0x43    ///< MIB entry type TIME_TICKS
N#define NET_SNMP_MIB_ATR_RO     0x80    ///< MIB entry attribute READ_ONLY
N#define NET_SNMP_MIB_OID_SIZE   17      ///< Max.size of Object ID value
N#define NET_SNMP_MIB_STR_SIZE   110     ///< Max.size of Octet String variable
N#define NET_SNMP_MIB_READ       0       ///< MIB entry Read access
N#define NET_SNMP_MIB_WRITE      1       ///< MIB entry Write access
N
N/// SNMP-MIB macros.
N#define NET_SNMP_MIB_STR(s)     sizeof(s)-1, s
N#define NET_SNMP_MIB_INT(o)     sizeof(o), (void *)&o
N#define NET_SNMP_MIB_IP(ip)     4, (void *)&ip
N#define NET_SNMP_MIB_OID0(f,s)  (f*40 + s)
N
N/// SNMP-MIB Entry information.
Ntypedef struct net_snmp_mib_info {
N  uint8_t type;                         ///< Object Type
N  uint8_t oid_len;                      ///< Object ID length
N  uint8_t oid[NET_SNMP_MIB_OID_SIZE];   ///< Object ID value
X  uint8_t oid[17];   
N  uint8_t var_size;                     ///< Size of a variable
N  void    *var;                         ///< Pointer to a variable
N  void    (*cb_func)(int32_t mode);     ///< Write/Read event callback function
N} const NET_SNMP_MIB_INFO;
N
N/// FS Interface Time info
Ntypedef struct net_fs_time {
N  uint8_t  hr;                          ///< Hours    [0..23]
N  uint8_t  min;                         ///< Minutes  [0..59]
N  uint8_t  sec;                         ///< Seconds  [0..59]
N  uint8_t  day;                         ///< Day      [1..31]
N  uint8_t  mon;                         ///< Month    [1..12]
N  uint16_t year;                        ///< Year     [1980..2107]
N} NET_FS_TIME;
N
N/// FS Interface Attributes
N#define NET_FS_ATTR_FILE        1       ///< File entry
N#define NET_FS_ATTR_DIRECTORY   2       ///< Directory entry
N
N
N//  ==== Network System API ====
N
N/// \brief Initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netInitialize (void);
N
N/// \brief De-initialize Network Component and interfaces. [\ref not_thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUninitialize (void);
N
N/// \brief Retrieve localhost name.  [\ref thread-safe]
N/// \return        pointer to localhost name, a null-terminated string.
Nextern const char *netSYS_GetHostName (void);
N
N/// \brief Set localhost name. [\ref thread-safe]
N/// \param[in]     hostname      new localhost name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSYS_SetHostName (const char *hostname);
N
N//  ==== UDP Socket API ====
N
N/// \brief Allocate a free UDP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netUDP_GetSocket (netUDP_cb_t cb_func);
N
N/// \brief Release UDP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_ReleaseSocket (int32_t socket);
N
N/// \brief Open UDP socket for communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     port          local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Open (int32_t socket, uint16_t port);
N
N/// \brief Stop UDP communication and close socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Close (int32_t socket);
N
N/// \brief Allocate memory for UDP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netUDP_GetBuffer (uint32_t size);
N
N/// \brief Send data to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_Send (int32_t socket, const NET_ADDR *addr, uint8_t *buf, uint32_t len);
N
N/// \brief Set UDP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netUDP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netUDP_SetOption (int32_t socket, netUDP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of UDP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netUDP_GetSocket.
N/// \return        local port number.
N///                - 0           = socket invalid or in invalid state.
Nextern uint16_t  netUDP_GetLocalPort (int32_t socket);
N
N//  ==== TCP Socket API ====
N
N/// \brief Allocate a free TCP socket. [\ref thread-safe]
N/// \param[in]     cb_func       event listening callback function.
N/// \return      socket handle number or execution status:
N///              - value >= 0:   socket handle number.
N///              - value < 0:    error occurred, -value is execution status as defined with \ref netStatus.
Nextern int32_t   netTCP_GetSocket (netTCP_cb_t cb_func);
N
N/// \brief Release TCP socket and free resources. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ReleaseSocket (int32_t socket);
N
N/// \brief Open TCP socket for incoming connection. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     port          local port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Listen (int32_t socket, uint16_t port);
N
N/// \brief Initiate a TCP connection to a remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     addr          structure containing remote IP address and port.
N/// \param[in]     local_port    local port number.
N///                              - 0 = system assigned local port.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Connect (int32_t socket, const NET_ADDR *addr, uint16_t local_port);
N
N/// \brief Stop TCP communication and start closing procedure. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Close (int32_t socket);
N
N/// \brief Instantly stop TCP communication. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Abort (int32_t socket);
N
N/// \brief Determine maximum number of data bytes that can be sent in TCP packet. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        maximum segment size in bytes.
Nextern uint32_t  netTCP_GetMaxSegmentSize (int32_t socket);
N
N/// \brief Allocate memory for TCP send buffer. [\ref thread-safe]
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
N///                - NULL      = out of memory.
Nextern uint8_t  *netTCP_GetBuffer (uint32_t size);
N
N/// \brief Check if TCP socket can send data. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      send status:
N///              - true        = Ready to send data.
N///              - false       = Not ready.
Nextern bool      netTCP_SendReady (int32_t socket);
Xextern _Bool      netTCP_SendReady (int32_t socket);
N
N/// \brief Send a data packet to remote node. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_Send (int32_t socket, uint8_t *buf, uint32_t len);
N
N/// \brief Determine current state of a TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      state information as defined with \ref netTCP_State.
Nextern netTCP_State netTCP_GetState (int32_t socket);
N
N/// \brief Reset TCP window size to a default value from the configuration. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_ResetReceiveWindow (int32_t socket);
N
N/// \brief Set TCP socket IP option. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[in]     option        option name as defined with \ref netTCP_Option.
N/// \param[in]     val           option value.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_SetOption (int32_t socket, netTCP_Option option, uint32_t val);
N
N/// \brief Retrieve local port number of TCP socket. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        local port number.
N///                - 0         = socket invalid or in invalid state.
Nextern uint16_t  netTCP_GetLocalPort (int32_t socket);
N
N/// \brief Retrieve IP address and port number of remote peer. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for remote peer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTCP_GetPeer (int32_t socket, NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Determine TCP socket connection timeout. [\ref thread-safe]
N/// \param[in]     socket        socket handle obtained with \ref netTCP_GetSocket.
N/// \return        connection timeout timer in seconds.
N///                - 0         = socket invalid or in invalid state.
Nextern uint32_t  netTCP_GetTimer (int32_t socket);
N
N//  ==== BSD Socket API ====
N
N#ifdef RTE_Network_Socket_BSD
S/// \brief Create a communication endpoint called socket. [\ref thread-safe]
S/// \param[in]     family        address family:
S///                              - AF_INET        = address family IPv4.
S///                              - AF_INET6       = address family IPv6.
S/// \param[in]     type          connection type of a socket:
S///                              - SOCK_STREAM    = connection based type.
S///                              - SOCK_DGRAM     = datagram connectionless type.
S/// \param[in]     protocol      protocol type:
S///                              - IPPROTO_TCP    = must be used with SOCK_STREAM type.
S///                              - IPPROTO_UDP    = must be used with SOCK_DGRAM TYPE.
S///                              - 0              = for system auto-select.
S/// \return      status information:
S///              - Socket descriptor (>0).
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOMEM          = No free sockets available.
Sextern int socket (int family, int type, int protocol);
S
S/// \brief Assign a local address and port to a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing local IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or already bound.
S///              - BSD_EADDRINUSE      = Address or port already in use.
S///              - BSD_EISCONN         = Socket already connected.
Sextern int bind (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Set a socket in a listening mode. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     backlog       number of connection requests that can be accepted.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter, socket not bound or already listening.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ERROR           = Failed to create socket backlog.
Sextern int listen (int sock, int backlog);
S
S/// \brief Accept connect request for a listening socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    addr          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - New socket descriptor (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Socket not in listen mode.
S///              - BSD_ENOTSUP         = Operation not supported for this socket type.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int accept (int sock, SOCKADDR *addr, int *addrlen);
S
S/// \brief Connect a socket to a remote host. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     addr          structure containing remote IP address and port.
S/// \param[in]     addrlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket in wrong state.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_EALREADY        = Connection already in progress.
S///              - BSD_EINPROGRESS     = Operation in progress.
S///              - BSD_EISCONN         = Socket is connected.
S///              - BSD_ECONNREFUSED    = Connection rejected by the peer.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int connect (int sock, const SOCKADDR *addr, int addrlen);
S
S/// \brief Send data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int send (int sock, const char *buf, int len, int flags);
S
S/// \brief Send data to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     buf           pointer to application data buffer to transmit.
S/// \param[in]     len           length of data (in bytes).
S/// \param[in]     flags         message flags:
S///                              - MSG_DONTWAIT   = don't wait to send data.
S///                              - 0              = for none.
S/// \param[in]     to            structure containing remote IP address and port.
S/// \param[in]     tolen         length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendto (int sock, const char *buf, int len, int flags, const SOCKADDR *to, int tolen);
S
S/// \brief Send a message to endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to target address (NULL for none).
S///                              - array of application buffer(s) containing the message.
S///                              - pointer to the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes sent (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_EDESTADDRREQ    = Destination address required.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ENOMEM          = Not enough memory.
S///              - BSD_ERROR           = Unspecified error.
Sextern int sendmsg (int sock, const MSGHDR *msg, int flags);
S
S/// \brief Receive data on already connected socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recv (int sock, char *buf, int len, int flags);
S
S/// \brief Receive data from endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    buf           pointer to application data buffer to store the data to.
S/// \param[in]     len           size of application data buffer (in bytes).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \param[out]    from          structure that will receive IP address and port number.
S///                              - NULL for none.
S/// \param[in,out] fromlen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_ECONNRESET      = Connection reset by the peer.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvfrom (int sock, char *buf, int len, int flags, SOCKADDR *from, int *fromlen);
S
S/// \brief Receive a message from a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in,out] msg           pointer to \ref MSGHDR structure containing:
S///                              - pointer to buffer to store the source address to (NULL for none).
S///                              - array of application buffer(s) for the incomming message.
S///                              - pointer to buffer for the ancillary data (NULL for none).
S/// \param[in]     flags         message flags: 
S///                              - MSG_DONTWAIT   = don't wait for data.
S///                              - MSG_PEEK       = peek at incoming data.
S///                              - 0              = for none.
S/// \return      status information:
S///              - Number of bytes received (>0).
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ELOCKED         = Socket locked by another thread.
S///              - BSD_ENOTSUP         = Operation not supported.
S///              - BSD_ENOTCONN        = Socket not connected.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ETIMEDOUT       = Operation timed out.
S///              - BSD_ECONNABORTED    = Connection aborted locally.
S///              - BSD_ERROR           = Unspecified error.
Sextern int recvmsg (int sock, MSGHDR *msg, int flags);
S
S/// \brief Close socket and release socket descriptor. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EWOULDBLOCK     = Operation would block.
S///              - BSD_ERROR           = Unspecified error.
Sextern int closesocket (int sock);
S
S/// \brief Retrieve IP address and port number of the endpoint node. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTCONN        = Socket not connected.
Sextern int getpeername (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve local IP address and port number. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[out]    name          structure that will receive IP address and port number.
S/// \param[in,out] namelen       length of \ref SOCKADDR structure.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter or socket not bound.
Sextern int getsockname (int sock, SOCKADDR *name, int *namelen);
S
S/// \brief Retrieve options for the socket.  [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be retrieved:
S///                              - SO_TYPE             = Type of a socket.
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[out]    optval        pointer to the buffer that will receive the option value.
S/// \param[in,out] optlen        input length of buffer, return length of the data.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int getsockopt (int sock, int level, int optname, char *optval, int *optlen);
S
S/// \brief Manipulate options for the socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     level         level at which the option is defined:
S///                              - SOL_SOCKET   = Socket level.
S///                              - IPPROTO_IP   = IPv4 protocol level.
S///                              - IPPROTO_IPV6 = IPv6 protocol level.
S/// \param[in]     optname       socket option for which the value is to be set:
S///                              - SO_KEEPALIVE        = Keep Alive.
S///                              - SO_RCVTIMEO         = Timeout for blocking receive (in ms).
S///                              - SO_SNDTIMEO         = Timeout for blocking send (in ms).
S///                              - IP_TOS              = Type of Service (TOS).
S///                              - IP_TTL              = Time to Live (TTL).
S///                              - IP_RECVDSTADDR      = Receive Destination IP Address.
S///                              - IPV6_TCLASS         = Traffic Class.
S///                              - IPV6_MULTICAST_HOPS = Multi-cast Hop Limit.
S///                              - IPV6_RECVDSTADDR    = Receive Destination IPv6 Address.
S/// \param[in]     optval        pointer to the buffer containing the option value.
S/// \param[in]     optlen        size of the buffer containing the option value.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int setsockopt (int sock, int level, int optname, const char *optval, int optlen);
S
S/// \brief Control IO mode of a socket. [\ref thread-safe]
S/// \param[in]     sock          socket descriptor obtained with \ref socket.
S/// \param[in]     cmd           command to perform:
S///                              - FIONBIO  = enable non-blocking mode.
S/// \param[in]     argp          command's parameter.
S/// \return      status information:
S///              - 0                   = Operation successful.
S///              - BSD_ESOCK           = Invalid socket descriptor or socket not created.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ENOTSUP         = Option not supported for this socket type.
Sextern int ioctlsocket (int sock, long cmd, unsigned long *argp);
S
S/// \brief Check the status of one or more sockets. [\ref thread-safe]
S/// \param[in]     nfds          range of sockets to be checked.
S/// \param[in,out] readfds       pointer to the set of sockets to check for read.
S///                              - NULL for none.
S/// \param[in,out] writefds      pointer to the set of sockets to check for write.
S///                              - NULL for none.
S/// \param[in,out] errorfds      pointer to the set of sockets to check for error.
S///                              - NULL for none.
S/// \param[in]     timeout       pointer to maximum time for select to wait.
S///                              - NULL for blocking wait for event.
S/// \return      status information:
S///              - number of ready sockets (>0)
S///              - 0                   = Operation timed out.
S///              - BSD_EINVAL          = Invalid parameter.
S///              - BSD_ERROR           = Suspend operation failed.
Sextern int select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
S
S/// \brief Retrieve host IP address from host name. [\ref thread-safe]
S/// \param[in]     name          host name.
S/// \param[out]    err           pointer to where to return error code (NULL for none):
S///                              - 0                   = Operation successful.
S///                              - BSD_EINVAL          = Invalid parameter.
S///                              - BSD_ELOCKED         = Resolver locked by another thread.
S///                              - BSD_ETIMEDOUT       = Operation timed out.
S///                              - BSD_EHOSTNOTFOUND   = Host not found.
S///                              - BSD_ERROR           = Unspecified error.
S/// \return      status information:
S///              - \ref HOSTENT result structure.
S///              - NULL in case of error.
Sextern HOSTENT *gethostbyname (const char *name, int *err);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \return      status information:
S///              - Internet address on success.
S///              - INADDR_NONE = on error.
Sextern IN_ADDR inet_addr (const char *cp);
S
S/// \brief Convert from text address to a network address. [\ref thread-safe]
S/// \param[in]     cp            text address in standard dotted-decimal notation.
S/// \param[out]    addr          buffer where the converted IPv4 address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_aton (const char *cp, IN_ADDR *addr);
S
S/// \brief Convert from network address to a text string. [\ref not_thread-safe]
S/// \param[in]     in            Internet IPv4 host address to convert.
S/// \return      pointer to the formatted string.
Sextern const char *inet_ntoa (IN_ADDR in);
S
S/// \brief Convert from text address to a binary network address. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           text address to be converted.
S/// \param[out]    dst           buffer where the converted address is to be stored.
S/// \return      status information:
S///              - 1           = Conversion successful.
S///              - 0           = Conversion failed.
Sextern int inet_pton (int af, const char *src, void *dst);
S
S/// \brief Convert from binary network address to a text string. [\ref thread-safe]
S/// \param[in]     af            address family:
S///                              - AF_INET  = Internet Address Family (IPv4).
S///                              - AF_INET6 = Internet Address Family version 6 (IPv6).
S/// \param[in]     src           binary address in network byte order to be converted.
S/// \param[out]    dst           buffer where the converted text address is to be stored.
S/// \param[in]     size          size of the buffer, at least:
S///                              - INET_ADDRSTRLEN for AF_INET.
S///                              - INET6_ADDRSTRLEN for AF_INET6.
S/// \return      pointer to the formatted string.
S///              - NULL in case of error.
Sextern const char *inet_ntop (int af, const void *src, char *dst, int size);
N#endif /* RTE_Network_Socket_BSD */
N
N//  ==== Interface User API ====
N
N/// \brief Get the current value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_GetOption (uint32_t if_id, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of an Interface option. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetOption (uint32_t if_id, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set default network interface for Internet access. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip_version    IP version as specified by \ref netIF_Version.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIF_SetDefault (uint32_t if_id, netIF_Version ip_version);
N
N//  ==== Ethernet Interface User API ====
N
N/// \brief Send raw Ethernet data. [\ref thread-safe]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the data.
N/// \param[in]     len           length of data in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netETH_SendRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Determine whether the ARP table has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     type          address cache type.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheIP (uint32_t if_id, const uint8_t *ip4_addr, netARP_CacheType type);
N
N/// \brief Determine whether the ARP table has IP address resolved for requested MAC address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_CacheMAC (uint32_t if_id, const uint8_t *mac_addr);
N
N/// \brief Get IP address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip4_addr      resolved IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip4_addr);
N
N/// \brief Get MAC address from the ARP cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_GetMAC (uint32_t if_id, const uint8_t *ip4_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_Probe (uint32_t if_id, const uint8_t *ip4_addr, netARP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      requested IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netARP_ProbeX (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Determine whether neighbor cache has MAC address resolved for requested IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_CacheIP (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Get IP address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mac_addr      requested MAC address.
N/// \param[out]    ip6_addr      resolved IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip6_addr);
N
N/// \brief Get MAC address from neighbor discovery cache. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[out]    mac_addr      resolved MAC address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_GetMAC (uint32_t if_id, const uint8_t *ip6_addr, uint8_t *mac_addr);
N
N/// \brief Determine whether the IP address is already in use. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \param[in]     cb_func       callback function to call, when probe session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_Probe (uint32_t if_id, const uint8_t *ip6_addr, netNDP_cb_t cb_func);
N
N/// \brief Determine whether the IP address is already in use in blocking mode. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip6_addr      requested IPv6 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netNDP_ProbeX (uint32_t if_id, const uint8_t *ip6_addr);
N
N/// \brief Join this host to a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Join (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Leave a host group specified with IP address. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     ip4_addr      group IPv4 address.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netIGMP_Leave (uint32_t if_id, const uint8_t *ip4_addr);
N
N/// \brief Enable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Enable (uint32_t if_id);
N
N/// \brief Disable Dynamic Host Configuration at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_Disable (uint32_t if_id);
N
N/// \brief Set DHCP Option value at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP_SetOption (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Enable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     mode          DHCPv6 operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Enable (uint32_t if_id, netDHCP6_Mode mode);
N
N/// \brief Disable Dynamic Host Configuration version 6 at runtime. [\ref thread-safe]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDHCP6_Disable (uint32_t if_id);
N
N//  ==== Ethernet Interface Callbacks ====
N
N/// \brief Notify the user of Ethernet link state change event. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     event         Ethernet link state event as defined in \ref netETH_Event.
N/// \param[in]     val           pointer to the event value.
N/// \return        none.
Nextern void      netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val);
N
N/// \brief Receive raw Ethernet data. [\ref user-provided]
N/// \param[in]     if_num        Ethernet interface number.
N/// \param[in]     buf           buffer containing the received data.
N/// \param[in]     len           length of received data in bytes.
N/// \return        none.
Nextern void      netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len);
N
N/// \brief Notify the user of DHCP event or extended DHCP option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCP option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N/// \brief Notify the user of DHCPv6 event or extended DHCPv6 option. [\ref user-provided]
N/// \param[in]     if_id         Interface identification (class and number).
N/// \param[in]     option        DHCPv6 option code.
N/// \param[in]     val           pointer to option value.
N/// \param[in]     len           length of option value in bytes.
N/// \return        none.
Nextern void      netDHCP6_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len);
N
N//  ==== WiFi Interface User API ====
N
N/// \brief Search for available WiFi networks. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    scan_info     array of structures for storing the scan information.
N/// \param[in,out] scan_num      input maximum number, return number of WiFi networks found.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Scan (uint32_t if_num, NET_WIFI_SCAN_INFO scan_info[], uint32_t *scan_num);
N
N/// \brief Get the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[out]    buf           buffer to store the option value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetOption (uint32_t if_num, netWiFi_Option option, void *buf, uint32_t buf_len);
N
N/// \brief Set the value of the WiFi driver option. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     option        driver option as specified by \ref netWiFi_Option.
N/// \param[in]     buf           buffer containing the option value.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_SetOption (uint32_t if_num, netWiFi_Option option, const void *buf, uint32_t buf_len);
N
N/// \brief Activate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[in]     config        pointer to the structure with configuration parameters.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Activate (uint32_t if_num, const NET_WIFI_CONFIG *config);
N
N/// \brief Deactivate the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_Deactivate (uint32_t if_num);
N
N/// \brief Get the connection state of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \return      connection state:
N///               - true       = Station connected to access point.
N///               - false      = Station not connected.
Nextern bool      netWiFi_IsConnected (uint32_t if_num);
Xextern _Bool      netWiFi_IsConnected (uint32_t if_num);
N
N/// \brief Get the network information of the WiFi interface. [\ref thread-safe]
N/// \param[in]     if_num        WiFi interface number.
N/// \param[out]    net_info      structure for storing the network information.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netWiFi_GetNetInfo (uint32_t if_num, NET_WIFI_NET_INFO *net_info);
N
N//  ==== PPP Interface User API ====
N
N/// \brief Start PPP interface to accept incoming PPP connection. [\ref thread-safe]
N/// \param[in]     username      remote username for authentication.
N/// \param[in]     password      remote password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Listen (const char *username, const char *password);
N
N/// \brief Start a dial-up connection to remote PPP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote PPP server.
N/// \param[in]     username      username for authentication.
N/// \param[in]     password      password for authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Connect (const char *dial_num, const char *username, const char *password);
N
N/// \brief Disconnect PPP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPPP_Close (void);
N
N/// \brief Determine the state of PPP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netPPP_LinkUp (void);
Xextern _Bool      netPPP_LinkUp (void);
N
N//  ==== SLIP Interface User API ====
N
N/// \brief Start SLIP interface to accept incoming SLIP connections. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Listen (void);
N
N/// \brief Start a dial-up connection to remote SLIP server. [\ref thread-safe]
N/// \param[in]     dial_num      phone number of remote SLIP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Connect (const char *dial_num);
N
N/// \brief Disconnect SLIP link between two modems. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSLIP_Close (void);
N
N/// \brief Determine the state of SLIP link. [\ref thread-safe]
N/// \return      link state:
N///              - true        = Link is up, IP frames can be exchanged.
N///              - false       = Link is down.
Nextern bool      netSLIP_LinkUp (void);
Xextern _Bool      netSLIP_LinkUp (void);
N
N//  ==== Ping User API ====
N
N/// \brief Start ICMP ping process. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of remote host.
N/// \param[in]     cb_func       callback function to call, when ping session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_Echo (const NET_ADDR *addr, netPing_cb_t cb_func);
N
N/// \brief Start ICMP ping process in blocking mode. [\ref thread-safe]
N/// \param[in]     target        remote hostname or absolute IP address.
N/// \param[in]     flags         ping process control flags.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netPing_EchoX (const char *target, uint32_t flags);
N
N//  ==== DNS Client User API ====
N
N/// \brief Resolve IP address of a host from a hostname. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     cb_func       callback function to call, when DNS session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByName (const char *name, int16_t addr_type, netDNSc_cb_t cb_func);
N
N/// \brief Resolve IP address of a host from a hostname in blocking mode. [\ref thread-safe]
N/// \param[in]     name          hostname, a null-terminated string.
N/// \param[in]     addr_type     network address type to resolve:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    addr          structure that will receive resolved IP address of the hostname.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_GetHostByNameX (const char *name, int16_t addr_type, NET_ADDR *addr);
N
N/// \brief Flush or clear the local DNS cache. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netDNSc_ClearCache (void);
N
N//  ==== FTP Server User API ====
N
N/// \brief Start FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Start (void);
N
N/// \brief Stop FTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_Stop (void);
N
N/// \brief Check if FTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netFTPs_Running (void);
Xextern _Bool      netFTPs_Running (void);
N
N/// \brief Get port number of FTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netFTPs_GetPort (void);
N
N/// \brief Set port number of FTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of FTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of FTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netFTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_SetPassword (const char *password);
N
N/// \brief Determine if FTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netFTPs_LoginActive (void);
Xextern _Bool      netFTPs_LoginActive (void);
N
N/// \brief Enable or disable FTP server authentication. [\ref thread-safe]
N/// \param[in]     login       new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPs_LoginOnOff (bool login);
Xextern netStatus netFTPs_LoginOnOff (_Bool login);
N
N//  ==== FTP Server Access Interface ====
N
N/// \brief Accept or deny connection from remote FTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote FTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== FTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exists in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netFTPs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netFTPs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Check if remote user is allowed to access a file on FTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         full path of a file to access.
N/// \param[in]     access        access mode as defined with Network Access definitions.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
Xextern _Bool      netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netFTPs_GetUserId (void);
N
N//  ==== FTP Server User Callbacks ====
N
N/// \brief Notify the user application about events in FTP server service. [\ref user-provided]
N/// \param[in]     event         FTP Server notification event as specified in \ref netFTPs_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPs_Notify (netFTPs_Event event);
N
N//  ==== FTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in FTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N/// \brief Delete a file in FTP server. [\ref interface]
N/// \param[in]     fname         name of the file to delete.
N/// \return
N///              - true        = File successfully deleted.
N///              - false       = Failed to delete a file.
Nextern bool      netFTPs_fdelete (const char *fname);
Xextern _Bool      netFTPs_fdelete (const char *fname);
N
N/// \brief Rename a file or directory in FTP server. [\ref interface]
N/// \param[in]     fname         old name to rename from.
N/// \param[in]     newname       new name to rename to.
N/// \return
N///              - true        = File or directory successfully renamed.
N///              - false       = Failed to rename a file or directory.
Nextern bool      netFTPs_frename (const char *fname, const char *newname);
Xextern _Bool      netFTPs_frename (const char *fname, const char *newname);
N
N/// \brief Make a new directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to create.
N/// \return
N///              - true        = Directory successfully created.
N///              - false       = Failed to create a directory.
Nextern bool      netFTPs_mkdir (const char *path);
Xextern _Bool      netFTPs_mkdir (const char *path);
N
N/// \brief Remove an empty directory in FTP server. [\ref interface]
N/// \param[in]     path          directory path to remove.
N/// \return
N///              - true        = Directory successfully removed.
N///              - false       = Failed to remove a directory.
Nextern bool      netFTPs_rmdir (const char *path);
Xextern _Bool      netFTPs_rmdir (const char *path);
N
N/// \brief Search the file system directory for matching files. [\ref interface]
N/// \param[in]     mask          file mask filter.
N/// \param[out]    fname         buffer to write filename to.
N///                              - NULL for none.
N/// \param[out]    fsize         pointer to where to return the file size.
N///                              - NULL for none.
N/// \param[out]    ftime         pointer to where to return the created or last modified time.
N///                              - NULL for none.
N/// \param[in]     first         find first file.
N/// \return      status information:
N///              - NET_FS_ATTR_FILE      = File found.
N///              - NET_FS_ATTR_DIRECTORY = Directory found.
N///              - 0                     = No entry found.
Nextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, bool first);
Xextern int32_t   netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, _Bool first);
N
N//  ==== FTP Client User API ====
N
N/// \brief Start FTP client file operation session. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote FTP server.
N/// \param[in]     command       FTP command to perform.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netFTPc_Connect (const NET_ADDR *addr, netFTP_Command command);
N
N//  ==== FTP Client User Callbacks ====
N
N/// \brief Request parameters for FTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netFTPc_Process (netFTPc_Request request, char *buf, uint32_t buf_len);
N
N/// \brief Notify the user application when FTP client operation ends. [\ref user-provided]
N/// \param[in]     event         FTP client notification event as specified in \ref netFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netFTPc_Notify (netFTPc_Event event);
N
N//  ==== FTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in FTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in FTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Server User API ====
N
N/// \brief Start the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Start (void);
N
N/// \brief Stop the TFTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_Stop (void);
N
N/// \brief Check if the TFTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTFTPs_Running (void);
Xextern _Bool      netTFTPs_Running (void);
N
N/// \brief Get port number of the TFTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTFTPs_GetPort (void);
N
N/// \brief Set port number of the TFTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of TFTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netTFTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of TFTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPs_SetRootPath (const char *path);
N
N//  ==== TFTP Server Access Interface ====
N
N/// \brief Accept or deny connection from a remote TFTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTFTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== TFTP Server File System Interface ====
N
N/// \brief Open a file for reading or writing in the TFTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPs_fopen (const char *fname, const char *mode);
N
N/// \brief Close a file previously open in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to a file in the TFTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== TFTP Client User API ====
N
N/// \brief Put a file to a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Put (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N/// \brief Retrieve a file from a remote TFTP server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of remote TFTP server.
N/// \param[in]     fname         pointer to the remote file name, a null-terminated string.
N/// \param[in]     local_fname   pointer to the local file name, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTFTPc_Get (const NET_ADDR *addr, const char *fname, const char *local_fname);
N
N//  ==== TFTP Client User Callbacks ====
N
N/// \brief Notify the user application when TFTP client operation ends. [\ref user-provided]
N/// \param[in]     event         TFTP client notification event as specified in \ref netTFTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netTFTPc_Notify (netTFTPc_Event event);
N
N//  ==== TFTP Client File System Interface ====
N
N/// \brief Open local file for reading or writing in the TFTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \param[in]     mode          type of access:
N///                              - "rb" = opens a file for reading.
N///                              - "wb" = opens a file for writing.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netTFTPc_fopen (const char *fname, const char *mode);
N
N/// \brief Close local file previously open in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netTFTPc_fclose (void *file);
N
N/// \brief Read block of data from local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netTFTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Write block of data to local file in the TFTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to write to.
N/// \param[in]     buf           block of memory to be written.
N/// \param[in]     len           length of data to write in bytes.
N/// \return        number of bytes successfully written.
Nextern uint32_t  netTFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len);
N
N//  ==== Telnet Server User API ====
N
N/// \brief Start the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Start (void);
N
N/// \brief Stop the Telnet server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_Stop (void);
N
N/// \brief Check if the Telnet server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netTELNETs_Running (void);
Xextern _Bool      netTELNETs_Running (void);
N
N/// \brief Get port number of the Telnet server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netTELNETs_GetPort (void);
N
N/// \brief Set port number of the Telnet server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPort (uint16_t port);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netTELNETs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_SetPassword (const char *password);
N
N/// \brief Determine if Telnet server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netTELNETs_LoginActive (void);
Xextern _Bool      netTELNETs_LoginActive (void);
N
N/// \brief Enable or disable Telnet server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_LoginOnOff (bool login);
Xextern netStatus netTELNETs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected Telnet client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the Telnet server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netTELNETs_GetSession (void);
N
N/// \brief Check command string for a command. [\ref thread-safe]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[in]     user_cmd      user command to check for (in upper case).
N/// \return
N///              - true        = Command found in command string.
N///              - false       = Command not found.
Nextern bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
Xextern _Bool      netTELNETs_CheckCommand (const char *cmd, const char *user_cmd);
N
N/// \brief Request a repeated call to netTELNETs_ProcessCommand function. [\ref thread-safe]
N/// \param[in]     delay         time period to wait in number of 100ms ticks.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RepeatCommand (uint32_t delay);
N
N/// \brief Request unsolicited message processing in netTELNETs_ProcessMessage function. [\ref thread-safe]
N/// \param[in]     session       session identification, when multiple connections are active.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netTELNETs_RequestMessage (int32_t session);
N
N//  ==== Telnet Server User Callbacks ====
N
N/// \brief Process and execute a command requested by the Telnet client. [\ref user-provided]
N/// \param[in]     cmd           pointer to command string from Telnet client.
N/// \param[out]    buf           output buffer to write the return message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again for the same command.
N///                - return len | (1u<<30) = disconnect flag, the system disconnects
N///                                          the Telnet client.
Nextern uint32_t  netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Request a message for a Telnet server session. [\ref user-provided]
N/// \param[in]     msg           code of requested message.
N/// \param[out]    buf           output buffer to write the message to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \return        number of bytes written to output buffer.
Nextern uint32_t  netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len);
N
N//  ==== Telnet Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote Telnet client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote Telnet client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netTELNETs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== Telnet Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netTELNETs_CheckUsername (const char *username);
N
N/// \brief Check user account password in the user database. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     password      pointer to password.
N/// \return
N///              - true        = password accepted.
N///              - false       = invalid password.
Nextern bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
Xextern _Bool      netTELNETs_CheckPassword (uint8_t user_id, const char *password);
N
N/// \brief Retrieve the user identification number. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netTELNETs_GetUserId (void);
N
N//  ==== HTTP Server User API ====
N
N/// \brief Start the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Start (void);
N
N/// \brief Stop the HTTP server. [\ref thread-safe]
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_Stop (void);
N
N/// \brief Check if the HTTP server is running. [\ref thread-safe]
N/// \return
N///              - true        = Server is running.
N///              - false       = Server is not running.
Nextern bool      netHTTPs_Running (void);
Xextern _Bool      netHTTPs_Running (void);
N
N/// \brief Get port number of the HTTP server. [\ref thread-safe]
N/// \return        port number.
Nextern uint16_t  netHTTPs_GetPort (void);
N
N/// \brief Set port number of the HTTP server. [\ref thread-safe]
N/// \param[in]     port          port number.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPort (uint16_t port);
N
N/// \brief Retrieve path to the root directory of HTTP server. [\ref thread-safe]
N/// \return        pointer to root path, a null-terminated string.
N///                - NULL if root folder is disabled in the configuration.
Nextern const char *netHTTPs_GetRootPath (void);
N
N/// \brief Set path to the root directory of HTTP server. [\ref thread-safe]
N/// \param[in]     path          new root path, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetRootPath (const char *path);
N
N/// \brief Retrieve username of the built-in user account. [\ref thread-safe]
N/// \return        pointer to username, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetUsername (void);
N
N/// \brief Set username of the built-in user account. [\ref thread-safe]
N/// \param[in]     username      new username, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetUsername (const char *username);
N
N/// \brief Retrieve password of the built-in user account. [\ref thread-safe]
N/// \return        pointer to password, a null-terminated string.
N///                - NULL if authentication is disabled in the configuration.
Nextern const char *netHTTPs_GetPassword (void);
N
N/// \brief Reset password of the built-in user account. [\ref thread-safe]
N/// \param[in]     password      new password, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_SetPassword (const char *password);
N
N/// \brief Determine if the HTTP server authentication is enabled. [\ref thread-safe]
N/// \return
N///              - true        = Authentication enabled in the configuration.
N///              - false       = Authentication is not enabled.
Nextern bool      netHTTPs_LoginActive (void);
Xextern _Bool      netHTTPs_LoginActive (void);
N
N/// \brief Enable or disable HTTP server authentication. [\ref thread-safe]
N/// \param[in]     login      new authentication state:
N///                            - true  = Enable authentication.
N///                            - false = Disable authentication.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_LoginOnOff (bool login);
Xextern netStatus netHTTPs_LoginOnOff (_Bool login);
N
N/// \brief Get IP address and port number of a connected remote HTTP client. [\ref thread-safe]
N/// \param[out]    addr          structure that will receive IP address and port number.
N/// \param[in]     addr_len      size of NET_ADDR structure for the client.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_GetClient (NET_ADDR *addr, uint32_t addr_len);
N
N/// \brief Get current session number of the HTTP server. [\ref thread-safe]
N/// \return        current session number.
Nextern int32_t   netHTTPs_GetSession (void);
N
N/// \brief Retrieve the preferred language setting from the browser. [\ref thread-safe]
N/// \return        pointer to the language code, a null-terminated string.
Nextern const char *netHTTPs_GetLanguage (void);
N
N/// \brief Get Content-Type HTML header, received in XML post request. [\ref thread-safe]
N/// \return        pointer to content type header, a null-terminated string.
Nextern const char *netHTTPs_GetContentType (void);
N
N//  ==== HTTP Server Access Interface ====
N
N/// \brief Accept or deny a connection from a remote HTTP client. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of remote HTTP client.
N/// \return
N///              - true        = Connection from the remote client is allowed.
N///              - false       = Connection is denied.
Nextern bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
Xextern _Bool      netHTTPs_AcceptClient (const NET_ADDR *addr);
N
N//  ==== HTTP Server Multi-User Interface ====
N
N/// \brief Check if an user account exist in the user database. [\ref user-provided]
N/// \param[in]     username      pointer to username.
N/// \param[in]     password      pointer to password.
N/// \return      status information:
N///              - User identification number.
N///              - 0 if the user is not existing.
Nextern uint8_t   netHTTPs_CheckAccount (const char *username, const char *password);
N
N/// \brief Retrieve the secret word for the selected user. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[out]    buf           buffer to store the secret word to.
N/// \param[in]     buf_len       length of buffer.
N/// \return        none.
Nextern void      netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len);
N
N/// \brief Check if remote user is allowed to access a file on HTTP server. [\ref user-provided]
N/// \param[in]     user_id       user identification number.
N/// \param[in]     fname         name of a file to access.
N/// \return
N///              - true        = File access is allowed.
N///              - false       = File access is denied.
Nextern bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
Xextern _Bool      netHTTPs_FileAccess (uint8_t user_id, const char *fname);
N
N/// \brief Retrieve the user identification. [\ref thread-safe]
N/// \return        user identification number (0 = system administrator).
Nextern uint8_t   netHTTPs_GetUserId (void);
N
N/// \brief Calculate HA1 hash value for the given credentials. [\ref thread-safe]
N/// \param[in]     username      username, a null-terminated string.
N/// \param[in]     password      password, a null-terminated string.
N/// \param[out]    buf           buffer to store the hash value to.
N/// \param[in]     buf_len       length of buffer.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netHTTPs_CalcHashHA1 (const char *username, const char *password, char *buf, uint32_t buf_len);
N
N//  ==== HTTP Server File System Interface ====
N
N/// \brief Open a file for reading in HTTP server. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netHTTPs_fopen (const char *fname);
N
N/// \brief Close a file previously open in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netHTTPs_fclose (void *file);
N
N/// \brief Read block of data from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netHTTPs_fread (void *file, uint8_t *buf, uint32_t len);
N
N/// \brief Read a string from a file in HTTP server. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           output buffer to write data to.
N/// \param[in]     size          size of output buffer.
N/// \return      status information:
N///              - Pointer to string on success.
N///              - NULL in case of an error.
Nextern char     *netHTTPs_fgets (void *file, char *buf, uint32_t size);
N
N/// \brief Retrieve file size and last modification time. [\ref interface]
N/// \param[in]     fname         name of the file.
N/// \param[out]    fsize         file size in bytes.
N/// \param[out]    ftime         created or last modified time.
N/// \return        none.
Nextern void      netHTTPs_fstat (const char *fname, uint32_t *fsize, uint32_t *ftime);
N
N//  ==== HTTP Server CGI ====
N
N/// \brief Process query string received by GET request. [\ref user-provided]
N/// \param[in]     qstr          pointer to the query string.
N/// \return        none.
Nextern void      netCGI_ProcessQuery (const char *qstr);
N
N/// \brief Process data received by POST request. [\ref user-provided]
N/// \param[in]     code          callback context:
N///                              - 0 = www-url-encoded form data.
N///                              - 1 = filename for file upload (null-terminated string).
N///                              - 2 = file upload raw data.
N///                              - 3 = end of file upload (file close requested).
N///                              - 4 = any other type of POST data (single or last stream).
N///                              - 5 = the same as 4, but with more data to follow.
N/// \param[in]     data          pointer to POST data.
N/// \param[in]     len           length of POST data.
N/// \return        none.
Nextern void      netCGI_ProcessData (uint8_t code, const char *data, uint32_t len);
N
N/// \brief Generate dynamic web data based on a CGI script. [\ref user-provided]
N/// \param[in]     env           environment string.
N/// \param[out]    buf           output data buffer.
N/// \param[in]     buf_len       size of output buffer (from 536 to 1440 bytes).
N/// \param[in,out] pcgi          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1U<<31) = repeat flag, the system calls this function
N///                                          again for the same script line.
N///                - return len | (1U<<30) = force transmit flag, the system transmits
N///                                          current packet immediately.
Nextern uint32_t  netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi);
N
N/// \brief Process environment variables and convert to ANSI format. [\ref thread-safe]
N/// \param[in]     env           pointer to environment variables.
N/// \param[out]    ansi          output buffer to write converted variable to.
N/// \param[in]     max_len       maximum length of environment variable.
N/// \return      status information:
N///              - pointer to the remaining environment variables to process.
N///              - NULL if there are no more environment variables to process.
Nextern const char *netCGI_GetEnvVar (const char *env, char *ansi, uint32_t max_len);
N
N/// \brief Override default character encoding in HTML documents. [\ref user-provided]
N/// \return        pointer to user defined character set type.
Nextern const char *netCGI_Charset (void);
N
N/// \brief Add custom MIME type for unsupported file types. [\ref user-provided]
N/// \param[in]     file_ext      filename extension, a null-terminated string.
N/// \return      MIME type information:
N///                - pointer to user defined Content-Type.
N///                - NULL for unknown type.
Nextern const char *netCGI_ContentType (const char *file_ext);
N
N/// \brief Redirect resource URL address to a new location. [\ref user-provided]
N/// \param[in]     file_name     resource filename, a null-terminated string.
N/// \return      URL redirection information:
N///                - pointer to user defined Location.
N///                - NULL for no URL address redirection.
Nextern const char *netCGI_Redirect (const char *file_name);
N
N/// \brief Override default Content-Type for CGX script files. [\ref user-provided]
N/// \return        pointer to user defined Content-Type.
Nextern const char *netCGX_ContentType (void);
N
N/// \brief Add custom HTTP response header. [\ref user-provided]
N/// \return        pointer to user defined HTTP header.
Nextern const char *netCGI_CustomHeader (void);
N
N//  ==== SMTP Client User API ====
N
N/// \brief Start SMTP client to send an email in legacy mode. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_Connect (const NET_ADDR *addr);
N
N/// \brief Send an email in blocking mode. [\ref thread-safe]
N/// \param[in]     mail          pointer to email content descriptor.
N/// \param[in]     mta           pointer to mail transfer agent descriptor.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSMTPc_SendMail (const NET_SMTP_MAIL *mail, const NET_SMTP_MTA *mta);
N
N//  ==== SMTP Client User Callbacks ====
N
N/// \brief Request parameters for SMTP client session. [\ref user-provided]
N/// \param[in]     request       request code.
N/// \param[out]    buf           output buffer to write the data to.
N/// \param[in]     buf_len       length of the output buffer in bytes.
N/// \param[in,out] pvar          pointer to a session's local buffer of 4 bytes.
N///                              - 1st call = cleared to 0.
N///                              - 2nd call = not altered by the system.
N///                              - 3rd call = not altered by the system, etc.
N/// \return        number of bytes written to output buffer.
N///                - return len | (1u<<31) = repeat flag, the system calls this function
N///                                          again when \a request is \ref netSMTPc_RequestBody.
Nextern uint32_t  netSMTPc_Process (netSMTPc_Request request, char *buf, uint32_t buf_len, uint32_t *pvar);
N
N/// \brief Notify the user application when SMTP client operation ends. [\ref user-provided]
N/// \param[in]     event         SMTP client notification event as specified in \ref netSMTPc_Event.
N/// \return        none.
N/// \note Network library calls this function to inform the user about events.
Nextern void      netSMTPc_Notify (netSMTPc_Event event);
N
N/// \brief Accept or deny authentication requested by SMTP server. [\ref user-provided]
N/// \param[in]     addr          structure containing IP address and port of SMTP server.
N/// \return
N///              - true        = Authentication is accepted.
N///              - false       = Authentication is denied.
Nextern bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
Xextern _Bool      netSMTPc_AcceptAuthentication (const NET_ADDR *addr);
N
N//  ==== SMTP Client File System Interface ====
N
N/// \brief Open a file for reading in SMTP client. [\ref interface]
N/// \param[in]     fname         name of the file to open.
N/// \return      status information:
N///              - Pointer to an open file.
N///              - NULL in case of an error.
Nextern void     *netSMTPc_fopen (const char *fname);
N
N/// \brief Close a file previously open in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to close.
N/// \return        none.
Nextern void      netSMTPc_fclose (void *file);
N
N/// \brief Read block of data from a file in SMTP client. [\ref interface]
N/// \param[in]     file          pointer to the file to read from.
N/// \param[out]    buf           block of memory to write data to.
N/// \param[in]     len           length of data to read in bytes.
N/// \return        number of bytes successfully read.
Nextern uint32_t  netSMTPc_fread (void *file, uint8_t *buf, uint32_t len);
N
N//  ==== SNTP Client User API ====
N
N/// \brief Set mode of operation for SNTP client. [\ref thread-safe]
N/// \param[in]     mode          SNTP client operation mode.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_SetMode (netSNTPc_Mode mode);
N
N/// \brief Determine current time from NTP or SNTP time server. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of NTP or SNTP server.
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[in]     cb_func       callback function to call, when the session ends.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTime (const NET_ADDR *addr, netSNTPc_cb_t cb_func);
N
N/// \brief Determine current time from NTP or SNTP time server in blocking mode. [\ref thread-safe]
N/// \param[in]     server        server name or absolute IP address (FQDN or IP address).
N///                              - NULL to use NTP server IP address from system configuration.
N/// \param[out]    seconds       pointer to the variable to return time in seconds.
N/// \param[out]    seconds_fraction
N///                              pointer to the variable to return fraction of seconds.
N///                              - NULL for none.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNTPc_GetTimeX (const char *server, uint32_t *seconds, uint32_t *seconds_fraction);
N
N//  ==== SNMP Agent User API ====
N
N/// \brief Send a trap message to the Trap Manager. [\ref thread-safe]
N/// \param[in]     addr          structure containing IP address of the Trap server.
N///                              - NULL to use Trap server IP address from system configuration.
N/// \param[in]     generic       generic trap type:
N///                              - 0  = ColdStart trap.
N///                              - 1  = WarmStart trap.
N///                              - 2  = LinkDown trap.
N///                              - 3  = LinkUp trap.
N///                              - 4  = AuthenticationFailure trap.
N///                              - 5  = EgpNeighborLoss trap.
N///                              - 6  = EnterpriseSpecific trap.
N/// \param[in]     specific      specific trap type for generic enterpriseSpecific trap:
N///                              - must be set to 0 for generic traps 0 ... 5
N/// \param[in]     obj_list      object list included in trap message.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_Trap (const NET_ADDR *addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list);
N
N/// \brief Change SNMP community to a new community. [\ref thread-safe]
N/// \param[in]     community     new community, a null-terminated string.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetCommunity (const char *community);
N
N/// \brief Register MIB table to SNMP Agent. [\ref thread-safe]
N/// \param[in]     info          pointer to MIB table.
N/// \param[in]     size          size of MIB table in bytes.
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus netSNMP_SetMIB_Table (const NET_SNMP_MIB_INFO *info, uint32_t size);
N
N// ==== Network Address Conversion ====
N
N/// \brief Convert IP address from binary to text form. [\ref thread-safe]
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[in]     ip_addr       IPv4 or IPv6 address in binary form.
N/// \param[out]    string_buf    buffer to store converted IP address to.
N/// \param[in]     buf_len       length of a string buffer, at least:
N///                              - 16 characters for IPv4 address.
N///                              - 40 characters for IPv6 address.
N/// \return      pointer to \a string_buf with null-terminated IP address string.
N///              - NULL in case of parameter error.
Nextern const char *netIP_ntoa (int16_t addr_type, const uint8_t *ip_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert IP address from text to binary form. [\ref thread-safe]
N/// \param[in]     addr_string   network address string:
N///                              - in dotted-decimal IPv4 notation.
N///                              - in compressed colon-hexadecimal IPv6 notation.
N/// \param[in]     addr_type     network address type:
N///                              - NET_ADDR_IP4 = IPv4 address.
N///                              - NET_ADDR_IP6 = IPv6 address.
N/// \param[out]    ip_addr       IPv6 or IPv6 address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
Xextern _Bool      netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr);
N
N/// \brief Convert MAC address from binary to text form. [\ref thread-safe]
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \param[out]    string_buf    buffer to store converted MAC address to.
N/// \param[in]     buf_len       length of a string buffer, at least 18 characters.
N/// \return      pointer to \a string_buf with null-terminated MAC address string.
N///              - NULL in case of parameter error.
Nextern const char *netMAC_ntoa (const uint8_t *mac_addr, char *string_buf, uint32_t buf_len);
N
N/// \brief Convert MAC address from text to binary form. [\ref thread-safe]
N/// \param[in]     mac_string    address string in hyphen MAC-address notation.
N/// \param[out]    mac_addr      MAC address in binary form.
N/// \return
N///              - true        = Conversion successful.
N///              - false       = Conversion failed.
Nextern bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
Xextern _Bool      netMAC_aton (const char *mac_string, uint8_t *mac_addr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_DS_H */
L 14 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\rl_net_lib.h" 2
N
N#ifdef __clang__
S  #pragma clang diagnostic ignored "-Wpadded"
N#endif
N
N/// General definitions
N#define NET_HEADER_LEN      4           ///< Network frame header length
N#define PHY_HEADER_LEN      14          ///< Physical/ethernet header length
N#define ETH_MAX_FRAME_SIZE  1514        ///< Maximum size of ethernet frame
N#define NET_USERNAME_SIZE   16          ///< Authentication username buffer size
N#define NET_PASSWORD_SIZE   16          ///< Authentication password buffer size
N#define NET_HA1_HASH_LEN    32          ///< HTTP Authentication HA1 hash length
N#define NET_ROOT_PATH_SIZE  128         ///< Root path buffer size
N#define NET_TCP_NO_ACK      0xFFFFFFFF  ///< Callback return value for no ACK
N#define NET_IF_CLASS_LOOP   (0 << 8)    ///< Loopback interface class
N
N/// Debug process definitions
N#ifdef RTE_Network_Debug_STDIO
S#define NET_SYSTEM_CORE     0           ///< Main system core
S#define NET_DYNAMIC_MEMORY  1           ///< Dynamic memory management
S#define NET_ETH_INTERFACE   2           ///< Ethernet interface 0
S#define NET_WIFI_INTERFACE  3           ///< WiFi interface
S#define NET_PPP_INTERFACE   4           ///< PPP interface
S#define NET_SLIP_INTERFACE  5           ///< SLIP interface
S#define NET_LOCAL_LOOPBACK  6           ///< Loopback virtual interface
S#define NET_ARP_CACHE       7           ///< Ethernet ARP cache
S#define NET_IP4_CORE        8           ///< IPv4 core and localhost
S#define NET_ICMP_CONTROL    9           ///< ICMP control service for IPv4
S
S#define NET_IGMP_HOST       10          ///< IGMP group managememt host for IPv4
S#define NET_IP6_CORE        11          ///< IPv6 core and localhost
S#define NET_ICMP6_CONTROL   12          ///< ICMP6 control service for IPv6
S#define NET_NDP_CACHE       13          ///< Ethernet Neighbor Discovery for IPv6
S#define NET_UDP_SOCKET      14          ///< UDP native socket
S#define NET_TCP_SOCKET      15          ///< TCP native socket
S#define NET_BSD_SOCKET      16          ///< BSD socket interface
S#define NET_NBNS_CLIENT     17          ///< NBNS client service for IPv4
S#define NET_DHCP_CLIENT     18          ///< DHCP client service for IPv4
S#define NET_DHCP6_CLIENT    19          ///< DHCP client service for IPv6
S
S#define NET_DNS_CLIENT      20          ///< DNS client service
S#define NET_SNMP_AGENT      21          ///< SNMP agent module
S#define NET_HTTP_SERVER     22          ///< HTTP server service
S#define NET_FTP_SERVER      23          ///< FTP server service
S#define NET_FTP_CLIENT      24          ///< FTP client service
S#define NET_TELNET_SERVER   25          ///< Telnet server service
S#define NET_TFTP_SERVER     26          ///< TFTP server service
S#define NET_TFTP_CLIENT     27          ///< TFTP client service
S#define NET_SMTP_CLIENT     28          ///< SMTP client service
S#define NET_SNTP_CLIENT     29          ///< SNTP client service
N#endif /* RTE_Network_Debug_STDIO */
N
N/// Telnet definitions
N#define TELNET_LBUF_SZ      96          ///< Command line buffer size in bytes
N#define TELNET_HIST_SZ      128         ///< Command history buffer size in bytes
N#define TELNET_FIFO_SZ      128         ///< Input character Fifo buffer in bytes
N
N/// BSD Socket ioctl commands
N#define FIONBIO             1           ///< Set mode (blocking/non-blocking)
N#define FIO_DELAY_ACK       2           ///< Set DELAY_ACK mode for stream socket
N#define FIO_KEEP_ALIVE      3           ///< Set KEEP_ALIVE mode for stream socket
N#define FIO_FLOW_CTRL       4           ///< Set FLOW_CTRL mode for stream socket
N
N#ifdef __cplusplus
Sextern "C"  {
N#endif
N
N/// Network OS identifier
Ntypedef void *NETOS_ID;
N
N/// Network scheduler function type
Ntypedef void (*net_sys_fn_t) (void);
N
N/// System Error codes
Ntypedef enum net_error {
N  NET_ERROR_MEM_ALLOC,                  ///< Alloc memory failed, out of memory
N  NET_ERROR_MEM_FREE,                   ///< Free memory failed, memory slot invalid
N  NET_ERROR_MEM_CORRUPT,                ///< Memory corruption detected
N  NET_ERROR_CONFIG,                     ///< Network configuration error detected
N  NET_ERROR_UDP_ALLOC,                  ///< No free UDP sockets available
N  NET_ERROR_TCP_ALLOC,                  ///< No free TCP sockets available
N  NET_ERROR_TCP_STATE                   ///< TCP socket in undefined state
N} NET_ERROR;
N
N/// Frame buffer structure
Ntypedef struct net_frame {
N  uint16_t length;                      ///< Length of data in frame
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[256];                   ///< Buffer data (protocol headers + data)
N	//}
N} NET_FRAME;
N
N/// Buffer queue structure
Ntypedef struct net_buffer {
N  struct net_buffer *next;              ///< Next buffer in the list
N  uint16_t length;                      ///< Length of data in buffer
N  uint16_t index;                       ///< Buffer position index
N	/// EDIT 20240125
N	//{
N  uint8_t  data[2024];                  ///< Buffer data
N	//}
N} NET_BUFFER;
N
N/// Library variant optimization
N#ifdef RTE_Network_IPv6
S  #define  Network_IPv6
S  #define __ADDR            NET_ADDR
S  #define __ADDR_IP_LEN     NET_ADDR_IP6_LEN
N#else
N  #define __ADDR            NET_ADDR4
N  #define __ADDR_IP_LEN     NET_ADDR_IP4_LEN
N#endif
N#define __FRAME(buf)        ((NET_FRAME *)(uint32_t)(buf))
N#define __BUFFER(buf)       ((NET_BUFFER *)(uint32_t)(buf))
N
N/// Local Machine info version 4
Ntypedef struct net_localm {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint16_t Reserved;                    ///< Reserved (used for alignment)
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Local IP address
X  uint8_t  IpAddr[4];    
N  uint8_t  NetMask[NET_ADDR_IP4_LEN];   ///< Netmask
X  uint8_t  NetMask[4];   
N  uint8_t  DefGW[NET_ADDR_IP4_LEN];     ///< Default gateway
X  uint8_t  DefGW[4];     
N  uint8_t  PriDNS[NET_ADDR_IP4_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[4];    
N  uint8_t  SecDNS[NET_ADDR_IP4_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[4];    
N} NET_LOCALM;
N
N/// Local Machine info version 6
Ntypedef struct net_localm6 {
N  uint16_t Mtu;                         ///< Maximum IP transmission unit
N  uint8_t  HopLimit;                    ///< Hop limit for outging IP packets
N  uint8_t  PrefixLen;                   ///< Subnet prefix length
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  TempAddr[NET_ADDR_IP6_LEN];  ///< Temporary IPv6 address
X  uint8_t  TempAddr[16];  
N  uint8_t  LLAddr[NET_ADDR_IP6_LEN];    ///< Link-local address
X  uint8_t  LLAddr[16];    
N  uint8_t  DefGW[NET_ADDR_IP6_LEN];     ///< Default gateway
X  uint8_t  DefGW[16];     
N  uint8_t  PriDNS[NET_ADDR_IP6_LEN];    ///< Primary DNS server
X  uint8_t  PriDNS[16];    
N  uint8_t  SecDNS[NET_ADDR_IP6_LEN];    ///< Secondary DNS server
X  uint8_t  SecDNS[16];    
N} NET_LOCALM6;
N
N/// ARP Cache Entry info
Ntypedef struct net_arp_info {
N  uint8_t  State;                       ///< Cache entry state
N  uint8_t  Type;                        ///< Cache entry type
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< IPv4 address
X  uint8_t  IpAddr[4];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  Reserved;                    ///< Reserved (not used)
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_ARP_INFO;
N
N/// IGMP Group info
Ntypedef struct net_igmp_info {
N  uint8_t  State;                       ///< Group membership state
N  uint8_t  Tout;                        ///< Timeout timer for reports
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Id;                          ///< Entry identification number
N  uint8_t  IpAddr[NET_ADDR_IP4_LEN];    ///< Group IPv4 address
X  uint8_t  IpAddr[4];    
N} NET_IGMP_INFO;
N
N/// NDP Cache Entry info
Ntypedef struct net_ndp_info {
N  uint8_t  State;                       ///< Cache state
N  uint8_t  Flags;                       ///< State flags
N  uint16_t Tout;                        ///< Timeout timer
N  uint8_t  IpAddr[NET_ADDR_IP6_LEN];    ///< IPv6 address
X  uint8_t  IpAddr[16];    
N  uint8_t  MacAddr[NET_ADDR_ETH_LEN];   ///< Hardware MAC address
X  uint8_t  MacAddr[6];   
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  Id;                          ///< Entry identification number
N  NET_FRAME *tx_list;                   ///< Frames waiting to resolve MAC address
N} NET_NDP_INFO;
N
N/// IP4-Frag session info
Ntypedef struct net_ip4_frag_info {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Len;                         ///< Total length of datagram fragments
N  NET_FRAME *frag_list;                 ///< Fragment queue list
N} NET_IP4_FRAG_INFO;
N
N/// UDP Socket info
Ntypedef struct net_udp_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Flags;                       ///< State flags and options
N  uint16_t LocPort;                     ///< Local UDP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  uint8_t  McastTtl;                    ///< Multicast time to live for IPv4
N  uint8_t  HopLimit;                    ///< Multicast hop limit for IPv6
N  const struct net_if_cfg *net_if;      ///< Network interface for broadcast frames
N  netUDP_cb_t cb_func;                  ///< Event callback function
N} NET_UDP_INFO;
N
N/// TCP Socket info
Ntypedef struct net_tcp_info {
N  netTCP_State State;                   ///< Socket state
N  uint8_t  Type;                        ///< Socket type
N  uint8_t  Flags;                       ///< State flags
N  uint16_t LocPort;                     ///< Local TCP port
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class/packet priority for IPv6
N  const uint8_t *LocAddr;               ///< Pointer to local IPv6 address
N  __ADDR   Peer;                        ///< Peer IP address and port
X  NET_ADDR4   Peer;                        
N  uint16_t MaxSegSize;                  ///< Transmit max. segment size
N  uint16_t ConnTout;                    ///< Connection timeout
N  uint16_t AliveTimer;                  ///< Keep alive timer
N  uint16_t RetryTimer;                  ///< Retransmission timer
N  uint8_t  AckTimer;                    ///< Receive delay-ack timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Retries;                     ///< Number of retries left
N  uint8_t  DupAcks;                     ///< Number of duplicate acks (fast recovery)
N  uint32_t SendUna;                     ///< Send sequence number unacknowledged
N  uint32_t SendNext;                    ///< Next send sequence number
N  uint32_t SendChk;                     ///< Check sequence number for dupacks
N  uint32_t SendWl1;                     ///< Sequence number of last window update
N  uint32_t SendWl2;                     ///< Acknowledge number of last window update
N  uint16_t SendWin;                     ///< Current send window
N  int16_t  RttSa;                       ///< Scaled average for RTT estimator
N  int16_t  RttSv;                       ///< Scaled deviation for RTT estimator
N  uint16_t CWnd;                        ///< Congestion window
N  uint16_t SsThresh;                    ///< Slow start treshold
N  uint16_t RecWin;                      ///< Current receive window
N  uint32_t RecNext;                     ///< Next receive sequence number
N  NET_FRAME *unack_list;                ///< Unacked queue list
N  const struct net_if_cfg *net_if;      ///< Network interface for the route
N  netTCP_cb_t cb_func;                  ///< Event callback function
N} NET_TCP_INFO;
N
N/// BSD Socket info
Ntypedef struct net_bsd_info {
N  uint8_t  State;                       ///< Socket state
N  uint8_t  Socket;                      ///< Assigned TCP/UDP socket
N  uint8_t  Flags;                       ///< Flags for socket option
N  uint8_t  Type;                        ///< Type of socket
N  __ADDR   RemHost;                     ///< Remote IP address and port
X  NET_ADDR4   RemHost;                     
N  __ADDR   LocHost;                     ///< Local IP address and port
X  NET_ADDR4   LocHost;                     
N  uint8_t  AcceptSock;                  ///< Accept socket list
N  uint8_t  ParentSock;                  ///< Parent (server) socket
N  uint16_t RecvTout;                    ///< Blocking receive timeout
N  uint16_t Timer;                       ///< Receiver timer
N  uint8_t  SendTout;                    ///< Blocking send timeout
N  uint8_t  xTimer;                      ///< Sender timer
N  uint8_t  Id;                          ///< Socket identification number
N  uint8_t  Event;                       ///< Owner wait-for events
N  uint8_t  xEvent;                      ///< Sender wait-for events
N  uint8_t  Tos;                         ///< Type of Service for IPv4
N  uint8_t  TClass;                      ///< Traffic class for IPv6
N  NETOS_ID Thread;                      ///< Socket owner thread
N  NETOS_ID xThread;                     ///< Socket sender thread
N  NET_BUFFER *buf_list;                 ///< Rx data buffer list
N} NET_BSD_INFO;
N
N/// DNS Cache Entry info
Ntypedef struct net_dns_info {
N  uint32_t HostId;                      ///< Host Id (CRC32 value of host name)
N  uint16_t Tout;                        ///< Cache timeout timer
N  int16_t  Type;                        ///< Address type: IPv4 or IPv6
N  uint8_t  IpAddr[__ADDR_IP_LEN];       ///< Internet IP address
X  uint8_t  IpAddr[4];       
N} NET_DNS_INFO;
N
N/// TFTP Server Session info
Ntypedef struct net_tftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned UDP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  Retries;                     ///< Retry counter
N  __ADDR   Client;                      ///< Client IP address and port (TID)
X  NET_ADDR4   Client;                      
N  uint16_t BlockSz;                     ///< Transfer block size
N  uint16_t BlockNr;                     ///< Block number
N  uint8_t  Timer;                       ///< Timeout timer
N  uint16_t BufLen;                      ///< Length of retransmit buffer
N  uint8_t  *Buf;                        ///< Transmit/retransmit buffer
N  void     *File;                       ///< File handle pointer
N} NET_TFTP_INFO;
N
N/// Telnet Session info
Ntypedef struct net_telnet_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint8_t  Flags;                       ///< State flags
N  uint8_t  BCnt;                        ///< Received data byte count
N  uint16_t Tout;                        ///< Timeout delay timer
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Widx;                        ///< Fifo buffer write index
N  uint8_t  Ridx;                        ///< Fifo buffer read index
N  uint8_t  hNext;                       ///< History command next position
N  uint8_t  hCurr;                       ///< History command current position
N  uint32_t SVar;                        ///< Session private variable
N  char     LBuf[TELNET_LBUF_SZ];        ///< Data line buffer
X  char     LBuf[96];        
N  char     Fifo[TELNET_FIFO_SZ];        ///< Fifo buffer for received line/keycodes
X  char     Fifo[128];        
N  char     Hist[TELNET_HIST_SZ];        ///< Command history buffer
X  char     Hist[128];        
N} NET_TELNET_INFO;
N
N/// FTP Session info
Ntypedef struct net_ftp_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< TCP control socket
N  uint16_t Flags;                       ///< State flags
N  __ADDR   Client;                      ///< Client IP address and port
X  NET_ADDR4   Client;                      
N  uint16_t DPort;                       ///< Data port (active or passive)
N  uint8_t  DSocket;                     ///< TCP data socket
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  Resp;                        ///< Server response code
N  uint8_t  PathLen;                     ///< Size of the path string
N  char    *Path;                        ///< Current working directory
N  char    *Name;                        ///< Absolute file/folder path name
N  void    *File;                        ///< File handle pointer
N} NET_FTP_INFO;
N
N/// HTTP Session info
Ntypedef struct net_http_info {
N  uint8_t  State;                       ///< Session state
N  uint8_t  Socket;                      ///< Assigned TCP socket
N  uint16_t Flags;                       ///< State flags
N  uint8_t  FType;                       ///< File type: html, jpeg, gif,...
N  uint8_t  PostSt;                      ///< POST method processing state
N  uint16_t DelimSz;                     ///< Boundary delimiter size
N  uint8_t  UserId;                      ///< User Id (authentication enabled)
N  uint8_t  TlsId;                       ///< TLS context identifier
N  uint8_t  Method;                      ///< Request method (GET,POST,...)
N  uint32_t CGIvar;                      ///< CGI session private variable
N  uint32_t DLen;                        ///< Data length (number of bytes to send)
N  uint32_t Count;                       ///< Total number of bytes sent
N  uint16_t BCnt;                        ///< Number of bytes sent in last packet
N  char     Lang[6];                     ///< Selected web language: en-us, de, fr...
N  uint32_t LMDate;                      ///< Last modified date (UTC format)
N  char    *Script;                      ///< Script buffer pointer
N  char    *pDelim;                      ///< Multipart boundary delimiter value
N  char    *pUser;                       ///< User MIME type or Redirect URL
N  void    *sFile;                       ///< Script interpreter file pointer
N  void    *dFile;                       ///< Data file pointer
N} NET_HTTP_INFO;
N
N/// HTTP Nonce Cache Entry info
Ntypedef struct net_http_nonce {
N  uint16_t Tout;                        ///< Timeout timer
N  uint16_t Count;                       ///< Number of references to nonce
N  char     Val[24];                     ///< Nonce value base64 encoded
N} NET_HTTP_NONCE;
N
N/// HTTP Error page info
Ntypedef struct net_http_error {
N  const char *header;                   ///< Common page header
N  const char *footer;                   ///< Common page footer
N  const char *e401;                     ///< 401 Unauthorized
N  const char *e403;                     ///< 403 Forbidden
N  const char *e404;                     ///< 404 Not Found
N  const char *e501;                     ///< 501 Not Implemented
N} const NET_HTTP_ERROR;
N
N/// SYS Configuration info
Ntypedef struct net_sys_cfg {
N  uint32_t   *MemPool;                  ///< Dynamic memory pool buffer
N  uint32_t   MemSize;                   ///< Memory pool size in bytes
N  char       *Path;                     ///< Path buffer for root-enabled services
N  const char *HostName;                 ///< Configured Local host name
N  bool       AutoStart;                 ///< Auto-Start server service
X  _Bool       AutoStart;                 
N  bool       TxQueUsed;                 ///< Tx queue used for PPP or SLIP
X  _Bool       TxQueUsed;                 
N  const net_sys_fn_t *fn_init;          ///< Network Init-function table
N  const net_sys_fn_t *fn_run;           ///< Network Run-function table
N} const NET_SYS_CFG;
N
N/// netIF_GetOption functions
Ntypedef struct {
N  netStatus (*eth_get_option) (uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*wifi_get_option)(uint32_t,netIF_Option,uint8_t*,uint32_t);
N  netStatus (*ppp_get_option) (netIF_Option,uint8_t*,uint32_t);
N  netStatus (*slip_get_option)(netIF_Option,uint8_t*,uint32_t);
N} const NETIF_GETOPT_FUNC;
N
N/// netIF_SetOption functions
Ntypedef struct {
N  netStatus (*eth_set_option) (uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*wifi_set_option)(uint32_t,netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*ppp_set_option) (netIF_Option,const uint8_t*,uint32_t);
N  netStatus (*slip_set_option)(netIF_Option,const uint8_t*,uint32_t);
N} const NETIF_SETOPT_FUNC;
N
N/// ARP Configuration info
Ntypedef struct net_arp_cfg {
N  struct net_arp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_ARP_INFO *Table;                  ///< Cache table array
N  uint8_t  TabSize;                     ///< Cache table size
N  uint8_t  TimeOut;                     ///< Cache expiration time in seconds
N  uint8_t  MaxRetry;                    ///< Number of retries to resolve MAC address
N  uint8_t  Resend;                      ///< Resend timeout in seconds
N  bool     Notify;                      ///< Notify on IP address changes
X  _Bool     Notify;                      
N} const NET_ARP_CFG;
N
N/// IGMP Configuration info
Ntypedef struct net_igmp_cfg {
N  struct net_igmp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_IGMP_INFO *Table;                 ///< Group table array
N  uint16_t TabSize;                     ///< Group table size
N} const NET_IGMP_CFG;
N
N/// DHCP Client Configuration info
Ntypedef struct net_dhcp_cfg {
N  struct net_dhcp_ctrl    *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const char *Vcid;                     ///< Vendor class identifier
N  uint8_t    VcidLen;                   ///< Length of Vendor class identifier
N  uint8_t    OptBootfile:1;             ///< Option bootfile enable
N  uint8_t    OptNtpServ :1;             ///< Option NTP servers enable
N} const NET_DHCP_CFG;
N
N/// IP4 Configuration info
Ntypedef struct net_ip4_cfg {
N  const char  *IpAddr;                  ///< IPv4 address
N  const char  *NetMask;                 ///< IPv4 network mask
N  const char  *DefGW;                   ///< Default gateway IPv4 address
N  const char  *PriDNS;                  ///< Primary DNS server
N  const char  *SecDNS;                  ///< Secondary DNS server
N  uint16_t     Mtu;                     ///< Maximum transmission unit
N  uint8_t      NoEcho  :1;              ///< Disable ping/echo response
N  uint8_t      EnNbns  :1;              ///< Enable NBNS protocol
N  NET_ARP_CFG *ArpCfg;                  ///< ARP configuration
N  NET_IGMP_CFG *IgmpCfg;                ///< IGMP configuration
N  NET_DHCP_CFG *DhcpCfg;                ///< DHCP configuraton
N} const NET_IP4_CFG;
N
N/// NDP Configuration info
Ntypedef struct net_ndp_cfg {
N  struct net_ndp_ctrl     *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_NDP_INFO *Table;                  ///< Neighbor cache table
N  uint8_t   TabSize;                    ///< Cache table size
N  uint8_t   TimeOut;                    ///< Cache expiration time in seconds
N  uint8_t   MaxRetry;                   ///< Number of retries to resolve MAC address
N  uint8_t   Resend;                     ///< Resend timeout in seconds
N} const NET_NDP_CFG;
N
N/// DHCP6 Client Configuration info
Ntypedef struct net_dhcp6_cfg {
N  struct net_dhcp6_ctrl   *Ctrl;        ///< Instance control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  uint8_t    Stateful  :1;              ///< Statefull mode enabled
N  uint8_t    OptVclass :1;              ///< Option Vendor class enabled
N  uint32_t   EnterpId;                  ///< Enterprise-number
N  const char *VcData;                   ///< Vendor class data
N} const NET_DHCP6_CFG;
N
N/// IP6 Configuration info
Ntypedef struct net_ip6_cfg {
N  const char   *IpAddr;                 ///< IPv6 address
N  const char   *DefGW;                  ///< Default gateway IPv6 address
N  const char   *PriDNS;                 ///< Primary DNS server
N  const char   *SecDNS;                 ///< Secondary DNS server
N  uint8_t       PrefixLen;              ///< Address prefix length
N  uint8_t       NoEcho :1;              ///< Disable ping/echo response
N  NET_NDP_CFG  *NdpCfg;                 ///< Neighbor discovery configuration
N  NET_DHCP6_CFG *Dhcp6Cfg;              ///< DHCPv6 configuration
N} const NET_IP6_CFG;
N
N/// Interface status info
Ntypedef struct net_if_state {
N  bool     LinkUp;                      ///< Link up or WiFi connected
X  _Bool     LinkUp;                      
N  bool     MacNew;                      ///< Mac address changed
X  _Bool     MacNew;                      
N  uint16_t Offload;                     ///< Checksum offload flags
N} NET_IF_STATE;
N
N/// General Interface descriptor
Ntypedef struct net_if_cfg {
N  NET_IF_STATE *State;                  ///< Interface Status
N  uint16_t     Id;                      ///< Interface Identifier
N  char         Name[6];                 ///< Interface Name null-terminated
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  NET_LOCALM  *localm;                  ///< Local machine info IPv4
N  NET_IP4_CFG *Ip4Cfg;                  ///< IPv4 configuration
N  NET_LOCALM6 *localm6;                 ///< Local machine info IPv6
N  NET_IP6_CFG *Ip6Cfg;                  ///< IPv6 configuration
N  bool (*send_frame)(uint32_t,          ///< Send frame function
X  _Bool (*send_frame)(uint32_t,          
N                     NET_FRAME*,uint8_t);
N  void (*config_mcast)(uint32_t);       ///< Config Multicast MAC filter for LAN
N  bool (*output_lan)(uint32_t,          ///< Low level output for LAN (Eth, WiFi)
X  _Bool (*output_lan)(uint32_t,          
N                     NET_FRAME*);
N} const NET_IF_CFG;
N
N/// Ethernet Interface descriptor
Ntypedef struct net_eth_cfg {
N  struct net_eth_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvMac;                  ///< Registered MAC driver
N  const void  *DrvPhy;                  ///< Registered PHY driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint16_t     VlanTag;                 ///< Vlan tag identifier
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t);           ///< Driver event notification callback
N} const NET_ETH_CFG;
N
N/// WiFi Interface descriptor
Ntypedef struct net_wifi_cfg {
N  struct net_wifi_ctrl    *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  const void  *DrvWifi;                 ///< Registered WiFi driver
N  uint8_t     *MacAddr;                 ///< Active MAC address
N  const char  *MacCfg;                  ///< Configured MAC address
N  uint8_t      Mode;                    ///< WiFi Mode (Station, AP)
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  void (*cb_event)(uint32_t,void*);     ///< Driver event notification callback
N} const NET_WIFI_CFG;
N
N/// Serial Device Configuration info
Ntypedef struct net_com_cfg {
N  struct net_com_ctrl   *Ctrl;          ///< Serial control block
N  struct net_modem_ctrl *ModemCtrl;     ///< Modem service control block
N  const void *DrvUsart;                 ///< Registered USART driver
N  const void *DrvModem;                 ///< Registered MODEM driver
N  const char *InitString;               ///< Modem initialization string
N  uint32_t    Speed;                    ///< Connection speed
N  uint8_t     FlowCtrl;                 ///< Flow control
N  uint8_t     MaxDelay;                 ///< Max. thread polling delay in ms
N  uint8_t     RecTout;                  ///< Frame receive timeout in ticks
N  void (*cb_event)  (uint32_t);         ///< USART driver event callback
N  void (*cb_request)(const char*,       ///< Modem driver request callback
N                     const char*,uint32_t,uint32_t);
N} const NET_COM_CFG;
N
N/// PPP Interface descriptor
Ntypedef struct net_ppp_cfg {
N  struct net_ppp_ctrl     *Ctrl;        ///< Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint32_t     ACCmap;                  ///< Async control character map
N  uint16_t     RetryTout;               ///< Retry timeout in ticks
N  uint16_t     EchoTout;                ///< LCP echo timeout in seconds
N  uint8_t      MaxRetry;                ///< Number of retries
N  uint8_t      EnAuth   :1;             ///< Enable authentication
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      ObtainIp :1;             ///< Obtain client IP address automatically
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N  struct net_lcp_ctrl       *LcpCtrl;   ///< LCP Service control block
N  const struct net_ppp_auth *PapAuth;   ///< PAP Authentication service
N  const struct net_ppp_auth *ChapAuth;  ///< CHAP Authentication service
N  struct net_ipcp_ctrl      *IpcpCtrl;  ///< IPCP Service control block
N} const NET_PPP_CFG;
N
N/// PPP PAP/CHAP Configuration info
Ntypedef struct net_ppp_auth {
N  void *Ctrl;                           ///< Authentication control block
N  void (*init)   (NET_PPP_CFG*);        ///< Initialize authentication
N  void (*uninit) (NET_PPP_CFG*);        ///< De-initialize authentication
N  void (*run)    (NET_PPP_CFG*);        ///< Run authentication
N  void (*process)(NET_PPP_CFG*,NET_FRAME*);///< Process authentication frame
N} const NET_PPP_AUTH;
N
N/// SLIP Interface descriptor
Ntypedef struct net_slip_cfg {
N  struct net_slip_ctrl    *Ctrl;        ///< SLIP Interface control block
N  const struct net_if_cfg *If;          ///< Link to general interface descriptor
N  NET_COM_CFG *ComCfg;                  ///< Serial device configuration
N  uint8_t      UseDefGW :1;             ///< Use default gateway on remote network
N  uint8_t      IfNum;                   ///< Interface number (0,1)
N} const NET_SLIP_CFG;
N
N/// IP4-Frag Configuration info
Ntypedef struct net_ip4_frag_cfg {
N  NET_IP4_FRAG_INFO *Scb;               ///< Reassembly control block array
N  uint8_t  NumSess;                     ///< Max. number of reassembly sessions
N  uint16_t ReassTout;                   ///< Reassembly timeout in ticks
N} const NET_IP4_FRAG_CFG;
N
N/// UDP Socket Configuration info
Ntypedef struct net_udp_cfg {
N  NET_UDP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of UDP sockets
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_UDP_CFG;
N
N/// TCP Socket Configuration info
Ntypedef struct net_tcp_cfg {
N  NET_TCP_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of TCP sockets
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint16_t SynRetryTout;                ///< SYN retry timeout in ticks
N  uint16_t InitRetryTout;               ///< Initial retransmit timeout in ticks
N  uint16_t DefTout;                     ///< Default connect timeout in seconds
N  uint16_t MaxSegSize;                  ///< Maximum segment size value
N  uint16_t RecWinSize;                  ///< Receiving window size in bytes
N  uint8_t  ConnRetry;                   ///< Number of retries to connect
N  uint16_t DynPortStart;                ///< Dynamic port start
N  uint16_t DynPortEnd;                  ///< Dynamic port end
N} const NET_TCP_CFG;
N
N/// BSD Socket Configuration info
Ntypedef struct net_bsd_cfg {
N  NET_BSD_INFO *Scb;                    ///< Socket control block array
N  uint8_t  NumSocks;                    ///< Number of BSD sockets
N  uint16_t RecvTout;                    ///< Blocking recv timeout in ticks
N} const NET_BSD_CFG;
N
N/// DNS Client Configuration info
Ntypedef struct net_dns_cfg {
N  NET_DNS_INFO *Table;                  ///< Cache table array
N  uint8_t   TabSize;                    ///< Cache table size
N} const NET_DNS_CFG;
N
N/// mbedTLS interface functions
Ntypedef struct net_tls_if {
N  uint8_t  (*get_context)(int32_t,netTCP_cb_t);  ///< Allocate secure TLS context
N  void     (*connect)    (uint8_t,const char *); ///< Connect to remote endpoint
N  void     (*listen)     (uint8_t);              ///< Listen for incomming connections
N  uint8_t *(*get_buf)    (uint32_t);             ///< Get memory for send buffer
N  void     (*write)      (uint8_t,const uint8_t*,uint32_t);///< Write data to TLS session
N  void     (*close)      (uint8_t,uint8_t);      ///< Close TLS session
N} const NET_TLS_IF;
N
N/// SMTP Client Attachment functions
Ntypedef struct {
N  uint32_t (*mail_attach)  (char*,uint32_t);     ///< Compose attachment
N  uint32_t (*mime_header)  (char*,const void*);  ///< Add MIME multipart header
N  const char*(*parse_fname)(const char*,void*);  ///< Parse attachment file name(s)
N} const NET_SMTP_ATTACH;
N
N/// SMTP Client Configuration info
Ntypedef struct net_smtp_cfg {
N  uint8_t   DefTout;                    ///< Default inactivity timeout
N  struct {                              ///< File System interface functions
N    void    *(*fopen) (const char*);             ///< Open file for reading
N    uint32_t (*fread) (void*,uint8_t*,uint32_t); ///< Read file data
N    void     (*fclose)(void*);                   ///< Close file
N  } fs_if;
N  NET_SMTP_ATTACH *attach_if;           ///< Attachment support interface
N  NET_TLS_IF      *tls_if;              ///< mbedTLS interface functions
N} const NET_SMTP_CFG;
N
N/// SNMP Agent Configuration info
Ntypedef struct net_snmp_cfg {
N  uint16_t   PortNum;                   ///< Listening port number
N  uint16_t   TrapPort;                  ///< Trap port number
N  const char *TrapIp;                   ///< Trap server IP address
N  const char *Community;                ///< Community name
N} const NET_SNMP_CFG;
N
N/// SNTP Client Configuration info
Ntypedef struct net_sntp_cfg {
N  const char *SrvIp;                    ///< NTP/SNTP server IP address
N  bool       Bcast;                     ///< Broadcast client mode (for LAN only)
X  _Bool       Bcast;                     
N} const NET_SNTP_CFG;
N
N/// TFTP Server Configuration info
Ntypedef struct net_tftp_cfg {
N  NET_TFTP_INFO *Scb;                   ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  uint8_t  MaxRetry;                    ///< Number of retries
N  uint16_t PortNum;                     ///< Listening port number
N  uint8_t  DefTout;                     ///< Inactive session timeout in seconds
N  bool     EnFwall;                     ///< Enable firewall support
X  _Bool     EnFwall;                     
N  const char *Root;                     ///< Root folder path
N} const NET_TFTP_CFG;
N
N/// TFTP Client Configuration info
Ntypedef struct net_tftpc_cfg {
N  uint16_t BlockSize;                   ///< Transfer block size
N  uint16_t RetryTout;                   ///< Retry timeout in ticks
N  uint8_t  MaxRetry;                    ///< Number of retries
N} const NET_TFTPC_CFG;
N
N/// Telnet Server Configuration info
Ntypedef struct net_telnet_cfg {
N  NET_TELNET_INFO *Scb;                 ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint8_t  NoEcho;                      ///< Disable server echo mode
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_TELNET_CFG;
N
N/// FTP Server Configuration info
Ntypedef struct net_ftp_cfg {
N  NET_FTP_INFO *Scb;                    ///< Session control block array
N  uint8_t  NumSess;                     ///< Max. number of active sessions
N  bool     EnAuth;                      ///< Enable user authentication
X  _Bool     EnAuth;                      
N  uint16_t PortNum;                     ///< Listening port number
N  uint16_t IdleTout;                    ///< Idle connection timeout in ticks
N  uint8_t  MsgLen;                      ///< Length of welcome message
N  const char *Msg;                      ///< Server welcome message
N  const char *Root;                     ///< Root folder path
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t  UserLen;                     ///< Length of admin username
N  uint8_t  PasswLen;                    ///< Length of admin password
N} const NET_FTP_CFG;
N
N/// FTP Client Configuration info
Ntypedef struct net_ftpc_cfg {
N  uint8_t DefTout;                      ///< Default inactivity timeout
N  bool    PasvMode;                     ///< FTP passive mode used
X  _Bool    PasvMode;                     
N} const NET_FTPC_CFG;
N
N/// HTTP Server Authentication functions
Ntypedef struct {
N  void    (*init)      (void);          ///< Initialize HTTP authentication
N  void    (*uninit)    (void);          ///< De-initialize HTTP authentication
N  void    (*run)       (void);          ///< Run HTTP authentication
N  uint32_t(*add_line)  (void*,char*);   ///< Add authentication header line
N  bool    (*parse_line)(void*,char*);   ///< Parse authentication header line
X  _Bool    (*parse_line)(void*,char*);   
N  void    (*calc_hash) (const char*,    ///< Calculate Digest hash HA1 value
N                        const char*,uint8_t*);
N} const NET_HTTP_AUTH;
N
N/// HTTP Server Configuration info
Ntypedef struct net_http_cfg {
N  NET_HTTP_INFO *Scb;                   ///< Session control block array
N  uint8_t   NumSess;                    ///< Max. number of active sessions
N  bool      EnAuth;                     ///< Enable user authentication
X  _Bool      EnAuth;                     
N  uint16_t  PortNum;                    ///< Listening port number
N  const char *SrvId;                    ///< Server-Id http header
N  const char *Root;                     ///< Root folder path
N  const char *Realm;                    ///< Authentication realm space
N  uint8_t    RealmLen;                  ///< Length of realm string
N  const char *User;                     ///< Default admin username
N  const char *Passw;                    ///< Default admin password
N  uint8_t   UserLen;                    ///< Length of admin username
N  uint8_t   PasswLen;                   ///< Length of admin password
N  NET_HTTP_NONCE *Nonce;                ///< Nonce cache table array
N  uint8_t   NumNonce;                   ///< Max. number of cache entries
N  uint8_t   NonceTout;                  ///< Cache entry timeout in seconds
N  NET_HTTP_AUTH *auth_if;               ///< Authentication support interface
N  NET_TLS_IF    *tls_if;                ///< mbedTLS interface functions
N} const NET_HTTP_CFG;
N
N/// Generic unspecified address
Nextern const uint8_t net_addr_unspec[];
N
N/// Network configuration data
Nextern NET_SYS_CFG      net_sys_config;
Nextern NET_IF_CFG       net_eth0_if_config;
Nextern NET_IF_CFG       net_eth1_if_config;
Nextern NET_IF_CFG       net_wifi0_if_config;
Nextern NET_IF_CFG       net_wifi1_if_config;
Nextern NET_IF_CFG       net_ppp0_if_config;
Nextern NET_IF_CFG       net_slip0_if_config;
N
Nextern NET_ETH_CFG   *const net_eth_list[];
Nextern NET_WIFI_CFG  *const net_wifi_list[];
Nextern NET_PPP_CFG   *const net_ppp_list[];
Nextern NET_SLIP_CFG  *const net_slip_list[];
Nextern NET_IF_CFG    *const net_if_list_lan[];
Nextern NET_IF_CFG    *const net_if_list_all[];
Nextern NET_IF_CFG    *const net_if_inet_def[];
Nextern NET_IF_CFG    *const net_if_link_def[];
Nextern NET_ARP_CFG   *const net_arp_list[];
Nextern NET_IGMP_CFG  *const net_igmp_list[];
Nextern NET_DHCP_CFG  *const net_dhcp_list[];
Nextern NET_NDP_CFG   *const net_ndp_list[];
Nextern NET_DHCP6_CFG *const net_dhcp6_list[];
N
Nextern NET_IP4_FRAG_CFG net_ip4_frag_config;
Nextern NET_UDP_CFG      net_udp_config;
Nextern NET_TCP_CFG      net_tcp_config;
Nextern NET_BSD_CFG      net_bsd_config;
Nextern NET_HTTP_CFG     net_http_config;
Nextern NET_HTTP_ERROR   net_http_error;
Nextern NET_TELNET_CFG   net_telnet_config;
Nextern NET_TFTP_CFG     net_tftp_config;
Nextern NET_TFTPC_CFG    net_tftpc_config;
Nextern NET_FTP_CFG      net_ftp_config;
Nextern NET_FTPC_CFG     net_ftpc_config;
Nextern NET_DNS_CFG      net_dns_config;
Nextern NET_SMTP_CFG     net_smtp_config;
Nextern NET_SNMP_CFG     net_snmp_config;
Nextern NET_SNTP_CFG     net_sntp_config;
N
N/// Network uninit functions
Nextern const net_sys_fn_t net_sys_fn_uninit[];
N
N/// Network interface functions
Nextern NETIF_GETOPT_FUNC  netif_getopt_func;
Nextern NETIF_SETOPT_FUNC  netif_setopt_func;
N
N/// Network exported functions.
Nextern NET_PPP_AUTH     net_ppp0_pap_auth;
Nextern NET_PPP_AUTH     net_ppp0_chap_auth;
Nextern NET_SMTP_ATTACH  net_smtp_attach_func;
Nextern NET_HTTP_AUTH    net_http_auth_basic_func;
Nextern NET_HTTP_AUTH    net_http_auth_digest_func;
N
N/// Local machine info
N#ifdef RTE_Network_Legacy
Sextern NET_LOCALM  *const net_localm[4];
N#endif
N
N//  ==== Network system ====
N
N/// \brief Network Component core thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netCore_Thread (void const *arg);
N
N/// \brief Network core tick timer callback.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void net_sys_tick (void const *arg);
N
N/// \brief Signal Network Component error.
N/// \param[in]     error         system error code.
N/// \return        None.
Nextern void net_sys_error (NET_ERROR error);
N
N/// \brief Acquire Network core protection mutex.
N/// \return        None.
Nextern void net_sys_lock   (void);
N
N/// \brief Release Network core protection mutex.
N/// \return        None.
Nextern void net_sys_unlock (void);
N
N//  ==== OS abstraction layer ====
N
N/// \brief Initialize OS abstraction layer.
N/// \return        None.
Nextern void netos_init (void);
N
N/// \brief Create network core thread.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_create (void);
N
N/// \brief Delete network core thread.
N/// \param[in]     thread        thread identifier.
N/// \return        None.
Nextern void netos_thread_delete (NETOS_ID thread);
N
N/// \brief Get running thread identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netos_thread_id (void);
N
N/// \brief Pass control to next ready thread.
N/// \return        None.
Nextern void netos_thread_pass (void);
N
N/// \brief Create network periodic tick timer.
N/// \return        timer identifier.
Nextern NETOS_ID netos_timer_create (void);
N
N/// \brief Delete network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \return        None.
Nextern void netos_timer_delete (NETOS_ID timer);
N
N/// \brief Start network periodic tick timer.
N/// \param[in]     timer         timer identifier.
N/// \param[in]     interval_ms   tick interval in millisec.
N/// \return        None.
Nextern void netos_timer_start (NETOS_ID timer, uint32_t interval_ms);
N
N/// \brief Create network protection mutex.
N/// \param[in]     sys_id        system identifier (0=core, 1=memory).
N/// \return        mutex identifier.
Nextern NETOS_ID netos_mutex_create (uint8_t sys_id);
N
N/// \brief Delete network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_mutex_delete (NETOS_ID mutex);
N
N/// \brief Lock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_lock (NETOS_ID mutex);
N
N/// \brief Unlock network protection mutex.
N/// \param[in]     mutex         mutex identifier.
N/// \return        None.
Nextern void netos_unlock (NETOS_ID mutex);
N
N/// \brief Delay network thread execution.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_delay (uint32_t ms);
N
N/// \brief Suspend thread until event flag is set.
N/// \param[in]     flag          event flag to wait for.
N/// \param[in]     ms            millisec to delay.
N/// \return        None.
Nextern void netos_flag_wait (uint32_t flag, uint32_t ms);
N
N/// \brief Set thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_set (NETOS_ID thread, uint32_t flag);
N
N/// \brief Clear thread event flag.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     flag          event flag to wait for.
N/// \return        None.
Nextern void netos_flag_clear (NETOS_ID thread, uint32_t flag);
N
N/// \brief Create network interface thread and protection semaphore.
N/// \param[in]     if_id         Network interface identification.
N/// \param[out]    semaphore     pointer to semaphore identifier.
N/// \return        thread identifier.
Nextern NETOS_ID netif_create (uint32_t if_id, NETOS_ID *semaphore);
N
N/// \brief Delete network interface thread and protection semaphore.
N/// \param[in]     thread        thread identifier.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_delete (NETOS_ID thread, NETOS_ID semaphore);
N
N/// \brief Lock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_lock (NETOS_ID semaphore);
N
N/// \brief Unlock network interface protection semaphore.
N/// \param[in]     semaphore     semaphore identifier.
N/// \return        None.
Nextern void netif_unlock (NETOS_ID semaphore);
N
N//  ==== Memory management ====
N
N/// \brief Allocate memory for the network frame.
N/// \param[in]     byte_size     buffer size in bytes.
N/// \return        Pointer to the allocated memory.
Nextern NET_FRAME *net_mem_alloc (uint32_t byte_size);
N
N/// \brief Release allocated memory.
N/// \param[in]     mem_ptr       pointer to the allocated memory.
N/// \return        None.
Nextern void net_mem_free (NET_FRAME *mem_ptr);
N
N//  ==== Ethernet interface ====
N
N/// \brief Ethernet interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netETH_Thread (void const *arg);
N
N/// \brief Initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_init (void);
N
N/// \brief De-initialize ethernet interface.
N/// \return        None.
Nextern void net_eth_iface_uninit (void);
N
N/// \brief Run ethernet interface main function.
N/// \return None.
Nextern void net_eth_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_eth_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Configure ethernet multicast address filtering.
N/// \param[in]     if_num        Interface number.
N/// \return        None.
Nextern void net_eth_config_mcast (uint32_t if_num);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_eth_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from eth driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (eth0, eth1).
N/// \return        None.
Nextern void net_eth_callback (uint32_t event, struct net_eth_ctrl *ctx);
N
N/// \brief Get MAC address for the given IP address (legacy).
N/// \param[in]     addr        structure containing IP address of a host.
N/// \return        Pointer to the MAC address in Neighbor cache.
Nextern const uint8_t *net_eth_get_addr (const __ADDR *addr);
Xextern const uint8_t *net_eth_get_addr (const NET_ADDR4 *addr);
N
N/// \brief Get current value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of Ethernet Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_eth_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N/// \brief Initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_init (void);
N
N/// \brief De-initialize ARP cache.
N/// \return        None.
Nextern void net_arp_cache_uninit (void);
N
N/// \brief Run ARP cache main function.
N/// \return None.
Nextern void net_arp_cache_run (void);
N
N/// \brief Send a notification of local IP address change (gratuitous ARP).
N/// \param[in]     net_if        network interface descriptor.
N/// \return        None.
Nextern void net_arp_notify (NET_IF_CFG *net_if);
N
N/// \brief Initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_init (void);
N
N/// \brief De-initialize IGMP group management.
N/// \return        None.
Nextern void net_igmp_host_uninit (void);
N
N/// \brief Run IGMP group management main function.
N/// \return        None.
Nextern void net_igmp_host_run (void);
N
N/// \brief Process IGMP group management frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received IGMP group management frame.
N/// \return        None.
Nextern void net_igmp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Check if local host is a member of provided group.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     ip4_addr      multicast IPv4 address to be checked.
N/// \return
N///              - true        = Local host is member of IGMP group ipadr.
N///              - false       = Local host is not member.
Nextern bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
Xextern _Bool net_igmp_is_member (NET_IF_CFG *net_if, const uint8_t *ip4_addr);
N
N/// \brief Collect IP addresses of active IGMP groups.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[out]    buf           buffer to copy group IP addresses to.
N/// \return        Number of IPs copied.
Nextern uint32_t net_igmp_collect_mcast (NET_IF_CFG *net_if, uint8_t *buf);
N
N/// \brief Initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_init (void);
N
N/// \brief De-initialize NDP cache.
N/// \return        None.
Nextern void net_ndp_cache_uninit (void);
N
N/// \brief Run NDP cache main function.
N/// \return None.
Nextern void net_ndp_cache_run (void);
N
N/// \brief Process Neighbor Discovery frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received ND frame.
N/// \return        None.
Nextern void net_ndp_process (NET_IF_CFG *net_if, NET_FRAME *frame);
N
N/// \brief Initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_init (void);
N
N/// \brief De-initialize NBNS client.
N/// \return        None.
Nextern void net_nbns_client_uninit (void);
N
N/// \brief Initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_init (void);
N
N/// \brief De-initialize DHCP client.
N/// \return        None.
Nextern void net_dhcp_client_uninit (void);
N
N/// \brief Run DHCP client main function.
N/// \return        None.
Nextern void net_dhcp_client_run (void);
N
N/// \brief Initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_init (void);
N
N/// \brief De-initialize DHCP6 client.
N/// \return        None.
Nextern void net_dhcp6_client_uninit (void);
N
N/// \brief Run DHCP6 client main function.
N/// \return        None.
Nextern void net_dhcp6_client_run (void);
N
N//  ==== WiFi interface ====
N
N/// \brief WiFi interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netWiFi_Thread (void const *arg);
N
N/// \brief Initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_init (void);
N
N/// \brief De-initialize WiFi interface.
N/// \return        None.
Nextern void net_wifi_iface_uninit (void);
N
N/// \brief Run WiFi interface main function.
N/// \return None.
Nextern void net_wifi_iface_run (void);
N
N/// \brief Construct ethernet header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_wifi_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Protected output of ethernet frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         network frame.
N/// \return
N///              - true  = output success.
N///              - false = output failed.
Nextern bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
Xextern _Bool net_wifi_output (uint32_t if_num, NET_FRAME *frame);
N
N/// \brief Send event notification from wifi driver.
N/// \param[in]     event         receive event.
N/// \param[in]     ctx           interface context (wifi0, wifi1).
N/// \return        None.
Nextern void net_wifi_callback (uint32_t event, struct net_wifi_ctrl *ctx);
N
N/// \brief Get current value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_get_option (uint32_t if_num, netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of WiFi Interface option.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_wifi_set_option (uint32_t if_num, netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== PPP interface ====
N
N/// \brief PPP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netPPP_Thread (void const *arg);
N
N/// \brief Initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_init (void);
N
N/// \brief De-initialize PPP interface.
N/// \return        None.
Nextern void net_ppp_iface_uninit (void);
N
N/// \brief Run PPP interface main function.
N/// \return        None.
Nextern void net_ppp_iface_run (void);
N
N/// \brief Construct PPP header for the frame and send it.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_ppp_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_ppp_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== SLIP interface ====
N
N/// \brief SLIP interface thread.
N/// \param[in]     arg           dummy parameter.
N/// \return        None.
Nextern void netSLIP_Thread (void const *arg);
N
N/// \brief Initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_init (void);
N
N/// \brief De-initialize SLIP interface.
N/// \return        None.
Nextern void net_slip_iface_uninit (void);
N
N/// \brief Run SLIP interface main function.
N/// \return        None.
Nextern void net_slip_iface_run (void);
N
N/// \brief Send a SLIP frame.
N/// \param[in]     if_num        Interface number.
N/// \param[in]     frame         frame to be sent.
N/// \param[in]     ip_ver        IP version of the frame.
N/// \return
N///              - true        = Frame successfuly sent.
N///              - false       = Failed to send a frame.
Nextern bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
Xextern _Bool net_slip_send_frame (uint32_t if_num, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Get current value of SLIP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[out]    buf           buffer to store the option value to
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_get_option (netIF_Option option, uint8_t *buf, uint32_t buf_len);
N
N/// \brief Set the value of PPP Interface option.
N/// \param[in]     option        Interface option as specified by \ref netIF_Option.
N/// \param[in]     buf           buffer containing the option value
N/// \param[in]     buf_len       length of buffer
N/// \return      status code that indicates the execution status of the function.
Nextern netStatus net_slip_set_option (netIF_Option option, const uint8_t *buf, uint32_t buf_len);
N
N//  ==== Serial and Modem interface ====
N
N/// \brief Send event notification from the USART driver.
N/// \param[in]     event         receive USART event.
N/// \param[in]     ctx           serial device context (ppp, slip).
N/// \return        None.
Nextern void net_com_callback (uint32_t event, struct net_com_ctrl *ctx);
N
N/// \brief Request callback from the modem driver.
N/// \param[in]     cmd           command to send to a modem driver.
N/// \param[in]     response      expected response to wait for.
N/// \param[in]     timeout       response timeout.
N/// \param[in]     retries       number of retries on failure.
N/// \param[in]     ctx           modem device context.
N/// \return        None.
Nextern void net_modem_callback (const char *cmd, const char *response, uint32_t timeout,
N                                uint32_t retries, struct net_modem_ctrl *ctx);
N
N//  ==== Network core ====
N
N/// \brief Initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_init (void);
N
N/// \brief De-initialize loopback interface.
N/// \return        None.
Nextern void net_loop_iface_uninit (void);
N
N/// \brief Run loopback interface main function.
N/// \return        None.
Nextern void net_loop_iface_run (void);
N
N/// \brief Initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_init (void);
N
N/// \brief De-initialize IPv4 fragmentation and reassembly.
N/// \return        None.
Nextern void net_ip4_frag_uninit (void);
N
N/// \brief Run IPv4 reassembly main function.
N/// \return        None.
Nextern void net_ip4_frag_run (void);
N
N/// \brief Reassemble incoming IPv4 fragment.
N/// \param[in]     frame         incoming IPv4 datagram fragment.
N/// \return        pointer to assembled frame or NULL if not completed yet.
Nextern NET_FRAME *net_ip4_frag_add (NET_FRAME *frame);
N
N/// \brief Split outgoing IPv4 datagram to small fragments.
N/// \param[in]     frame         outgoing IPv4 datagram.
N/// \param[in]     mtu           maximum transmission unit.
N/// \return        pointer to generated frame fragment.
Nextern NET_FRAME *net_ip4_frag_get (NET_FRAME *frame, uint16_t mtu);
N
N/// \brief Initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_init (void);
N
N/// \brief De-initialize Ping client.
N/// \return        None.
Nextern void net_ping_client_uninit (void);
N
N/// \brief Run Ping client main function.
N/// \return        None.
Nextern void net_ping_client_run (void);
N
N/// \brief Initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_init (void);
N
N/// \brief De-initialize UDP sockets.
N/// \return        None.
Nextern void net_udp_socket_uninit (void);
N
N/// \brief Process UDP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received UDP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_udp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_init (void);
N
N/// \brief De-initialize TCP sockets.
N/// \return        None.
Nextern void net_tcp_socket_uninit (void);
N
N/// \brief Run TCP socket main function.
N/// \return        None.
Nextern void net_tcp_socket_run (void);
N
N/// \brief Process TCP frame.
N/// \param[in]     net_if        network interface descriptor.
N/// \param[in]     frame         received TCP frame.
N/// \param[in]     ip_ver        received IP version.
N/// \return        None.
Nextern void net_tcp_process (NET_IF_CFG *net_if, NET_FRAME *frame, uint8_t ip_ver);
N
N/// \brief Set or change TCP socket callback function.
N/// \param[in]     socket        socket handle.
N/// \param[in]     cb_func       event listening callback function.
N/// \return        None.
Nextern void net_tcp_set_cb (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Retrieve TCP socket remote peer address.
N/// \param[in]     socket        socket handle.
N/// \return        pointer to network address structure.
Nextern NET_ADDR *net_tcp_get_peer_ptr (int32_t socket);
N
N/// \brief Convert TCP socket state into a string.
N/// \param[in]     state         socket state as defined with netTCP_State.
N/// \return        pointer to the text representation of a socket state.
Nextern const char *net_tcp_ntoa (netTCP_State state);
N
N/// \brief Initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_init (void);
N
N/// \brief De-initialize DNS client.
N/// \return        None.
Nextern void net_dns_client_uninit (void);
N
N/// \brief Run DNS client main function.
N/// \return        None.
Nextern void net_dns_client_run (void);
N
N/// \brief Initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_init (void);
N
N/// \brief De-initialize BSD sockets.
N/// \return        None.
Nextern void net_bsd_socket_uninit (void);
N
N/// \brief Run BSD socket main function.
N/// \return        None.
Nextern void net_bsd_socket_run (void);
N
N/// \brief Initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_init (void);
N
N/// \brief De-initialize BSD host resolver.
N/// \return        None.
Nextern void net_bsd_host_uninit (void);
N
N//  ==== FTP server service ====
N
N/// \brief Initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_init (void);
N
N/// \brief De-initialize FTP server.
N/// \return        None.
Nextern void net_ftp_server_uninit (void);
N
N/// \brief Run FTP server main function.
N/// \return        None.
Nextern void net_ftp_server_run (void);
N
N//  ==== FTP client application ====
N
N/// \brief Initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_init (void);
N
N/// \brief De-initialize FTP client.
N/// \return        None.
Nextern void net_ftp_client_uninit (void);
N
N/// \brief Run FTP client main function.
N/// \return        None.
Nextern void net_ftp_client_run (void);
N
N//  ==== TFTP server service ====
N
N/// \brief Initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_init (void);
N
N/// \brief De-initialize TFTP server.
N/// \return        None.
Nextern void net_tftp_server_uninit (void);
N
N/// \brief Run TFTP server main function.
N/// \return        None.
Nextern void net_tftp_server_run (void);
N
N//  ==== TFTP client application ====
N
N/// \brief Initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_init (void);
N
N/// \brief De-initialize TFTP client.
N/// \return        None.
Nextern void net_tftp_client_uninit (void);
N
N/// \brief Run TFTP client main function.
N/// \return        None.
Nextern void net_tftp_client_run (void);
N
N//  ==== SMTP client application ====
N
N/// \brief Initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_init (void);
N
N/// \brief De-initialize SMTP client.
N/// \return        None.
Nextern void net_smtp_client_uninit (void);
N
N/// \brief Run SMTP client main function.
N/// \return        None.
Nextern void net_smtp_client_run (void);
N
N//  ==== SNMP agent application ====
N
N/// \brief Initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_init (void);
N
N/// \brief De-initialize SNMP agent.
N/// \return        None.
Nextern void net_snmp_agent_uninit (void);
N
N/// \brief Run SNMP agent main function.
N/// \return        None.
Nextern void net_snmp_agent_run (void);
N
N//  ==== SNTP client application ====
N
N/// \brief Initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_init (void);
N
N/// \brief De-initialize SNTP client.
N/// \return        None.
Nextern void net_sntp_client_uninit (void);
N
N/// \brief Run SNTP client main function.
N/// \return        None.
Nextern void net_sntp_client_run (void);
N
N//  ==== Telnet server service ====
N
N/// \brief Initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_init (void);
N
N/// \brief De-initialize Telnet server.
N/// \return        None.
Nextern void net_telnet_server_uninit (void);
N
N/// \brief Run Telnet server main function.
N/// \return        None.
Nextern void net_telnet_server_run (void);
N
N//  ==== HTTP server service ====
N
N/// \brief Initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_init (void);
N
N/// \brief De-initialize HTTP server.
N/// \return        None.
Nextern void net_http_server_uninit (void);
N
N/// \brief Run HTTP server main function.
N/// \return        None.
Nextern void net_http_server_run (void);
N
N/// \brief Convert generic time to internal HTTP time format.
N/// \param[in]     hr            hours   [0..23].
N/// \param[in]     min           minutes [0..59].
N/// \param[in]     sec           seconds [0..59].
N/// \param[in]     day           day     [1..31].
N/// \param[in]     mon           month   [1..12].
N/// \param[in]     year          year    [1980..2107].
N/// \return        converted time in UTC format.
Nextern uint32_t net_http_time (uint8_t hr, uint8_t min, uint8_t sec, 
N                               uint8_t day, uint8_t mon, uint16_t year);
N
N//  ==== TLS interface ====
N
N/// \brief Initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceInit (void);
N
N/// \brief De-initialize TLS interface.
N/// \return        None.
Nextern void netTLS_InterfaceUninit (void);
N
N/// \brief Allocate secure TLS context.
N/// \param[in]     socket        associated TCP socket.
N/// \param[in]     cb_func       event listening TCP callback function.
N/// \return        Secure session identifier or 0=none.
Nextern uint8_t netTLS_GetContext (int32_t socket, netTCP_cb_t cb_func);
N
N/// \brief Establish encrypted TLS connection to remote endpoint.
N/// \param[in]     tls_id        TLS session id.
N/// \param[in]     srv_name      hostname of the server.
N/// \return        None.
Nextern void netTLS_Connect (uint8_t tls_id, const char *srv_name);
N
N/// \brief Start TLS server listening for encrypted connection.
N/// \param[in]     tls_id        TLS session id.
N/// \return        None.
Nextern void netTLS_Listen (uint8_t tls_id);
N
N/// \brief Allocate memory for TLS send buffer.
N/// \param[in]     size          number of bytes to allocate.
N/// \return        pointer to the allocated memory.
Nextern uint8_t *netTLS_GetBuffer (uint32_t size);
N
N///  \brief Write data to TLS session.
N///  \param[in]    tls_id        TLS context id.
N///  \param[in]    buf           pointer to data buffer.
N///  \param[in]    len           length of data (in bytes).
N///  \return       None.
Nextern void netTLS_Write (uint8_t tls_id, const uint8_t *buf, uint32_t len);
N
N/// \brief Stop TLS communication and close socket.
N/// \param[in]     tls_id        TLS context id.
N/// \param[in]     sock_mode     socket close mode: 1=normal, 0=abort.
N/// \return        None.
Nextern void netTLS_Close (uint8_t tls_id, uint8_t sock_mode);
N
N//  ==== Network address conversion ====
N
N/// \brief Copy IP address and port.
N/// \param[out]    dst_addr      destination IPv4 or IPv6 address.
N/// \param[in]     src_addr      source IPv4 or IPv6 address.
N/// \return        None.
Nextern void net_addr_copy (__ADDR *dst_addr, const __ADDR *src_addr);
Xextern void net_addr_copy (NET_ADDR4 *dst_addr, const NET_ADDR4 *src_addr);
N
N/// \brief Convert IPv4 address from binary to string.
N/// \param[in]     ip4_addr      IPv4 address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_addr4_ntoa (const uint8_t *ip4_addr);
N
N/// \brief Convert IPv4 address from text to binary form.
N/// \param[in]     cp            IPv4 address string (ie. "192.168.1.100").
N/// \param[out]    ip4_addr      4-byte address in binary form.
N/// \return
N///                - true  = successfull,
N///                - false = failed.
Nextern bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
Xextern _Bool net_addr4_aton (const char *cp, uint8_t *ip4_addr);
N
N/// \brief Convert MAC address from binary to string.
N/// \param[in]     mac_addr      MAC address in binary form.
N/// \return        pointer to converted string.
Nextern const char *net_mac_ntoa (const uint8_t *mac_addr);
N
N//  ==== Network debug ====
N
N/// \brief Initialize STDIO debug interface.
N/// \return        None.
Nextern void net_debug_init (void);
N
N/// \brief Debug print information message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_info (int32_t proc, const char *fmt, ...);
N
N/// \brief Debug print error message.
N/// \param[in]     proc          network process id.
N/// \param[in]     fmt           printf format string.
N/// \return        None.
Nextern void net_dbg_error (int32_t proc, const char *fmt, ...);
N
N/// \brief Convert process id into a string.
N/// \param[in]     proc          network process id.
N/// \return        pointer to process id string.
Nextern const char *net_dbg_proc (int32_t proc);
N
N/// \brief Get current network time for debug.
N/// \return        pointer to current time string.
Nextern const char *net_dbg_time (void);
N
N/// \brief Initialize Event Recorder debug interface.
N/// \return        None.
Nextern void net_evr_init (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RL_NET_LIB_H */
L 13 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_debug.h" 2
N
N#ifndef DBG_SYSTEM_EN
S  #error "::Network:CORE:Debug configuration update required"
N#endif
N
N#ifndef DBG_WIFI
S  #define DBG_WIFI      0
N#endif
N
N#ifdef RTE_Network_Debug_STDIO
S/* Printf style debug */
S
S#if   defined(__CC_ARM)
S  #pragma diag_suppress 111
S#elif defined(__clang__)
S  #pragma clang diagnostic ignored "-Wformat-nonliteral"
S#endif
S
S#if (DBG_TIME)
S  #define __DBG_TIME    net_dbg_time()
S#else
S  #define __DBG_TIME    ""
S#endif
S
S/* Print debug information message */
Svoid net_dbg_info (int32_t proc, const char *fmt, ...) {
S  __va_list args;
S
S  switch (proc) {
S
S#if (DBG_SYSTEM_EN)
S    case NET_SYSTEM_CORE:   break;
S  #if (DBG_MEM > 1)
S    case NET_DYNAMIC_MEMORY:break;
S  #endif
S  #if (DBG_ETH > 1)
S    case NET_ETH_INTERFACE: break;
S  #endif
S  #if (DBG_WIFI > 1)
S    case NET_WIFI_INTERFACE:break;
S  #endif
S  #if (DBG_PPP > 1)
S    case NET_PPP_INTERFACE: break;
S  #endif
S  #if (DBG_SLIP > 1)
S    case NET_SLIP_INTERFACE:break;
S  #endif
S  #if (DBG_LOOP > 1)
S    case NET_LOCAL_LOOPBACK:break;
S  #endif
S#endif
S
S#if (DBG_CORE4_EN)
S  #if (DBG_IP4 > 1)
S    case NET_IP4_CORE:      break;
S  #endif
S  #if (DBG_ICMP > 1)
S    case NET_ICMP_CONTROL:  break;
S  #endif
S  #if (DBG_IGMP > 1)
S    case NET_IGMP_HOST:     break;
S  #endif
S  #if (DBG_NBNS > 1)
S    case NET_NBNS_CLIENT:   break;
S  #endif
S  #if (DBG_DHCP > 1)
S    case NET_DHCP_CLIENT:   break;
S  #endif
S  #if (DBG_ARP > 1)
S    case NET_ARP_CACHE:     break;
S  #endif
S#endif
S
S#if (DBG_CORE6_EN)
S  #if (DBG_IP6 > 1)
S    case NET_IP6_CORE:      break;
S  #endif
S  #if (DBG_ICMP6 > 1)
S    case NET_ICMP6_CONTROL: break;
S  #endif
S  #if (DBG_DHCP6 > 1)
S    case NET_DHCP6_CLIENT:  break;
S  #endif
S  #if (DBG_NDP6 > 1)
S    case NET_NDP_CACHE:     break;
S  #endif
S#endif
S
S#if (DBG_SOCKET_EN)
S  #if (DBG_UDP_SOCKET > 1)
S    case NET_UDP_SOCKET:    break;
S  #endif
S  #if (DBG_TCP_SOCKET > 1)
S    case NET_TCP_SOCKET:    break;
S  #endif
S  #if (DBG_BSD_SOCKET > 1)
S    case NET_BSD_SOCKET:    break;
S  #endif
S#endif
S
S#if (DBG_SERVICE_EN)
S  #if (DBG_HTTP_SERVER > 1)
S    case NET_HTTP_SERVER:   break;
S  #endif
S  #if (DBG_FTP_SERVER > 1)
S    case NET_FTP_SERVER:    break;
S  #endif
S  #if (DBG_FTP_CLIENT > 1)
S    case NET_FTP_CLIENT:    break;
S  #endif
S  #if (DBG_TELNET_SERVER > 1)
S    case NET_TELNET_SERVER: break;
S  #endif
S  #if (DBG_TFTP_SERVER > 1)
S    case NET_TFTP_SERVER:   break;
S  #endif
S  #if (DBG_TFTP_CLIENT > 1)
S    case NET_TFTP_CLIENT:   break;
S  #endif
S  #if (DBG_SMTP_CLIENT > 1)
S    case NET_SMTP_CLIENT:   break;
S  #endif
S  #if (DBG_DNS_CLIENT > 1)
S    case NET_DNS_CLIENT:    break;
S  #endif
S  #if (DBG_SNMP_AGENT > 1)
S    case NET_SNMP_AGENT:    break;
S  #endif
S  #if (DBG_SNTP_CLIENT > 1)
S    case NET_SNTP_CLIENT:   break;
S  #endif
S#endif
S
S    default: return;
S  }
S  printf ("%s%s:",__DBG_TIME,net_dbg_proc(proc));
S
S  va_start (args,fmt);
S  vprintf (fmt,args);
S  va_end (args);
S}
S
S/* Pring debug error message */
Svoid net_dbg_error (int32_t proc, const char *fmt, ...) {
S  __va_list args;
S
S  switch (proc) {
S
S#if (DBG_SYSTEM_EN)
S    case NET_SYSTEM_CORE:   break;
S  #if (DBG_MEM > 0)
S    case NET_DYNAMIC_MEMORY:break;
S  #endif
S  #if (DBG_ETH > 0)
S    case NET_ETH_INTERFACE: break;
S  #endif
S  #if (DBG_WIFI > 0)
S    case NET_WIFI_INTERFACE:break;
S  #endif
S  #if (DBG_PPP > 0)
S    case NET_PPP_INTERFACE: break;
S  #endif
S  #if (DBG_SLIP > 0)
S    case NET_SLIP_INTERFACE:break;
S  #endif
S  #if (DBG_LOOP > 0)
S    case NET_LOCAL_LOOPBACK:break;
S  #endif
S#endif
S
S#if (DBG_CORE4_EN)
S  #if (DBG_IP4 > 0)
S    case NET_IP4_CORE:      break;
S  #endif
S  #if (DBG_ICMP > 0)
S    case NET_ICMP_CONTROL:  break;
S  #endif
S  #if (DBG_IGMP > 0)
S    case NET_IGMP_HOST:     break;
S  #endif
S  #if (DBG_NBNS > 0)
S    case NET_NBNS_CLIENT:   break;
S  #endif
S  #if (DBG_DHCP > 0)
S    case NET_DHCP_CLIENT:   break;
S  #endif
S  #if (DBG_ARP > 0)
S    case NET_ARP_CACHE:     break;
S  #endif
S#endif
S
S#if (DBG_CORE6_EN)
S  #if (DBG_IP6 > 0)
S    case NET_IP6_CORE:      break;
S  #endif
S  #if (DBG_ICMP6 > 0)
S    case NET_ICMP6_CONTROL: break;
S  #endif
S  #if (DBG_DHCP6 > 0)
S    case NET_DHCP6_CLIENT:  break;
S  #endif
S  #if (DBG_NDP6 > 0)
S    case NET_NDP_CACHE:     break;
S  #endif
S#endif
S
S#if (DBG_SOCKET_EN)
S  #if (DBG_UDP_SOCKET > 0)
S    case NET_UDP_SOCKET:    break;
S  #endif
S  #if (DBG_TCP_SOCKET > 0)
S    case NET_TCP_SOCKET:    break;
S  #endif
S  #if (DBG_BSD_SOCKET > 0)
S    case NET_BSD_SOCKET:    break;
S  #endif
S#endif
S
S#if (DBG_SERVICE_EN)
S  #if (DBG_HTTP_SERVER > 0)
S    case NET_HTTP_SERVER:   break;
S  #endif
S  #if (DBG_FTP_SERVER > 0)
S    case NET_FTP_SERVER:    break;
S  #endif
S  #if (DBG_FTP_CLIENT > 0)
S    case NET_FTP_CLIENT:    break;
S  #endif
S  #if (DBG_TELNET_SERVER > 0)
S    case NET_TELNET_SERVER: break;
S  #endif
S  #if (DBG_TFTP_SERVER > 0)
S    case NET_TFTP_SERVER:   break;
S  #endif
S  #if (DBG_TFTP_CLIENT > 0)
S    case NET_TFTP_CLIENT:   break;
S  #endif
S  #if (DBG_SMTP_CLIENT > 0)
S    case NET_SMTP_CLIENT:   break;
S  #endif
S  #if (DBG_DNS_CLIENT > 0)
S    case NET_DNS_CLIENT:    break;
S  #endif
S  #if (DBG_SNMP_AGENT > 0)
S    case NET_SNMP_AGENT:    break;
S  #endif
S  #if (DBG_SNTP_CLIENT > 0)
S    case NET_SNTP_CLIENT:   break;
S  #endif
S#endif
S
S    default: return;
S  }
S  printf ("%s%s-ERR:",__DBG_TIME,net_dbg_proc(proc));
S
S  va_start (args,fmt);
S  vprintf (fmt,args);
S  va_end (args);
S}
N#endif /* RTE_Network_Debug_STDIO */
N
N#ifdef RTE_Network_Debug
N/* Event Recorder debug */
N#define DEBUG_EVR
N#include "net_evr.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_evr.h" 1
N/*------------------------------------------------------------------------------
N * MDK Middleware - Component ::Network
N * Copyright (c) 2004-2020 Arm Limited (or its affiliates). All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    net_evr.h
N * Purpose: Network definitions for Event Recorder
N * Rev.:    V7.13.3
N *----------------------------------------------------------------------------*/
N
N#ifdef DEBUG_EVR
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_evr.h" 2
N#include "EventRecorder.h"
L 1 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\ARM_Compiler\1.6.3\Include\EventRecorder.h" 1
N/*------------------------------------------------------------------------------
N * MDK - Component ::Event Recorder
N * Copyright (c) 2016-2018 ARM Germany GmbH. All rights reserved.
N *------------------------------------------------------------------------------
N * Name:    EventRecorder.h
N * Purpose: Event Recorder Header File
N * Rev.:    V1.4.0
N *----------------------------------------------------------------------------*/
N
N#ifndef __EVENT_RECORDER_H
N#define __EVENT_RECORDER_H
N
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N// Defines for parameter level for macro EventID
N#define EventLevelError         0x00000U    ///< Run-time error in the component
N#define EventLevelAPI           0x10000U    ///< API function call 
N#define EventLevelOp            0x20000U    ///< Internal operation 
N#define EventLevelDetail        0x30000U    ///< Additional detailed information of operations
N
N// Defines for parameter comp_no for macro EventID
N#define EvtStatistics_No        0xEFU       ///< Component number for \ref Event_Execution_Statistic in \ref EventID
N#define EvtPrintf_No            0xFEU       ///< Component number for \ref printf_redirect in \ref EventID
N
N/// Composed event \em id from level, component number and message number
N#define EventID(level, comp_no, msg_no) ((level & 0x30000U) | ((comp_no & 0xFFU) << 8) | (msg_no & 0xFFU))
N
N// Defines for parameter recording for Event Recorder Setup Functions
N#define EventRecordNone         0x00U       ///< Record events is disabled
N#define EventRecordError        0x01U       ///< Record events with level \ref EventLevelError
N#define EventRecordAPI          0x02U       ///< Record events with level \ref EventLevelAPI
N#define EventRecordOp           0x04U       ///< Record events with level \ref EventLevelOp
N#define EventRecordDetail       0x08U       ///< Record events with level \ref EventLevelDetail
N#define EventRecordAll          0x0FU       ///< Record events with any level
N
N
N// Callback function for user provided timer -----------------------------------
N
N/// Setup timer hardware.
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderTimerSetup (void);
N
N/// Get timer frequency.
N/// \return       timer frequency in Hz
Nextern uint32_t EventRecorderTimerGetFreq (void);
N
N/// Get timer count.
N/// \return       timer count (32-bit)
Nextern uint32_t EventRecorderTimerGetCount (void);
N
N
N// Event Recorder Setup Functions ----------------------------------------------
N
N/// Initialize Event Recorder
N/// \param[in]    recording   initial level mask for event record filter
N/// \param[in]    start       initial recording setup (1=start, 0=stop)
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderInitialize (uint32_t recording, uint32_t start);
N
N/// Enable recording of events with specified level and component range
N/// \param[in]    recording   level mask for event record filter
N/// \param[in]    comp_start  first component number of range
N/// \param[in]    comp_end    last Component number of range
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderEnable (uint32_t recording, uint32_t comp_start, uint32_t comp_end);
N
N/// Disable recording of events with specified level and component range
N/// \param[in]    recording   level mask for event record filter
N/// \param[in]    comp_start  first component number of range
N/// \param[in]    comp_end    last Component number of range
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderDisable (uint32_t recording, uint32_t comp_start, uint32_t comp_end);
N
N/// Start event recording
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderStart (void);
N
N/// Stop event recording
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderStop (void);
N
N/// Update Event Recorder timestamp clock
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecorderClockUpdate (void);
N
N
N// Event Data Recording Functions ----------------------------------------------
N
N/// Record an event with variable data size
N/// \param[in]    id     event identifier (level, component number, message number)
N/// \param[in]    data   event data buffer
N/// \param[in]    len    event data length
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecordData (uint32_t id, const void *data, uint32_t len);
N
N/// Record an event with two 32-bit data values
N/// \param[in]    id     event identifier (level, component number, message number)
N/// \param[in]    val1   first data value
N/// \param[in]    val2   second data value
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecord2 (uint32_t id, uint32_t val1, uint32_t val2);
N
N/// Record an event with four 32-bit data values
N/// \param[in]    id     event identifier (level, component number, message number)
N/// \param[in]    val1   first data value
N/// \param[in]    val2   second data value
N/// \param[in]    val3   third data value
N/// \param[in]    val4   fourth data value
N/// \return       status (1=Success, 0=Failure)
Nextern uint32_t EventRecord4 (uint32_t id, uint32_t val1, uint32_t val2, uint32_t val3, uint32_t val4);
N
N
N// Event Start/Stop macros for execution statistics ----------------------------
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStartA(slot)          EventRecord2 (0xEF00U+EventLevelError+(slot), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStartAv(slot, v1, v2) EventRecord2 (0xEF10U+EventLevelError+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStopA(slot)           EventRecord2 (0xEF20U+EventLevelError+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStopAv(slot, v1, v2)  EventRecord2 (0xEF30U+EventLevelError+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStartB(slot)          EventRecord2 (0xEF40U+EventLevelAPI+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStartBv(slot, v1, v2) EventRecord2 (0xEF50U+EventLevelAPI+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStopB(slot)           EventRecord2 (0xEF60U+EventLevelAPI+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStopBv(slot, v1, v2)  EventRecord2 (0xEF70U+EventLevelAPI+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStartC(slot)          EventRecord2 (0xEF80U+EventLevelOp+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStartCv(slot, v1, v2) EventRecord2 (0xEF90U+EventLevelOp+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStopC(slot)           EventRecord2 (0xEFA0U+EventLevelOp+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStopCv(slot, v1, v2)  EventRecord2 (0xEFB0U+EventLevelOp+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStartD(slot)          EventRecord2 (0xEFC0U+EventLevelDetail+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15)
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStartDv(slot, v1, v2) EventRecord2 (0xEFD0U+EventLevelDetail+((slot) & 0xFU), (v1), (v2))
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N#define EventStopD(slot)           EventRecord2 (0xEFE0U+EventLevelDetail+((slot) & 0xFU), ((uint32_t) __FILE__), __LINE__)
N
N/// \param[in]    slot   slot number (up to 16 slots, 0..15) 
N/// \param[in]    v1     first data value
N/// \param[in]    v2     second data value
N#define EventStopDv(slot, v1, v2)  EventRecord2 (0xEFF0U+EventLevelDetail+((slot) & 0xFU), (v1), (v2))
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __EVENT_RECORDER_H */
L 13 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_evr.h" 2
N
N#ifndef __STATIC_INLINE
N  #define __STATIC_INLINE   static __inline __attribute__((always_inline))
N#endif
N
Nextern uint32_t net_dbg_buf[9];         ///< Buffer for complex debug structures 
N
N/// Union for accessing the debug parameters. 
Nunion evr_access {
N  uint32_t u32[9];                      ///< 4-byte access
N  uint16_t u16[18];                     ///< 2-byte access
N  uint8_t  u8 [36];                     ///< 1-byte access
N};
N#define evr_buf             (*(union evr_access *)&net_dbg_buf)
N
N// Local definition of NET_ADDR structure.
Ntypedef struct evr_addr {
N  int16_t  type;
N  uint16_t port;
N  uint8_t  addr[16];
N} EVR_ADDR;
N
N// Network components ----------------------------------------------------------
N#define EvtNetSYS           0xC0        ///< System Core
N#define EvtNetMEM           0xC1        ///< Memory Management
N#define EvtNetETH           0xC2        ///< ETH Interface
N#define EvtNetWiFi          0xDD        ///< WiFi Interface
N#define EvtNetPPP           0xC3        ///< PPP Interface
N#define EvtNetSLIP          0xC4        ///< SLIP Interface
N#define EvtNetLOOP          0xC5        ///< Loopback Interface
N
N#define EvtNetIP4           0xC6        ///< IPv4 Core
N#define EvtNetICMP          0xC7        ///< ICMP Control
N#define EvtNetIGMP          0xC8        ///< IGMP Group Management
N#define EvtNetNBNS          0xC9        ///< NetBIOS Name Service Client
N#define EvtNetDHCP          0xCA        ///< Dynamic Host Configuration Client
N#define EvtNetARP           0xCB        ///< Ethernet Address Resolution
N
N#define EvtNetIP6           0xCC        ///< IPv6 Core
N#define EvtNetICMP6         0xCD        ///< ICMPv6 Control
N#define EvtNetDHCP6         0xCE        ///< Dynamic Host Configuration Client for IPv6
N#define EvtNetNDP           0xCF        ///< Neighbor Discovery for IPv6
N
N#define EvtNetUDP           0xD0        ///< Socket UDP
N#define EvtNetTCP           0xD1        ///< Socket TCP
N#define EvtNetBSD           0xD2        ///< Socket BSD
N
N#define EvtNetHTTPs         0xD3        ///< Web Server
N#define EvtNetFTPs          0xD4        ///< File Transfer Server
N#define EvtNetFTPc          0xD5        ///< File Transfer Client
N#define EvtNetTeln          0xD6        ///< Telnet Server
N#define EvtNetTFTPs         0xD7        ///< Trivial File Transfer Server
N#define EvtNetTFTPc         0xD8        ///< Trivial File Transfer Client
N#define EvtNetSMTP          0xD9        ///< Simple Mail Transfer Client
N#define EvtNetDNS           0xDA        ///< Domain Name Service Client
N#define EvtNetSNMP          0xDB        ///< Simple Network Management Agent
N#define EvtNetSNTP          0xDC        ///< Simple Network Time Client
N#endif
N
N
N// NetSYS event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetSYS_InitSystem            EventID (EventLevelOp,    EvtNetSYS, 0)
N#define EvtNetSYS_ThreadCreateFailed    EventID (EventLevelError, EvtNetSYS, 1)
N#define EvtNetSYS_TimerCreateFailed     EventID (EventLevelError, EvtNetSYS, 2)
N#define EvtNetSYS_InitComplete          EventID (EventLevelOp,    EvtNetSYS, 3)
N#define EvtNetSYS_GetOption             EventID (EventLevelAPI,   EvtNetSYS, 4)
N#define EvtNetSYS_SetOption             EventID (EventLevelAPI,   EvtNetSYS, 5)
N#define EvtNetSYS_SetDefault            EventID (EventLevelAPI,   EvtNetSYS, 6)
N#define EvtNetSYS_SetHostName           EventID (EventLevelAPI,   EvtNetSYS, 7)
N#define EvtNetSYS_UninitSystem          EventID (EventLevelOp,    EvtNetSYS, 8)
N#define EvtNetSYS_UninitComplete        EventID (EventLevelOp,    EvtNetSYS, 9)
N#endif
N
N/**
N  \brief  Event on network initialize start (Op)
N  \param  lib_version   encoded library version BCD (MMmmbbbb)
N                         - MM:   Major
N                         - mm:   minor
N                         - bbbb: build
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_InitSystem(uint32_t lib_version) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_InitSystem(uint32_t lib_version) {
N    uint16_t version = (uint16_t)(lib_version >> 16);
N    uint16_t build   = (uint16_t)(lib_version);
N    EventRecord2 (EvtNetSYS_InitSystem, version, build);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (0 & 0xFFU)), version, build);
N  }
N#else
S  #define EvrNetSYS_InitSystem(lib_version)
N#endif
N
N/**
N  \brief  Event on failure to create network core thread (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_ThreadCreateFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_ThreadCreateFailed(void) {
N    EventRecord2 (EvtNetSYS_ThreadCreateFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSYS_ThreadCreateFailed()
N#endif
N
N/**
N  \brief  Event on failure to create network interval timer (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_TimerCreateFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_TimerCreateFailed(void) {
N    EventRecord2 (EvtNetSYS_TimerCreateFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSYS_TimerCreateFailed()
N#endif
N
N/**
N  \brief  Event on network initialize complete (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_InitComplete(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_InitComplete(void) {
N    EventRecord2 (EvtNetSYS_InitComplete, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (3 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSYS_InitComplete()
N#endif
N
N/**
N  \brief  Event on set interface option (API)
N  \param  if_id         network interface identifier
N  \param  option        interface option to set
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_SetOption(uint16_t if_id, int32_t option) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_SetOption(uint16_t if_id, int32_t option) {
N    EventRecord2 (EvtNetSYS_SetOption, if_id, (uint32_t)option);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (5 & 0xFFU)), if_id, (uint32_t)option);
N  }
N#else
S  #define EvrNetSYS_SetOption(if_id, option)
N#endif
N
N/**
N  \brief  Event on get interface option (API)
N  \param  if_id         network interface identifier
N  \param  option        interface option to get
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_GetOption(uint16_t if_id, int32_t option) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_GetOption(uint16_t if_id, int32_t option) {
N    EventRecord2 (EvtNetSYS_GetOption, if_id, (uint32_t)option);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (4 & 0xFFU)), if_id, (uint32_t)option);
N  }
N#else
S  #define EvrNetSYS_GetOption(if_id, option)
N#endif
N
N/**
N  \brief  Event on set default interface (API)
N  \param  if_id         network interface identifier
N  \param  ip_version    internet protocol version to use
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_SetDefault(uint16_t if_id, int32_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_SetDefault(uint16_t if_id, int32_t ip_version) {
N    EventRecord2 (EvtNetSYS_SetDefault, if_id, (uint32_t)ip_version);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (6 & 0xFFU)), if_id, (uint32_t)ip_version);
N  }
N#else
S  #define EvrNetSYS_SetDefault(if_id, ip_version)
N#endif
N
N/**
N  \brief  Event on set local host name (API)
N  \param  name          pointer to host name string
N  \param  length        length of host name string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_SetHostName(const char *name, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_SetHostName(const char *name, uint32_t length) {
N    EventRecordData (EvtNetSYS_SetHostName, name, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (7 & 0xFFU)), name, length);
N  }
N#else
S  #define EvrNetSYS_SetHostName(name, length)
N#endif
N
N/**
N  \brief  Event on network uninitialize start (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_UninitSystem(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_UninitSystem(void) {
N    EventRecord2 (EvtNetSYS_UninitSystem, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSYS_UninitSystem()
N#endif
N
N/**
N  \brief  Event on network uninitialize complete (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSYS_UninitComplete(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSYS_UninitComplete(void) {
N    EventRecord2 (EvtNetSYS_UninitComplete, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC0 & 0xFFU) << 8) | (9 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSYS_UninitComplete()
N#endif
N
N
N// NetMEM event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetMEM_InitMemory                EventID (EventLevelOp,    EvtNetMEM,  0)
N#define EvtNetMEM_AllocMemory               EventID (EventLevelOp,    EvtNetMEM,  1)
N#define EvtNetMEM_AllocLimitExceeded        EventID (EventLevelOp,    EvtNetMEM,  2)
N#define EvtNetMEM_AllocOutOfMemory          EventID (EventLevelError, EvtNetMEM,  3)
N#define EvtNetMEM_ShrinkMemory              EventID (EventLevelOp,    EvtNetMEM,  4)
N#define EvtNetMEM_FreeMemory                EventID (EventLevelOp,    EvtNetMEM,  5)
N#define EvtNetMEM_FreeInvalidBlock          EventID (EventLevelError, EvtNetMEM,  6)
N#define EvtNetMEM_FreeLinkCorrupted         EventID (EventLevelError, EvtNetMEM,  7)
N#define EvtNetMEM_UninitMemory              EventID (EventLevelOp,    EvtNetMEM,  8)
N#endif
N
N/**
N  \brief  Event on initialize memory management (Op)
N  \param  pool_size     size of the memory pool
N  \param  limit0        usage limit 0 (limit for ethernet and BSD receive buffering)
N  \param  limit1        usage limit 1 (limit for TCP send buffering)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_InitMemory(uint32_t pool_size, uint32_t limit0, uint32_t limit1) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_InitMemory(uint32_t pool_size, uint32_t limit0, uint32_t limit1) {
N    EventRecord4 (EvtNetMEM_InitMemory, pool_size, limit0, limit1, 0);
X    EventRecord4 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (0 & 0xFFU)), pool_size, limit0, limit1, 0);
N  }
N#else
S  #define EvrNetMEM_InitMemory(pool_size, limit0, limit1)
N#endif
N
N/**
N  \brief  Event on request to allocate memory (Op)
N  \param  size          requested memory size in bytes
N  \param  used          used memory status in bytes
N  \param  blocks        number of used blocks status
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_AllocMemory(uint32_t size, uint32_t used, uint32_t blocks) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_AllocMemory(uint32_t size, uint32_t used, uint32_t blocks) {
N    EventRecord4 (EvtNetMEM_AllocMemory, size, used, blocks, 0);
X    EventRecord4 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (1 & 0xFFU)), size, used, blocks, 0);
N  }
N#else
S  #define EvrNetMEM_AllocMemory(size, used, blocks)
N#endif
N
N/**
N  \brief  Event on memory allocation limit exceeded (Op)
N  \param  size          requested memory size in bytes
N  \param  used          used memory status in bytes
N  \param  blocks        number of used blocks status
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_AllocLimitExceeded(uint32_t size, uint32_t used, uint32_t blocks) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_AllocLimitExceeded(uint32_t size, uint32_t used, uint32_t blocks) {
N    EventRecord4 (EvtNetMEM_AllocLimitExceeded, size, used, blocks, 0);
X    EventRecord4 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (2 & 0xFFU)), size, used, blocks, 0);
N  }
N#else
S  #define EvrNetMEM_AllocLimitExceeded(size, used, blocks)
N#endif
N
N/**
N  \brief  Event on out of memory error (Error)
N  \param  size          requested memory size in bytes
N  \param  used          used memory status in bytes
N  \param  blocks        number of used blocks status
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_AllocOutOfMemory(uint32_t size, uint32_t used, uint32_t blocks) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_AllocOutOfMemory(uint32_t size, uint32_t used, uint32_t blocks) {
N    EventRecord4 (EvtNetMEM_AllocOutOfMemory, size, used, blocks, 0);
X    EventRecord4 (((0x00000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (3 & 0xFFU)), size, used, blocks, 0);
N  }
N#else
S  #define EvrNetMEM_AllocOutOfMemory(size, used, blocks)
N#endif
N
N/**
N  \brief  Event on shrink memory block request (Op)
N  \param  new_size      new block size
N  \param  old_size      current block size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_ShrinkMemory(uint32_t new_size, uint32_t old_size) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_ShrinkMemory(uint32_t new_size, uint32_t old_size) {
N    EventRecord2 (EvtNetMEM_ShrinkMemory, new_size, old_size);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (4 & 0xFFU)), new_size, old_size);
N  }
N#else
S  #define EvrNetMEM_ShrinkMemory(new_size, old_size)
N#endif
N
N/**
N  \brief  Event on request to free memory (Op)
N  \param  size          size of the memory block to free
N  \param  used          used memory status in bytes
N  \param  blocks        number of used blocks status
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_FreeMemory(uint32_t size, uint32_t used, uint32_t blocks) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_FreeMemory(uint32_t size, uint32_t used, uint32_t blocks) {
N    EventRecord4 (EvtNetMEM_FreeMemory, size, used, blocks, 0);
X    EventRecord4 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (5 & 0xFFU)), size, used, blocks, 0);
N  }
N#else
S  #define EvrNetMEM_FreeMemory(size, used, blocks)
N#endif
N
N/**
N  \brief  Event on attempt to free an invalid memory (Error)
N  \param  size          size of the memory block to free
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_FreeInvalidBlock(uint32_t size) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_FreeInvalidBlock(uint32_t size) {
N    EventRecord2 (EvtNetMEM_FreeInvalidBlock, size, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (6 & 0xFFU)), size, 0);
N  }
N#else
S  #define EvrNetMEM_FreeInvalidBlock(size)
N#endif
N
N/**
N  \brief  Event on corrupted internal memory link (Error)
N  \param  size          size of the memory block to free
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_FreeLinkCorrupted(uint32_t size) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_FreeLinkCorrupted(uint32_t size) {
N    EventRecord2 (EvtNetMEM_FreeLinkCorrupted, size, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (7 & 0xFFU)), size, 0);
N  }
N#else
S  #define EvrNetMEM_FreeLinkCorrupted(size)
N#endif
N
N/**
N  \brief  Event on de-initialize memory management (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetMEM_UninitMemory(void) {
X  static __inline __attribute__((always_inline)) void EvrNetMEM_UninitMemory(void) {
N    EventRecord2 (EvtNetMEM_UninitMemory, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC1 & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetMEM_UninitMemory()
N#endif
N
N
N// NetETH event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetETH_InitInterface             EventID (EventLevelOp,    EvtNetETH,  0)
N#define EvtNetETH_MacAddressConfigError     EventID (EventLevelError, EvtNetETH,  1)
N#define EvtNetETH_VlanConfigError           EventID (EventLevelError, EvtNetETH, 43)
N#define EvtNetETH_VlanInitError             EventID (EventLevelError, EvtNetETH, 44)
N#define EvtNetETH_PhyDriverConfigError      EventID (EventLevelError, EvtNetETH,  2)
N#define EvtNetETH_PhyDriverInitError        EventID (EventLevelError, EvtNetETH,  3)
N#define EvtNetETH_Ip4ConfigError            EventID (EventLevelError, EvtNetETH,  4)
N#define EvtNetETH_Ip6ConfigError            EventID (EventLevelError, EvtNetETH,  5)
N#define EvtNetETH_ThreadCreateFailed        EventID (EventLevelError, EvtNetETH,  6)
N#define EvtNetETH_GetOptionInvalidParameter EventID (EventLevelError, EvtNetETH,  7)
N#define EvtNetETH_SetOptionInvalidParameter EventID (EventLevelError, EvtNetETH,  8)
N#define EvtNetETH_SetMacAddress             EventID (EventLevelOp,    EvtNetETH,  9)
N#define EvtNetETH_SetVlanIdentifier         EventID (EventLevelOp,    EvtNetETH, 10)
N#define EvtNetETH_SetIp4Address             EventID (EventLevelOp,    EvtNetETH, 11)
N#define EvtNetETH_SetIp4SubnetMask          EventID (EventLevelOp,    EvtNetETH, 12)
N#define EvtNetETH_SetIp4DefaultGateway      EventID (EventLevelOp,    EvtNetETH, 13)
N#define EvtNetETH_SetIp4PrimaryDNS          EventID (EventLevelOp,    EvtNetETH, 14)
N#define EvtNetETH_SetIp4SecondaryDNS        EventID (EventLevelOp,    EvtNetETH, 15)
N#define EvtNetETH_SetIp4Mtu                 EventID (EventLevelOp,    EvtNetETH, 16)
N#define EvtNetETH_SetIp6Address             EventID (EventLevelOp,    EvtNetETH, 17)
N#define EvtNetETH_SetIp6DefaultGateway      EventID (EventLevelOp,    EvtNetETH, 18)
N#define EvtNetETH_SetIp6PrimaryDNS          EventID (EventLevelOp,    EvtNetETH, 19)
N#define EvtNetETH_SetIp6SecondaryDNS        EventID (EventLevelOp,    EvtNetETH, 20)
N#define EvtNetETH_SetIp6PrefixLength        EventID (EventLevelOp,    EvtNetETH, 21)
N#define EvtNetETH_SendFrame                 EventID (EventLevelOp,    EvtNetETH, 22)
N#define EvtNetETH_LinkDownError             EventID (EventLevelError, EvtNetETH, 23)
N#define EvtNetETH_SendDataTooLarge          EventID (EventLevelError, EvtNetETH, 24)
N#define EvtNetETH_SendIp4Disabled           EventID (EventLevelError, EvtNetETH, 45)
N#define EvtNetETH_Ip4LocalAddressUndefined  EventID (EventLevelError, EvtNetETH, 25)
N#define EvtNetETH_Ip4MacAddressUnresolved   EventID (EventLevelError, EvtNetETH, 26)
N#define EvtNetETH_EnqueueFrame              EventID (EventLevelOp,    EvtNetETH, 27)
N#define EvtNetETH_SendIp6Disabled           EventID (EventLevelError, EvtNetETH, 45) // End
N#define EvtNetETH_Ip6LocalAddressUndefined  EventID (EventLevelError, EvtNetETH, 28)
N#define EvtNetETH_Ip6MacAddressUnresolved   EventID (EventLevelError, EvtNetETH, 29)
N#define EvtNetETH_InvalidIpVersion          EventID (EventLevelError, EvtNetETH, 30)
N#define EvtNetETH_ShowFrameHeader           EventID (EventLevelDetail,EvtNetETH, 31)
N#define EvtNetETH_LinkDownStatus            EventID (EventLevelOp,    EvtNetETH, 32)
N#define EvtNetETH_LinkUpStatus              EventID (EventLevelOp,    EvtNetETH, 33)
N#define EvtNetETH_ReceiveFrame              EventID (EventLevelOp,    EvtNetETH, 34)
N#define EvtNetETH_VlanInvalid               EventID (EventLevelOp,    EvtNetETH, 35)
N#define EvtNetETH_Ip4Disabled               EventID (EventLevelOp,    EvtNetETH, 36)
N#define EvtNetETH_Ip6Disabled               EventID (EventLevelOp,    EvtNetETH, 37)
N#define EvtNetETH_ProtocolUnknown           EventID (EventLevelOp,    EvtNetETH, 38)
N#define EvtNetETH_SendRawFrame              EventID (EventLevelAPI,   EvtNetETH, 39)
N#define EvtNetETH_SendRawInvalidParameter   EventID (EventLevelError, EvtNetETH, 40)
N#define EvtNetETH_OutputLowLevel            EventID (EventLevelOp,    EvtNetETH, 41)
N#define EvtNetETH_UninitInterface           EventID (EventLevelOp,    EvtNetETH, 42)
N#endif
N
N/**
N  \brief  Event on Ethernet interface initialize (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_InitInterface(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_InitInterface(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_InitInterface, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (0 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_InitInterface(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet MAC address configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_MacAddressConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_MacAddressConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_MacAddressConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (1 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_MacAddressConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet VLAN configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_VlanConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_VlanConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_VlanConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (43 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_VlanConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet VLAN initialization error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_VlanInitError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_VlanInitError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_VlanInitError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (44 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_VlanInitError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet PHY configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_PhyDriverConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_PhyDriverConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_PhyDriverConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (2 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_PhyDriverConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet PHY initialization error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_PhyDriverInitError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_PhyDriverInitError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_PhyDriverInitError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (3 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_PhyDriverInitError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet IPv4 configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip4ConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip4ConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip4ConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (4 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip4ConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet IPv6 configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip6ConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip6ConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip6ConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (5 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip6ConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet thread create failed (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_ThreadCreateFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_ThreadCreateFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_ThreadCreateFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (6 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_ThreadCreateFailed(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet get_option invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_GetOptionInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_GetOptionInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_GetOptionInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (7 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_GetOptionInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet set_option invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetOptionInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetOptionInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_SetOptionInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (8 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_SetOptionInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface MAC address (Op)
N  \param  if_num        interface number
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_num;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetETH_SetMacAddress, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (9 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetETH_SetMacAddress(if_num, mac_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set VLAN identifier (Op)
N  \param  if_num        interface number
N  \param  vlan_id       VLAN identifier
N                         - 0: VLAN tagging disabled
N  \remark VLAN identifier is limited in the range from 1 to 4093.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetVlanIdentifier(uint8_t if_num, uint16_t vlan_id) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetVlanIdentifier(uint8_t if_num, uint16_t vlan_id) {
N    EventRecord2 (EvtNetETH_SetVlanIdentifier, if_num, vlan_id);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (10 & 0xFFU)), if_num, vlan_id);
N  }
N#else
S  #define EvrNetETH_SetVlanIdentifier(if_num, vlan_id)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv4 address (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4Address(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4Address(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetETH_SetIp4Address, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (11 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_SetIp4Address(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv4 subnet mask (Op)
N  \param  if_num        interface number
N  \param  net_mask      pointer to IPv4 subnet mask
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4SubnetMask(uint8_t if_num, const uint8_t *net_mask) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4SubnetMask(uint8_t if_num, const uint8_t *net_mask) {
N    memcpy (&evr_buf.u32[0], net_mask, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], net_mask, 4);
N    EventRecord2 (EvtNetETH_SetIp4SubnetMask, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (12 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_SetIp4SubnetMask(if_num, net_mask)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv4 default gateway (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4DefaultGateway(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4DefaultGateway(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetETH_SetIp4DefaultGateway, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (13 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_SetIp4DefaultGateway(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface primary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4PrimaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4PrimaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetETH_SetIp4PrimaryDNS, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (14 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_SetIp4PrimaryDNS(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface secondary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4SecondaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4SecondaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetETH_SetIp4SecondaryDNS, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (15 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_SetIp4SecondaryDNS(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface MTU (Op)
N  \param  if_num        interface number
N  \param  mtu           maximum transmission unit
N                         - 0: fragmentation disabled
N  \remark MTU is limited in the range from 576 to 1500 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp4Mtu(uint8_t if_num, uint16_t mtu) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp4Mtu(uint8_t if_num, uint16_t mtu) {
N    EventRecord2 (EvtNetETH_SetIp4Mtu, if_num, mtu);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (16 & 0xFFU)), if_num, mtu);
N  }
N#else
S  #define EvrNetETH_SetIp4Mtu(if_num, mtu)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv6 static address (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp6Address(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp6Address(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetETH_SetIp6Address, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (17 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetETH_SetIp6Address(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv6 default gateway (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp6DefaultGateway(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp6DefaultGateway(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetETH_SetIp6DefaultGateway, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (18 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetETH_SetIp6DefaultGateway(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface primary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp6PrimaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp6PrimaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetETH_SetIp6PrimaryDNS, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (19 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetETH_SetIp6PrimaryDNS(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface secondary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp6SecondaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp6SecondaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetETH_SetIp6SecondaryDNS, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (20 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetETH_SetIp6SecondaryDNS(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet set interface IPv6 subnet prefix length (Op)
N  \param  if_num        interface number
N  \param  pref_len      subnet prefix length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SetIp6PrefixLength(uint8_t if_num, uint8_t pref_len) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SetIp6PrefixLength(uint8_t if_num, uint8_t pref_len) {
N    EventRecord2 (EvtNetETH_SetIp6PrefixLength, if_num, pref_len);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (21 & 0xFFU)), if_num, pref_len);
N  }
N#else
S  #define EvrNetETH_SetIp6PrefixLength(if_num, pref_len)
N#endif
N
N/**
N  \brief  Event on Ethernet send frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendFrame(uint8_t if_num, uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendFrame(uint8_t if_num, uint32_t length, uint8_t ip_version) {
N    uint32_t val2 = ((uint32_t)ip_version << 16) | length;
N    EventRecord2 (EvtNetETH_SendFrame, if_num, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (22 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetETH_SendFrame(if_num, length, ip_version)
N#endif
N
N/**
N  \brief  Event on Ethernet link down error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_LinkDownError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_LinkDownError(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_LinkDownError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (23 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_LinkDownError(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet send payload too large error (Error)
N  \param  if_num        interface number
N  \param  length        data length in bytes
N  \param  max_length    maximum length of data in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendDataTooLarge(uint8_t if_num, uint32_t length, uint32_t max_length) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendDataTooLarge(uint8_t if_num, uint32_t length, uint32_t max_length) {
N    uint32_t val2 = (max_length << 16) | length;
N    EventRecord2 (EvtNetETH_SendDataTooLarge, if_num, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (24 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetETH_SendDataTooLarge(if_num, length, max_length)
N#endif
N
N/**
N  \brief  Event on Ethernet send IPv4 disabled error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendIp4Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendIp4Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_SendIp4Disabled, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (45 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_SendIp4Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet local IPv4 address undefined (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip4LocalAddressUndefined(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip4LocalAddressUndefined(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip4LocalAddressUndefined, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (25 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip4LocalAddressUndefined(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet MAC address unresolved (Error)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip4MacAddressUnresolved(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip4MacAddressUnresolved(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetETH_Ip4MacAddressUnresolved, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (26 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetETH_Ip4MacAddressUnresolved(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on enqueued Ethernet frame for unresolved MAC address (Op)
N  \param  if_num        interface number
N  \param  ca_entry      cache entry identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_EnqueueFrame(uint8_t if_num, uint8_t ca_entry, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_EnqueueFrame(uint8_t if_num, uint8_t ca_entry, uint32_t length) {
N    uint32_t val2 = ((uint32_t)ca_entry << 16) | length;
N    EventRecord2 (EvtNetETH_EnqueueFrame, if_num, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (27 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetETH_EnqueueFrame(if_num, ca_entry, length)
N#endif
N
N/**
N  \brief  Event on Ethernet send IPv6 disabled error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendIp6Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendIp6Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_SendIp6Disabled, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (45 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_SendIp6Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet local IPv6 address undefined (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip6LocalAddressUndefined(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip6LocalAddressUndefined(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip6LocalAddressUndefined, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (28 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip6LocalAddressUndefined(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet MAC address unresolved (Error)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip6MacAddressUnresolved(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip6MacAddressUnresolved(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetETH_Ip6MacAddressUnresolved, &evr_buf, 20);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (29 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetETH_Ip6MacAddressUnresolved(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on Ethernet invalid IP version (Error)
N  \param  if_num        interface number
N  \param  ip_version    invalid IP protocol version value
N                        - 0: IPv4
N                        - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_InvalidIpVersion(uint8_t if_num, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_InvalidIpVersion(uint8_t if_num, uint8_t ip_version) {
N    EventRecord2 (EvtNetETH_InvalidIpVersion, if_num, ip_version);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (30 & 0xFFU)), if_num, ip_version);
N  }
N#else
S  #define EvrNetETH_InvalidIpVersion(if_num, ip_version)
N#endif
N
N/**
N  \brief  Event on Ethernet display send/receive frame header (Detail)
N  \param  eth_header    pointer to ethernet frame header of 14 bytes
N                         - DstAddr  (6 bytes)
N                         - SrcAddr  (6 bytes)
N                         - Protocol (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_ShowFrameHeader(const void *eth_header) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_ShowFrameHeader(const void *eth_header) {
N    EventRecordData (EvtNetETH_ShowFrameHeader, eth_header, 14);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (31 & 0xFFU)), eth_header, 14);
N  }
N#else
S  #define EvrNetETH_ShowFrameHeader(eth_header)
N#endif
N
N/**
N  \brief  Event on Ethernet link down status (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_LinkDownStatus(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_LinkDownStatus(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_LinkDownStatus, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (32 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_LinkDownStatus(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet link up status (Op)
N  \param  if_num        interface number
N  \param  link_info     link information:
N                        - duplex (bit 2)
N                        - speed  (bit 1,0)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_LinkUpStatus(uint8_t if_num, uint8_t link_info) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_LinkUpStatus(uint8_t if_num, uint8_t link_info) {
N    EventRecord2 (EvtNetETH_LinkUpStatus, if_num, link_info);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (33 & 0xFFU)), if_num, link_info);
N  }
N#else
S  #define EvrNetETH_LinkUpStatus(if_num, link_info)
N#endif
N
N/**
N  \brief  Event on Ethernet receive frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_ReceiveFrame(uint8_t if_num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_ReceiveFrame(uint8_t if_num, uint32_t length) {
N    EventRecord2 (EvtNetETH_ReceiveFrame, if_num, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (34 & 0xFFU)), if_num, length);
N  }
N#else
S  #define EvrNetETH_ReceiveFrame(if_num, length)
N#endif
N
N/**
N  \brief  Event on Ethernet receive VLAN invalid (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_VlanInvalid(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_VlanInvalid(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_VlanInvalid, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (35 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_VlanInvalid(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet receive IPv4 disabled (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip4Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip4Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip4Disabled, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (36 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip4Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet receive IPv6 disabled (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_Ip6Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_Ip6Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_Ip6Disabled, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (37 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_Ip6Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on Ethernet receive protocol unknown (Op)
N  \param  if_num        interface number
N  \param  protocol      unknown ethernet protocol type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_ProtocolUnknown(uint8_t if_num, uint16_t protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_ProtocolUnknown(uint8_t if_num, uint16_t protocol) {
N    EventRecord2 (EvtNetETH_ProtocolUnknown, if_num, protocol);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (38 & 0xFFU)), if_num, protocol);
N  }
N#else
S  #define EvrNetETH_ProtocolUnknown(if_num, protocol)
N#endif
N
N/**
N  \brief  Event on Ethernet send raw frame (API)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendRawFrame(uint8_t if_num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendRawFrame(uint8_t if_num, uint32_t length) {
N    EventRecord2 (EvtNetETH_SendRawFrame, if_num, length);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (39 & 0xFFU)), if_num, length);
N  }
N#else
S  #define EvrNetETH_SendRawFrame(if_num, length)
N#endif
N
N/**
N  \brief  Event on Ethernet send raw frame invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_SendRawInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_SendRawInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_SendRawInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (40 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_SendRawInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on output Ethernet frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_OutputLowLevel(uint8_t if_num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_OutputLowLevel(uint8_t if_num, uint32_t length) {
N    EventRecord2 (EvtNetETH_OutputLowLevel, if_num, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (41 & 0xFFU)), if_num, length);
N  }
N#else
S  #define EvrNetETH_OutputLowLevel(if_num, length)
N#endif
N
N/**
N  \brief  Event on Ethernet interface de-initialize (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetETH_UninitInterface(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetETH_UninitInterface(uint8_t if_num) {
N    EventRecord2 (EvtNetETH_UninitInterface, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC2 & 0xFFU) << 8) | (42 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetETH_UninitInterface(if_num)
N#endif
N
N
N// NetWiFi event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetWiFi_InitInterface             EventID (EventLevelOp,    EvtNetWiFi,  0)
N#define EvtNetWiFi_DriverInitFailed          EventID (EventLevelError, EvtNetWiFi,  1)
N#define EvtNetWiFi_SetBypassModeFailed       EventID (EventLevelError, EvtNetWiFi,  2)
N#define EvtNetWiFi_GetMacAddressFailed       EventID (EventLevelError, EvtNetWiFi,  3)
N#define EvtNetWiFi_DriverMacAddress          EventID (EventLevelOp,    EvtNetWiFi,  4)
N#define EvtNetWiFi_MacAddressConfigError     EventID (EventLevelError, EvtNetWiFi,  5)
N#define EvtNetWiFi_SetMacAddressFailed       EventID (EventLevelError, EvtNetWiFi,  6)
N#define EvtNetWiFi_Ip4ConfigError            EventID (EventLevelError, EvtNetWiFi,  7)
N#define EvtNetWiFi_Ip6ConfigError            EventID (EventLevelError, EvtNetWiFi,  8)
N#define EvtNetWiFi_ThreadCreateFailed        EventID (EventLevelError, EvtNetWiFi,  9)
N#define EvtNetWiFi_GetOptionInvalidParameter EventID (EventLevelError, EvtNetWiFi, 10)
N#define EvtNetWiFi_SetOptionInvalidParameter EventID (EventLevelError, EvtNetWiFi, 11)
N#define EvtNetWiFi_SetMacAddress             EventID (EventLevelOp,    EvtNetWiFi, 12)
N#define EvtNetWiFi_SetIp4Address             EventID (EventLevelOp,    EvtNetWiFi, 13)
N#define EvtNetWiFi_SetIp4SubnetMask          EventID (EventLevelOp,    EvtNetWiFi, 14)
N#define EvtNetWiFi_SetIp4DefaultGateway      EventID (EventLevelOp,    EvtNetWiFi, 15)
N#define EvtNetWiFi_SetIp4PrimaryDNS          EventID (EventLevelOp,    EvtNetWiFi, 16)
N#define EvtNetWiFi_SetIp4SecondaryDNS        EventID (EventLevelOp,    EvtNetWiFi, 17)
N#define EvtNetWiFi_SetIp4Mtu                 EventID (EventLevelOp,    EvtNetWiFi, 18)
N#define EvtNetWiFi_SetIp6Address             EventID (EventLevelOp,    EvtNetWiFi, 19)
N#define EvtNetWiFi_SetIp6DefaultGateway      EventID (EventLevelOp,    EvtNetWiFi, 20)
N#define EvtNetWiFi_SetIp6PrimaryDNS          EventID (EventLevelOp,    EvtNetWiFi, 21)
N#define EvtNetWiFi_SetIp6SecondaryDNS        EventID (EventLevelOp,    EvtNetWiFi, 22)
N#define EvtNetWiFi_SetIp6PrefixLength        EventID (EventLevelOp,    EvtNetWiFi, 23)
N#define EvtNetWiFi_Scan                      EventID (EventLevelAPI,   EvtNetWiFi, 24)
N#define EvtNetWiFi_ScanWrongMode             EventID (EventLevelError, EvtNetWiFi, 25)
N#define EvtNetWiFi_ScanInvalidParameter      EventID (EventLevelError, EvtNetWiFi, 26)
N#define EvtNetWiFi_ScanComplete              EventID (EventLevelOp,    EvtNetWiFi, 27)
N#define EvtNetWiFi_GetOption                 EventID (EventLevelAPI,   EvtNetWiFi, 28)
N#define EvtNetWiFi_SetOption                 EventID (EventLevelAPI,   EvtNetWiFi, 29)
N#define EvtNetWiFi_Activate                  EventID (EventLevelAPI,   EvtNetWiFi, 30)
N#define EvtNetWiFi_ActivateInvalidParameter  EventID (EventLevelError, EvtNetWiFi, 31)
N#define EvtNetWiFi_Deactivate                EventID (EventLevelAPI,   EvtNetWiFi, 32)
N#define EvtNetWiFi_DeactivateInvalidParam    EventID (EventLevelError, EvtNetWiFi, 33)
N#define EvtNetWiFi_GetNetInfo                EventID (EventLevelAPI,   EvtNetWiFi, 34)
N#define EvtNetWiFi_GetNetInfoWrongMode       EventID (EventLevelError, EvtNetWiFi, 35)
N#define EvtNetWiFi_GetNetInfoInvalidParam    EventID (EventLevelError, EvtNetWiFi, 36)
N#define EvtNetWiFi_SendFrame                 EventID (EventLevelOp,    EvtNetWiFi, 37)
N#define EvtNetWiFi_NotConnected              EventID (EventLevelError, EvtNetWiFi, 38)
N#define EvtNetWiFi_SendDataTooLarge          EventID (EventLevelError, EvtNetWiFi, 39)
N#define EvtNetWiFi_SendIp4Disabled           EventID (EventLevelError, EvtNetWiFi, 56)
N#define EvtNetWiFi_Ip4LocalAddressUndefined  EventID (EventLevelError, EvtNetWiFi, 40)
N#define EvtNetWiFi_Ip4MacAddressUnresolved   EventID (EventLevelError, EvtNetWiFi, 41)
N#define EvtNetWiFi_EnqueueFrame              EventID (EventLevelOp,    EvtNetWiFi, 42)
N#define EvtNetWiFi_SendIp6Disabled           EventID (EventLevelError, EvtNetWiFi, 57) // End
N#define EvtNetWiFi_Ip6LocalAddressUndefined  EventID (EventLevelError, EvtNetWiFi, 43)
N#define EvtNetWiFi_Ip6MacAddressUnresolved   EventID (EventLevelError, EvtNetWiFi, 44)
N#define EvtNetWiFi_InvalidIpVersion          EventID (EventLevelError, EvtNetWiFi, 45)
N#define EvtNetWiFi_ShowFrameHeader           EventID (EventLevelDetail,EvtNetWiFi, 46)
N#define EvtNetWiFi_LinkStateChange           EventID (EventLevelOp,    EvtNetWiFi, 47)
N#define EvtNetWiFi_ReceiveFrame              EventID (EventLevelOp,    EvtNetWiFi, 48)
N#define EvtNetWiFi_Ip4Disabled               EventID (EventLevelOp,    EvtNetWiFi, 49)
N#define EvtNetWiFi_Ip6Disabled               EventID (EventLevelOp,    EvtNetWiFi, 50)
N#define EvtNetWiFi_ProtocolUnknown           EventID (EventLevelOp,    EvtNetWiFi, 51)
N#define EvtNetWiFi_OutputLowLevel            EventID (EventLevelOp,    EvtNetWiFi, 52)
N#define EvtNetWiFi_TxQueueOverflow           EventID (EventLevelError, EvtNetWiFi, 53)
N#define EvtNetWiFi_OutputNoMemory            EventID (EventLevelError, EvtNetWiFi, 54)
N#define EvtNetWiFi_UninitInterface           EventID (EventLevelOp,    EvtNetWiFi, 55)
N#endif
N
N/**
N  \brief  Event on WiFi interface initialize (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_InitInterface(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_InitInterface(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_InitInterface, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (0 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_InitInterface(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi failed to initialize the driver (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_DriverInitFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_DriverInitFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_DriverInitFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (1 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_DriverInitFailed(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi failed to activate bypass mode (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetBypassModeFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetBypassModeFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_SetBypassModeFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (2 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_SetBypassModeFailed(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi driver get MAC address failed (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetMacAddressFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetMacAddressFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_GetMacAddressFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (3 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_GetMacAddressFailed(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi driver provided MAC address (Op)
N  \param  if_num        interface number
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_DriverMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_DriverMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_num;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetWiFi_DriverMacAddress, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (4 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetWiFi_DriverMacAddress(if_num, mac_addr)
N#endif
N
N/**
N  \brief  Event on WiFi MAC address configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_MacAddressConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_MacAddressConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_MacAddressConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (5 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_MacAddressConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi driver failed to set MAC address (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetMacAddressFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetMacAddressFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_SetMacAddressFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (6 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_SetMacAddressFailed(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi IPv4 configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip4ConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip4ConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip4ConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (7 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip4ConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi IPv6 configuration error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip6ConfigError(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip6ConfigError(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip6ConfigError, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (8 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip6ConfigError(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi thread create failed (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ThreadCreateFailed(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ThreadCreateFailed(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_ThreadCreateFailed, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (9 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_ThreadCreateFailed(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi get_option invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetOptionInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetOptionInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_GetOptionInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (10 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_GetOptionInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi set_option invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetOptionInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetOptionInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_SetOptionInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (11 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_SetOptionInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi set interface MAC address (Op)
N  \param  if_num        interface number
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetMacAddress(uint8_t if_num, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_num;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetWiFi_SetMacAddress, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (12 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetWiFi_SetMacAddress(if_num, mac_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv4 address (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4Address(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4Address(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetWiFi_SetIp4Address, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (13 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_SetIp4Address(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv4 subnet mask (Op)
N  \param  if_num        interface number
N  \param  net_mask      pointer to IPv4 subnet mask
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4SubnetMask(uint8_t if_num, const uint8_t *net_mask) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4SubnetMask(uint8_t if_num, const uint8_t *net_mask) {
N    memcpy (&evr_buf.u32[0], net_mask, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], net_mask, 4);
N    EventRecord2 (EvtNetWiFi_SetIp4SubnetMask, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (14 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_SetIp4SubnetMask(if_num, net_mask)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv4 default gateway (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4DefaultGateway(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4DefaultGateway(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetWiFi_SetIp4DefaultGateway, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (15 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_SetIp4DefaultGateway(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface primary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4PrimaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4PrimaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetWiFi_SetIp4PrimaryDNS, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (16 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_SetIp4PrimaryDNS(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface secondary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4SecondaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4SecondaryDNS(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetWiFi_SetIp4SecondaryDNS, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (17 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_SetIp4SecondaryDNS(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface MTU (Op)
N  \param  if_num        interface number
N  \param  mtu           maximum transmission unit
N                         - 0: fragmentation disabled
N  \remark MTU is limited in the range from 576 to 1500 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp4Mtu(uint8_t if_num, uint16_t mtu) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp4Mtu(uint8_t if_num, uint16_t mtu) {
N    EventRecord2 (EvtNetWiFi_SetIp4Mtu, if_num, mtu);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (18 & 0xFFU)), if_num, mtu);
N  }
N#else
S  #define EvrNetWiFi_SetIp4Mtu(if_num, mtu)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv6 static address (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp6Address(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp6Address(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetWiFi_SetIp6Address, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (19 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetWiFi_SetIp6Address(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv6 default gateway (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp6DefaultGateway(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp6DefaultGateway(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetWiFi_SetIp6DefaultGateway, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (20 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetWiFi_SetIp6DefaultGateway(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface primary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp6PrimaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp6PrimaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetWiFi_SetIp6PrimaryDNS, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (21 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetWiFi_SetIp6PrimaryDNS(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface secondary DNS server (Op)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp6SecondaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp6SecondaryDNS(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetWiFi_SetIp6SecondaryDNS, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (22 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetWiFi_SetIp6SecondaryDNS(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on WiFi set interface IPv6 subnet prefix length (Op)
N  \param  if_num        interface number
N  \param  pref_len      subnet prefix length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetIp6PrefixLength(uint8_t if_num, uint8_t pref_len) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetIp6PrefixLength(uint8_t if_num, uint8_t pref_len) {
N    EventRecord2 (EvtNetWiFi_SetIp6PrefixLength, if_num, pref_len);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (23 & 0xFFU)), if_num, pref_len);
N  }
N#else
S  #define EvrNetWiFi_SetIp6PrefixLength(if_num, pref_len)
N#endif
N
N/**
N  \brief  Event on WiFi scan wireless networks (API)
N  \param  if_num        interface number
N  \param  max_num       maximum number of networks to scan
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Scan(uint8_t if_num, uint32_t max_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Scan(uint8_t if_num, uint32_t max_num) {
N    EventRecord2 (EvtNetWiFi_Scan, if_num, max_num);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (24 & 0xFFU)), if_num, max_num);
N  }
N#else
S  #define EvrNetWiFi_Scan(if_num, max_num)
N#endif
N
N/**
N  \brief  Event on WiFi scan in wrong mode (Error)
N  \param  if_num        interface number
N  \param  mode          WiFi interface mode
N                         - 0: Station
N                         - 1: Access Point
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ScanWrongMode(uint8_t if_num, uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ScanWrongMode(uint8_t if_num, uint32_t mode) {
N    EventRecord2 (EvtNetWiFi_ScanWrongMode, if_num, mode);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (25 & 0xFFU)), if_num, mode);
N  }
N#else
S  #define EvrNetWiFi_ScanWrongMode(if_num, mode)
N#endif
N
N/**
N  \brief  Event on WiFi scan invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ScanInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ScanInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_ScanInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (26 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_ScanInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi scan wireless networks complete (Op)
N  \param  if_num        interface number
N  \param  num           number of wireless networks found
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ScanComplete(uint8_t if_num, uint32_t num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ScanComplete(uint8_t if_num, uint32_t num) {
N    EventRecord2 (EvtNetWiFi_ScanComplete, if_num, num);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (27 & 0xFFU)), if_num, num);
N  }
N#else
S  #define EvrNetWiFi_ScanComplete(if_num, num)
N#endif
N
N/**
N  \brief  Event on WiFi get driver option (API)
N  \param  if_num        interface number
N  \param  opt           WiFi driver option to get
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetOption(uint8_t if_num, uint32_t opt) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetOption(uint8_t if_num, uint32_t opt) {
N    EventRecord2 (EvtNetWiFi_GetOption, if_num, opt);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (28 & 0xFFU)), if_num, opt);
N  }
N#else
S  #define EvrNetWiFi_GetOption(if_num, opt)
N#endif
N
N/**
N  \brief  Event on WiFi set driver option (API)
N  \param  if_num        interface number
N  \param  opt           WiFi driver option to set
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SetOption(uint8_t if_num, uint32_t opt) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SetOption(uint8_t if_num, uint32_t opt) {
N    EventRecord2 (EvtNetWiFi_SetOption, if_num, opt);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (29 & 0xFFU)), if_num, opt);
N  }
N#else
S  #define EvrNetWiFi_SetOption(if_num, opt)
N#endif
N
N/**
N  \brief  Event on WiFi interface activate (API)
N  \param  if_num        interface number
N  \param  mode          WiFi interface mode
N                         - 0: Station
N                         - 1: Access Point
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Activate(uint8_t if_num, uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Activate(uint8_t if_num, uint32_t mode) {
N    EventRecord2 (EvtNetWiFi_Activate, if_num, mode);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (30 & 0xFFU)), if_num, mode);
N  }
N#else
S  #define EvrNetWiFi_Activate(if_num, mode)
N#endif
N
N/**
N  \brief  Event on WiFi activate invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ActivateInvalidParameter(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ActivateInvalidParameter(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_ActivateInvalidParameter, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (31 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_ActivateInvalidParameter(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi interface deactivate (API)
N  \param  if_num        interface number
N  \param  mode          WiFi interface mode
N                         - 0: Station
N                         - 1: Access Point
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Deactivate(uint8_t if_num, uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Deactivate(uint8_t if_num, uint32_t mode) {
N    EventRecord2 (EvtNetWiFi_Deactivate, if_num, mode);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (32 & 0xFFU)), if_num, mode);
N  }
N#else
S  #define EvrNetWiFi_Deactivate(if_num, mode)
N#endif
N
N/**
N  \brief  Event on WiFi deactivate invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_DeactivateInvalidParam(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_DeactivateInvalidParam(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_DeactivateInvalidParam, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (33 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_DeactivateInvalidParam(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi get network information (API)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetNetInfo(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetNetInfo(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_GetNetInfo, if_num, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (34 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_GetNetInfo(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi get network information in wrong mode (Error)
N  \param  if_num        interface number
N  \param  mode          WiFi interface mode
N                         - 0: Station
N                         - 1: Access Point
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetNetInfoWrongMode(uint8_t if_num, uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetNetInfoWrongMode(uint8_t if_num, uint32_t mode) {
N    EventRecord2 (EvtNetWiFi_GetNetInfoWrongMode, if_num, mode);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (35 & 0xFFU)), if_num, mode);
N  }
N#else
S  #define EvrNetWiFi_GetNetInfoWrongMode(if_num, mode)
N#endif
N
N/**
N  \brief  Event on WiFi get network information invalid parameter (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_GetNetInfoInvalidParam(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_GetNetInfoInvalidParam(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_GetNetInfoInvalidParam, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (36 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_GetNetInfoInvalidParam(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi send frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SendFrame(uint8_t if_num, uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SendFrame(uint8_t if_num, uint32_t length, uint8_t ip_version) {
N    uint32_t val2 = ((uint32_t)ip_version << 16) | length;
N    EventRecord2 (EvtNetWiFi_SendFrame, if_num, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (37 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetWiFi_SendFrame(if_num, length, ip_version)
N#endif
N
N/**
N  \brief  Event on WiFi station not connected (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_NotConnected(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_NotConnected(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_NotConnected, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (38 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_NotConnected(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi send payload too large error (Error)
N  \param  if_num        interface number
N  \param  length        data length in bytes
N  \param  max_length    maximum length of data in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SendDataTooLarge(uint8_t if_num, uint32_t length, uint32_t max_length) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SendDataTooLarge(uint8_t if_num, uint32_t length, uint32_t max_length) {
N    uint32_t val2 = (max_length << 16) | length;
N    EventRecord2 (EvtNetWiFi_SendDataTooLarge, if_num, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (39 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetWiFi_SendDataTooLarge(if_num, length, max_length)
N#endif
N
N/**
N  \brief  Event on WiFi send IPv4 disabled error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SendIp4Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SendIp4Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_SendIp4Disabled, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (56 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_SendIp4Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi local IPv4 address undefined (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip4LocalAddressUndefined(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip4LocalAddressUndefined(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip4LocalAddressUndefined, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (40 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip4LocalAddressUndefined(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi MAC address unresolved (Error)
N  \param  if_num        interface number
N  \param  ip4_addr      pointer to IPv4 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip4MacAddressUnresolved(uint8_t if_num, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip4MacAddressUnresolved(uint8_t if_num, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetWiFi_Ip4MacAddressUnresolved, if_num, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (41 & 0xFFU)), if_num, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetWiFi_Ip4MacAddressUnresolved(if_num, ip4_addr)
N#endif
N
N/**
N  \brief  Event on enqueued WiFi frame for unresolved MAC address (Op)
N  \param  if_num        interface number
N  \param  ca_entry      cache entry identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_EnqueueFrame(uint8_t if_num, uint32_t ca_entry, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_EnqueueFrame(uint8_t if_num, uint32_t ca_entry, uint32_t length) {
N    uint32_t val2 = ((uint32_t)ca_entry << 16) | length;
N    EventRecord2 (EvtNetWiFi_EnqueueFrame, if_num, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (42 & 0xFFU)), if_num, val2);
N  }
N#else
S  #define EvrNetWiFi_EnqueueFrame(if_num, ca_entry, length)
N#endif
N
N/**
N  \brief  Event on WiFi send IPv6 disabled error (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_SendIp6Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_SendIp6Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_SendIp6Disabled, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (57 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_SendIp6Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi local IPv6 address undefined (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip6LocalAddressUndefined(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip6LocalAddressUndefined(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip6LocalAddressUndefined, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (43 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip6LocalAddressUndefined(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi MAC address unresolved (Error)
N  \param  if_num        interface number
N  \param  ip6_addr      pointer to IPv6 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip6MacAddressUnresolved(uint8_t if_num, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip6MacAddressUnresolved(uint8_t if_num, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_num;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_num;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetWiFi_Ip6MacAddressUnresolved, &evr_buf, 20);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (44 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetWiFi_Ip6MacAddressUnresolved(if_num, ip6_addr)
N#endif
N
N/**
N  \brief  Event on WiFi invalid IP version (Error)
N  \param  if_num        interface number
N  \param  ip_version    invalid IP protocol version value
N                        - 0: IPv4
N                        - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_InvalidIpVersion(uint8_t if_num, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_InvalidIpVersion(uint8_t if_num, uint8_t ip_version) {
N    EventRecord2 (EvtNetWiFi_InvalidIpVersion, if_num, ip_version);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (45 & 0xFFU)), if_num, ip_version);
N  }
N#else
S  #define EvrNetWiFi_InvalidIpVersion(if_num, ip_version)
N#endif
N
N/**
N  \brief  Event on WiFi display send/receive frame header (Detail)
N  \param  eth_header    pointer to ethernet frame header of 14 bytes
N                         - DstAddr  (6 bytes)
N                         - SrcAddr  (6 bytes)
N                         - Protocol (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ShowFrameHeader(const void *eth_header) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ShowFrameHeader(const void *eth_header) {
N    EventRecordData (EvtNetWiFi_ShowFrameHeader, eth_header, 14);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (46 & 0xFFU)), eth_header, 14);
N  }
N#else
S  #define EvrNetWiFi_ShowFrameHeader(eth_header)
N#endif
N
N/**
N  \brief  Event on WiFi connection state change (Op)
N  \param  if_num        interface number
N  \param  state         wireless station connection state
N                         - 0: disconnected
N                         - 1: connected to Access Point
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_LinkStateChange(uint8_t if_num, uint32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_LinkStateChange(uint8_t if_num, uint32_t state) {
N    EventRecord2 (EvtNetWiFi_LinkStateChange, if_num, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (47 & 0xFFU)), if_num, state);
N  }
N#else
S  #define EvrNetWiFi_LinkStateChange(if_num, state)
N#endif
N
N/**
N  \brief  Event on WiFi receive frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ReceiveFrame(uint8_t if_num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ReceiveFrame(uint8_t if_num, uint32_t length) {
N    EventRecord2 (EvtNetWiFi_ReceiveFrame, if_num, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (48 & 0xFFU)), if_num, length);
N  }
N#else
S  #define EvrNetWiFi_ReceiveFrame(if_num, length)
N#endif
N
N/**
N  \brief  Event on WiFi receive IPv4 disabled (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip4Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip4Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip4Disabled, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (49 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip4Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi receive IPv6 disabled (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_Ip6Disabled(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_Ip6Disabled(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_Ip6Disabled, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (50 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_Ip6Disabled(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi receive protocol unknown (Op)
N  \param  if_num        interface number
N  \param  protocol      unknown ethernet protocol type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_ProtocolUnknown(uint8_t if_num, uint16_t protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_ProtocolUnknown(uint8_t if_num, uint16_t protocol) {
N    EventRecord2 (EvtNetWiFi_ProtocolUnknown, if_num, protocol);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (51 & 0xFFU)), if_num, protocol);
N  }
N#else
S  #define EvrNetWiFi_ProtocolUnknown(if_num, protocol)
N#endif
N
N/**
N  \brief  Event on WiFi output frame (Op)
N  \param  if_num        interface number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_OutputLowLevel(uint8_t if_num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_OutputLowLevel(uint8_t if_num, uint32_t length) {
N    EventRecord2 (EvtNetWiFi_OutputLowLevel, if_num, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (52 & 0xFFU)), if_num, length);
N  }
N#else
S  #define EvrNetWiFi_OutputLowLevel(if_num, length)
N#endif
N
N/**
N  \brief  Event on WiFi output queue overflow (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_TxQueueOverflow(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_TxQueueOverflow(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_TxQueueOverflow, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (53 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_TxQueueOverflow(if_num)
N#endif
N
N/**
N  \brief  Event on WIFI output out of memory (Error)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_OutputNoMemory(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_OutputNoMemory(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_OutputNoMemory, if_num, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (54 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_OutputNoMemory(if_num)
N#endif
N
N/**
N  \brief  Event on WiFi interface de-initialize (Op)
N  \param  if_num        interface number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetWiFi_UninitInterface(uint8_t if_num) {
X  static __inline __attribute__((always_inline)) void EvrNetWiFi_UninitInterface(uint8_t if_num) {
N    EventRecord2 (EvtNetWiFi_UninitInterface, if_num, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDD & 0xFFU) << 8) | (55 & 0xFFU)), if_num, 0);
N  }
N#else
S  #define EvrNetWiFi_UninitInterface(if_num)
N#endif
N
N
N// NetPPP event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N/* PPP-Core events */
N#define EvtNetPPP_InitInterface             EventID (EventLevelOp,    EvtNetPPP,  0)
N#define EvtNetPPP_ThreadCreateFailed        EventID (EventLevelError, EvtNetPPP,  1)
N#define EvtNetPPP_GetOptionInvalidParameter EventID (EventLevelError, EvtNetPPP,  2)
N#define EvtNetPPP_SetOptionInvalidParameter EventID (EventLevelError, EvtNetPPP,  3)
N#define EvtNetPPP_SetIp4Address             EventID (EventLevelOp,    EvtNetPPP,  4)
N#define EvtNetPPP_SetIp4PrimaryDNS          EventID (EventLevelOp,    EvtNetPPP,  5)
N#define EvtNetPPP_SetIp4SecondaryDNS        EventID (EventLevelOp,    EvtNetPPP,  6)
N#define EvtNetPPP_SetIp4Mtu                 EventID (EventLevelOp,    EvtNetPPP,  7)
N#define EvtNetPPP_ReceiveFrame              EventID (EventLevelOp,    EvtNetPPP,  8)
N#define EvtNetPPP_FrameTooShort             EventID (EventLevelOp,    EvtNetPPP,  9)
N#define EvtNetPPP_ChecksumFailed            EventID (EventLevelError, EvtNetPPP, 10)
N#define EvtNetPPP_CtrlByteInvalid           EventID (EventLevelError, EvtNetPPP, 11)
N#define EvtNetPPP_SendFrame                 EventID (EventLevelOp,    EvtNetPPP, 12)
N#define EvtNetPPP_InvalidIpVersion          EventID (EventLevelError, EvtNetPPP, 13)
N#define EvtNetPPP_NetworkLayerDown          EventID (EventLevelError, EvtNetPPP, 14)
N#define EvtNetPPP_SendDataTooLarge          EventID (EventLevelError, EvtNetPPP, 15)
N#define EvtNetPPP_NoMemoryError             EventID (EventLevelError, EvtNetPPP, 16)
N#define EvtNetPPP_QueueAddTransmit          EventID (EventLevelOp,    EvtNetPPP, 17)
N#define EvtNetPPP_RejectProtocol            EventID (EventLevelOp,    EvtNetPPP, 18)
N#define EvtNetPPP_RejectCode                EventID (EventLevelOp,    EvtNetPPP, 19)
N#define EvtNetPPP_Connect                   EventID (EventLevelAPI,   EvtNetPPP, 20)
N#define EvtNetPPP_ConnectInvalidParameter   EventID (EventLevelError, EvtNetPPP, 21)
N#define EvtNetPPP_ConnectWrongState         EventID (EventLevelError, EvtNetPPP, 22)
N#define EvtNetPPP_Listen                    EventID (EventLevelAPI,   EvtNetPPP, 23)
N#define EvtNetPPP_ListenInvalidParameter    EventID (EventLevelError, EvtNetPPP, 24)
N#define EvtNetPPP_ListenWrongState          EventID (EventLevelError, EvtNetPPP, 25)
N#define EvtNetPPP_Close                     EventID (EventLevelAPI,   EvtNetPPP, 26)
N#define EvtNetPPP_ShowUsername              EventID (EventLevelOp,    EvtNetPPP, 27)
N#define EvtNetPPP_ShowPassword              EventID (EventLevelOp,    EvtNetPPP, 28)
N#define EvtNetPPP_ModemOffline              EventID (EventLevelOp,    EvtNetPPP, 29)
N#define EvtNetPPP_DataLinkDown              EventID (EventLevelOp,    EvtNetPPP, 30)
N#define EvtNetPPP_UninitInterface           EventID (EventLevelOp,    EvtNetPPP, 31)
N/* PPP-LCP events */
N#define EvtNetPPP_LcpInit                   EventID (EventLevelOp,    EvtNetPPP, 32)
N#define EvtNetPPP_LcpSendConfigRequest      EventID (EventLevelOp,    EvtNetPPP, 33)
N#define EvtNetPPP_LcpNoRetriesLeft          EventID (EventLevelError, EvtNetPPP, 34)
N#define EvtNetPPP_LcpOptionCharMap          EventID (EventLevelDetail,EvtNetPPP, 35)
N#define EvtNetPPP_LcpOptionPfc              EventID (EventLevelDetail,EvtNetPPP, 36)
N#define EvtNetPPP_LcpOptionAcfc             EventID (EventLevelDetail,EvtNetPPP, 37)
N#define EvtNetPPP_LcpOptionMagicNumber      EventID (EventLevelDetail,EvtNetPPP, 38)
N#define EvtNetPPP_LcpOptionAuthPap          EventID (EventLevelDetail,EvtNetPPP, 39)
N#define EvtNetPPP_LcpOptionAuthChapMd5      EventID (EventLevelDetail,EvtNetPPP, 40)
N#define EvtNetPPP_LcpSendEchoRequest        EventID (EventLevelOp,    EvtNetPPP, 41)
N#define EvtNetPPP_LcpSendTerminateRequest   EventID (EventLevelOp,    EvtNetPPP, 42)
N#define EvtNetPPP_LcpSendFrame              EventID (EventLevelOp,    EvtNetPPP, 43)
N#define EvtNetPPP_LcpReceiveFrame           EventID (EventLevelOp,    EvtNetPPP, 44)
N#define EvtNetPPP_LcpDataLinkUp             EventID (EventLevelOp,    EvtNetPPP, 45)
N#define EvtNetPPP_LcpOptionMru              EventID (EventLevelOp,    EvtNetPPP, 46)
N#define EvtNetPPP_LcpOptionAuth             EventID (EventLevelOp,    EvtNetPPP, 47)
N#define EvtNetPPP_LcpOptionAuthChapNotMd5   EventID (EventLevelOp,    EvtNetPPP, 48)
N#define EvtNetPPP_LcpOptionUnknown          EventID (EventLevelOp,    EvtNetPPP, 49)
N#define EvtNetPPP_LcpSendReject             EventID (EventLevelOp,    EvtNetPPP, 50)
N#define EvtNetPPP_LcpSendNak                EventID (EventLevelOp,    EvtNetPPP, 51)
N#define EvtNetPPP_LcpSendAck                EventID (EventLevelOp,    EvtNetPPP, 52)
N#define EvtNetPPP_LcpWrongAckReceived       EventID (EventLevelOp,    EvtNetPPP, 53)
N#define EvtNetPPP_LcpWrongNakReceived       EventID (EventLevelOp,    EvtNetPPP, 54)
N#define EvtNetPPP_LcpConfigAuthFailed       EventID (EventLevelError, EvtNetPPP, 55)
N#define EvtNetPPP_LcpWrongRejectReceived    EventID (EventLevelOp,    EvtNetPPP, 56)
N#define EvtNetPPP_LcpEchoMagicNumber        EventID (EventLevelOp,    EvtNetPPP, 57)
N#define EvtNetPPP_LcpWrongPeerMagicNumber   EventID (EventLevelOp,    EvtNetPPP, 58)
N#define EvtNetPPP_LcpSendEchoReply          EventID (EventLevelOp,    EvtNetPPP, 59)
N#define EvtNetPPP_LcpWrongEchoReplyReceived EventID (EventLevelOp,    EvtNetPPP, 60)
N#define EvtNetPPP_LcpSendTerminateAck       EventID (EventLevelOp,    EvtNetPPP, 61)
N#define EvtNetPPP_LcpUninit                 EventID (EventLevelOp,    EvtNetPPP, 62)
N/* PPP-PAP events */
N#define EvtNetPPP_PapInit                   EventID (EventLevelOp,    EvtNetPPP, 63)
N#define EvtNetPPP_PapSendAuthRequest        EventID (EventLevelOp,    EvtNetPPP, 64)
N#define EvtNetPPP_PapShowPassword           EventID (EventLevelOp,    EvtNetPPP, 65)
N#define EvtNetPPP_PapSendFrame              EventID (EventLevelOp,    EvtNetPPP, 66)
N#define EvtNetPPP_PapReceiveFrame           EventID (EventLevelOp,    EvtNetPPP, 67)
N#define EvtNetPPP_PapLoginSuccess           EventID (EventLevelOp,    EvtNetPPP, 68)
N#define EvtNetPPP_PapLoginFailed            EventID (EventLevelError, EvtNetPPP, 69)
N#define EvtNetPPP_PapWrongAckReceived       EventID (EventLevelOp,    EvtNetPPP, 70)
N#define EvtNetPPP_PapWrongNakReceived       EventID (EventLevelOp,    EvtNetPPP, 71)
N#define EvtNetPPP_PapUninit                 EventID (EventLevelOp,    EvtNetPPP, 72)
N/* PPP-CHAP events */
N#define EvtNetPPP_ChapInit                  EventID (EventLevelOp,    EvtNetPPP, 73)
N#define EvtNetPPP_ChapSendChallenge         EventID (EventLevelOp,    EvtNetPPP, 74)
N#define EvtNetPPP_ChapSendFrame             EventID (EventLevelOp,    EvtNetPPP, 75)
N#define EvtNetPPP_ChapReceiveFrame          EventID (EventLevelOp,    EvtNetPPP, 76)
N#define EvtNetPPP_ChapWrongResponseReceived EventID (EventLevelOp,    EvtNetPPP, 77)
N#define EvtNetPPP_ChapWrongSuccessReceived  EventID (EventLevelOp,    EvtNetPPP, 78)
N#define EvtNetPPP_ChapWrongFailureReceived  EventID (EventLevelOp,    EvtNetPPP, 79)
N#define EvtNetPPP_ChapLoginSuccess          EventID (EventLevelOp,    EvtNetPPP, 80)
N#define EvtNetPPP_ChapLoginFailed           EventID (EventLevelError, EvtNetPPP, 81)
N#define EvtNetPPP_ChapUninit                EventID (EventLevelOp,    EvtNetPPP, 82)
N/* PPP-IPCP events */
N#define EvtNetPPP_IpcpInit                  EventID (EventLevelOp,    EvtNetPPP, 83)
N#define EvtNetPPP_IpcpIp4ConfigError        EventID (EventLevelError, EvtNetPPP, 84)
N#define EvtNetPPP_IpcpSendConfigRequest     EventID (EventLevelOp,    EvtNetPPP, 85)
N#define EvtNetPPP_IpcpOptionIpAddress       EventID (EventLevelDetail,EvtNetPPP, 86)
N#define EvtNetPPP_IpcpOptionPrimaryDns      EventID (EventLevelDetail,EvtNetPPP, 87)
N#define EvtNetPPP_IpcpOptionSecondaryDns    EventID (EventLevelDetail,EvtNetPPP, 88)
N#define EvtNetPPP_IpcpSendFrame             EventID (EventLevelOp,    EvtNetPPP, 89)
N#define EvtNetPPP_IpcpReceiveFrame          EventID (EventLevelOp,    EvtNetPPP, 90)
N#define EvtNetPPP_IpcpOptionUnknown         EventID (EventLevelOp,    EvtNetPPP, 91)
N#define EvtNetPPP_IpcpSendReject            EventID (EventLevelOp,    EvtNetPPP, 92)
N#define EvtNetPPP_IpcpSendNak               EventID (EventLevelOp,    EvtNetPPP, 93)
N#define EvtNetPPP_IpcpSendAck               EventID (EventLevelOp,    EvtNetPPP, 94)
N#define EvtNetPPP_IpcpWrongAckReceived      EventID (EventLevelOp,    EvtNetPPP, 95)
N#define EvtNetPPP_IpcpNetworkLayerUp        EventID (EventLevelOp,    EvtNetPPP, 96)
N#define EvtNetPPP_IpcpWrongNakReceived      EventID (EventLevelOp,    EvtNetPPP, 97)
N#define EvtNetPPP_IpcpWrongRejectReceived   EventID (EventLevelOp,    EvtNetPPP, 98)
N#define EvtNetPPP_IpcpWrongSubnet           EventID (EventLevelOp,    EvtNetPPP, 99)
N#define EvtNetPPP_IpcpPrimaryDnsRejected    EventID (EventLevelOp,    EvtNetPPP,100)
N#define EvtNetPPP_IpcpSecondaryDnsRejected  EventID (EventLevelOp,    EvtNetPPP,101)
N#define EvtNetPPP_IpcpIpAddressRejected     EventID (EventLevelError, EvtNetPPP,102)
N#define EvtNetPPP_IpcpNotRequestedOption    EventID (EventLevelError, EvtNetPPP,103)
N#define EvtNetPPP_IpcpUninit                EventID (EventLevelOp,    EvtNetPPP,104)
N#endif
N
N// PPP core event recorder functions -------------------------------------------
N
N/**
N  \brief  Event on PPP interface initialize (Op)
N  \remark Point-to-Point Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_InitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_InitInterface(void) {
N    EventRecord2 (EvtNetPPP_InitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_InitInterface()
N#endif
N
N/**
N  \brief  Event on PPP thread create failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ThreadCreateFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ThreadCreateFailed(void) {
N    EventRecord2 (EvtNetPPP_ThreadCreateFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ThreadCreateFailed()
N#endif
N
N/**
N  \brief  Event on PPP get_option invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_GetOptionInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_GetOptionInvalidParameter(void) {
N    EventRecord2 (EvtNetPPP_GetOptionInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_GetOptionInvalidParameter()
N#endif
N
N/**
N  \brief  Event on PPP set_option invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SetOptionInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SetOptionInvalidParameter(void) {
N    EventRecord2 (EvtNetPPP_SetOptionInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (3 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_SetOptionInvalidParameter()
N#endif
N
N/**
N  \brief  Event on PPP set interface IPv4 address (Op)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SetIp4Address(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SetIp4Address(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_SetIp4Address, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (4 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_SetIp4Address(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP set interface primary DNS server (Op)
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SetIp4PrimaryDNS(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SetIp4PrimaryDNS(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_SetIp4PrimaryDNS, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (5 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_SetIp4PrimaryDNS(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP set interface secondary DNS server (Op)
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SetIp4SecondaryDNS(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SetIp4SecondaryDNS(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_SetIp4SecondaryDNS, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (6 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_SetIp4SecondaryDNS(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP set interface MTU (Op)
N  \param  mtu           maximum transmission unit
N                         - 0: fragmentation disabled
N  \remark MTU is limited in the range from 576 to 1500 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SetIp4Mtu(uint16_t mtu) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SetIp4Mtu(uint16_t mtu) {
N    EventRecord2 (EvtNetPPP_SetIp4Mtu, mtu, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (7 & 0xFFU)), mtu, 0);
N  }
N#else
S  #define EvrNetPPP_SetIp4Mtu(mtu)
N#endif
N
N/**
N  \brief  Event on PPP receive frame (Op)
N  \param  protocol      PPP protocol type
N                         - 0xC021: LCP
N                         - 0xC023: PAP
N                         - 0xC223: CHAP
N                         - 0x8021: IPCP
N                         - 0x0021: IP
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ReceiveFrame(uint16_t protocol, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ReceiveFrame(uint16_t protocol, uint32_t length) {
N    EventRecord2 (EvtNetPPP_ReceiveFrame, protocol, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (8 & 0xFFU)), protocol, length);
N  }
N#else
S  #define EvrNetPPP_ReceiveFrame(protocol, length)
N#endif
N
N/**
N  \brief  Event on PPP receive frame too short (Op)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    if (length > 1536) length = 0;
N    EventRecord2 (EvtNetPPP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (9 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetPPP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on PPP frame checksum check failed (Error)
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChecksumFailed(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChecksumFailed(uint32_t length) {
N    EventRecord2 (EvtNetPPP_ChecksumFailed, length, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (10 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetPPP_ChecksumFailed(length)
N#endif
N
N/**
N  \brief  Event on PPP frame control byte invalid (Error)
N  \param  ctrl          received control byte
N  \param  ctrl_valid    valid control byte
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_CtrlByteInvalid(uint8_t ctrl, uint8_t ctrl_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_CtrlByteInvalid(uint8_t ctrl, uint8_t ctrl_valid) {
N    EventRecord2 (EvtNetPPP_CtrlByteInvalid, ctrl, ctrl_valid);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (11 & 0xFFU)), ctrl, ctrl_valid);
N  }
N#else
S  #define EvrNetPPP_CtrlByteInvalid(ctrl, ctrl_valid)
N#endif
N
N/**
N  \brief  Event on PPP send frame (Op)
N  \param  protocol      PPP protocol type
N                         - 0xC021: LCP
N                         - 0xC023: PAP
N                         - 0xC223: CHAP
N                         - 0x8021: IPCP
N                         - 0x0021: IP
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SendFrame(uint16_t protocol, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SendFrame(uint16_t protocol, uint32_t length) {
N    EventRecord2 (EvtNetPPP_SendFrame, protocol, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (12 & 0xFFU)), protocol, length);
N  }
N#else
S  #define EvrNetPPP_SendFrame(protocol, length)
N#endif
N
N/**
N  \brief  Event on PPP invalid IP version (Error)
N  \param  ip_version    invalid IP protocol version value
N                        - 0: IPv4
N                        - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_InvalidIpVersion(uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_InvalidIpVersion(uint8_t ip_version) {
N    EventRecord2 (EvtNetPPP_InvalidIpVersion, ip_version, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (13 & 0xFFU)), ip_version, 0);
N  }
N#else
S  #define EvrNetPPP_InvalidIpVersion(ip_version)
N#endif
N
N/**
N  \brief  Event on PPP network layer down (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_NetworkLayerDown(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_NetworkLayerDown(void) {
N    EventRecord2 (EvtNetPPP_NetworkLayerDown, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (14 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_NetworkLayerDown()
N#endif
N
N/**
N  \brief  Event on PPP send payload too large (Error)
N  \param  length        data length in bytes
N  \param  max_length    maximum length of data in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_SendDataTooLarge(uint32_t length, uint32_t max_length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_SendDataTooLarge(uint32_t length, uint32_t max_length) {
N    EventRecord2 (EvtNetPPP_SendDataTooLarge, length, max_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (15 & 0xFFU)), length, max_length);
N  }
N#else
S  #define EvrNetPPP_SendDataTooLarge(length, max_length)
N#endif
N
N/**
N  \brief  Event on PPP out of memory for send (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_NoMemoryError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_NoMemoryError(void) {
N    EventRecord2 (EvtNetPPP_NoMemoryError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_NoMemoryError()
N#endif
N
N/**
N  \brief  Event on PPP add frame to transmit queue (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_QueueAddTransmit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_QueueAddTransmit(void) {
N    EventRecord2 (EvtNetPPP_QueueAddTransmit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (17 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_QueueAddTransmit()
N#endif
N
N/**
N  \brief  Event on PPP reject unsupported protocol type (Op)
N  \param  protocol      unsupported protocol type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_RejectProtocol(uint16_t protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_RejectProtocol(uint16_t protocol) {
N    EventRecord2 (EvtNetPPP_RejectProtocol, protocol, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (18 & 0xFFU)), protocol, 0);
N  }
N#else
S  #define EvrNetPPP_RejectProtocol(protocol)
N#endif
N
N/**
N  \brief  Event on PPP reject unsupported cp code (Op)
N  \param  protocol      PPP protocol type
N                         - 0xC021: LCP
N                         - 0x8021: IPCP
N  \param  code          unsupported control code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_RejectCode(uint16_t protocol, uint8_t code) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_RejectCode(uint16_t protocol, uint8_t code) {
N    EventRecord2 (EvtNetPPP_RejectCode, protocol, code);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (19 & 0xFFU)), protocol, code);
N  }
N#else
S  #define EvrNetPPP_RejectCode(protocol, code)
N#endif
N
N/**
N  \brief  Event on PPP start connecting (API)
N  \param  dial_number   pointer to a dial number string
N  \param  length        length of the dial number string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_Connect(const char *dial_number, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_Connect(const char *dial_number, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetPPP_Connect, dial_number, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (20 & 0xFFU)), dial_number, length);
N  }
N#else
S  #define EvrNetPPP_Connect(dial_number, length)
N#endif
N
N/**
N  \brief  Event on PPP connect invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ConnectInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ConnectInvalidParameter(void) {
N    EventRecord2 (EvtNetPPP_ConnectInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (21 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ConnectInvalidParameter()
N#endif
N
N/**
N  \brief  Event on PPP connect in wrong state (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ConnectWrongState(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ConnectWrongState(void) {
N    EventRecord2 (EvtNetPPP_ConnectWrongState, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (22 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ConnectWrongState()
N#endif
N
N/**
N  \brief  Event on PPP start listening (API)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_Listen(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_Listen(void) {
N    EventRecord2 (EvtNetPPP_Listen, 0, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (23 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_Listen()
N#endif
N
N/**
N  \brief  Event on PPP listen invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ListenInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ListenInvalidParameter(void) {
N    EventRecord2 (EvtNetPPP_ListenInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (24 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ListenInvalidParameter()
N#endif
N
N/**
N  \brief  Event on PPP listen in wrong state (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ListenWrongState(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ListenWrongState(void) {
N    EventRecord2 (EvtNetPPP_ListenWrongState, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (25 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ListenWrongState()
N#endif
N
N/**
N  \brief  Event on PPP close connection (API)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_Close(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_Close(void) {
N    EventRecord2 (EvtNetPPP_Close, 0, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (26 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_Close()
N#endif
N
N/**
N  \brief  Event on PPP display username (Op)
N  \param  username      pointer to a username string
N  \param  length        length of the username string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ShowUsername(const char *username, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ShowUsername(const char *username, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetPPP_ShowUsername, username, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (27 & 0xFFU)), username, length);
N  }
N#else
S  #define EvrNetPPP_ShowUsername(username, length)
N#endif
N
N/**
N  \brief  Event on PPP display password (Op)
N  \param  password      pointer to a password string
N  \param  length        length of the password string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ShowPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ShowPassword(const char *password, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetPPP_ShowPassword, password, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (28 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetPPP_ShowPassword(password, length)
N#endif
N
N/**
N  \brief  Event on PPP link change to modem offline (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ModemOffline(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ModemOffline(void) {
N    EventRecord2 (EvtNetPPP_ModemOffline, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (29 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ModemOffline()
N#endif
N
N/**
N  \brief  Event on PPP data-link layer down (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_DataLinkDown(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_DataLinkDown(void) {
N    EventRecord2 (EvtNetPPP_DataLinkDown, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (30 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_DataLinkDown()
N#endif
N
N/**
N  \brief  Event on PPP interface de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_UninitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_UninitInterface(void) {
N    EventRecord2 (EvtNetPPP_UninitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (31 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_UninitInterface()
N#endif
N
N// PPP-LCP event recorder functions --------------------------------------------
N
N/**
N  \brief  Event on PPP-LCP initialize (Op)
N  \remark Point-to-Point Link Control Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpInit(void) {
N    EventRecord2 (EvtNetPPP_LcpInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (32 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpInit()
N#endif
N
N/**
N  \brief  Event on PPP-LCP send configuration request (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendConfigRequest(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendConfigRequest(void) {
N    EventRecord2 (EvtNetPPP_LcpSendConfigRequest, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (33 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendConfigRequest()
N#endif
N
N/**
N  \brief  Event on PPP-LCP no retries left for LCP negotiation (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpNoRetriesLeft(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpNoRetriesLeft(void) {
N    EventRecord2 (EvtNetPPP_LcpNoRetriesLeft, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (34 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpNoRetriesLeft()
N#endif
N
N/**
N  \brief  Event on PPP-LCP option character map (Detail)
N  \param  char_map      character bit-map for non printable characters
N                         - bit 0: ascii character 0
N                         - bit 1: ascii character 1
N                         - bit 2: ascii character 2
N                         -  ...
N                         - bit 31: ascii character 31
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionCharMap(uint32_t char_map) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionCharMap(uint32_t char_map) {
N    EventRecord2 (EvtNetPPP_LcpOptionCharMap, char_map, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (35 & 0xFFU)), char_map, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionCharMap(char_map)
N#endif
N
N/**
N  \brief  Event on PPP-LCP option PFC (Detail)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionPfc(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionPfc(void) {
N    EventRecord2 (EvtNetPPP_LcpOptionPfc, 0, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (36 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionPfc()
N#endif
N
N/**
N  \brief  Event on PPP-LCP option ACFC (Detail)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionAcfc(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionAcfc(void) {
N    EventRecord2 (EvtNetPPP_LcpOptionAcfc, 0, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (37 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionAcfc()
N#endif
N
N/**
N  \brief  Event on PPP-LCP option magic number (Detail)
N  \param  magic_number  magic random number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionMagicNumber(uint32_t magic_number) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionMagicNumber(uint32_t magic_number) {
N    EventRecord2 (EvtNetPPP_LcpOptionMagicNumber, magic_number, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (38 & 0xFFU)), magic_number, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionMagicNumber(magic_number)
N#endif
N
N/**
N  \brief  Event on PPP-LCP option Authentication PAP (Detail)
N  \remark Password Authentication Protocol - plain text
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionAuthPap(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionAuthPap(void) {
N    EventRecord2 (EvtNetPPP_LcpOptionAuthPap, 0, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (39 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionAuthPap()
N#endif
N
N/**
N  \brief  Event on PPP-LCP option Authentication CHAP (Detail)
N  \remark Challenge Handshake Authentication Protocol with MD5
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionAuthChapMd5(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionAuthChapMd5(void) {
N    EventRecord2 (EvtNetPPP_LcpOptionAuthChapMd5, 0, 0);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (40 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionAuthChapMd5()
N#endif
N
N/**
N  \brief  Event on PPP-LCP send echo request (Op)
N  \param  magic_number  magic random number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendEchoRequest(uint32_t magic_number) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendEchoRequest(uint32_t magic_number) {
N    EventRecord2 (EvtNetPPP_LcpSendEchoRequest, magic_number, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (41 & 0xFFU)), magic_number, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendEchoRequest(magic_number)
N#endif
N
N/**
N  \brief  Event on PPP-LCP send LCP terminate request (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendTerminateRequest(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendTerminateRequest(void) {
N    EventRecord2 (EvtNetPPP_LcpSendTerminateRequest, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (42 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendTerminateRequest()
N#endif
N
N/**
N  \brief  Event on PPP-LCP send frame (Op)
N  \param  lcp_header    pointer to LCP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendFrame(const void *lcp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendFrame(const void *lcp_header) {
N    EventRecordData (EvtNetPPP_LcpSendFrame, lcp_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (43 & 0xFFU)), lcp_header, 4);
N  }
N#else
S  #define EvrNetPPP_LcpSendFrame(lcp_header)
N#endif
N
N/**
N  \brief  Event on PPP-LCP receive frame (Op)
N  \param  lcp_header    pointer to LCP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpReceiveFrame(const void *lcp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpReceiveFrame(const void *lcp_header) {
N    EventRecordData (EvtNetPPP_LcpReceiveFrame, lcp_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (44 & 0xFFU)), lcp_header, 4);
N  }
N#else
S  #define EvrNetPPP_LcpReceiveFrame(lcp_header)
N#endif
N
N/**
N  \brief  Event on PPP-LCP data-link layer established (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpDataLinkUp(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpDataLinkUp(void) {
N    EventRecord2 (EvtNetPPP_LcpDataLinkUp, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (45 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpDataLinkUp()
N#endif
N
N/**
N  \brief  Event on PPP-LCP option MRU (Op)
N  \param  mru_size      maximum receive unit size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionMru(uint16_t mru_size) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionMru(uint16_t mru_size) {
N    EventRecord2 (EvtNetPPP_LcpOptionMru, mru_size, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (46 & 0xFFU)), mru_size, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionMru(mru_size)
N#endif
N
N/**
N  \brief  Event on PPP-LCP option authentication type (Op)
N  \param  auth_type     authentication type code
N                         - 0xC023: PAP
N                         - 0xC223: CHAP
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionAuth(uint16_t auth_type) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionAuth(uint16_t auth_type) {
N    EventRecord2 (EvtNetPPP_LcpOptionAuth, auth_type, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (47 & 0xFFU)), auth_type, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionAuth(auth_type)
N#endif
N
N/**
N  \brief  Event on PPP-LCP option CHAP authentication not MD5 type (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionAuthChapNotMd5(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionAuthChapNotMd5(void) {
N    EventRecord2 (EvtNetPPP_LcpOptionAuthChapNotMd5, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (48 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionAuthChapNotMd5()
N#endif
N
N/**
N  \brief  Event on PPP-LCP unknown option received (Op)
N  \param  lcp_option    unknown LCP option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpOptionUnknown(uint8_t lcp_option) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpOptionUnknown(uint8_t lcp_option) {
N    EventRecord2 (EvtNetPPP_LcpOptionUnknown, lcp_option, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (49 & 0xFFU)), lcp_option, 0);
N  }
N#else
S  #define EvrNetPPP_LcpOptionUnknown(lcp_option)
N#endif
N
N/**
N  \brief  Event on PPP-LCP send reject (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendReject(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendReject(void) {
N    EventRecord2 (EvtNetPPP_LcpSendReject, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (50 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendReject()
N#endif
N
N/**
N  \brief  Event on PPP-LCP send not acknowledge (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendNak(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendNak(void) {
N    EventRecord2 (EvtNetPPP_LcpSendNak, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (51 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendNak()
N#endif
N
N/**
N  \brief  Event on PPP-LCP send acknowledge (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendAck(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendAck(void) {
N    EventRecord2 (EvtNetPPP_LcpSendAck, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (52 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendAck()
N#endif
N
N/**
N  \brief  Event on PPP-LCP wrong acknowledge received (Op)
N  \param  id            received LCP identifier
N  \param  id_valid      valid LCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpWrongAckReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpWrongAckReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_LcpWrongAckReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (53 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_LcpWrongAckReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-LCP wrong not-acknowledge received (Op)
N  \param  id            received LCP identifier
N  \param  id_valid      valid LCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpWrongNakReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpWrongNakReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_LcpWrongNakReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (54 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_LcpWrongNakReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-LCP authentication type negotiation failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpConfigAuthFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpConfigAuthFailed(void) {
N    EventRecord2 (EvtNetPPP_LcpConfigAuthFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (55 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpConfigAuthFailed()
N#endif
N
N/**
N  \brief  Event on PPP-LCP wrong reject received (Op)
N  \param  id            received LCP identifier
N  \param  id_valid      valid LCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpWrongRejectReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpWrongRejectReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_LcpWrongRejectReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (56 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_LcpWrongRejectReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-LCP echo magic number (Op)
N  \param  magic_number  peer echo magic number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpEchoMagicNumber(uint32_t magic_number) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpEchoMagicNumber(uint32_t magic_number) {
N    EventRecord2 (EvtNetPPP_LcpEchoMagicNumber, magic_number, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (57 & 0xFFU)), magic_number, 0);
N  }
N#else
S  #define EvrNetPPP_LcpEchoMagicNumber(magic_number)
N#endif
N
N/**
N  \brief  Event on PPP-LCP wrong peer magic number (Op)
N  \param  magic         received peer magic number
N  \param  magic_valid   valid peer magic number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpWrongPeerMagicNumber(uint32_t magic, uint32_t magic_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpWrongPeerMagicNumber(uint32_t magic, uint32_t magic_valid) {
N    EventRecord2 (EvtNetPPP_LcpWrongPeerMagicNumber, magic, magic_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (58 & 0xFFU)), magic, magic_valid);
N  }
N#else
S  #define EvrNetPPP_LcpWrongPeerMagicNumber(magic, magic_valid)
N#endif
N
N/**
N  \brief  Event on PPP-LCP send echo reply (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendEchoReply(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendEchoReply(void) {
N    EventRecord2 (EvtNetPPP_LcpSendEchoReply, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (59 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendEchoReply()
N#endif
N
N/**
N  \brief  Event on PPP-LCP wrong echo reply received (Op)
N  \param  id            received LCP identifier
N  \param  id_valid      valid LCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpWrongEchoReplyReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpWrongEchoReplyReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_LcpWrongEchoReplyReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (60 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_LcpWrongEchoReplyReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-LCP send terminate acknowledge (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpSendTerminateAck(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpSendTerminateAck(void) {
N    EventRecord2 (EvtNetPPP_LcpSendTerminateAck, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (61 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpSendTerminateAck()
N#endif
N
N/**
N  \brief  Event on PPP-LCP de-initialize (Op)
N  \remark Point-to-Point Link Control Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_LcpUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_LcpUninit(void) {
N    EventRecord2 (EvtNetPPP_LcpUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (62 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_LcpUninit()
N#endif
N
N// PPP-PAP event recorder functions --------------------------------------------
N
N/**
N  \brief  Event on PPP-PAP initialize (Op)
N  \remark Password Authentication Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapInit(void) {
N    EventRecord2 (EvtNetPPP_PapInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (63 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_PapInit()
N#endif
N
N/**
N  \brief  Event on PPP-PAP send authentication request (Op)
N  \param  peer_id       peer identifier string (username)
N  \param  length        length of the peer_id string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapSendAuthRequest(const char *peer_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapSendAuthRequest(const char *peer_id, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetPPP_PapSendAuthRequest, peer_id, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (64 & 0xFFU)), peer_id, length);
N  }
N#else
S  #define EvrNetPPP_PapSendAuthRequest(peer_id, length)
N#endif
N
N/**
N  \brief  Event on PPP-PAP display password (Op)
N  \param  password      authentication password
N  \param  length        length of authentication password
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapShowPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapShowPassword(const char *password, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetPPP_PapShowPassword, password, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (65 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetPPP_PapShowPassword(password, length)
N#endif
N
N/**
N  \brief  Event on PPP-PAP send frame (Op)
N  \param  pap_header    pointer to PAP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapSendFrame(const void *pap_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapSendFrame(const void *pap_header) {
N    EventRecordData (EvtNetPPP_PapSendFrame, pap_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (66 & 0xFFU)), pap_header, 4);
N  }
N#else
S  #define EvrNetPPP_PapSendFrame(pap_header)
N#endif
N
N/**
N  \brief  Event on PPP-PAP receive frame (Op)
N  \param  pap_header    pointer to PAP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapReceiveFrame(const void *pap_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapReceiveFrame(const void *pap_header) {
N    EventRecordData (EvtNetPPP_PapReceiveFrame, pap_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (67 & 0xFFU)), pap_header, 4);
N  }
N#else
S  #define EvrNetPPP_PapReceiveFrame(pap_header)
N#endif
N
N/**
N  \brief  Event on PPP-PAP login success (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapLoginSuccess(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapLoginSuccess(void) {
N    EventRecord2 (EvtNetPPP_PapLoginSuccess, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (68 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_PapLoginSuccess()
N#endif
N
N/**
N  \brief  Event on PPP-PAP login failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapLoginFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapLoginFailed(void) {
N    EventRecord2 (EvtNetPPP_PapLoginFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (69 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_PapLoginFailed()
N#endif
N
N/**
N  \brief  Event on PPP-PAP wrong acknowledge received (Op)
N  \param  id            received PAP identifier
N  \param  id_valid      valid PAP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapWrongAckReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapWrongAckReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_PapWrongAckReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (70 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_PapWrongAckReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-PAP wrong not-acknowledge received (Op)
N  \param  id            received PAP identifier
N  \param  id_valid      valid PAP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapWrongNakReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapWrongNakReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_PapWrongNakReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (71 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_PapWrongNakReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-PAP de-initialize (Op)
N  \remark Password Authentication Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_PapUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_PapUninit(void) {
N    EventRecord2 (EvtNetPPP_PapUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (72 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_PapUninit()
N#endif
N
N// PPP-CHAP event recorder functions -------------------------------------------
N
N/**
N  \brief  Event on PPP-CHAP initialize (Op)
N  \remark Challenge-Handshake Authentication Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapInit(void) {
N    EventRecord2 (EvtNetPPP_ChapInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (73 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ChapInit()
N#endif
N
N/**
N  \brief  Event on PPP-CHAP send challenge (Op)
N  \param  name          system identification string
N  \param  length        length of the system identification string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapSendChallenge(const char *name, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapSendChallenge(const char *name, uint32_t length) {
N    EventRecordData (EvtNetPPP_ChapSendChallenge, name, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (74 & 0xFFU)), name, length);
N  }
N#else
S  #define EvrNetPPP_ChapSendChallenge(name, length)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP send frame (Op)
N  \param  chap_header   pointer to CHAP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapSendFrame(const void *chap_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapSendFrame(const void *chap_header) {
N    EventRecordData (EvtNetPPP_ChapSendFrame, chap_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (75 & 0xFFU)), chap_header, 4);
N  }
N#else
S  #define EvrNetPPP_ChapSendFrame(chap_header)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP receive frame (Op)
N  \param  chap_header   pointer to CHAP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapReceiveFrame(const void *chap_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapReceiveFrame(const void *chap_header) {
N    EventRecordData (EvtNetPPP_ChapReceiveFrame, chap_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (76 & 0xFFU)), chap_header, 4);
N  }
N#else
S  #define EvrNetPPP_ChapReceiveFrame(chap_header)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP wrong response received (Op)
N  \param  id            received CHAP identifier
N  \param  id_valid      valid CHAP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapWrongResponseReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapWrongResponseReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_ChapWrongResponseReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (77 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_ChapWrongResponseReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP wrong success received (Op)
N  \param  id            received CHAP identifier
N  \param  id_valid      valid CHAP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapWrongSuccessReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapWrongSuccessReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_ChapWrongSuccessReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (78 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_ChapWrongSuccessReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP wrong failure received (Op)
N  \param  id            received CHAP identifier
N  \param  id_valid      valid CHAP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapWrongFailureReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapWrongFailureReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_ChapWrongFailureReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (79 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_ChapWrongFailureReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-CHAP login success (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapLoginSuccess(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapLoginSuccess(void) {
N    EventRecord2 (EvtNetPPP_ChapLoginSuccess, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (80 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ChapLoginSuccess()
N#endif
N
N/**
N  \brief  Event on PPP-CHAP login failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapLoginFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapLoginFailed(void) {
N    EventRecord2 (EvtNetPPP_ChapLoginFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (81 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ChapLoginFailed()
N#endif
N
N/**
N  \brief  Event on PPP-CHAP de-initialize (Op)
N  \remark Challenge-Handshake Authentication Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_ChapUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_ChapUninit(void) {
N    EventRecord2 (EvtNetPPP_ChapUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (82 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_ChapUninit()
N#endif
N
N// PPP-IPCP event recorder functions -------------------------------------------
N
N/**
N  \brief  Event on PPP-IPCP initialize (Op)
N  \remark PPP Internet Protocol Control Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpInit(void) {
N    EventRecord2 (EvtNetPPP_IpcpInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (83 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpInit()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP interface IPv4 configuration error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpIp4ConfigError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpIp4ConfigError(void) {
N    EventRecord2 (EvtNetPPP_IpcpIp4ConfigError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (84 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpIp4ConfigError()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP send configuration request (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSendConfigRequest(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSendConfigRequest(void) {
N    EventRecord2 (EvtNetPPP_IpcpSendConfigRequest, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (85 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpSendConfigRequest()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP option IP-address (Detail)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpOptionIpAddress(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpOptionIpAddress(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_IpcpOptionIpAddress, ip4_addr, 4);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (86 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpOptionIpAddress(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP option primary DNS server address (Detail)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpOptionPrimaryDns(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpOptionPrimaryDns(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_IpcpOptionPrimaryDns, ip4_addr, 4);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (87 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpOptionPrimaryDns(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP option secondary DNS server address (Detail)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpOptionSecondaryDns(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpOptionSecondaryDns(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_IpcpOptionSecondaryDns, ip4_addr, 4);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (88 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpOptionSecondaryDns(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP send frame (Op)
N  \param  ipcp_header   pointer to IPCP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSendFrame(const void *ipcp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSendFrame(const void *ipcp_header) {
N    EventRecordData (EvtNetPPP_IpcpSendFrame, ipcp_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (89 & 0xFFU)), ipcp_header, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpSendFrame(ipcp_header)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP receive frame (Op)
N  \param  ipcp_header   pointer to IPCP frame header of 4 bytes
N                         - Code (1 byte)
N                         - Id   (1 byte)
N                         - Len  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpReceiveFrame(const void *ipcp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpReceiveFrame(const void *ipcp_header) {
N    EventRecordData (EvtNetPPP_IpcpReceiveFrame, ipcp_header, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (90 & 0xFFU)), ipcp_header, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpReceiveFrame(ipcp_header)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP unknown option received (Op)
N  \param  ipcp_option   unknown IPCP option
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpOptionUnknown(uint8_t ipcp_option) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpOptionUnknown(uint8_t ipcp_option) {
N    EventRecord2 (EvtNetPPP_IpcpOptionUnknown, ipcp_option, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (91 & 0xFFU)), ipcp_option, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpOptionUnknown(ipcp_option)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP send reject (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSendReject(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSendReject(void) {
N    EventRecord2 (EvtNetPPP_IpcpSendReject, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (92 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpSendReject()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP send not acknowledge (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSendNak(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSendNak(void) {
N    EventRecord2 (EvtNetPPP_IpcpSendNak, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (93 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpSendNak()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP send acknowledge (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSendAck(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSendAck(void) {
N    EventRecord2 (EvtNetPPP_IpcpSendAck, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (94 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpSendAck()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP wrong acknowledge received (Op)
N  \param  id            received IPCP identifier
N  \param  id_valid      valid IPCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpWrongAckReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpWrongAckReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_IpcpWrongAckReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (95 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_IpcpWrongAckReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP network-layer established (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpNetworkLayerUp(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpNetworkLayerUp(void) {
N    EventRecord2 (EvtNetPPP_IpcpNetworkLayerUp, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (96 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpNetworkLayerUp()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP wrong not-acknowledge received (Op)
N  \param  id            received IPCP identifier
N  \param  id_valid      valid IPCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpWrongNakReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpWrongNakReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_IpcpWrongNakReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (97 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_IpcpWrongNakReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP wrong reject received (Op)
N  \param  id            received IPCP identifier
N  \param  id_valid      valid IPCP identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpWrongRejectReceived(uint8_t id, uint8_t id_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpWrongRejectReceived(uint8_t id, uint8_t id_valid) {
N    EventRecord2 (EvtNetPPP_IpcpWrongRejectReceived, id, id_valid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (98 & 0xFFU)), id, id_valid);
N  }
N#else
S  #define EvrNetPPP_IpcpWrongRejectReceived(id, id_valid)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP advertised IP-address not in subnet (Op)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpWrongSubnet(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpWrongSubnet(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetPPP_IpcpWrongSubnet, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (99 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetPPP_IpcpWrongSubnet(ip4_addr)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP primary DNS server option rejected (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpPrimaryDnsRejected(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpPrimaryDnsRejected(void) {
N    EventRecord2 (EvtNetPPP_IpcpPrimaryDnsRejected, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (100 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpPrimaryDnsRejected()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP secondary DNS server option rejected (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpSecondaryDnsRejected(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpSecondaryDnsRejected(void) {
N    EventRecord2 (EvtNetPPP_IpcpSecondaryDnsRejected, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (101 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpSecondaryDnsRejected()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP IP-address option rejected (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpIpAddressRejected(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpIpAddressRejected(void) {
N    EventRecord2 (EvtNetPPP_IpcpIpAddressRejected, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (102 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpIpAddressRejected()
N#endif
N
N/**
N  \brief  Event on PPP-IPCP not requested option rejected (Error)
N  \param  ipcp_option   rejected option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpNotRequestedOption(uint8_t ipcp_option) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpNotRequestedOption(uint8_t ipcp_option) {
N    EventRecord2 (EvtNetPPP_IpcpNotRequestedOption, ipcp_option, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (103 & 0xFFU)), ipcp_option, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpNotRequestedOption(ipcp_option)
N#endif
N
N/**
N  \brief  Event on PPP-IPCP de-initialize (Op)
N  \remark PPP Internet Protocol Control Protocol
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetPPP_IpcpUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetPPP_IpcpUninit(void) {
N    EventRecord2 (EvtNetPPP_IpcpUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC3 & 0xFFU) << 8) | (104 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetPPP_IpcpUninit()
N#endif
N
N
N// NetSLIP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetSLIP_InitInterface            EventID (EventLevelOp,    EvtNetSLIP,  0)
N#define EvtNetSLIP_Ip4ConfigError           EventID (EventLevelError, EvtNetSLIP,  1)
N#define EvtNetSLIP_ThreadCreateFailed       EventID (EventLevelError, EvtNetSLIP,  2)
N#define EvtNetSLIP_GetOptionInvalidParameter EventID (EventLevelError,EvtNetSLIP,  3)
N#define EvtNetSLIP_SetOptionInvalidParameter EventID (EventLevelError,EvtNetSLIP,  4)
N#define EvtNetSLIP_SetIp4Address            EventID (EventLevelOp,    EvtNetSLIP,  5)
N#define EvtNetSLIP_SetIp4PrimaryDNS         EventID (EventLevelOp,    EvtNetSLIP,  6)
N#define EvtNetSLIP_SetIp4SecondaryDNS       EventID (EventLevelOp,    EvtNetSLIP,  7)
N#define EvtNetSLIP_SetIp4Mtu                EventID (EventLevelOp,    EvtNetSLIP,  8)
N#define EvtNetSLIP_Connect                  EventID (EventLevelAPI,   EvtNetSLIP,  9)
N#define EvtNetSLIP_ConnectInvalidParameter  EventID (EventLevelError, EvtNetSLIP, 10)
N#define EvtNetSLIP_ConnectWrongState        EventID (EventLevelError, EvtNetSLIP, 11)
N#define EvtNetSLIP_Listen                   EventID (EventLevelAPI,   EvtNetSLIP, 12)
N#define EvtNetSLIP_ListenWrongState         EventID (EventLevelError, EvtNetSLIP, 13)
N#define EvtNetSLIP_Close                    EventID (EventLevelAPI,   EvtNetSLIP, 14)
N#define EvtNetSLIP_SendFrame                EventID (EventLevelOp,    EvtNetSLIP, 15)
N#define EvtNetSLIP_InvalidIpVersion         EventID (EventLevelError, EvtNetSLIP, 16)
N#define EvtNetSLIP_SendDataTooLarge         EventID (EventLevelError, EvtNetSLIP, 17)
N#define EvtNetSLIP_NoMemoryError            EventID (EventLevelError, EvtNetSLIP, 18)
N#define EvtNetSLIP_QueueAddTransmit         EventID (EventLevelOp,    EvtNetSLIP, 19)
N#define EvtNetSLIP_ModemOffline             EventID (EventLevelOp,    EvtNetSLIP, 20)
N#define EvtNetSLIP_ReceiveFrame             EventID (EventLevelOp,    EvtNetSLIP, 21)
N#define EvtNetSLIP_UninitInterface          EventID (EventLevelOp,    EvtNetSLIP, 22)
N#endif
N
N/**
N  \brief  Event on SLIP interface initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_InitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_InitInterface(void) {
N    EventRecord2 (EvtNetSLIP_InitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_InitInterface()
N#endif
N
N/**
N  \brief  Event on SLIP IPv4 configuration error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_Ip4ConfigError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_Ip4ConfigError(void) {
N    EventRecord2 (EvtNetSLIP_Ip4ConfigError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_Ip4ConfigError()
N#endif
N
N/**
N  \brief  Event on SLIP thread create failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ThreadCreateFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ThreadCreateFailed(void) {
N    EventRecord2 (EvtNetSLIP_ThreadCreateFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_ThreadCreateFailed()
N#endif
N
N/**
N  \brief  Event on SLIP get_option invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_GetOptionInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_GetOptionInvalidParameter(void) {
N    EventRecord2 (EvtNetSLIP_GetOptionInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (3 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_GetOptionInvalidParameter()
N#endif
N
N/**
N  \brief  Event on SLIP set_option invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SetOptionInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SetOptionInvalidParameter(void) {
N    EventRecord2 (EvtNetSLIP_SetOptionInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_SetOptionInvalidParameter()
N#endif
N
N/**
N  \brief  Event on SLIP set interface IPv4 address (Op)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SetIp4Address(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SetIp4Address(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSLIP_SetIp4Address, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (5 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSLIP_SetIp4Address(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SLIP set interface primary DNS server (Op)
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SetIp4PrimaryDNS(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SetIp4PrimaryDNS(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSLIP_SetIp4PrimaryDNS, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (6 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSLIP_SetIp4PrimaryDNS(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SLIP set interface secondary DNS server (Op)
N  \param  ip4_addr      pointer to IPv4 address of a DNS server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SetIp4SecondaryDNS(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SetIp4SecondaryDNS(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSLIP_SetIp4SecondaryDNS, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (7 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSLIP_SetIp4SecondaryDNS(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SLIP set interface MTU (Op)
N  \param  mtu           maximum transmission unit
N                         - 0: fragmentation disabled
N  \remark MTU is limited in the range from 296 to 1500 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SetIp4Mtu(uint16_t mtu) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SetIp4Mtu(uint16_t mtu) {
N    EventRecord2 (EvtNetSLIP_SetIp4Mtu, mtu, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (8 & 0xFFU)), mtu, 0);
N  }
N#else
S  #define EvrNetSLIP_SetIp4Mtu(mtu)
N#endif
N
N/**
N  \brief  Event on SLIP start connecting (API)
N  \param  dial_number   pointer to a number to dial string
N  \param  length        length of the dial_number string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_Connect(const char *dial_number, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_Connect(const char *dial_number, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetSLIP_Connect, dial_number, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (9 & 0xFFU)), dial_number, length);
N  }
N#else
S  #define EvrNetSLIP_Connect(dial_number, length)
N#endif
N
N/**
N  \brief  Event on SLIP connect invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ConnectInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ConnectInvalidParameter(void) {
N    EventRecord2 (EvtNetSLIP_ConnectInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (10 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_ConnectInvalidParameter()
N#endif
N
N/**
N  \brief  Event on SLIP connect in wrong state (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ConnectWrongState(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ConnectWrongState(void) {
N    EventRecord2 (EvtNetSLIP_ConnectWrongState, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (11 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_ConnectWrongState()
N#endif
N
N/**
N  \brief  Event on SLIP start listening (API)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_Listen(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_Listen(void) {
N    EventRecord2 (EvtNetSLIP_Listen, 0, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (12 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_Listen()
N#endif
N
N/**
N  \brief  Event on SLIP listen in wrong state (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ListenWrongState(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ListenWrongState(void) {
N    EventRecord2 (EvtNetSLIP_ListenWrongState, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_ListenWrongState()
N#endif
N
N/**
N  \brief  Event on SLIP close connection (API)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_Close(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_Close(void) {
N    EventRecord2 (EvtNetSLIP_Close, 0, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (14 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_Close()
N#endif
N
N/**
N  \brief  Event on SLIP send frame (Op)
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SendFrame(uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SendFrame(uint32_t length, uint8_t ip_version) {
N    EventRecord2 (EvtNetSLIP_SendFrame, length, ip_version);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (15 & 0xFFU)), length, ip_version);
N  }
N#else
S  #define EvrNetSLIP_SendFrame(length, ip_version)
N#endif
N
N/**
N  \brief  Event on SLIP invalid IP version (Error)
N  \param  ip_version    invalid IP protocol version value
N                        - 0: IPv4
N                        - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_InvalidIpVersion(uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_InvalidIpVersion(uint8_t ip_version) {
N    EventRecord2 (EvtNetSLIP_InvalidIpVersion, ip_version, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (16 & 0xFFU)), ip_version, 0);
N  }
N#else
S  #define EvrNetSLIP_InvalidIpVersion(ip_version)
N#endif
N
N/**
N  \brief  Event on SLIP send payload too large (Error)
N  \param  length        data length in bytes
N  \param  max_length    maximum length of data in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_SendDataTooLarge(uint32_t length, uint32_t max_length) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_SendDataTooLarge(uint32_t length, uint32_t max_length) {
N    EventRecord2 (EvtNetSLIP_SendDataTooLarge, length, max_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (17 & 0xFFU)), length, max_length);
N  }
N#else
S  #define EvrNetSLIP_SendDataTooLarge(length, max_length)
N#endif
N
N/**
N  \brief  Event on SLIP out of memory for send (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_NoMemoryError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_NoMemoryError(void) {
N    EventRecord2 (EvtNetSLIP_NoMemoryError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_NoMemoryError()
N#endif
N
N/**
N  \brief  Event on SLIP add frame to transmit queue (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_QueueAddTransmit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_QueueAddTransmit(void) {
N    EventRecord2 (EvtNetSLIP_QueueAddTransmit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (19 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_QueueAddTransmit()
N#endif
N
N/**
N  \brief  Event on SLIP link change to modem offline (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ModemOffline(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ModemOffline(void) {
N    EventRecord2 (EvtNetSLIP_ModemOffline, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (20 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_ModemOffline()
N#endif
N
N/**
N  \brief  Event on SLIP receive frame (Op)
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_ReceiveFrame(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_ReceiveFrame(uint32_t length) {
N    EventRecord2 (EvtNetSLIP_ReceiveFrame, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (21 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetSLIP_ReceiveFrame(length)
N#endif
N
N/**
N  \brief  Event on SLIP interface de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSLIP_UninitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSLIP_UninitInterface(void) {
N    EventRecord2 (EvtNetSLIP_UninitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC4 & 0xFFU) << 8) | (22 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSLIP_UninitInterface()
N#endif
N
N
N// NetLOOP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetLOOP_InitInterface            EventID (EventLevelOp,    EvtNetLOOP, 0)
N#define EvtNetLOOP_SendFrame                EventID (EventLevelOp,    EvtNetLOOP, 1)
N#define EvtNetLOOP_NoMemoryError            EventID (EventLevelError, EvtNetLOOP, 2)
N#define EvtNetLOOP_ReceiveFrame             EventID (EventLevelOp,    EvtNetLOOP, 3)
N#define EvtNetLOOP_UninitInterface          EventID (EventLevelOp,    EvtNetLOOP, 4)
N#endif
N
N/**
N  \brief  Event on Loopback interface initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetLOOP_InitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetLOOP_InitInterface(void) {
N    EventRecord2 (EvtNetLOOP_InitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC5 & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetLOOP_InitInterface()
N#endif
N
N/**
N  \brief  Event on Loopback send frame (Op)
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetLOOP_SendFrame(uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetLOOP_SendFrame(uint32_t length, uint8_t ip_version) {
N    EventRecord2 (EvtNetLOOP_SendFrame, length, ip_version);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC5 & 0xFFU) << 8) | (1 & 0xFFU)), length, ip_version);
N  }
N#else
S  #define EvrNetLOOP_SendFrame(length, ip_version)
N#endif
N
N/**
N  \brief  Event on Loopback out of memory for send (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetLOOP_NoMemoryError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetLOOP_NoMemoryError(void) {
N    EventRecord2 (EvtNetLOOP_NoMemoryError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC5 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetLOOP_NoMemoryError()
N#endif
N
N/**
N  \brief  Event on Loopback receive frame (Op)
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetLOOP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetLOOP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
N    EventRecord2 (EvtNetLOOP_ReceiveFrame, length, ip_version);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC5 & 0xFFU) << 8) | (3 & 0xFFU)), length, ip_version);
N  }
N#else
S  #define EvrNetLOOP_ReceiveFrame(length, ip_version)
N#endif
N
N/**
N  \brief  Event on Loopback interface de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetLOOP_UninitInterface(void) {
X  static __inline __attribute__((always_inline)) void EvrNetLOOP_UninitInterface(void) {
N    EventRecord2 (EvtNetLOOP_UninitInterface, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC5 & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetLOOP_UninitInterface()
N#endif
N
N
N// NetIP4 event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetIP4_InitCore                  EventID (EventLevelOp,    EvtNetIP4,  0)
N#define EvtNetIP4_ReceiveFrame              EventID (EventLevelOp,    EvtNetIP4,  1)
N#define EvtNetIP4_FrameTooShort             EventID (EventLevelError, EvtNetIP4,  2)
N#define EvtNetIP4_InvalidIpVersion          EventID (EventLevelError, EvtNetIP4,  3)
N#define EvtNetIP4_ShowFrameHeader           EventID (EventLevelDetail,EvtNetIP4,  4)
N#define EvtNetIP4_SourceIpAddressInvalid    EventID (EventLevelError, EvtNetIP4,  5)
N#define EvtNetIP4_WrongMulticastProtocol    EventID (EventLevelError, EvtNetIP4,  6)
N#define EvtNetIP4_WrongBroadcastProtocol    EventID (EventLevelError, EvtNetIP4,  7)
N#define EvtNetIP4_WrongDestinationAddress   EventID (EventLevelOp,    EvtNetIP4,  8)
N#define EvtNetIP4_ChecksumFailed            EventID (EventLevelError, EvtNetIP4,  9)
N#define EvtNetIP4_FragmentDfFlagSet         EventID (EventLevelError, EvtNetIP4, 10)
N#define EvtNetIP4_FragmentationNotEnabled   EventID (EventLevelError, EvtNetIP4, 11)
N#define EvtNetIP4_SendFrame                 EventID (EventLevelOp,    EvtNetIP4, 12)
N#define EvtNetIP4_ProtocolUnknown           EventID (EventLevelError, EvtNetIP4, 13)
N#define EvtNetIP4_DestinationAddressNull    EventID (EventLevelError, EvtNetIP4, 14)
N#define EvtNetIP4_SetDefaultInterface       EventID (EventLevelOp,    EvtNetIP4, 15)
N#define EvtNetIP4_UninitCore                EventID (EventLevelOp,    EvtNetIP4, 16)
N#endif
N
N/**
N  \brief  Event on IP4 core initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_InitCore(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_InitCore(uint16_t if_id) {
N    EventRecord2 (EvtNetIP4_InitCore, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (0 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP4_InitCore(if_id)
N#endif
N
N/**
N  \brief  Event on IP4 receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetIP4_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (1 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetIP4_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on IP4 receive frame too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetIP4_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (2 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetIP4_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on IP4 invalid protocol version (Error)
N  \param  if_id         network interface identifier
N  \param  ip_version    IP protocol version value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_InvalidIpVersion(uint16_t if_id, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_InvalidIpVersion(uint16_t if_id, uint8_t ip_version) {
N    EventRecord2 (EvtNetIP4_InvalidIpVersion, if_id, ip_version);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (3 & 0xFFU)), if_id, ip_version);
N  }
N#else
S  #define EvrNetIP4_InvalidIpVersion(if_id, ip_version)
N#endif
N
N/**
N  \brief  Event on IP4 display frame header (Detail)
N  \param  ip4_header    pointer to IPv4 frame header of 20 bytes
N                         - VerHlen  (1 byte)
N                         - Tos      (1 byte)
N                         - Len      (2 bytes)
N                         - Id       (2 bytes)
N                         - FragOffs (2 bytes)
N                         - Ttl      (1 byte)
N                         - Proto    (1 byte)
N                         - Chksum   (2 bytes)
N                         - SrcAddr  (4 bytes)
N                         - DstAddr  (4 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_ShowFrameHeader(const void *ip4_header) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_ShowFrameHeader(const void *ip4_header) {
N    EventRecordData (EvtNetIP4_ShowFrameHeader, ip4_header, 20);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (4 & 0xFFU)), ip4_header, 20);
N  }
N#else
S  #define EvrNetIP4_ShowFrameHeader(ip4_header)
N#endif
N
N/**
N  \brief  Event on IP4 source IP address invalid (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_SourceIpAddressInvalid(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_SourceIpAddressInvalid(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIP4_SourceIpAddressInvalid, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (5 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIP4_SourceIpAddressInvalid(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IP4 wrong multicast protocol type (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_protocol  wrong protocol type value
N  \remark Only UDP and IGMP multicast frames are allowed.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_WrongMulticastProtocol(uint16_t if_id, uint8_t ip4_protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_WrongMulticastProtocol(uint16_t if_id, uint8_t ip4_protocol) {
N    EventRecord2 (EvtNetIP4_WrongMulticastProtocol, if_id, ip4_protocol);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (6 & 0xFFU)), if_id, ip4_protocol);
N  }
N#else
S  #define EvrNetIP4_WrongMulticastProtocol(if_id, ip4_protocol)
N#endif
N
N/**
N  \brief  Event on IP4 wrong broadcast protocol type (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_protocol  wrong protocol type value
N  \remark Only UDP subnet broadcast frames are allowed.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_WrongBroadcastProtocol(uint16_t if_id, uint8_t ip4_protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_WrongBroadcastProtocol(uint16_t if_id, uint8_t ip4_protocol) {
N    EventRecord2 (EvtNetIP4_WrongBroadcastProtocol, if_id, ip4_protocol);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (7 & 0xFFU)), if_id, ip4_protocol);
N  }
N#else
S  #define EvrNetIP4_WrongBroadcastProtocol(if_id, ip4_protocol)
N#endif
N
N/**
N  \brief  Event on IP4 wrong destination address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_WrongDestinationAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_WrongDestinationAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIP4_WrongDestinationAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (8 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIP4_WrongDestinationAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IP4 header checksum check failed (Error)
N  \param  if_id         network interface identifier
N  \param  length        header length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_ChecksumFailed(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_ChecksumFailed(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetIP4_ChecksumFailed, if_id, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (9 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetIP4_ChecksumFailed(if_id, length)
N#endif
N
N/**
N  \brief  Event on IP4 receive fragmented frame with DF-flag set (Error)
N  \param  if_id         network interface identifier
N  \param  frag          IP flags and fragment offset
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_FragmentDfFlagSet(uint16_t if_id, uint16_t frag) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_FragmentDfFlagSet(uint16_t if_id, uint16_t frag) {
N    EventRecord2 (EvtNetIP4_FragmentDfFlagSet, if_id, frag);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (10 & 0xFFU)), if_id, frag);
N  }
N#else
S  #define EvrNetIP4_FragmentDfFlagSet(if_id, flags)
N#endif
N
N/**
N  \brief  Event on IP4 receive fragmented frame (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_FragmentationNotEnabled(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_FragmentationNotEnabled(uint16_t if_id) {
N    EventRecord2 (EvtNetIP4_FragmentationNotEnabled, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (11 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP4_FragmentationNotEnabled(if_id)
N#endif
N
N/**
N  \brief  Event on IP4 send frame (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_protocol  IPv4 protocol type
N                         - 1:  ICMP
N                         - 2:  IGMP
N                         - 6:  TCP
N                         - 17: UDP
N  \param  length        frame length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_SendFrame(uint16_t if_id, uint8_t ip4_protocol, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_SendFrame(uint16_t if_id, uint8_t ip4_protocol, uint32_t length) {
N    uint32_t val2 = (length << 16) | ip4_protocol;
N    EventRecord2 (EvtNetIP4_SendFrame, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (12 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetIP4_SendFrame(if_id, ip4_protocol, length)
N#endif
N
N/**
N  \brief  Event on IP4 unknown protocol type in sending frame (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_protocol  unknown IPv4 protocol type value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_ProtocolUnknown(uint16_t if_id, uint8_t ip4_protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_ProtocolUnknown(uint16_t if_id, uint8_t ip4_protocol) {
N    EventRecord2 (EvtNetIP4_ProtocolUnknown, if_id, ip4_protocol);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (13 & 0xFFU)), if_id, ip4_protocol);
N  }
N#else
S  #define EvrNetIP4_ProtocolUnknown(if_id, ip4_protocol)
N#endif
N
N/**
N  \brief  Event on IP4 destination address not provided (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_DestinationAddressNull(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_DestinationAddressNull(uint16_t if_id) {
N    EventRecord2 (EvtNetIP4_DestinationAddressNull, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (14 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP4_DestinationAddressNull(if_id)
N#endif
N
N/**
N  \brief  Event on IP4 set default interface for internet access (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_SetDefaultInterface(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_SetDefaultInterface(uint16_t if_id) {
N    EventRecord2 (EvtNetIP4_SetDefaultInterface, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (15 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP4_SetDefaultInterface(if_id)
N#endif
N
N/**
N  \brief  Event on IP4 core de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP4_UninitCore(void) {
X  static __inline __attribute__((always_inline)) void EvrNetIP4_UninitCore(void) {
N    EventRecord2 (EvtNetIP4_UninitCore, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC6 & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetIP4_UninitCore()
N#endif
N
N
N// NetICMP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N/* ICMP-Core events */
N#define EvtNetICMP_ReceiveFrame             EventID (EventLevelOp,    EvtNetICMP,  0)
N#define EvtNetICMP_ShowFrameHeader          EventID (EventLevelDetail,EvtNetICMP, 24)
N#define EvtNetICMP_FrameTooShort            EventID (EventLevelError, EvtNetICMP,  1)
N#define EvtNetICMP_ChecksumFailed           EventID (EventLevelError, EvtNetICMP,  2)
N#define EvtNetICMP_EchoRequestWrongCode     EventID (EventLevelError, EvtNetICMP,  3)
N#define EvtNetICMP_EchoRequestReceived      EventID (EventLevelOp,    EvtNetICMP,  4)
N#define EvtNetICMP_EchoReplyDisabled        EventID (EventLevelOp,    EvtNetICMP, 25) // End
N#define EvtNetICMP_SendEchoReply            EventID (EventLevelOp,    EvtNetICMP,  5)
N#define EvtNetICMP_EchoReplyReceived        EventID (EventLevelOp,    EvtNetICMP,  6)
N#define EvtNetICMP_EchoReplyWrongState      EventID (EventLevelError, EvtNetICMP,  7)
N#define EvtNetICMP_EchoReplyWrongCode       EventID (EventLevelError, EvtNetICMP,  8)
N#define EvtNetICMP_EchoReplyWrongIpAddress  EventID (EventLevelError, EvtNetICMP,  9)
N#define EvtNetICMP_EchoReplyWrongId         EventID (EventLevelError, EvtNetICMP, 10)
N#define EvtNetICMP_EchoReplyWrongPayload    EventID (EventLevelError, EvtNetICMP, 11)
N#define EvtNetICMP_MessageTypeUnknown       EventID (EventLevelOp,    EvtNetICMP, 12)
N#define EvtNetICMP_SendEchoRequest          EventID (EventLevelOp,    EvtNetICMP, 13)
N/* ICMP-Ping client events */
N#define EvtNetICMP_PingInit                 EventID (EventLevelOp,    EvtNetICMP, 14)
N#define EvtNetICMP_PingEcho                 EventID (EventLevelAPI,   EvtNetICMP, 15)
N#define EvtNetICMP_PingTargetNotValid       EventID (EventLevelError, EvtNetICMP, 16)
N#define EvtNetICMP_PingDnsError             EventID (EventLevelError, EvtNetICMP, 17)
N#define EvtNetICMP_PingInvalidParameter     EventID (EventLevelError, EvtNetICMP, 18)
N#define EvtNetICMP_PingClientBusy           EventID (EventLevelError, EvtNetICMP, 19)
N#define EvtNetICMP_PingSendRequest          EventID (EventLevelOp,    EvtNetICMP, 20)
N#define EvtNetICMP_PingRetransmitRequest    EventID (EventLevelOp,    EvtNetICMP, 21)
N#define EvtNetICMP_PingTimeout              EventID (EventLevelOp,    EvtNetICMP, 22)
N#define EvtNetICMP_PingUninit               EventID (EventLevelOp,    EvtNetICMP, 23)
N#endif
N
N/**
N  \brief  Event on ICMP receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetICMP_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (0 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetICMP_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on ICMP display send/receive frame header (Detail)
N  \param  icmp_header   pointer to ICMP frame header of 8 bytes
N                         - Type    (1 byte)
N                         - Code    (1 byte)
N                         - Chksum  (2 bytes)
N                         - EchoId  (2 bytes)
N                         - EchoSeq (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_ShowFrameHeader(const void *icmp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_ShowFrameHeader(const void *icmp_header) {
N    EventRecordData (EvtNetICMP_ShowFrameHeader, icmp_header, 8);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (24 & 0xFFU)), icmp_header, 8);
N  }
N#else
S  #define EvrNetICMP_ShowFrameHeader(icmp_header)
N#endif
N
N/**
N  \brief  Event on ICMP receive frame is too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetICMP_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (1 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on ICMP frame checksum check failed (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_ChecksumFailed(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_ChecksumFailed(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetICMP_ChecksumFailed, if_id, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (2 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetICMP_ChecksumFailed(if_id, length)
N#endif
N
N/**
N  \brief  Event on ICMP receive wrong code in echo request (Error)
N  \param  if_id         network interface identifier
N  \param  code          received ICMP code
N  \param  code_valid    valid ICMP code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoRequestWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoRequestWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
N    uint32_t val2 = ((uint32_t)code_valid << 16) | code;
N    EventRecord2 (EvtNetICMP_EchoRequestWrongCode, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (3 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP_EchoRequestWrongCode(if_id, code, code_valid)
N#endif
N
N/**
N  \brief  Event on ICMP receive echo request (Op)
N  \param  if_id         network interface identifier
N  \param  data_length   length of the payload data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoRequestReceived(uint16_t if_id, uint32_t data_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoRequestReceived(uint16_t if_id, uint32_t data_length) {
N    EventRecord2 (EvtNetICMP_EchoRequestReceived, if_id, data_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (4 & 0xFFU)), if_id, data_length);
N  }
N#else
S  #define EvrNetICMP_EchoRequestReceived(if_id, data_length)
N#endif
N
N/**
N  \brief  Event on ICMP sending echo reply disabled (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyDisabled(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyDisabled(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_EchoReplyDisabled, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (25 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_EchoReplyDisabled(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP send echo reply (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_SendEchoReply(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_SendEchoReply(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_SendEchoReply, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (5 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_SendEchoReply(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP receive echo reply (Op)
N  \param  if_id         network interface identifier
N  \param  data_length   length of the payload data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyReceived(uint16_t if_id, uint32_t data_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyReceived(uint16_t if_id, uint32_t data_length) {
N    EventRecord2 (EvtNetICMP_EchoReplyReceived, if_id, data_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (6 & 0xFFU)), if_id, data_length);
N  }
N#else
S  #define EvrNetICMP_EchoReplyReceived(if_id, data_length)
N#endif
N
N/**
N  \brief  Event on ICMP receive echo reply in wrong state (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyWrongState(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyWrongState(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_EchoReplyWrongState, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (7 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_EchoReplyWrongState(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP receive wrong code in echo reply (Error)
N  \param  if_id         network interface identifier
N  \param  code          received ICMP code
N  \param  code_valid    valid ICMP code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
N    uint32_t val2 = ((uint32_t)code_valid << 16) | code;
N    EventRecord2 (EvtNetICMP_EchoReplyWrongCode, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (8 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP_EchoReplyWrongCode(if_id, code, code_valid)
N#endif
N
N/**
N  \brief  Event on ICMP wrong source IPv4 address in echo reply (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyWrongIpAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyWrongIpAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetICMP_EchoReplyWrongIpAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (9 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetICMP_EchoReplyWrongIpAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ICMP wrong echo identifier in echo reply (Error)
N  \param  if_id         network interface identifier
N  \param  eid           received echo identifier
N  \param  eid_valid     valid echo identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyWrongId(uint16_t if_id, uint16_t eid, uint16_t eid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyWrongId(uint16_t if_id, uint16_t eid, uint16_t eid_valid) {
N    uint32_t val2 = ((uint32_t)eid_valid << 16) | eid;
N    EventRecord2 (EvtNetICMP_EchoReplyWrongId, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (10 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP_EchoReplyWrongId(if_id, eid, eid_valid)
N#endif
N
N/**
N  \brief  Event on ICMP invalid payload data in echo reply (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_EchoReplyWrongPayload(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_EchoReplyWrongPayload(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_EchoReplyWrongPayload, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (11 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_EchoReplyWrongPayload(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP message type unknown (Op)
N  \param  if_id         network interface identifier
N  \param  icmp_type     wrong ICMP message type value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_MessageTypeUnknown(uint16_t if_id, uint8_t icmp_type) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_MessageTypeUnknown(uint16_t if_id, uint8_t icmp_type) {
N    EventRecord2 (EvtNetICMP_MessageTypeUnknown, if_id, icmp_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (12 & 0xFFU)), if_id, icmp_type);
N  }
N#else
S  #define EvrNetICMP_MessageTypeUnknown(if_id, icmp_type)
N#endif
N
N/**
N  \brief  Event on ICMP send echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_SendEchoRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_SendEchoRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_SendEchoRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (13 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_SendEchoRequest(if_id)
N#endif
N
N// ICMP ping client event recorder functions -----------------------------------
N
N/**
N  \brief  Event on Ping client initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingInit(void) {
N    EventRecord2 (EvtNetICMP_PingInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (14 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingInit()
N#endif
N
N/**
N  \brief  Event on Ping echo request (API)
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingEcho(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingEcho(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetICMP_PingEcho, ip4_addr, 4);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (15 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetICMP_PingEcho(ip4_addr)
N#endif
N
N/**
N  \brief  Event on Ping target name not valid (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingTargetNotValid(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingTargetNotValid(void) {
N    EventRecord2 (EvtNetICMP_PingTargetNotValid, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingTargetNotValid()
N#endif
N
N/**
N  \brief  Event on Ping host name resolver error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingDnsError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingDnsError(void) {
N    EventRecord2 (EvtNetICMP_PingDnsError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (17 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingDnsError()
N#endif
N
N/**
N  \brief  Event on Ping invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingInvalidParameter(void) {
N    EventRecord2 (EvtNetICMP_PingInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingInvalidParameter()
N#endif
N
N/**
N  \brief  Event on Ping client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingClientBusy(void) {
N    EventRecord2 (EvtNetICMP_PingClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (19 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingClientBusy()
N#endif
N
N/**
N  \brief  Event on Ping send echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingSendRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingSendRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_PingSendRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (20 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_PingSendRequest(if_id)
N#endif
N
N/**
N  \brief  Event on Ping retransmit echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingRetransmitRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingRetransmitRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_PingRetransmitRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (21 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_PingRetransmitRequest(if_id)
N#endif
N
N/**
N  \brief  Event on Ping client timeout (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingTimeout(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingTimeout(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP_PingTimeout, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (22 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP_PingTimeout(if_id)
N#endif
N
N/**
N  \brief  Event on Ping client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP_PingUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP_PingUninit(void) {
N    EventRecord2 (EvtNetICMP_PingUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC7 & 0xFFU) << 8) | (23 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP_PingUninit()
N#endif
N
N
N// NetIGMP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetIGMP_InitManager              EventID (EventLevelOp,    EvtNetIGMP,  0)
N#define EvtNetIGMP_Join                     EventID (EventLevelAPI,   EvtNetIGMP,  1)
N#define EvtNetIGMP_AlreadyInGroup           EventID (EventLevelOp,    EvtNetIGMP,  2)
N#define EvtNetIGMP_NoFreeEntries            EventID (EventLevelError, EvtNetIGMP,  3)
N#define EvtNetIGMP_SendReport               EventID (EventLevelOp,    EvtNetIGMP,  4)
N#define EvtNetIGMP_Leave                    EventID (EventLevelAPI,   EvtNetIGMP,  5)
N#define EvtNetIGMP_NotInGroup               EventID (EventLevelError, EvtNetIGMP,  6)
N#define EvtNetIGMP_SendLeave                EventID (EventLevelOp,    EvtNetIGMP,  7)
N#define EvtNetIGMP_ReceiveFrame             EventID (EventLevelOp,    EvtNetIGMP,  8)
N#define EvtNetIGMP_FrameTooShort            EventID (EventLevelError, EvtNetIGMP,  9)
N#define EvtNetIGMP_ChecksumFailed           EventID (EventLevelError, EvtNetIGMP, 10)
N#define EvtNetIGMP_GroupSpecificQuery       EventID (EventLevelOp,    EvtNetIGMP, 11)
N#define EvtNetIGMP_DestAddressWrong         EventID (EventLevelError, EvtNetIGMP, 12)
N#define EvtNetIGMP_DelayedReportScheduled   EventID (EventLevelOp,    EvtNetIGMP, 13)
N#define EvtNetIGMP_GeneralQuery             EventID (EventLevelOp,    EvtNetIGMP, 14)
N#define EvtNetIGMP_StartModeIGMPv1          EventID (EventLevelOp,    EvtNetIGMP, 15)
N#define EvtNetIGMP_MaxTimeForReport         EventID (EventLevelOp,    EvtNetIGMP, 16)
N#define EvtNetIGMP_GroupReportsScheduled    EventID (EventLevelOp,    EvtNetIGMP, 17)
N#define EvtNetIGMP_ReportReceived           EventID (EventLevelOp,    EvtNetIGMP, 18)
N#define EvtNetIGMP_OwnReportCanceled        EventID (EventLevelOp,    EvtNetIGMP, 19)
N#define EvtNetIGMP_StartModeIGMPv2          EventID (EventLevelOp,    EvtNetIGMP, 20)
N#define EvtNetIGMP_SendDelayedReport        EventID (EventLevelOp,    EvtNetIGMP, 21)
N#define EvtNetIGMP_UninitManager            EventID (EventLevelOp,    EvtNetIGMP, 22)
N#endif
N
N/**
N  \brief  Event on IGMP manager initialize (Op)
N  \param  if_id         network interface identifier
N  \param  num_entries   number of entries available in membership table
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_InitManager(uint16_t if_id, uint32_t num_entries) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_InitManager(uint16_t if_id, uint32_t num_entries) {
N    EventRecord2 (EvtNetIGMP_InitManager, if_id, num_entries);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (0 & 0xFFU)), if_id, num_entries);
N  }
N#else
S  #define EvrNetIGMP_InitManager(if_id, num_entries)
N#endif
N
N/**
N  \brief  Event on IGMP join group membership (API)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_Join(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_Join(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_Join, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (1 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_Join(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP join already a member (Op)
N  \param  if_id         network interface identifier
N  \param  group_id      group membership identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_AlreadyInGroup(uint16_t if_id, uint8_t group_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_AlreadyInGroup(uint16_t if_id, uint8_t group_id) {
N    EventRecord2 (EvtNetIGMP_AlreadyInGroup, if_id, group_id);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (2 & 0xFFU)), if_id, group_id);
N  }
N#else
S  #define EvrNetIGMP_AlreadyInGroup(if_id, group_id)
N#endif
N
N/**
N  \brief  Event on IGMP join no free entries available (Error)
N  \param  if_id         network interface identifier
N  \param  num_used      number of used membership table entries
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_NoFreeEntries(uint16_t if_id, uint8_t num_used) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_NoFreeEntries(uint16_t if_id, uint8_t num_used) {
N    EventRecord2 (EvtNetIGMP_NoFreeEntries, if_id, num_used);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (3 & 0xFFU)), if_id, num_used);
N  }
N#else
S  #define EvrNetIGMP_NoFreeEntries(if_id, num_used)
N#endif
N
N/**
N  \brief  Event on IGMP send report message (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_SendReport(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_SendReport(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_SendReport, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (4 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_SendReport(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP leave group membership (API)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_Leave(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_Leave(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_Leave, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (5 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_Leave(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP leave not a member (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_NotInGroup(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_NotInGroup(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_NotInGroup, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (6 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_NotInGroup(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP send leave message (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_SendLeave(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_SendLeave(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_SendLeave, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (7 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_SendLeave(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  message_type  type of received message
N  \param  length        length of received message
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_ReceiveFrame(uint16_t if_id, uint8_t message_type, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_ReceiveFrame(uint16_t if_id, uint8_t message_type, uint32_t length) {
N    uint32_t val1 = ((uint32_t)message_type << 16) | if_id;
N    EventRecord2 (EvtNetIGMP_ReceiveFrame, val1, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (8 & 0xFFU)), val1, length);
N  }
N#else
S  #define EvrNetIGMP_ReceiveFrame(if_id, message_type, length)
N#endif
N
N/**
N  \brief  Event on IGMP receive frame is too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetIGMP_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (9 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetIGMP_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on IGMP frame checksum check failed (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_ChecksumFailed(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_ChecksumFailed(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetIGMP_ChecksumFailed, if_id, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (10 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetIGMP_ChecksumFailed(if_id, length)
N#endif
N
N/**
N  \brief  Event on IGMPv2 group specific query (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_GroupSpecificQuery(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_GroupSpecificQuery(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_GroupSpecificQuery, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (11 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_GroupSpecificQuery(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMPv2 destination address wrong (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_DestAddressWrong(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_DestAddressWrong(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_DestAddressWrong, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (12 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_DestAddressWrong(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMPv2 report message delayed (Op)
N  \param  if_id         network interface identifier
N  \param  max_time      maximum delay time in 100 ms ticks
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_DelayedReportScheduled(uint16_t if_id, uint8_t max_time) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_DelayedReportScheduled(uint16_t if_id, uint8_t max_time) {
N    EventRecord2 (EvtNetIGMP_DelayedReportScheduled, if_id, max_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (13 & 0xFFU)), if_id, max_time);
N  }
N#else
S  #define EvrNetIGMP_DelayedReportScheduled(if_id, max_time)
N#endif
N
N/**
N  \brief  Event on IGMPv1 general query (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_GeneralQuery(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_GeneralQuery(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_GeneralQuery, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (14 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_GeneralQuery(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on start IGMPv1 mode (Op)
N  \param  if_id         network interface identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_StartModeIGMPv1(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_StartModeIGMPv1(uint16_t if_id) {
N    EventRecord2 (EvtNetIGMP_StartModeIGMPv1, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (15 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIGMP_StartModeIGMPv1(if_id)
N#endif
N
N/**
N  \brief  Event on IGMPv2 maximum time for report messages (Op)
N  \param  if_id         network interface identifier
N  \param  max_time      maximum delay time in 100 ms ticks
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_MaxTimeForReport(uint16_t if_id, uint8_t max_time) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_MaxTimeForReport(uint16_t if_id, uint8_t max_time) {
N    EventRecord2 (EvtNetIGMP_MaxTimeForReport, if_id, max_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (16 & 0xFFU)), if_id, max_time);
N  }
N#else
S  #define EvrNetIGMP_MaxTimeForReport(if_id, max_time)
N#endif
N
N/**
N  \brief  Event on IGMP scheduled reports for all active groups (Op)
N  \param  if_id         network interface identifier
N  \param  n_reports     number of scheduled reports
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_GroupReportsScheduled(uint16_t if_id, uint32_t n_reports) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_GroupReportsScheduled(uint16_t if_id, uint32_t n_reports) {
N    EventRecord2 (EvtNetIGMP_GroupReportsScheduled, if_id, n_reports);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (17 & 0xFFU)), if_id, n_reports);
N  }
N#else
S  #define EvrNetIGMP_GroupReportsScheduled(if_id, n_reports)
N#endif
N
N/**
N  \brief  Event on IGMP received report message (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_ReportReceived(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_ReportReceived(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_ReportReceived, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (18 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_ReportReceived(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on own report canceled (Op)
N  \param  if_id         network interface identifier
N  \param  group_id      group membership identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_OwnReportCanceled(uint16_t if_id, uint8_t group_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_OwnReportCanceled(uint16_t if_id, uint8_t group_id) {
N    EventRecord2 (EvtNetIGMP_OwnReportCanceled, if_id, group_id);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (19 & 0xFFU)), if_id, group_id);
N  }
N#else
S  #define EvrNetIGMP_OwnReportCanceled(if_id, group_id)
N#endif
N
N/**
N  \brief  Event on start IGMPv2 mode (Op)
N  \param  if_id         network interface identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_StartModeIGMPv2(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_StartModeIGMPv2(uint16_t if_id) {
N    EventRecord2 (EvtNetIGMP_StartModeIGMPv2, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (20 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIGMP_StartModeIGMPv2(if_id)
N#endif
N
N/**
N  \brief  Event on IGMP send delayed report message (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a group
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_SendDelayedReport(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_SendDelayedReport(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetIGMP_SendDelayedReport, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (21 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetIGMP_SendDelayedReport(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on IGMP manager de-initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIGMP_UninitManager(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIGMP_UninitManager(uint16_t if_id) {
N    EventRecord2 (EvtNetIGMP_UninitManager, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC8 & 0xFFU) << 8) | (22 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIGMP_UninitManager(if_id)
N#endif
N
N
N// NetNBNS event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetNBNS_InitService              EventID (EventLevelOp,    EvtNetNBNS, 0)
N#define EvtNetNBNS_GetSocketFailed          EventID (EventLevelError, EvtNetNBNS, 1)
N#define EvtNetNBNS_ReceiveFrame             EventID (EventLevelOp,    EvtNetNBNS, 2)
N#define EvtNetNBNS_WrongRemotePort          EventID (EventLevelError, EvtNetNBNS, 3)
N#define EvtNetNBNS_FrameTooShort            EventID (EventLevelError, EvtNetNBNS, 4)
N#define EvtNetNBNS_NetBiosDisabled          EventID (EventLevelOp,    EvtNetNBNS, 9) // End
N#define EvtNetNBNS_NameQueryRequest         EventID (EventLevelOp,    EvtNetNBNS, 5)
N#define EvtNetNBNS_QueryFromAddress         EventID (EventLevelDetail,EvtNetNBNS, 6)
N#define EvtNetNBNS_NameQueryResponse        EventID (EventLevelOp,    EvtNetNBNS, 7)
N#define EvtNetNBNS_UninitService            EventID (EventLevelOp,    EvtNetNBNS, 8)
N#endif
N
N/**
N  \brief  Event on NBNS name service initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_InitService(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_InitService(uint16_t if_id) {
N    EventRecord2 (EvtNetNBNS_InitService, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (0 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNBNS_InitService(if_id)
N#endif
N
N/**
N  \brief  Event on NBNS failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_GetSocketFailed(void) {
N    EventRecord2 (EvtNetNBNS_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetNBNS_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on NBNS receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetNBNS_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (2 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetNBNS_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on NBNS wrong remote UDP port (Error)
N  \param  if_id         network interface identifier
N  \param  port          received remote port number
N  \param  port_valid    valid remote port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_WrongRemotePort(uint16_t if_id, uint16_t port, uint16_t port_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_WrongRemotePort(uint16_t if_id, uint16_t port, uint16_t port_valid) {
N    uint32_t val2 = ((uint32_t)port_valid << 16) | port;
N    EventRecord2 (EvtNetNBNS_WrongRemotePort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (3 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetNBNS_WrongRemotePort(if_id, port, port_valid)
N#endif
N
N/**
N  \brief  Event on NBNS receive frame is too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetNBNS_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (4 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetNBNS_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on NBNS receive frame for NetBIOS disabled (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_NetBiosDisabled(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_NetBiosDisabled(uint16_t if_id) {
N    EventRecord2 (EvtNetNBNS_NetBiosDisabled, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (9 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNBNS_NetBiosDisabled(if_id)
N#endif
N
N/**
N  \brief  Event on NBNS name query request received (Op)
N  \param  q_name        pointer to a question name string
N  \param  length        length of the question name string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_NameQueryRequest(const char *q_name, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_NameQueryRequest(const char *q_name, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetNBNS_NameQueryRequest, q_name, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (5 & 0xFFU)), q_name, length);
N  }
N#else
S  #define EvrNetNBNS_NameQueryRequest(q_name, length)
N#endif
N
N/**
N  \brief  Event on NBNS name query from IP-address (Detail)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of a host
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_QueryFromAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_QueryFromAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetNBNS_QueryFromAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (6 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetNBNS_QueryFromAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on NBNS response to a name query (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to local IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_NameQueryResponse(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_NameQueryResponse(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetNBNS_NameQueryResponse, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (7 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetNBNS_NameQueryResponse(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on NBNS name service de-initialize (Op)
N  \param  if_id         network interface identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNBNS_UninitService(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNBNS_UninitService(uint16_t if_id) {
N    EventRecord2 (EvtNetNBNS_UninitService, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xC9 & 0xFFU) << 8) | (8 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNBNS_UninitService(if_id)
N#endif
N
N
N// NetDHCP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetDHCP_InitClient               EventID (EventLevelOp,    EvtNetDHCP,  0)
N#define EvtNetDHCP_GetSocketFailed          EventID (EventLevelError, EvtNetDHCP,  1)
N#define EvtNetDHCP_StartClient              EventID (EventLevelOp,    EvtNetDHCP,  2)
N#define EvtNetDHCP_StopClient               EventID (EventLevelOp,    EvtNetDHCP,  3)
N#define EvtNetDHCP_ClientState              EventID (EventLevelOp,    EvtNetDHCP,  4)
N#define EvtNetDHCP_NextState                EventID (EventLevelOp,    EvtNetDHCP,  5)
N#define EvtNetDHCP_StateRetransmit          EventID (EventLevelOp,    EvtNetDHCP,  6)
N#define EvtNetDHCP_ChangeStateOnTimeout     EventID (EventLevelOp,    EvtNetDHCP,  7)
N#define EvtNetDHCP_AutoIpAddressProbe       EventID (EventLevelOp,    EvtNetDHCP,  8)
N#define EvtNetDHCP_AutoIpSuccess            EventID (EventLevelOp,    EvtNetDHCP,  9)
N#define EvtNetDHCP_T2Expired                EventID (EventLevelOp,    EvtNetDHCP, 10)
N#define EvtNetDHCP_LeaseExpired             EventID (EventLevelError, EvtNetDHCP, 11)
N#define EvtNetDHCP_SendDhcpMessage          EventID (EventLevelOp,    EvtNetDHCP, 12)
N#define EvtNetDHCP_ReceiveFrame             EventID (EventLevelOp,    EvtNetDHCP, 13)
N#define EvtNetDHCP_WrongServerPort          EventID (EventLevelError, EvtNetDHCP, 14)
N#define EvtNetDHCP_FrameTooShort            EventID (EventLevelError, EvtNetDHCP, 15)
N#define EvtNetDHCP_MisformedReply           EventID (EventLevelError, EvtNetDHCP, 16)
N#define EvtNetDHCP_WrongTransactionId       EventID (EventLevelError, EvtNetDHCP, 17)
N#define EvtNetDHCP_WrongClientHwAddress     EventID (EventLevelError, EvtNetDHCP, 18)
N#define EvtNetDHCP_WrongMagicCookie         EventID (EventLevelError, EvtNetDHCP, 19)
N#define EvtNetDHCP_InvalidMessageType       EventID (EventLevelOp,    EvtNetDHCP, 20)
N#define EvtNetDHCP_ShowMessage              EventID (EventLevelOp,    EvtNetDHCP, 21)
N#define EvtNetDHCP_FileOverloadOptions      EventID (EventLevelDetail,EvtNetDHCP, 22)
N#define EvtNetDHCP_SnameOverloadOptions     EventID (EventLevelDetail,EvtNetDHCP, 23)
N#define EvtNetDHCP_MissingServerId          EventID (EventLevelOp,    EvtNetDHCP, 24)
N#define EvtNetDHCP_ForwardedMessage         EventID (EventLevelOp,    EvtNetDHCP, 25)
N#define EvtNetDHCP_RelayAgentAddressInvalid EventID (EventLevelError, EvtNetDHCP, 26)
N#define EvtNetDHCP_ShowRelayAgentAddress    EventID (EventLevelDetail,EvtNetDHCP, 27)
N#define EvtNetDHCP_ShowOfferedAddress       EventID (EventLevelOp,    EvtNetDHCP, 28)
N#define EvtNetDHCP_ServerAddressNotSelected EventID (EventLevelOp,    EvtNetDHCP, 29)
N#define EvtNetDHCP_AssignedAddrNotRequested EventID (EventLevelOp,    EvtNetDHCP, 30)
N#define EvtNetDHCP_ShowAssignedAddress      EventID (EventLevelOp,    EvtNetDHCP, 31)
N#define EvtNetDHCP_ShowServerId             EventID (EventLevelOp,    EvtNetDHCP, 32)
N#define EvtNetDHCP_ShowNetMask              EventID (EventLevelOp,    EvtNetDHCP, 33)
N#define EvtNetDHCP_ShowGatewayAddress       EventID (EventLevelOp,    EvtNetDHCP, 34)
N#define EvtNetDHCP_ShowDnsServers           EventID (EventLevelOp,    EvtNetDHCP, 35)
N#define EvtNetDHCP_ShowLeaseTime            EventID (EventLevelOp,    EvtNetDHCP, 36)
N#define EvtNetDHCP_ShowTimeT1               EventID (EventLevelOp,    EvtNetDHCP, 37)
N#define EvtNetDHCP_ShowTimeT2               EventID (EventLevelOp,    EvtNetDHCP, 38)
N#define EvtNetDHCP_ShowBootfileName         EventID (EventLevelOp,    EvtNetDHCP, 39)
N#define EvtNetDHCP_ShowNtpServerList        EventID (EventLevelOp,    EvtNetDHCP, 40)
N#define EvtNetDHCP_SetOptionInvalidParam    EventID (EventLevelError, EvtNetDHCP, 41)
N#define EvtNetDHCP_SetOptionInvalidState    EventID (EventLevelError, EvtNetDHCP, 42)
N#define EvtNetDHCP_SetOptionClientIdDefault EventID (EventLevelAPI,   EvtNetDHCP, 43)
N#define EvtNetDHCP_SetOptionClientId        EventID (EventLevelAPI,   EvtNetDHCP, 44)
N#define EvtNetDHCP_UninitClient             EventID (EventLevelOp,    EvtNetDHCP, 45)
N#endif
N
N/**
N  \brief  Event on DHCP client initialize (Op)
N  \param  if_id         network interface identifier
N  \param  bootfile      Bootfile name option enabled
N  \param  ntp_servers   NTP servers list option enabled
N  \param  vcid          Vendor Class Identifier option enabled
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_InitClient(uint16_t if_id, uint8_t bootfile,
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_InitClient(uint16_t if_id, uint8_t bootfile,
N                                             uint8_t ntp_servers, uint8_t vcid) {
N    uint32_t val2 = ((uint32_t)bootfile << 2) | (ntp_servers << 1) | vcid;
N    EventRecord2 (EvtNetDHCP_InitClient, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (0 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_InitClient(if_id, bootfile, ntp_servers, vcid)
N#endif
N
N/**
N  \brief  Event on DHCP failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_GetSocketFailed(void) {
N    EventRecord2 (EvtNetDHCP_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDHCP_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on DHCP client start (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_StartClient(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_StartClient(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_StartClient, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (2 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_StartClient(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP client stop (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_StopClient(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_StopClient(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_StopClient, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (3 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_StopClient(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP indication of client state (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ClientState(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ClientState(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_ClientState, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (4 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_ClientState(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP transition to next state (Op)
N  \param  if_id         network interface identifier
N  \param  state         next state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_NextState(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_NextState(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_NextState, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (5 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_NextState(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP retransmit in current state (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_StateRetransmit(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_StateRetransmit(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_StateRetransmit, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (6 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_StateRetransmit(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP state timeout and transit to next state (Op)
N  \param  if_id         network interface identifier
N  \param  current       current state
N  \param  next          next state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ChangeStateOnTimeout(uint16_t if_id, uint8_t current, uint8_t next) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ChangeStateOnTimeout(uint16_t if_id, uint8_t current, uint8_t next) {
N    uint32_t val2 = ((uint32_t)next << 16) | current;
N    EventRecord2 (EvtNetDHCP_ChangeStateOnTimeout, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (7 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_ChangeStateOnTimeout(if_id, current, next)
N#endif
N
N/**
N  \brief  Event on DHCP address probe for AutoIP mode (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_AutoIpAddressProbe(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_AutoIpAddressProbe(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_AutoIpAddressProbe, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (8 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_AutoIpAddressProbe(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP assign AutoIP address success (Op)
N  \param  if_id         network interface identifier
N  \param  auto_lm       pointer to assigned AutoIP address and network mask
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_AutoIpSuccess(uint16_t if_id, const uint8_t *auto_lm) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_AutoIpSuccess(uint16_t if_id, const uint8_t *auto_lm) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], auto_lm, 8);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], auto_lm, 8);
N    EventRecordData (EvtNetDHCP_AutoIpSuccess, &evr_buf, 12);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (9 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 12);
N  }
N#else
S  #define EvrNetDHCP_AutoIpSuccess(if_id, auto_lm)
N#endif
N
N/**
N  \brief  Event on DHCP timer T2 expired (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_T2Expired(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_T2Expired(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_T2Expired, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (10 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_T2Expired(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP address lease time expired (Error)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_LeaseExpired(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_LeaseExpired(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_LeaseExpired, if_id, state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (11 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_LeaseExpired(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP send message (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N  \param  broadcast     broadcast the message
N                         - 0: no
N                         - 1: yes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SendDhcpMessage(uint16_t if_id, uint8_t msg_type, uint8_t broadcast) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SendDhcpMessage(uint16_t if_id, uint8_t msg_type, uint8_t broadcast) {
N    uint32_t val2 = ((uint32_t)broadcast << 16) | msg_type;
N    EventRecord2 (EvtNetDHCP_SendDhcpMessage, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (12 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_SendDhcpMessage(if_id, msg_type, broadcast)
N#endif
N
N/**
N  \brief  Event on DHCP receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address of the server
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ReceiveFrame(uint16_t if_id, const uint8_t *ip4_addr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ReceiveFrame(uint16_t if_id, const uint8_t *ip4_addr, uint32_t length) {
N    uint32_t val1 = (length << 16) | if_id;
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ReceiveFrame, val1, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (13 & 0xFFU)), val1, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ReceiveFrame(if_id, ip4_addr, length)
N#endif
N
N/**
N  \brief  Event on DHCP wrong server UDP port (Error)
N  \param  if_id         network interface identifier
N  \param  port          received server port number
N  \param  port_valid    valid server port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_WrongServerPort(uint16_t if_id, uint16_t port, uint16_t port_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_WrongServerPort(uint16_t if_id, uint16_t port, uint16_t port_valid) {
N    uint32_t val2 = ((uint32_t)port_valid << 16) | port;
N    EventRecord2 (EvtNetDHCP_WrongServerPort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (14 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_WrongServerPort(if_id, port, port_valid)
N#endif
N
N/**
N  \brief  Event on DHCP receive frame too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetDHCP_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (15 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on DHCP receive misformed reply (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_MisformedReply(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_MisformedReply(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_MisformedReply, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (16 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_MisformedReply(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP receive wrong transaction identifier (Error)
N  \param  if_id         network interface identifier
N  \param  xid           received transaction identifier
N  \param  xid_valid     valid transaction identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_WrongTransactionId(uint16_t if_id, uint32_t xid, uint32_t xid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_WrongTransactionId(uint16_t if_id, uint32_t xid, uint32_t xid_valid) {
N    EventRecord4 (EvtNetDHCP_WrongTransactionId, if_id, xid, xid_valid, 0);
X    EventRecord4 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (17 & 0xFFU)), if_id, xid, xid_valid, 0);
N  }
N#else
S  #define EvrNetDHCP_WrongTransactionId(if_id, xid, xid_valid)
N#endif
N
N/**
N  \brief  Event on DHCP receive wrong Client Hardware Address (Error)
N  \param  if_id         network interface identifier
N  \param  chaddr        pointer to received chaddr address (MAC)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_WrongClientHwAddress(uint16_t if_id, const uint8_t *chaddr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_WrongClientHwAddress(uint16_t if_id, const uint8_t *chaddr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], chaddr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], chaddr, 6);
N    EventRecordData (EvtNetDHCP_WrongClientHwAddress, &evr_buf, 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (18 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetDHCP_WrongClientHwAddress(if_id, chaddr)
N#endif
N
N/**
N  \brief  Event on DHCP receive wrong BOOTP Magic Cookie (Error)
N  \param  if_id         network interface identifier
N  \param  cookie        received magic cookie
N  \param  cookie_valid  valid magic cookie
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_WrongMagicCookie(uint16_t if_id, uint32_t cookie, uint32_t cookie_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_WrongMagicCookie(uint16_t if_id, uint32_t cookie, uint32_t cookie_valid) {
N    EventRecord4 (EvtNetDHCP_WrongMagicCookie, if_id, cookie, cookie_valid, 0);
X    EventRecord4 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (19 & 0xFFU)), if_id, cookie, cookie_valid, 0);
N  }
N#else
S  #define EvrNetDHCP_WrongMagicCookie(if_id, cookie, cookie_valid)
N#endif
N
N/**
N  \brief  Event on DHCP receive invalid message type (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \param  msg_valid     valid message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_InvalidMessageType(uint16_t if_id, uint8_t msg_type, uint8_t msg_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_InvalidMessageType(uint16_t if_id, uint8_t msg_type, uint8_t msg_valid) {
N    uint32_t val2 = ((uint32_t)msg_valid << 16) | msg_type;
N    EventRecord2 (EvtNetDHCP_InvalidMessageType, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (20 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_InvalidMessageType(if_id, msg_type, msg_valid)
N#endif
N
N/**
N  \brief  Event on DHCP display message type (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowMessage(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowMessage(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP_ShowMessage, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (21 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP_ShowMessage(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP receive options overloaded to "File" field (Detail)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_FileOverloadOptions(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_FileOverloadOptions(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP_FileOverloadOptions, if_id, msg_type);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (22 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP_FileOverloadOptions(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP receive options overloaded to "Sname" field (Detail)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SnameOverloadOptions(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SnameOverloadOptions(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP_SnameOverloadOptions, if_id, msg_type);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (23 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP_SnameOverloadOptions(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP receive message with no Server ID (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_MissingServerId(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_MissingServerId(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP_MissingServerId, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (24 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP_MissingServerId(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP receive forwarded message (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ForwardedMessage(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ForwardedMessage(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP_ForwardedMessage, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (25 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP_ForwardedMessage(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP receive message from invalid Relay Agent (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_RelayAgentAddressInvalid(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_RelayAgentAddressInvalid(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_RelayAgentAddressInvalid, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (26 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_RelayAgentAddressInvalid(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP display relay agent IP address (Detail)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowRelayAgentAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowRelayAgentAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ShowRelayAgentAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (27 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowRelayAgentAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP display offered IP address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowOfferedAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowOfferedAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ShowOfferedAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (28 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowOfferedAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP receive message from not selected server (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ServerAddressNotSelected(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ServerAddressNotSelected(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ServerAddressNotSelected, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (29 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ServerAddressNotSelected(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP receive wrong assigned IP address in DHCP_ACK (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_AssignedAddrNotRequested(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_AssignedAddrNotRequested(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_AssignedAddrNotRequested, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (30 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_AssignedAddrNotRequested(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP display assigned IP address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowAssignedAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowAssignedAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ShowAssignedAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (31 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowAssignedAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP display Server Identifier (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowServerId(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowServerId(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ShowServerId, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (32 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowServerId(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP display Network Mask (Op)
N  \param  if_id         network interface identifier
N  \param  net_mask      pointer to network mask
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowNetMask(uint16_t if_id, const uint8_t *net_mask) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowNetMask(uint16_t if_id, const uint8_t *net_mask) {
N    memcpy (&evr_buf.u32[0], net_mask, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], net_mask, 4);
N    EventRecord2 (EvtNetDHCP_ShowNetMask, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (33 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowNetMask(if_id, net_mask)
N#endif
N
N/**
N  \brief  Event on DHCP display gateway IPv4 address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IPv4 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowGatewayAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowGatewayAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetDHCP_ShowGatewayAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (34 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetDHCP_ShowGatewayAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on DHCP display DNS server addresses (Op)
N  \param  if_id         network interface identifier
N  \param  dns_list      pointer to DNS server address list
N  \remark Displays primary and secondary DNS server address.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowDnsServers(uint16_t if_id, const uint8_t *dns_list) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowDnsServers(uint16_t if_id, const uint8_t *dns_list) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], dns_list, 8);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], dns_list, 8);
N    EventRecordData (EvtNetDHCP_ShowDnsServers, &evr_buf, 12);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (35 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 12);
N  }
N#else
S  #define EvrNetDHCP_ShowDnsServers(if_id, dns_list)
N#endif
N
N/**
N  \brief  Event on DHCP display address lease time (Op)
N  \param  if_id         network interface identifier
N  \param  lease_time    lease time in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowLeaseTime(uint16_t if_id, uint32_t lease_time) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowLeaseTime(uint16_t if_id, uint32_t lease_time) {
N    EventRecord2 (EvtNetDHCP_ShowLeaseTime, if_id, lease_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (36 & 0xFFU)), if_id, lease_time);
N  }
N#else
S  #define EvrNetDHCP_ShowLeaseTime(if_id, lease_time)
N#endif
N
N/**
N  \brief  Event on DHCP display renewal time T1 (Op)
N  \param  if_id         network interface identifier
N  \param  t1_time       t1 time in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowTimeT1(uint16_t if_id, uint32_t t1_time) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowTimeT1(uint16_t if_id, uint32_t t1_time) {
N    EventRecord2 (EvtNetDHCP_ShowTimeT1, if_id, t1_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (37 & 0xFFU)), if_id, t1_time);
N  }
N#else
S  #define EvrNetDHCP_ShowTimeT1(if_id, t1_time)
N#endif
N
N/**
N  \brief  Event on DHCP display rebinding time T2 (Op)
N  \param  if_id         network interface identifier
N  \param  t2_time       t2 time in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowTimeT2(uint16_t if_id, uint32_t t2_time) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowTimeT2(uint16_t if_id, uint32_t t2_time) {
N    EventRecord2 (EvtNetDHCP_ShowTimeT2, if_id, t2_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (38 & 0xFFU)), if_id, t2_time);
N  }
N#else
S  #define EvrNetDHCP_ShowTimeT2(if_id, t2_time)
N#endif
N
N/**
N  \brief  Event on DHCP display Bootfile Name (Op)
N  \param  bootfile      bootfile name string
N  \param  length        length of the bootfile name string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowBootfileName(const uint8_t *bootfile, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowBootfileName(const uint8_t *bootfile, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData (EvtNetDHCP_ShowBootfileName, bootfile, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (39 & 0xFFU)), bootfile, length);
N  }
N#else
S  #define EvrNetDHCP_ShowBootfileName(bootfile, length)
N#endif
N
N/**
N  \brief  Event on DHCP display list of NTP server addresses (Op)
N  \param  if_id         network interface identifier
N  \param  ntp_list      pointer to an array of NTP server IP addresses
N  \param  length        length of an array in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_ShowNtpServerList(uint16_t if_id, const uint8_t *ntp_list, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_ShowNtpServerList(uint16_t if_id, const uint8_t *ntp_list, uint32_t length) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u16[1] = (uint16_t)(length > 12 ? 12 : length);
X    (*(union evr_access *)&net_dbg_buf).u16[1] = (uint16_t)(length > 12 ? 12 : length);
N    memcpy (&evr_buf.u16[2], ntp_list, evr_buf.u16[1]); 
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[2], ntp_list, (*(union evr_access *)&net_dbg_buf).u16[1]); 
N    EventRecordData (EvtNetDHCP_ShowNtpServerList, &evr_buf, evr_buf.u16[1]);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (40 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), (*(union evr_access *)&net_dbg_buf).u16[1]);
N  }
N#else
S  #define EvrNetDHCP_ShowNtpServerList(if_id, ntp_list, length)
N#endif
N
N/**
N  \brief  Event on DHCP set_option invalid parameter (Error)
N  \param  if_id         network interface identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SetOptionInvalidParam(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SetOptionInvalidParam(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_SetOptionInvalidParam, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (41 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_SetOptionInvalidParam(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP set_option invalid client state (Error)
N  \param  if_id         network interface identifier
N  \param  state         DHCP client state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SetOptionInvalidState(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SetOptionInvalidState(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP_SetOptionInvalidState, if_id, state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (42 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP_SetOptionInvalidState(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP set_option with default Client-identifier (API)
N  \param  if_id         network interface identifier
N  \param  type          hardware type
N                         - 0:   Generic,
N                         - 1:   Ethernet,
N                         - 255: IANA.
N  \remark Default DHCP Client-identifier is ethernet MAC address.
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SetOptionClientIdDefault(uint16_t if_id, uint8_t type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SetOptionClientIdDefault(uint16_t if_id, uint8_t type) {
N    EventRecord2 (EvtNetDHCP_SetOptionClientIdDefault, if_id, type);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (43 & 0xFFU)), if_id, type);
N  }
N#else
S  #define EvrNetDHCP_SetOptionClientIdDefault(if_id, type)
N#endif
N
N/**
N  \brief  Event on DHCP set_option with user Client-identifier (API)
N  \param  if_id         network interface identifier
N  \param  type          hardware type
N                         - 0:   Generic,
N                         - 1:   Ethernet,
N                         - 255: IANA.
N  \param  length        length of DHCP option including hardware type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_SetOptionClientId(uint16_t if_id, uint8_t type, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_SetOptionClientId(uint16_t if_id, uint8_t type, uint32_t length) {
N    uint32_t val2 = ((uint32_t)type << 16) | length;
N    EventRecord2 (EvtNetDHCP_SetOptionClientId, if_id, val2);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (44 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP_SetOptionClientId(if_id, type, length)
N#endif
N
N/**
N  \brief  Event on DHCP client de-initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP_UninitClient(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP_UninitClient(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP_UninitClient, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCA & 0xFFU) << 8) | (45 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP_UninitClient(if_id)
N#endif
N
N
N// NetARP event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetARP_InitCache                 EventID (EventLevelOp,    EvtNetARP,  0)
N#define EvtNetARP_ReceiveFrame              EventID (EventLevelOp,    EvtNetARP,  1)
N#define EvtNetARP_FrameTooShort             EventID (EventLevelError, EvtNetARP,  2)
N#define EvtNetARP_FrameCorrupted            EventID (EventLevelError, EvtNetARP,  3)
N#define EvtNetARP_ShowFrameHeader           EventID (EventLevelDetail,EvtNetARP,  4)
N#define EvtNetARP_SenderAddressInvalid      EventID (EventLevelOp,    EvtNetARP,  5)
N#define EvtNetARP_CacheEntryUpdate          EventID (EventLevelOp,    EvtNetARP,  6)
N#define EvtNetARP_ProbeResponseReceived     EventID (EventLevelOp,    EvtNetARP,  7)
N#define EvtNetARP_WrongIpAddress            EventID (EventLevelOp,    EvtNetARP,  8)
N#define EvtNetARP_WrongMacAddress           EventID (EventLevelOp,    EvtNetARP,  9)
N#define EvtNetARP_OpcodeUnknown             EventID (EventLevelOp,    EvtNetARP, 10)
N#define EvtNetARP_SendReply                 EventID (EventLevelOp,    EvtNetARP, 11)
N#define EvtNetARP_CacheEntryRefreshed       EventID (EventLevelOp,    EvtNetARP, 12)
N#define EvtNetARP_WrongResponse             EventID (EventLevelError, EvtNetARP, 13)
N#define EvtNetARP_SendRequest               EventID (EventLevelOp,    EvtNetARP, 14)
N#define EvtNetARP_CacheAllocFailed          EventID (EventLevelError, EvtNetARP, 15)
N#define EvtNetARP_CacheIpRefreshed          EventID (EventLevelOp,    EvtNetARP, 16)
N#define EvtNetARP_CacheAdd                  EventID (EventLevelOp,    EvtNetARP, 17)
N#define EvtNetARP_GatewayUnknown            EventID (EventLevelError, EvtNetARP, 18)
N#define EvtNetARP_CacheEntryAdded           EventID (EventLevelOp,    EvtNetARP, 19)
N#define EvtNetARP_CacheEarly                EventID (EventLevelOp,    EvtNetARP, 20)
N#define EvtNetARP_CacheFind                 EventID (EventLevelOp,    EvtNetARP, 21)
N#define EvtNetARP_UsingGateway              EventID (EventLevelOp,    EvtNetARP, 22)
N#define EvtNetARP_UnresolvedMacAddress      EventID (EventLevelError, EvtNetARP, 23)
N#define EvtNetARP_EntryFound                EventID (EventLevelOp,    EvtNetARP, 24)
N#define EvtNetARP_CacheIp                   EventID (EventLevelAPI,   EvtNetARP, 25)
N#define EvtNetARP_CacheIpInvalidParameter   EventID (EventLevelError, EvtNetARP, 26)
N#define EvtNetARP_CacheMac                  EventID (EventLevelAPI,   EvtNetARP, 27)
N#define EvtNetARP_CacheMacInvalidParameter  EventID (EventLevelError, EvtNetARP, 28)
N#define EvtNetARP_UnresolvedIpAddress       EventID (EventLevelError, EvtNetARP, 29)
N#define EvtNetARP_GetIp                     EventID (EventLevelAPI,   EvtNetARP, 30)
N#define EvtNetARP_GetIpInvalidParameter     EventID (EventLevelError, EvtNetARP, 31)
N#define EvtNetARP_GetIpEntryNotFound        EventID (EventLevelOp,    EvtNetARP, 32)
N#define EvtNetARP_GetMac                    EventID (EventLevelAPI,   EvtNetARP, 33)
N#define EvtNetARP_GetMacInvalidParameter    EventID (EventLevelError, EvtNetARP, 34)
N#define EvtNetARP_GetMacEntryNotFound       EventID (EventLevelOp,    EvtNetARP, 35)
N#define EvtNetARP_Probe                     EventID (EventLevelAPI,   EvtNetARP, 36)
N#define EvtNetARP_ProbeInvalidParameter     EventID (EventLevelError, EvtNetARP, 37)
N#define EvtNetARP_ProbeBusy                 EventID (EventLevelError, EvtNetARP, 38)
N#define EvtNetARP_ProbeRetransmit           EventID (EventLevelOp,    EvtNetARP, 39)
N#define EvtNetARP_ProbeTimeout              EventID (EventLevelOp,    EvtNetARP, 40)
N#define EvtNetARP_CacheEntryTimeout         EventID (EventLevelOp,    EvtNetARP, 41)
N#define EvtNetARP_EntryReleased             EventID (EventLevelOp,    EvtNetARP, 42)
N#define EvtNetARP_ResolveEntry              EventID (EventLevelOp,    EvtNetARP, 43)
N#define EvtNetARP_RefreshEntry              EventID (EventLevelOp,    EvtNetARP, 44)
N#define EvtNetARP_UninitCache               EventID (EventLevelOp,    EvtNetARP, 45)
N#endif
N
N/**
N  \brief  Event on ARP cache initialize (Op)
N  \param  if_id         network interface identifier
N  \param  num_entries   number of entries available in cache
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_InitCache(uint16_t if_id, uint32_t num_entries) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_InitCache(uint16_t if_id, uint32_t num_entries) {
N    EventRecord2 (EvtNetARP_InitCache, if_id, num_entries);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (0 & 0xFFU)), if_id, num_entries);
N  }
N#else
S  #define EvrNetARP_InitCache(if_id, num_entries)
N#endif
N
N/**
N  \brief  Event on ARP receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  opcode        operation code of received message
N                         - 0x0001: ARP Request
N                         - 0x0002: ARP Reply
N                         - 0x0003: Reverse ARP Request
N                         - 0x0004: Reverse ARP Reply
N                         - 0x0008: Inverse ARP Request
N                         - 0x0009: Inverse ARP Response
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ReceiveFrame(uint16_t if_id, uint16_t opcode, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ReceiveFrame(uint16_t if_id, uint16_t opcode, uint32_t length) {
N    uint32_t val2 = ((uint32_t)opcode << 16) | length;
N    EventRecord2 (EvtNetARP_ReceiveFrame, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (1 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetARP_ReceiveFrame(if_id, opcode, length)
N#endif
N
N/**
N  \brief  Event on ARP receive frame is too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetARP_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (2 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetARP_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on ARP received frame corrupted (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_FrameCorrupted(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_FrameCorrupted(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_FrameCorrupted, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (3 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_FrameCorrupted(if_id)
N#endif
N
N/**
N  \brief  Event on ARP display send/receive frame header (Detail)
N  \param  arp_header    pointer to ARP frame header of 28 bytes
N                         - HwType       (2 bytes)
N                         - ProtType     (2 bytes)
N                         - HwLen        (1 byte)
N                         - ProtLen      (1 byte)
N                         - OpCode       (2 bytes)
N                         - SendHwAddr   (6 bytes)
N                         - SendIpAddr   (4 bytes)
N                         - TargHwAddr   (6 bytes)
N                         - TargIpAddr   (4 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ShowFrameHeader(const void *arp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ShowFrameHeader(const void *arp_header) {
N    EventRecordData (EvtNetARP_ShowFrameHeader, arp_header, 28);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (4 & 0xFFU)), arp_header, 28);
N  }
N#else
S  #define EvrNetARP_ShowFrameHeader(arp_header)
N#endif
N
N/**
N  \brief  Event on ARP invalid IP or MAC address of sender received (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_SenderAddressInvalid(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_SenderAddressInvalid(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_SenderAddressInvalid, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (5 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_SenderAddressInvalid(if_id)
N#endif
N
N/**
N  \brief  Event on ARP cache entry update (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheEntryUpdate(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheEntryUpdate(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_CacheEntryUpdate, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (6 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_CacheEntryUpdate(if_id, entry)
N#endif
N
N/**
N  \brief  Event on ARP probe response received (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ProbeResponseReceived(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ProbeResponseReceived(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_ProbeResponseReceived, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (7 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_ProbeResponseReceived(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP wrong destination IP address received (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_WrongIpAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_WrongIpAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_WrongIpAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (8 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_WrongIpAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP wrong destination MAC address received (Op)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_WrongMacAddress(uint16_t if_id, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_WrongMacAddress(uint16_t if_id, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetARP_WrongMacAddress, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (9 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetARP_WrongMacAddress(if_id, mac_addr)
N#endif
N
N/**
N  \brief  Event on ARP unknown opcode received (Op)
N  \param  if_id         network interface identifier
N  \param  opcode        unknown operation code value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_OpcodeUnknown(uint16_t if_id, uint16_t opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_OpcodeUnknown(uint16_t if_id, uint16_t opcode) {
N    EventRecord2 (EvtNetARP_OpcodeUnknown, if_id, opcode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (10 & 0xFFU)), if_id, opcode);
N  }
N#else
S  #define EvrNetARP_OpcodeUnknown(if_id, opcode)
N#endif
N
N/**
N  \brief  Event on ARP send reply message (Op)
N  \param  if_id         network interface identifier
N  \param  opcode        operation code of sending message
N                         - 0x0002: ARP Reply
N                         - 0x0009: Inverse ARP Response
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_SendReply(uint16_t if_id, uint16_t opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_SendReply(uint16_t if_id, uint16_t opcode) {
N    EventRecord2 (EvtNetARP_SendReply, if_id, opcode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (11 & 0xFFU)), if_id, opcode);
N  }
N#else
S  #define EvrNetARP_SendReply(if_id, opcode)
N#endif
N
N/**
N  \brief  Event on ARP cache entry refreshed (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheEntryRefreshed(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheEntryRefreshed(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_CacheEntryRefreshed, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (12 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_CacheEntryRefreshed(if_id, entry)
N#endif
N
N/**
N  \brief  Event on ARP wrong response received (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_WrongResponse(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_WrongResponse(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_WrongResponse, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (13 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_WrongResponse(if_id)
N#endif
N
N/**
N  \brief  Event on ARP send request message (Op)
N  \param  if_id         network interface identifier
N  \param  opcode        operation code of sending message
N                         - 0x0001: ARP Request
N                         - 0x0008: Inverse ARP Request
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_SendRequest(uint16_t if_id, uint16_t opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_SendRequest(uint16_t if_id, uint16_t opcode) {
N    EventRecord2 (EvtNetARP_SendRequest, if_id, opcode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (14 & 0xFFU)), if_id, opcode);
N  }
N#else
S  #define EvrNetARP_SendRequest(if_id, opcode)
N#endif
N
N/**
N  \brief  Event on ARP allocate free cache entry failed (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheAllocFailed(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheAllocFailed(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_CacheAllocFailed, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (15 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_CacheAllocFailed(if_id)
N#endif
N
N/**
N  \brief  Event on ARP refresh cached IP address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheIpRefreshed(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheIpRefreshed(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_CacheIpRefreshed, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (16 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_CacheIpRefreshed(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP add host address to ARP cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheAdd(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheAdd(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    memcpy (&evr_buf.u8[8], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[8], mac_addr, 6);
N    EventRecordData (EvtNetARP_CacheAdd, &evr_buf, 14);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (17 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 14);
N  }
N#else
S  #define EvrNetARP_CacheAdd(if_id, ip4_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on ARP cache add gateway unknown (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GatewayUnknown(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GatewayUnknown(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_GatewayUnknown, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (18 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_GatewayUnknown(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP cache entry added (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheEntryAdded(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheEntryAdded(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_CacheEntryAdded, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (19 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_CacheEntryAdded(if_id, entry)
N#endif
N
N/**
N  \brief  Event on ARP early cache address of the sender (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N  \param  mac_addr      pointer to MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheEarly(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheEarly(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    memcpy (&evr_buf.u8[8], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[8], mac_addr, 6);
N    EventRecordData (EvtNetARP_CacheEarly, &evr_buf, 14);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (20 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 14);
N  }
N#else
S  #define EvrNetARP_CacheEarly(if_id, ip4_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on ARP find IP address in cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheFind(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheFind(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_CacheFind, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (21 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_CacheFind(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP use gateway to access external address (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_UsingGateway(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_UsingGateway(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_UsingGateway, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (22 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_UsingGateway(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP unresolved MAC address in cache (Error)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to requested IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_UnresolvedMacAddress(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_UnresolvedMacAddress(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_UnresolvedMacAddress, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (23 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_UnresolvedMacAddress(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP cache entry found (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_EntryFound(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_EntryFound(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_EntryFound, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (24 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_EntryFound(if_id, entry)
N#endif
N
N/**
N  \brief  Event on netARP_CacheIP execute (API)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to requested IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheIp(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheIp(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_CacheIp, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (25 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_CacheIp(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on netARP_CacheIP invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheIpInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheIpInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_CacheIpInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (26 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_CacheIpInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netARP_CacheMAC execute (API)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to requested MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheMac(uint16_t if_id, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheMac(uint16_t if_id, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetARP_CacheMac, &evr_buf, 8);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (27 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetARP_CacheMac(if_id, mac_addr)
N#endif
N
N/**
N  \brief  Event on netARP_CacheMAC invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheMacInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheMacInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_CacheMacInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (28 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_CacheMacInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on ARP unresolved IP address in cache (Op)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to MAC cache address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_UnresolvedIpAddress(uint16_t if_id, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_UnresolvedIpAddress(uint16_t if_id, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetARP_UnresolvedIpAddress, &evr_buf, 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (29 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetARP_UnresolvedIpAddress(if_id, mac_addr)
N#endif
N
N/**
N  \brief  Event on netARP_GetIP resolving success (API)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to requested MAC address
N  \param  ip4_addr      pointer to resolved IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetIp(uint16_t if_id, const uint8_t *mac_addr, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetIp(uint16_t if_id, const uint8_t *mac_addr, const uint8_t *ip4_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    memcpy (&evr_buf.u8[8], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[8], mac_addr, 6);
N    EventRecordData (EvtNetARP_GetIp, &evr_buf, 14);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (30 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 14);
N  }
N#else
S  #define EvrNetARP_GetIp(if_id, mac_addr, ip4_addr)
N#endif
N
N/**
N  \brief  Event on netARP_GetIP invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetIpInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetIpInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_GetIpInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (31 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_GetIpInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netARP_GetIP entry with MAC address not found in cache (Op)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to requested MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetIpEntryNotFound(uint16_t if_id, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetIpEntryNotFound(uint16_t if_id, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetARP_GetIpEntryNotFound, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (32 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetARP_GetIpEntryNotFound(if_id, mac_addr)
N#endif
N
N/**
N  \brief  Event on netARP_GetMAC resolving success (API)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to requested IP address
N  \param  mac_addr      pointer to resolved MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetMac(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetMac(uint16_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    memcpy (&evr_buf.u8[8], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[8], mac_addr, 6);
N    EventRecordData (EvtNetARP_GetMac, &evr_buf, 14);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (33 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 14);
N  }
N#else
S  #define EvrNetARP_GetMac(if_id, ip4_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on netARP_GetMAC invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetMacInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetMacInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_GetMacInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (34 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_GetMacInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netARP_GetMAC entry with IP address not found in cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to requested IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_GetMacEntryNotFound(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_GetMacEntryNotFound(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_GetMacEntryNotFound, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (35 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_GetMacEntryNotFound(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on netARP_Probe execute (API)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to requested IP address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_Probe(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_Probe(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_Probe, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (36 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_Probe(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on netARP_Probe invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ProbeInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ProbeInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_ProbeInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (37 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_ProbeInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on ARP probe process busy (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ProbeBusy(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ProbeBusy(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_ProbeBusy, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (38 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_ProbeBusy(if_id)
N#endif
N
N/**
N  \brief  Event on ARP probe retransmit (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address of probed host
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ProbeRetransmit(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ProbeRetransmit(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_ProbeRetransmit, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (39 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_ProbeRetransmit(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP probe timeout (Op)
N  \param  if_id         network interface identifier
N  \param  ip4_addr      pointer to IP address of probed host
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ProbeTimeout(uint16_t if_id, const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ProbeTimeout(uint16_t if_id, const uint8_t *ip4_addr) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetARP_ProbeTimeout, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (40 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetARP_ProbeTimeout(if_id, ip4_addr)
N#endif
N
N/**
N  \brief  Event on ARP cache entry timeout (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N  \param  ip4_addr      pointer to IP address
N  \param  mac_addr      pointer to MAC address
N  \param  type          cache entry type
N                        - 0: Fixed IP
N                        - 1: Temporary IP
N                        - 2: In-use temporary IP
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_CacheEntryTimeout(uint16_t if_id, uint32_t entry,
X  static __inline __attribute__((always_inline)) void EvrNetARP_CacheEntryTimeout(uint16_t if_id, uint32_t entry,
N                    const uint8_t *ip4_addr, const uint8_t *mac_addr, uint32_t type) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u8[2]  = (uint8_t)entry;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = (uint8_t)entry;
N    evr_buf.u8[3]  = (uint8_t)type;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = (uint8_t)type;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    memcpy (&evr_buf.u8[8], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[8], mac_addr, 6);
N    EventRecordData (EvtNetARP_CacheEntryTimeout, &evr_buf, 14);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (41 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 14);
N  }
N#else
S  #define EvrNetARP_CacheEntryTimeout(if_id, entry, type, ip4_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on ARP cache entry released (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_EntryReleased(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_EntryReleased(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_EntryReleased, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (42 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_EntryReleased(if_id, entry)
N#endif
N
N/**
N  \brief  Event on resolve ARP cache entry (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_ResolveEntry(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_ResolveEntry(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_ResolveEntry, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (43 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_ResolveEntry(if_id, entry)
N#endif
N
N/**
N  \brief  Event on refresh ARP cache entry (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_RefreshEntry(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_RefreshEntry(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetARP_RefreshEntry, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (44 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetARP_RefreshEntry(if_id, entry)
N#endif
N
N/**
N  \brief  Event on ARP cache de-initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetARP_UninitCache(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetARP_UninitCache(uint16_t if_id) {
N    EventRecord2 (EvtNetARP_UninitCache, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCB & 0xFFU) << 8) | (45 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetARP_UninitCache(if_id)
N#endif
N
N
N// NetIP6 event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetIP6_InitCore                  EventID (EventLevelOp,    EvtNetIP6,  0)
N#define EvtNetIP6_ReceiveFrame              EventID (EventLevelOp,    EvtNetIP6,  1)
N#define EvtNetIP6_FrameTooShort             EventID (EventLevelError, EvtNetIP6,  2)
N#define EvtNetIP6_InvalidIpVersion          EventID (EventLevelError, EvtNetIP6,  3)
N#define EvtNetIP6_ShowFrameHeader           EventID (EventLevelDetail,EvtNetIP6,  4)
N#define EvtNetIP6_WrongDestinationAddress   EventID (EventLevelOp,    EvtNetIP6,  5)
N#define EvtNetIP6_InterfaceNotSupported     EventID (EventLevelError, EvtNetIP6,  6)
N#define EvtNetIP6_WrongMulticastProtocol    EventID (EventLevelError, EvtNetIP6,  7)
N#define EvtNetIP6_SendFrame                 EventID (EventLevelOp,    EvtNetIP6,  8)
N#define EvtNetIP6_ProtocolUnknown           EventID (EventLevelError, EvtNetIP6,  9)
N#define EvtNetIP6_SourceAddressNull         EventID (EventLevelError, EvtNetIP6, 10)
N#define EvtNetIP6_DestinationAddressNull    EventID (EventLevelError, EvtNetIP6, 11)
N#define EvtNetIP6_SetDefaultInterface       EventID (EventLevelOp,    EvtNetIP6, 12)
N#define EvtNetIP6_UninitCore                EventID (EventLevelOp,    EvtNetIP6, 13)
N#endif
N
N/**
N  \brief  Event on IP6 core initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_InitCore(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_InitCore(uint16_t if_id) {
N    EventRecord2 (EvtNetIP6_InitCore, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (0 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP6_InitCore(if_id)
N#endif
N
N/**
N  \brief  Event on IP6 receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetIP6_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (1 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetIP6_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on IP6 receive frame too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetIP6_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (2 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetIP6_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on IP6 invalid protocol version (Error)
N  \param  if_id         network interface identifier
N  \param  ip_version    IPv6 protocol version value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_InvalidIpVersion(uint16_t if_id, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_InvalidIpVersion(uint16_t if_id, uint8_t ip_version) {
N    EventRecord2 (EvtNetIP6_InvalidIpVersion, if_id, ip_version);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (3 & 0xFFU)), if_id, ip_version);
N  }
N#else
S  #define EvrNetIP6_InvalidIpVersion(if_id, ip_version)
N#endif
N
N/**
N  \brief  Event on IP6 display frame header (Detail)
N  \param  ip6_header    pointer to IPv6 frame header of 40 bytes
N                         - VerClass  (1 byte)
N                         - ClassFlow (1 byte)
N                         - Flow      (2 bytes)
N                         - Len       (2 bytes)
N                         - NextHdr   (1 byte)
N                         - HopLim    (1 byte)
N                         - SrcAddr   (16 bytes)
N                         - DstAddr   (16 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_ShowFrameHeader(const void *ip6_header) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_ShowFrameHeader(const void *ip6_header) {
N    EventRecordData (EvtNetIP6_ShowFrameHeader, ip6_header, 40);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (4 & 0xFFU)), ip6_header, 40);
N  }
N#else
S  #define EvrNetIP6_ShowFrameHeader(ip6_header)
N#endif
N
N/**
N  \brief  Event on IP6 wrong destination address (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_WrongDestinationAddress(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_WrongDestinationAddress(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetIP6_WrongDestinationAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (5 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetIP6_WrongDestinationAddress(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on IP6 network interface not supported (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_InterfaceNotSupported(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_InterfaceNotSupported(uint16_t if_id) {
N    EventRecord2 (EvtNetIP6_InterfaceNotSupported, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (6 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP6_InterfaceNotSupported(if_id)
N#endif
N
N/**
N  \brief  Event on IP6 wrong multicast protocol type (Error)
N  \param  if_id         network interface identifier
N  \param  ip6_protocol  received protocol type
N  \remark Only UDP multicast frames are allowed.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_WrongMulticastProtocol(uint16_t if_id, uint8_t ip6_protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_WrongMulticastProtocol(uint16_t if_id, uint8_t ip6_protocol) {
N    EventRecord2 (EvtNetIP6_WrongMulticastProtocol, if_id, ip6_protocol);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (7 & 0xFFU)), if_id, ip6_protocol);
N  }
N#else
S  #define EvrNetIP6_WrongMulticastProtocol(if_id, ip6_protocol)
N#endif
N
N/**
N  \brief  Event on IP6 send frame (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_protocol  IPv6 protocol type
N                         - 6:  TCP
N                         - 17: UDP
N                         - 58: ICMP6
N  \param  length        frame length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_SendFrame(uint16_t if_id, uint8_t ip6_protocol, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_SendFrame(uint16_t if_id, uint8_t ip6_protocol, uint32_t length) {
N    uint32_t val2 = (length << 16) | ip6_protocol;
N    EventRecord2 (EvtNetIP6_SendFrame, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (8 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetIP6_SendFrame(if_id, ip6_protocol, length)
N#endif
N
N/**
N  \brief  Event on IP6 unknown protocol type in sending frame (Error)
N  \param  if_id         network interface identifier
N  \param  ip6_protocol  unknown IPv6 protocol type value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_ProtocolUnknown(uint16_t if_id, uint8_t ip6_protocol) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_ProtocolUnknown(uint16_t if_id, uint8_t ip6_protocol) {
N    EventRecord2 (EvtNetIP6_ProtocolUnknown, if_id, ip6_protocol);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (9 & 0xFFU)), if_id, ip6_protocol);
N  }
N#else
S  #define EvrNetIP6_ProtocolUnknown(if_id, ip6_protocol)
N#endif
N
N/**
N  \brief  Event on IP6 source address not provided (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_SourceAddressNull(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_SourceAddressNull(uint16_t if_id) {
N    EventRecord2 (EvtNetIP6_SourceAddressNull, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (10 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP6_SourceAddressNull(if_id)
N#endif
N
N/**
N  \brief  Event on IP6 destination address not provided (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_DestinationAddressNull(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_DestinationAddressNull(uint16_t if_id) {
N    EventRecord2 (EvtNetIP6_DestinationAddressNull, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (11 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP6_DestinationAddressNull(if_id)
N#endif
N
N/**
N  \brief  Event on IP6 set default interface for internet access (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_SetDefaultInterface(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_SetDefaultInterface(uint16_t if_id) {
N    EventRecord2 (EvtNetIP6_SetDefaultInterface, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (12 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetIP6_SetDefaultInterface(if_id)
N#endif
N
N/**
N  \brief  Event on IP6 core de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetIP6_UninitCore(void) {
X  static __inline __attribute__((always_inline)) void EvrNetIP6_UninitCore(void) {
N    EventRecord2 (EvtNetIP6_UninitCore, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCC & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetIP6_UninitCore()
N#endif
N
N
N// NetICMP6 event identifiers --------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetICMP6_ReceiveFrame            EventID (EventLevelOp,    EvtNetICMP6,  0)
N#define EvtNetICMP6_ShowFrameHeader         EventID (EventLevelDetail,EvtNetICMP6, 25)
N#define EvtNetICMP6_FrameTooShort           EventID (EventLevelError, EvtNetICMP6,  1)
N#define EvtNetICMP6_ChecksumFailed          EventID (EventLevelError, EvtNetICMP6,  2)
N#define EvtNetICMP6_EchoRequestWrongCode    EventID (EventLevelError, EvtNetICMP6,  3)
N#define EvtNetICMP6_EchoRequestReceived     EventID (EventLevelOp,    EvtNetICMP6,  4)
N#define EvtNetICMP6_EchoReplyDisabled       EventID (EventLevelOp,    EvtNetICMP6, 26) // End
N#define EvtNetICMP6_SendEchoReply           EventID (EventLevelOp,    EvtNetICMP6,  5)
N#define EvtNetICMP6_EchoReplyReceived       EventID (EventLevelOp,    EvtNetICMP6,  6)
N#define EvtNetICMP6_EchoReplyWrongState     EventID (EventLevelError, EvtNetICMP6,  7)
N#define EvtNetICMP6_EchoReplyWrongCode      EventID (EventLevelError, EvtNetICMP6,  8)
N#define EvtNetICMP6_EchoReplyWrongIpAddress EventID (EventLevelError, EvtNetICMP6,  9)
N#define EvtNetICMP6_EchoReplyWrongId        EventID (EventLevelError, EvtNetICMP6, 10)
N#define EvtNetICMP6_EchoReplyWrongPayload   EventID (EventLevelError, EvtNetICMP6, 11)
N#define EvtNetICMP6_MessageDiscarded        EventID (EventLevelOp,    EvtNetICMP6, 12)
N#define EvtNetICMP6_WrongHopLimit           EventID (EventLevelError, EvtNetICMP6, 13)
N#define EvtNetICMP6_WrongCode               EventID (EventLevelError, EvtNetICMP6, 14)
N#define EvtNetICMP6_MessageTypeUnknown      EventID (EventLevelOp,    EvtNetICMP6, 15)
N#define EvtNetICMP6_SendFrame               EventID (EventLevelOp,    EvtNetICMP6, 16)
N/* ICMP6-Ping client events */
N#define EvtNetICMP6_PingEcho                EventID (EventLevelAPI,   EvtNetICMP6, 17)
N#define EvtNetICMP6_PingTargetNotValid      EventID (EventLevelError, EvtNetICMP6, 18)
N#define EvtNetICMP6_PingDnsError            EventID (EventLevelError, EvtNetICMP6, 19)
N#define EvtNetICMP6_PingInvalidParameter    EventID (EventLevelError, EvtNetICMP6, 20)
N#define EvtNetICMP6_PingClientBusy          EventID (EventLevelError, EvtNetICMP6, 21)
N#define EvtNetICMP6_PingSendRequest         EventID (EventLevelOp,    EvtNetICMP6, 22)
N#define EvtNetICMP6_PingRetransmitRequest   EventID (EventLevelOp,    EvtNetICMP6, 23)
N#define EvtNetICMP6_PingTimeout             EventID (EventLevelOp,    EvtNetICMP6, 24)
N#endif
N
N/**
N  \brief  Event on ICMP6 receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetICMP6_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (0 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetICMP6_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on ICMP6 display send/receive frame header (Detail)
N  \param  icmp6_header  pointer to ICMP6 frame header of 8 bytes
N                         - Type    (1 byte)
N                         - Code    (1 byte)
N                         - Chksum  (2 bytes)
N                         - EchoId  (2 bytes)
N                         - EchoSeq (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_ShowFrameHeader(const void *icmp6_header) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_ShowFrameHeader(const void *icmp6_header) {
N    EventRecordData (EvtNetICMP6_ShowFrameHeader, icmp6_header, 8);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (25 & 0xFFU)), icmp6_header, 8);
N  }
N#else
S  #define EvrNetICMP6_ShowFrameHeader(icmp6_header)
N#endif
N
N/**
N  \brief  Event on ICMP6 receive frame is too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetICMP6_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (1 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on ICMP6 frame checksum check failed (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_ChecksumFailed(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_ChecksumFailed(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetICMP6_ChecksumFailed, if_id, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (2 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetICMP6_ChecksumFailed(if_id, length)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong code in echo request received (Error)
N  \param  if_id         network interface identifier
N  \param  code          received ICMPv6 code
N  \param  code_valid    valid ICMPv6 code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoRequestWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoRequestWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
N    uint32_t val2 = ((uint32_t)code_valid) | code;
N    EventRecord2 (EvtNetICMP6_EchoRequestWrongCode, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (3 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_EchoRequestWrongCode(if_id, code, code_valid)
N#endif
N
N/**
N  \brief  Event on ICMP6 echo request received (Op)
N  \param  if_id         network interface identifier
N  \param  data_length   length of the payload data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoRequestReceived(uint16_t if_id, uint32_t data_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoRequestReceived(uint16_t if_id, uint32_t data_length) {
N    EventRecord2 (EvtNetICMP6_EchoRequestReceived, if_id, data_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (4 & 0xFFU)), if_id, data_length);
N  }
N#else
S  #define EvrNetICMP6_EchoRequestReceived(if_id, data_length)
N#endif
N
N/**
N  \brief  Event on ICMP6 sending echo reply disabled (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyDisabled(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyDisabled(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_EchoReplyDisabled, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (26 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyDisabled(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 send echo reply (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_SendEchoReply(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_SendEchoReply(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_SendEchoReply, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (5 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_SendEchoReply(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 echo reply received (Op)
N  \param  if_id         network interface identifier
N  \param  data_length   length of the payload data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyReceived(uint16_t if_id, uint32_t data_length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyReceived(uint16_t if_id, uint32_t data_length) {
N    EventRecord2 (EvtNetICMP6_EchoReplyReceived, if_id, data_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (6 & 0xFFU)), if_id, data_length);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyReceived(if_id, data_length)
N#endif
N
N/**
N  \brief  Event on ICMP6 echo reply received in wrong ping process state (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyWrongState(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyWrongState(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_EchoReplyWrongState, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (7 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyWrongState(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong code in echo reply received (Error)
N  \param  if_id         network interface identifier
N  \param  code          received ICMPv6 code
N  \param  code_valid    valid ICMPv6 code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyWrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
N    uint32_t val2 = ((uint32_t)code_valid << 16) | code;
N    EventRecord2 (EvtNetICMP6_EchoReplyWrongCode, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (8 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyWrongCode(if_id, code, code_valid)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong source IPv6 address of echo reply (Error)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyWrongIpAddress(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyWrongIpAddress(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetICMP6_EchoReplyWrongIpAddress, &evr_buf, 20);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (9 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyWrongIpAddress(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong echo identifier value in echo reply (Error)
N  \param  if_id         network interface identifier
N  \param  eid           received echo identifier
N  \param  eid_valid     valid echo identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyWrongId(uint16_t if_id, uint16_t eid, uint16_t eid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyWrongId(uint16_t if_id, uint16_t eid, uint16_t eid_valid) {
N    uint32_t val2 = ((uint32_t)eid_valid << 16) | eid;
N    EventRecord2 (EvtNetICMP6_EchoReplyWrongId, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (10 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyWrongId(if_id, eid, eid_valid)
N#endif
N
N/**
N  \brief  Event on ICMP6 echo reply payload data invalid (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_EchoReplyWrongPayload(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_EchoReplyWrongPayload(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_EchoReplyWrongPayload, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (11 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_EchoReplyWrongPayload(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 router solicitation message discarded (Op)
N  \param  if_id         network interface identifier
N  \param  type          ICMPv6 message type
N  \remark Hosts must silently discard RS messages [RFC4861 page 38]
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_MessageDiscarded(uint16_t if_id, uint8_t type) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_MessageDiscarded(uint16_t if_id, uint8_t type) {
N    EventRecord2 (EvtNetICMP6_MessageDiscarded, if_id, type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (12 & 0xFFU)), if_id, type);
N  }
N#else
S  #define EvrNetICMP6_MessageDiscarded(if_id, type)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong hop limit in discover message (Error)
N  \param  if_id         network interface identifier
N  \param  hop_limit     received hop limit
N  \param  hop_valid     valid hop limit
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_WrongHopLimit(uint16_t if_id, uint8_t hop_limit, uint8_t hop_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_WrongHopLimit(uint16_t if_id, uint8_t hop_limit, uint8_t hop_valid) {
N    uint32_t val2 = ((uint32_t)hop_valid << 16) | hop_limit;
N    EventRecord2 (EvtNetICMP6_WrongHopLimit, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (13 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_WrongHopLimit(if_id, hop_limit, hop_valid)
N#endif
N
N/**
N  \brief  Event on ICMP6 wrong code in discover message (Error)
N  \param  if_id         network interface identifier
N  \param  code          received ICMPv6 code
N  \param  code_valid    valid ICMPv6 code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_WrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_WrongCode(uint16_t if_id, uint8_t code, uint8_t code_valid) {
N    uint32_t val2 = ((uint32_t)code_valid << 16) | code;
N    EventRecord2 (EvtNetICMP6_WrongCode, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (14 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetICMP6_WrongCode(if_id, code, code_valid)
N#endif
N
N/**
N  \brief  Event on ICMP6 message type unknown (Op)
N  \param  if_id         network interface identifier
N  \param  type          ICMP6 message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_MessageTypeUnknown(uint16_t if_id, uint8_t type) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_MessageTypeUnknown(uint16_t if_id, uint8_t type) {
N    EventRecord2 (EvtNetICMP6_MessageTypeUnknown, if_id, type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (15 & 0xFFU)), if_id, type);
N  }
N#else
S  #define EvrNetICMP6_MessageTypeUnknown(if_id, type)
N#endif
N
N/**
N  \brief  Event on ICMP6 send frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_SendFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_SendFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetICMP6_SendFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (16 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetICMP6_SendFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on ICMP6 ping echo request (API)
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingEcho(const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingEcho(const uint8_t *ip6_addr) {
N    EventRecordData (EvtNetICMP6_PingEcho, ip6_addr, 16);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (17 & 0xFFU)), ip6_addr, 16);
N  }
N#else
S  #define EvrNetICMP6_PingEcho(ip6_addr)
N#endif
N
N/**
N  \brief  Event on ICMP6 ping target name not valid (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingTargetNotValid(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingTargetNotValid(void) {
N    EventRecord2 (EvtNetICMP6_PingTargetNotValid, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP6_PingTargetNotValid()
N#endif
N
N/**
N  \brief  Event on ICMP6 ping host name resolver error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingDnsError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingDnsError(void) {
N    EventRecord2 (EvtNetICMP6_PingDnsError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (19 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP6_PingDnsError()
N#endif
N
N/**
N  \brief  Event on ICMP6 ping invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingInvalidParameter(void) {
N    EventRecord2 (EvtNetICMP6_PingInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (20 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP6_PingInvalidParameter()
N#endif
N
N/**
N  \brief  Event on ICMP6 ping client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingClientBusy(void) {
N    EventRecord2 (EvtNetICMP6_PingClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (21 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetICMP6_PingClientBusy()
N#endif
N
N/**
N  \brief  Event on ICMP6 send echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingSendRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingSendRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_PingSendRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (22 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_PingSendRequest(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 retransmit echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingRetransmitRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingRetransmitRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_PingRetransmitRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (23 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_PingRetransmitRequest(if_id)
N#endif
N
N/**
N  \brief  Event on ICMP6 timeout on send echo request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetICMP6_PingTimeout(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetICMP6_PingTimeout(uint16_t if_id) {
N    EventRecord2 (EvtNetICMP6_PingTimeout, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCD & 0xFFU) << 8) | (24 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetICMP6_PingTimeout(if_id)
N#endif
N
N
N// NetDHCP6 event identifiers --------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetDHCP6_InitClient              EventID (EventLevelOp,    EvtNetDHCP6,  0)
N#define EvtNetDHCP6_GetSocketFailed         EventID (EventLevelError, EvtNetDHCP6,  1)
N#define EvtNetDHCP6_StartClient             EventID (EventLevelOp,    EvtNetDHCP6,  2)
N#define EvtNetDHCP6_StopClient              EventID (EventLevelOp,    EvtNetDHCP6,  3)
N#define EvtNetDHCP6_ClientState             EventID (EventLevelOp,    EvtNetDHCP6,  4)
N#define EvtNetDHCP6_NextState               EventID (EventLevelOp,    EvtNetDHCP6,  5)
N#define EvtNetDHCP6_NextStateDelay          EventID (EventLevelOp,    EvtNetDHCP6,  6)
N#define EvtNetDHCP6_ChangeStateLinkDown     EventID (EventLevelOp,    EvtNetDHCP6,  7)
N#define EvtNetDHCP6_NoAddressAvailable      EventID (EventLevelOp,    EvtNetDHCP6,  8)
N#define EvtNetDHCP6_StateRetransmit         EventID (EventLevelOp,    EvtNetDHCP6,  9)
N#define EvtNetDHCP6_StateTimeout            EventID (EventLevelOp,    EvtNetDHCP6, 10)
N#define EvtNetDHCP6_ChangeStateOnTimeout    EventID (EventLevelOp,    EvtNetDHCP6, 11)
N#define EvtNetDHCP6_T1Expired               EventID (EventLevelOp,    EvtNetDHCP6, 12)
N#define EvtNetDHCP6_T2Expired               EventID (EventLevelOp,    EvtNetDHCP6, 13)
N#define EvtNetDHCP6_SendDhcpMessage         EventID (EventLevelOp,    EvtNetDHCP6, 14)
N#define EvtNetDHCP6_ReceiveFrame            EventID (EventLevelOp,    EvtNetDHCP6, 15)
N#define EvtNetDHCP6_FrameTooShort           EventID (EventLevelError, EvtNetDHCP6, 16)
N#define EvtNetDHCP6_WrongTransactionId      EventID (EventLevelError, EvtNetDHCP6, 17)
N#define EvtNetDHCP6_MessageTypeUnknown      EventID (EventLevelError, EvtNetDHCP6, 18)
N#define EvtNetDHCP6_ShowMessage             EventID (EventLevelOp,    EvtNetDHCP6, 19)
N#define EvtNetDHCP6_InvalidMessageType      EventID (EventLevelOp,    EvtNetDHCP6, 20)
N#define EvtNetDHCP6_WrongClientId           EventID (EventLevelOp,    EvtNetDHCP6, 21)
N#define EvtNetDHCP6_ServerNotChosen         EventID (EventLevelOp,    EvtNetDHCP6, 22)
N#define EvtNetDHCP6_StatusCode              EventID (EventLevelOp,    EvtNetDHCP6, 23)
N#define EvtNetDHCP6_WrongServerId           EventID (EventLevelOp,    EvtNetDHCP6, 24)
N#define EvtNetDHCP6_ShowDnsServers          EventID (EventLevelOp,    EvtNetDHCP6, 25)
N#define EvtNetDHCP6_MissingServerId         EventID (EventLevelOp,    EvtNetDHCP6, 26)
N#define EvtNetDHCP6_WrongIaid               EventID (EventLevelOp,    EvtNetDHCP6, 27)
N#define EvtNetDHCP6_ShowIanaOffer           EventID (EventLevelOp,    EvtNetDHCP6, 28)
N#define EvtNetDHCP6_OfferTimerCheckFailed   EventID (EventLevelError, EvtNetDHCP6, 29)
N#define EvtNetDHCP6_UninitClient            EventID (EventLevelOp,    EvtNetDHCP6, 30)
N#endif
N
N/**
N  \brief  Event on DHCP6 client initialize (Op)
N  \param  if_id         network interface identifier
N  \param  vclass        Vendor Class option enabled
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_InitClient(uint16_t if_id, uint8_t vclass) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_InitClient(uint16_t if_id, uint8_t vclass) {
N    EventRecord2 (EvtNetDHCP6_InitClient, if_id, vclass);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (0 & 0xFFU)), if_id, vclass);
N  }
N#else
S  #define EvrNetDHCP6_InitClient(if_id, vclass)
N#endif
N
N/**
N  \brief  Event on DHCP6 failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_GetSocketFailed(void) {
N    EventRecord2 (EvtNetDHCP6_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDHCP6_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on DHCP6 client start (Op)
N  \param  if_id         network interface identifier
N  \param  mode          client mode
N                         - 0: Stateless mode
N                         - 1: Stateful mode
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_StartClient(uint16_t if_id, uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_StartClient(uint16_t if_id, uint32_t mode) {
N    EventRecord2 (EvtNetDHCP6_StartClient, if_id, mode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (2 & 0xFFU)), if_id, mode);
N  }
N#else
S  #define EvrNetDHCP6_StartClient(if_id, mode)
N#endif
N
N/**
N  \brief  Event on DHCP6 client stop (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_StopClient(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_StopClient(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP6_StopClient, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (3 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP6_StopClient(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP6 indication of client state (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ClientState(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ClientState(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_ClientState, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (4 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_ClientState(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 transition to next state (Op)
N  \param  if_id         network interface identifier
N  \param  state         next state
N
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_NextState(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_NextState(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_NextState, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (5 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_NextState(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 transition to next state with random delay (Op)
N  \param  if_id         network interface identifier
N  \param  state         next state
N  \param  delay         start delay (in 100ms ticks)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_NextStateDelay(uint16_t if_id, uint8_t state, uint16_t delay) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_NextStateDelay(uint16_t if_id, uint8_t state, uint16_t delay) {
N    uint32_t val2 = ((uint32_t)delay << 16) | state;
N    EventRecord2 (EvtNetDHCP6_NextStateDelay, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (6 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP6_NextStateDelay(if_id, state, delay)
N#endif
N
N/**
N  \brief  Event on DHCP6 change state on link-down (Op)
N  \param  if_id         network interface identifier
N  \param  state         next state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ChangeStateLinkDown(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ChangeStateLinkDown(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_ChangeStateLinkDown, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (7 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_ChangeStateLinkDown(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive status no address available (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_NoAddressAvailable(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_NoAddressAvailable(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_NoAddressAvailable, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (8 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_NoAddressAvailable(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 retransmit request in current state (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_StateRetransmit(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_StateRetransmit(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_StateRetransmit, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (9 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_StateRetransmit(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 timeout in current state (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_StateTimeout(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_StateTimeout(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_StateTimeout, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (10 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_StateTimeout(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 state timeout and transit to next state (Op)
N  \param  if_id         network interface identifier
N  \param  current       current state
N  \param  next          next state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ChangeStateOnTimeout(uint16_t if_id, uint8_t current, uint8_t next) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ChangeStateOnTimeout(uint16_t if_id, uint8_t current, uint8_t next) {
N    uint32_t val2 = ((uint32_t)next << 16) | current;
N    EventRecord2 (EvtNetDHCP6_ChangeStateOnTimeout, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (11 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP6_ChangeStateOnTimeout(if_id, current, next)
N#endif
N
N/**
N  \brief  Event on DHCP6 timer T1 expired (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_T1Expired(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_T1Expired(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_T1Expired, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (12 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_T1Expired(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 timer T2 expired (Op)
N  \param  if_id         network interface identifier
N  \param  state         current state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_T2Expired(uint16_t if_id, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_T2Expired(uint16_t if_id, uint8_t state) {
N    EventRecord2 (EvtNetDHCP6_T2Expired, if_id, state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (13 & 0xFFU)), if_id, state);
N  }
N#else
S  #define EvrNetDHCP6_T2Expired(if_id, state)
N#endif
N
N/**
N  \brief  Event on DHCP6 send message (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N  \param  xid           transaction identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_SendDhcpMessage(uint16_t if_id, uint8_t msg_type, uint32_t xid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_SendDhcpMessage(uint16_t if_id, uint8_t msg_type, uint32_t xid) {
N    uint32_t val1 = ((uint32_t)msg_type << 16) | if_id;
N    EventRecord2 (EvtNetDHCP6_SendDhcpMessage, val1, xid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (14 & 0xFFU)), val1, xid);
N  }
N#else
S  #define EvrNetDHCP6_SendDhcpMessage(if_id, msg_type, xid)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive frame (Op)
N  \param  if_id         network interface identifier
N  \param  length        message length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ReceiveFrame(uint16_t if_id, uint32_t length) {
N    EventRecord2 (EvtNetDHCP6_ReceiveFrame, if_id, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (15 & 0xFFU)), if_id, length);
N  }
N#else
S  #define EvrNetDHCP6_ReceiveFrame(if_id, length)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive frame too short (Error)
N  \param  if_id         network interface identifier
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_FrameTooShort(uint16_t if_id, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetDHCP6_FrameTooShort, if_id, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (16 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP6_FrameTooShort(if_id, length, min_length)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive wrong transaction identifier (Error)
N  \param  if_id         network interface identifier
N  \param  xid           received transaction identifier
N  \param  xid_valid     valid transaction identifier
N  \remark The size of transaction identifier (XID) is 3 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_WrongTransactionId(uint16_t if_id, uint32_t xid, uint32_t xid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_WrongTransactionId(uint16_t if_id, uint32_t xid, uint32_t xid_valid) {
N    EventRecord4 (EvtNetDHCP6_WrongTransactionId, if_id, xid, xid_valid, 0);
X    EventRecord4 (((0x00000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (17 & 0xFFU)), if_id, xid, xid_valid, 0);
N  }
N#else
S  #define EvrNetDHCP6_WrongTransactionId(if_id, xid, xid_valid)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive unknown message type (Error)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_MessageTypeUnknown(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_MessageTypeUnknown(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP6_MessageTypeUnknown, if_id, msg_type);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (18 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP6_MessageTypeUnknown(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP6 display message information (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      message type
N  \param  xid           transaction identifier
N  \remark The size of transaction identifier (XID) is 3 bytes.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ShowMessage(uint16_t if_id, uint8_t msg_type, uint32_t xid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ShowMessage(uint16_t if_id, uint8_t msg_type, uint32_t xid) {
N    uint32_t val1 = ((uint32_t)msg_type << 16) | if_id;
N    EventRecord2 (EvtNetDHCP6_ShowMessage, val1, xid);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (19 & 0xFFU)), val1, xid);
N  }
N#else
S  #define EvrNetDHCP6_ShowMessage(if_id, msg_type, xid)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive invalid message type (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \param  msg_valid     valid message type
N  \remark Silently discard other message types.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_InvalidMessageType(uint16_t if_id, uint8_t msg_type, uint8_t msg_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_InvalidMessageType(uint16_t if_id, uint8_t msg_type, uint8_t msg_valid) {
N    uint32_t val2 = ((uint32_t)msg_valid << 16) | msg_type;
N    EventRecord2 (EvtNetDHCP6_InvalidMessageType, if_id, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (20 & 0xFFU)), if_id, val2);
N  }
N#else
S  #define EvrNetDHCP6_InvalidMessageType(if_id, msg_type, msg_valid)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive wrong client identifier (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \remark Silently discard the message.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_WrongClientId(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_WrongClientId(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP6_WrongClientId, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (21 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP6_WrongClientId(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP6 server not chosen in DISCOVER, REBIND state (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \remark Silently discard the message.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ServerNotChosen(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ServerNotChosen(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP6_ServerNotChosen, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (22 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP6_ServerNotChosen(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive option status code (Op)
N  \param  if_id         network interface identifier
N  \param  status        status code
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_StatusCode(uint16_t if_id, uint16_t status) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_StatusCode(uint16_t if_id, uint16_t status) {
N    EventRecord2 (EvtNetDHCP6_StatusCode, if_id, status);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (23 & 0xFFU)), if_id, status);
N  }
N#else
S  #define EvrNetDHCP6_StatusCode(if_id, status)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive wrong server identifier (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \remark Silently discard the message.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_WrongServerId(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_WrongServerId(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP6_WrongServerId, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (24 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP6_WrongServerId(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP6 display DNS server addresses (Op)
N  \param  if_id         network interface identifier
N  \param  dns_list      pointer to DNS server address list
N  \remark Displays primary and secondary DNS server address.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ShowDnsServers(uint16_t if_id, const uint8_t *dns_list) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ShowDnsServers(uint16_t if_id, const uint8_t *dns_list) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], dns_list, 32);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], dns_list, 32);
N    EventRecordData (EvtNetDHCP6_ShowDnsServers, &evr_buf, 36);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (25 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 36);
N  }
N#else
S  #define EvrNetDHCP6_ShowDnsServers(if_id, dns_list)
N#endif
N
N/**
N  \brief  Event on DHCP6 missing server identifier option (Op)
N  \param  if_id         network interface identifier
N  \param  msg_type      received message type
N  \remark Silently discard the message.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_MissingServerId(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_MissingServerId(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetDHCP6_MissingServerId, if_id, msg_type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (26 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetDHCP6_MissingServerId(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on DHCP6 receive wrong IAID (Op)
N  \param  if_id         network interface identifier
N  \param  iaid          received IAID value
N  \param  iaid_valid    valid IAID value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_WrongIaid(uint16_t if_id, uint32_t iaid, uint32_t iaid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_WrongIaid(uint16_t if_id, uint32_t iaid, uint32_t iaid_valid) {
N    EventRecord4 (EvtNetDHCP6_WrongIaid, if_id, iaid, iaid_valid, 0);
X    EventRecord4 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (27 & 0xFFU)), if_id, iaid, iaid_valid, 0);
N  }
N#else
S  #define EvrNetDHCP6_WrongIaid(if_id, iaid, iaid_valid)
N#endif
N
N/**
N  \brief  Event on DHCP6 display IANA offer (Op)
N  \param  iana_offer    pointer to IANA structure of 32 bytes
N                         - T1        (4 bytes)
N                         - T2        (4 bytes)
N                         - Addr     (16 bytes)
N                         - PrefTime  (4 bytes)
N                         - ValidTime (4 bytes)
N  \remark IANA: Identity Association for non-temporary Address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_ShowIanaOffer(const void *iana_offer) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_ShowIanaOffer(const void *iana_offer) {
N    EventRecordData (EvtNetDHCP6_ShowIanaOffer, iana_offer, 32);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (28 & 0xFFU)), iana_offer, 32);
N  }
N#else
S  #define EvrNetDHCP6_ShowIanaOffer(iana_offer)
N#endif
N
N/**
N  \brief  Event on DHCP6 offer address timer check failed (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_OfferTimerCheckFailed(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_OfferTimerCheckFailed(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP6_OfferTimerCheckFailed, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (29 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP6_OfferTimerCheckFailed(if_id)
N#endif
N
N/**
N  \brief  Event on DHCP6 client de-initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDHCP6_UninitClient(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetDHCP6_UninitClient(uint16_t if_id) {
N    EventRecord2 (EvtNetDHCP6_UninitClient, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCE & 0xFFU) << 8) | (30 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetDHCP6_UninitClient(if_id)
N#endif
N
N
N// NetNDP event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetNDP_InitCache                 EventID (EventLevelOp,    EvtNetNDP,  0)
N#define EvtNetNDP_FrameCheckFailed          EventID (EventLevelError, EvtNetNDP,  1)
N#define EvtNetNDP_AddressNotLinkLocal       EventID (EventLevelOp,    EvtNetNDP,  2)
N#define EvtNetNDP_RouterAdvertisement       EventID (EventLevelOp,    EvtNetNDP,  3)
N#define EvtNetNDP_OptionMtu                 EventID (EventLevelOp,    EvtNetNDP,  4)
N#define EvtNetNDP_OptionSourceMacAddress    EventID (EventLevelOp,    EvtNetNDP,  5)
N#define EvtNetNDP_OptionPrefixInfo          EventID (EventLevelOp,    EvtNetNDP,  6)
N#define EvtNetNDP_PrefixInfoNotValid        EventID (EventLevelOp,    EvtNetNDP,  7)
N#define EvtNetNDP_WrongTargetAddress        EventID (EventLevelOp,    EvtNetNDP,  8)
N#define EvtNetNDP_NeighborSolicitation      EventID (EventLevelOp,    EvtNetNDP,  9)
N#define EvtNetNDP_ProbeRequest              EventID (EventLevelOp,    EvtNetNDP, 10)
N#define EvtNetNDP_NeighborAdvertisement     EventID (EventLevelOp,    EvtNetNDP, 11)
N#define EvtNetNDP_ProbeResponse             EventID (EventLevelOp,    EvtNetNDP, 12)
N#define EvtNetNDP_WrongDestinationAddress   EventID (EventLevelOp,    EvtNetNDP, 13)
N#define EvtNetNDP_SendReply                 EventID (EventLevelOp,    EvtNetNDP, 14)
N#define EvtNetNDP_ShowFlags                 EventID (EventLevelOp,    EvtNetNDP, 15)
N#define EvtNetNDP_SendRequest               EventID (EventLevelOp,    EvtNetNDP, 16)
N#define EvtNetNDP_ShowTargetAddress         EventID (EventLevelOp,    EvtNetNDP, 17)
N#define EvtNetNDP_OptionTargetMacAddress    EventID (EventLevelOp,    EvtNetNDP, 18)
N#define EvtNetNDP_CacheEntryUpdate          EventID (EventLevelOp,    EvtNetNDP, 19)
N#define EvtNetNDP_WrongResponse             EventID (EventLevelError, EvtNetNDP, 20)
N#define EvtNetNDP_MakeLinkLocalAddress      EventID (EventLevelOp,    EvtNetNDP, 21)
N#define EvtNetNDP_MakeTempAddress           EventID (EventLevelOp,    EvtNetNDP, 22)
N#define EvtNetNDP_CacheIpRefreshed          EventID (EventLevelOp,    EvtNetNDP, 23)
N#define EvtNetNDP_CacheAdd                  EventID (EventLevelOp,    EvtNetNDP, 24)
N#define EvtNetNDP_RouterListFull            EventID (EventLevelOp,    EvtNetNDP, 25)
N#define EvtNetNDP_CacheAllocFailed          EventID (EventLevelError, EvtNetNDP, 26)
N#define EvtNetNDP_CacheEntryAdded           EventID (EventLevelOp,    EvtNetNDP, 27)
N#define EvtNetNDP_CacheEntryDeleted         EventID (EventLevelOp,    EvtNetNDP, 28)
N#define EvtNetNDP_CacheEntryRefreshed       EventID (EventLevelOp,    EvtNetNDP, 29)
N#define EvtNetNDP_CacheFind                 EventID (EventLevelOp,    EvtNetNDP, 30)
N#define EvtNetNDP_GatewayUnknown            EventID (EventLevelError, EvtNetNDP, 31)
N#define EvtNetNDP_UsingGateway              EventID (EventLevelOp,    EvtNetNDP, 32)
N#define EvtNetNDP_UnresolvedMacAddress      EventID (EventLevelError, EvtNetNDP, 33)
N#define EvtNetNDP_EntryFound                EventID (EventLevelOp,    EvtNetNDP, 34)
N#define EvtNetNDP_CacheIp                   EventID (EventLevelAPI,   EvtNetNDP, 35)
N#define EvtNetNDP_CacheIpInvalidParameter   EventID (EventLevelError, EvtNetNDP, 36)
N#define EvtNetNDP_GetIp                     EventID (EventLevelAPI,   EvtNetNDP, 37)
N#define EvtNetNDP_GetIpInvalidParameter     EventID (EventLevelError, EvtNetNDP, 38)
N#define EvtNetNDP_GetIpEntryNotFound        EventID (EventLevelOp,    EvtNetNDP, 39)
N#define EvtNetNDP_GetMac                    EventID (EventLevelAPI,   EvtNetNDP, 40)
N#define EvtNetNDP_GetMacInvalidParameter    EventID (EventLevelError, EvtNetNDP, 41)
N#define EvtNetNDP_GetMacEntryNotFound       EventID (EventLevelOp,    EvtNetNDP, 42)
N#define EvtNetNDP_Probe                     EventID (EventLevelAPI,   EvtNetNDP, 43)
N#define EvtNetNDP_ProbeInvalidParameter     EventID (EventLevelError, EvtNetNDP, 44)
N#define EvtNetNDP_ProbeBusy                 EventID (EventLevelError, EvtNetNDP, 45)
N#define EvtNetNDP_ProbeRetransmit           EventID (EventLevelOp,    EvtNetNDP, 46)
N#define EvtNetNDP_ProbeTimeout              EventID (EventLevelOp,    EvtNetNDP, 47)
N#define EvtNetNDP_CacheEntryTimeout         EventID (EventLevelOp,    EvtNetNDP, 48)
N#define EvtNetNDP_EntryReleased             EventID (EventLevelOp,    EvtNetNDP, 49)
N#define EvtNetNDP_ResolveEntry              EventID (EventLevelOp,    EvtNetNDP, 50)
N#define EvtNetNDP_RefreshEntry              EventID (EventLevelOp,    EvtNetNDP, 51)
N#define EvtNetNDP_UninitCache               EventID (EventLevelOp,    EvtNetNDP, 52)
N#endif
N
N/**
N  \brief  Event on NDP cache initialize (Op)
N  \param  if_id         network interface identifier
N  \param  num_entries   number of entries available in NDP cache
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_InitCache(uint16_t if_id, uint32_t num_entries) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_InitCache(uint16_t if_id, uint32_t num_entries) {
N    EventRecord2 (EvtNetNDP_InitCache, if_id, num_entries);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (0 & 0xFFU)), if_id, num_entries);
N  }
N#else
S  #define EvrNetNDP_InitCache(if_id, num_entries)
N#endif
N
N/**
N  \brief  Event on NDP discovery frame consistency check failed (Error)
N  \param  if_id         network interface identifier
N  \param  msg_type      discovery message type
N                         - 134: Router Advertisement
N                         - 135: Neighbor Solicitation
N                         - 136: Neighbor Advertisement
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_FrameCheckFailed(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_FrameCheckFailed(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetNDP_FrameCheckFailed, if_id, msg_type);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (1 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetNDP_FrameCheckFailed(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on NDP receive address not link-local (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 source address
N  \remark Nodes must silently discard RA messages if source IP not link-local.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_AddressNotLinkLocal(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_AddressNotLinkLocal(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_AddressNotLinkLocal, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (2 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_AddressNotLinkLocal(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP receive Router Advertisement (RA) message (Op)
N  \param  if_id         network interface identifier
N  \param  hop_limit     current hop limit
N  \param  flags         advertisement flags
N                         - 0x80: M-flag (Managed address configuration)
N                         - 0x40: O-flag (Other configuration)
N  \param  lifetime      router lifetime in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_RouterAdvertisement(uint16_t if_id,
X  static __inline __attribute__((always_inline)) void EvrNetNDP_RouterAdvertisement(uint16_t if_id,
N                           uint8_t hop_limit, uint8_t flags, uint16_t lifetime) {
N    evr_buf.u16[0] = lifetime;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = lifetime;
N    evr_buf.u8[2]  = hop_limit;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = hop_limit;
N    evr_buf.u8[3]  = flags;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = flags;
N    EventRecord2 (EvtNetNDP_RouterAdvertisement, if_id, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (3 & 0xFFU)), if_id, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetNDP_RouterAdvertisement(if_id, hop_limit, flags, lifetime)
N#endif
N
N/**
N  \brief  Event on NDP option Maximum transmission unit (MTU) (Op)
N  \param  if_id         network interface identifier
N  \param  mtu           maximum transmission unit
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_OptionMtu(uint16_t if_id, uint32_t mtu) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_OptionMtu(uint16_t if_id, uint32_t mtu) {
N    EventRecord2 (EvtNetNDP_OptionMtu, if_id, mtu);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (4 & 0xFFU)), if_id, mtu);
N  }
N#else
S  #define EvrNetNDP_OptionMtu(if_id, mtu)
N#endif
N
N/**
N  \brief  Event on NDP option Source link-layer (MAC) address (Op)
N  \param  if_id         network interface identifier
N  \param  src_addr      source link-layer address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_OptionSourceMacAddress(uint16_t if_id, const uint8_t *src_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_OptionSourceMacAddress(uint16_t if_id, const uint8_t *src_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], src_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], src_addr, 6);
N    EventRecordData (EvtNetNDP_OptionSourceMacAddress, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (5 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetNDP_OptionSourceMacAddress(if_id, src_addr)
N#endif
N
N/**
N  \brief  Event on NDP option address prefix info (Op)
N  \param  opt_prefix    pointer to prefix info structure (32 bytes)
N                         - Type:      1 byte
N                         - Length:    1 byte
N                         - PrefixLen: 1 byte
N                         - Flags:     1 byte
N                         - Valid:     4 bytes
N                         - Preferred: 4 bytes
N                         - Reserved:  4 bytes
N                         - Prefix:   16 bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_OptionPrefixInfo(const uint8_t *opt_prefix) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_OptionPrefixInfo(const uint8_t *opt_prefix) {
N    EventRecordData (EvtNetNDP_OptionPrefixInfo, opt_prefix, 32);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (6 & 0xFFU)), opt_prefix, 32);
N  }
N#else
S  #define EvrNetNDP_OptionPrefixInfo(opt_prefix)
N#endif
N
N/**
N  \brief  Event on NDP prefix information option not valid (Op)
N  \remark Nodes must silently discard not valid RA messages.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_PrefixInfoNotValid(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_PrefixInfoNotValid(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_PrefixInfoNotValid, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (7 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_PrefixInfoNotValid(if_id)
N#endif
N
N/**
N  \brief  Event on NDP receive wrong target address (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     pointer to target address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_WrongTargetAddress(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_WrongTargetAddress(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_WrongTargetAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (8 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_WrongTargetAddress(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP receive Neighbor Solicitation (NS) message (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     pointer to target address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_NeighborSolicitation(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_NeighborSolicitation(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_NeighborSolicitation, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (9 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_NeighborSolicitation(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP receive probe request (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeRequest(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeRequest(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_ProbeRequest, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (10 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_ProbeRequest(if_id)
N#endif
N
N/**
N  \brief  Event on NDP receive Neighbor Advertisement (NA) message (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     pointer to target address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_NeighborAdvertisement(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_NeighborAdvertisement(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_NeighborAdvertisement, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (11 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_NeighborAdvertisement(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP receive probe response (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeResponse(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeResponse(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_ProbeResponse, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (12 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_ProbeResponse(if_id)
N#endif
N
N/**
N  \brief  Event on NDP receive wrong destination address (Op)
N  \param  if_id         network interface identifier
N  \param  dst_addr      pointer to destination address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_WrongDestinationAddress(uint16_t if_id, const uint8_t *dst_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_WrongDestinationAddress(uint16_t if_id, const uint8_t *dst_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], dst_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], dst_addr, 16);
N    EventRecordData (EvtNetNDP_WrongDestinationAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (13 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_WrongDestinationAddress(if_id, dst_addr)
N#endif
N
N/**
N  \brief  Event on NDP send advertisement reply to solicitation message (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     pointer to target address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_SendReply(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_SendReply(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_SendReply, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (14 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_SendReply(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP display advertisement message flags (Op)
N  \param  if_id         network interface identifier
N  \param  flags         message flags
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ShowFlags(uint16_t if_id, uint32_t flags) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ShowFlags(uint16_t if_id, uint32_t flags) {
N    EventRecord2 (EvtNetNDP_ShowFlags, if_id, flags);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (15 & 0xFFU)), if_id, flags);
N  }
N#else
S  #define EvrNetNDP_ShowFlags(if_id, flags)
N#endif
N
N/**
N  \brief  Event on NDP send solicitation request (Op)
N  \param  if_id         network interface identifier
N  \param  type          request type
N                         - 133: Router Solicitation
N                         - 135: Neighbor Solicitation
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_SendRequest(uint16_t if_id, uint32_t type) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_SendRequest(uint16_t if_id, uint32_t type) {
N    if (type == 255) type = 135;
N    EventRecord2 (EvtNetNDP_SendRequest, if_id, type);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (16 & 0xFFU)), if_id, type);
N  }
N#else
S  #define EvrNetNDP_SendRequest(if_id, type)
N#endif
N
N/**
N  \brief  Event on NDP display target IPv6 address (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     pointer to target address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ShowTargetAddress(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ShowTargetAddress(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_ShowTargetAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (17 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_ShowTargetAddress(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP option target link-layer (MAC) address (Op)
N  \param  if_id         network interface identifier
N  \param  targ_addr     target link-layer address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_OptionTargetMacAddress(uint16_t if_id, const uint8_t *targ_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_OptionTargetMacAddress(uint16_t if_id, const uint8_t *targ_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], targ_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], targ_addr, 16);
N    EventRecordData (EvtNetNDP_OptionTargetMacAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (18 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_OptionTargetMacAddress(if_id, targ_addr)
N#endif
N
N/**
N  \brief  Event on NDP cache entry update (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheEntryUpdate(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheEntryUpdate(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetNDP_CacheEntryUpdate, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (19 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetNDP_CacheEntryUpdate(if_id, entry)
N#endif
N
N/**
N  \brief  Event on NDP wrong response received (Error)
N  \param  if_id         network interface identifier
N  \param  msg_type      discovery message type
N                         - 136: Neighbor Advertisement
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_WrongResponse(uint16_t if_id, uint8_t msg_type) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_WrongResponse(uint16_t if_id, uint8_t msg_type) {
N    EventRecord2 (EvtNetNDP_WrongResponse, if_id, msg_type);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (20 & 0xFFU)), if_id, msg_type);
N  }
N#else
S  #define EvrNetNDP_WrongResponse(if_id, msg_type)
N#endif
N
N/**
N  \brief  Event on NDP make link-local address (Op)
N  \param  if_id         network interface identifier
N  \param  local_addr    pointer to link-local address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_MakeLinkLocalAddress(uint16_t if_id, const uint8_t *local_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_MakeLinkLocalAddress(uint16_t if_id, const uint8_t *local_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], local_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], local_addr, 16);
N    EventRecordData (EvtNetNDP_MakeLinkLocalAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (21 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_MakeLinkLocalAddress(if_id, local_addr)
N#endif
N
N/**
N  \brief  Event on NDP make temporary address (SLAAC) using prefix info (Op)
N  \param  if_id         network interface identifier
N  \param  temp_addr     pointer to temporary address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_MakeTempAddress(uint16_t if_id, const uint8_t *temp_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_MakeTempAddress(uint16_t if_id, const uint8_t *temp_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], temp_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], temp_addr, 16);
N    EventRecordData (EvtNetNDP_MakeTempAddress, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (22 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_MakeTempAddress(if_id, temp_addr)
N#endif
N
N/**
N  \brief  Event on NDP cached IP address refreshed (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheIpRefreshed(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheIpRefreshed(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_CacheIpRefreshed, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (23 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_CacheIpRefreshed(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP add entry to NDP cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address
N  \param  mac_addr      pointer to MAC address
N  \param  type          cache entry type:
N                         - 0x01: Host
N                         - 0x02: Router
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheAdd(uint16_t if_id,
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheAdd(uint16_t if_id,
N                    const uint8_t *ip6_addr, const uint8_t *mac_addr, uint8_t type) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u8[2]  = 0;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = 0;
N    evr_buf.u8[3]  = (uint8_t)type;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = (uint8_t)type;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    memcpy (&evr_buf.u8[20], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[20], mac_addr, 6);
N    EventRecordData (EvtNetNDP_CacheAdd, &evr_buf, 26);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (24 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 26);
N  }
N#else
S  #define EvrNetNDP_CacheAdd(if_id, ip6_addr, mac_addr, type)
N#endif
N
N/**
N  \brief  Event on NDP cache add router list full (Op)
N  \param  if_id         network interface identifier
N  \param  max_count     maximum number of routers cached
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_RouterListFull(uint16_t if_id, uint32_t max_count) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_RouterListFull(uint16_t if_id, uint32_t max_count) {
N    EventRecord2 (EvtNetNDP_RouterListFull, if_id, max_count);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (25 & 0xFFU)), if_id, max_count);
N  }
N#else
S  #define EvrNetNDP_RouterListFull(if_id, max_count)
N#endif
N
N/**
N  \brief  Event on NDP allocate free cache entry failed (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheAllocFailed(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheAllocFailed(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_CacheAllocFailed, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (26 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_CacheAllocFailed(if_id)
N#endif
N
N/**
N  \brief  Event on NDP cache entry added (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N  \param  timeout       entry timeout in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheEntryAdded(uint16_t if_id, uint32_t entry, uint32_t timeout) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheEntryAdded(uint16_t if_id, uint32_t entry, uint32_t timeout) {
N    uint32_t val1 = (entry << 16) | if_id;
N    EventRecord2 (EvtNetNDP_CacheEntryAdded, val1, timeout);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (27 & 0xFFU)), val1, timeout);
N  }
N#else
S  #define EvrNetNDP_CacheEntryAdded(if_id, entry, timeout)
N#endif
N
N/**
N  \brief  Event on NDP cache entry deleted (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N  \param  ip6_addr      pointer to IPv6 address
N  \param  type          cache entry type:
N                         - 0x01: Host
N                         - 0x02: Router
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheEntryDeleted(uint16_t if_id,
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheEntryDeleted(uint16_t if_id,
N                         uint32_t entry, const uint8_t *ip6_addr, uint8_t type) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u8[2]  = (uint8_t)entry;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = (uint8_t)entry;
N    evr_buf.u8[3]  = (uint8_t)type;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = (uint8_t)type;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_CacheEntryDeleted, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (28 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_CacheEntryDeleted(if_id, entry, ip6_addr, type)
N#endif
N
N/**
N  \brief  Event on NDP cache entry refreshed (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheEntryRefreshed(uint16_t if_id,
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheEntryRefreshed(uint16_t if_id,
N                         uint32_t entry, const uint8_t *ip6_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u8[2]  = (uint8_t)entry;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = (uint8_t)entry;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_CacheEntryRefreshed, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (29 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_CacheEntryRefreshed(if_id, entry, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP find IP address in cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheFind(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheFind(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_CacheFind, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (30 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_CacheFind(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP cache add gateway unknown (Error)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GatewayUnknown(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GatewayUnknown(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_GatewayUnknown, &evr_buf, 20);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (31 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_GatewayUnknown(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP using gateway to access external address (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address of a gateway
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_UsingGateway(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_UsingGateway(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_UsingGateway, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (32 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_UsingGateway(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP unresolved MAC address in cache (Error)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to requested IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_UnresolvedMacAddress(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_UnresolvedMacAddress(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_UnresolvedMacAddress, &evr_buf, 20);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (33 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_UnresolvedMacAddress(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP cache entry found (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_EntryFound(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_EntryFound(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetNDP_EntryFound, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (34 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetNDP_EntryFound(if_id, entry)
N#endif
N
N/**
N  \brief  Event on netNDP_CacheIP execute (API)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to requested IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheIp(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheIp(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_CacheIp, &evr_buf, 20);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (35 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_CacheIp(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_CacheIP invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheIpInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheIpInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_CacheIpInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (36 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_CacheIpInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netNDP_GetIP resolving success (API)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to requested MAC address
N  \param  ip6_addr      pointer to resolved IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetIp(uint16_t if_id, const uint8_t *mac_addr, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetIp(uint16_t if_id, const uint8_t *mac_addr, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    memcpy (&evr_buf.u8[20], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[20], mac_addr, 6);
N    EventRecordData (EvtNetNDP_GetIp, &evr_buf, 26);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (37 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 26);
N  }
N#else
S  #define EvrNetNDP_GetIp(if_id, mac_addr, ip6_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_GetIP invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetIpInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetIpInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_GetIpInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (38 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_GetIpInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netNDP_GetIP entry with MAC address not found in cache (Op)
N  \param  if_id         network interface identifier
N  \param  mac_addr      pointer to requested MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetIpEntryNotFound(uint16_t if_id, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetIpEntryNotFound(uint16_t if_id, const uint8_t *mac_addr) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    memcpy (&evr_buf.u16[1], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u16[1], mac_addr, 6);
N    EventRecordData (EvtNetNDP_GetIpEntryNotFound, &evr_buf, 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (39 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetNDP_GetIpEntryNotFound(if_id, mac_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_GetMAC resolving success (API)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to requested IPv6 address
N  \param  mac_addr      pointer to resolved MAC address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetMac(uint16_t if_id, const uint8_t *ip6_addr, const uint8_t *mac_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetMac(uint16_t if_id, const uint8_t *ip6_addr, const uint8_t *mac_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    memcpy (&evr_buf.u8[20], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[20], mac_addr, 6);
N    EventRecordData (EvtNetNDP_GetMac, &evr_buf, 26);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (40 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 26);
N  }
N#else
S  #define EvrNetNDP_GetMac(if_id, ip6_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_GetMAC invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetMacInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetMacInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_GetMacInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (41 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_GetMacInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on netNDP_GetMAC entry with IP address not found in cache (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to requested IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_GetMacEntryNotFound(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_GetMacEntryNotFound(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_GetMacEntryNotFound, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (42 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_GetMacEntryNotFound(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_Probe execute (API)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to requested IPv6 address
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_Probe(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_Probe(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_Probe, &evr_buf, 20);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (43 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_Probe(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on netNDP_Probe invalid parameter (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeInvalidParameter(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeInvalidParameter(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_ProbeInvalidParameter, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (44 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_ProbeInvalidParameter(if_id)
N#endif
N
N/**
N  \brief  Event on NDP probe process busy (Error)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeBusy(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeBusy(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_ProbeBusy, if_id, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (45 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_ProbeBusy(if_id)
N#endif
N
N/**
N  \brief  Event on NDP probe retransmit (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address of probed host
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeRetransmit(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeRetransmit(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_ProbeRetransmit, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (46 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_ProbeRetransmit(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP probe timeout (Op)
N  \param  if_id         network interface identifier
N  \param  ip6_addr      pointer to IPv6 address of probed host
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ProbeTimeout(uint16_t if_id, const uint8_t *ip6_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ProbeTimeout(uint16_t if_id, const uint8_t *ip6_addr) {
N    evr_buf.u32[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = if_id;
N    memcpy (&evr_buf.u32[1], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], ip6_addr, 16);
N    EventRecordData (EvtNetNDP_ProbeTimeout, &evr_buf, 20);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (47 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 20);
N  }
N#else
S  #define EvrNetNDP_ProbeTimeout(if_id, ip6_addr)
N#endif
N
N/**
N  \brief  Event on NDP cache entry timeout (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N  \param  ip6_addr      pointer to IPv6 address
N  \param  mac_addr      pointer to MAC address
N  \param  type          cache entry type:
N                         - 0x01: Host
N                         - 0x02: Router
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_CacheEntryTimeout(uint16_t if_id, uint32_t entry,
X  static __inline __attribute__((always_inline)) void EvrNetNDP_CacheEntryTimeout(uint16_t if_id, uint32_t entry,
N                    const uint8_t *ip6_addr, const uint8_t *mac_addr, uint32_t type) {
N    evr_buf.u16[0] = if_id;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = if_id;
N    evr_buf.u8[2]  = (uint8_t)entry;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = (uint8_t)entry;
N    evr_buf.u8[3]  = (uint8_t)type;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = (uint8_t)type;
N    memcpy (&evr_buf.u8[4], ip6_addr, 16);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip6_addr, 16);
N    memcpy (&evr_buf.u8[20], mac_addr, 6);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[20], mac_addr, 6);
N    EventRecordData (EvtNetNDP_CacheEntryTimeout, &evr_buf, 26);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (48 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 26);
N  }
N#else
S  #define EvrNetNDP_CacheEntryTimeout(if_id, entry, type, ip6_addr, mac_addr)
N#endif
N
N/**
N  \brief  Event on NDP cache entry released (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_EntryReleased(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_EntryReleased(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetNDP_EntryReleased, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (49 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetNDP_EntryReleased(if_id, entry)
N#endif
N
N/**
N  \brief  Event on resolve NDP cache entry (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_ResolveEntry(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_ResolveEntry(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetNDP_ResolveEntry, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (50 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetNDP_ResolveEntry(if_id, entry)
N#endif
N
N/**
N  \brief  Event on refresh NDP cache entry (Op)
N  \param  if_id         network interface identifier
N  \param  entry         cache entry number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_RefreshEntry(uint16_t if_id, uint32_t entry) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_RefreshEntry(uint16_t if_id, uint32_t entry) {
N    EventRecord2 (EvtNetNDP_RefreshEntry, if_id, entry);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (51 & 0xFFU)), if_id, entry);
N  }
N#else
S  #define EvrNetNDP_RefreshEntry(if_id, entry)
N#endif
N
N/**
N  \brief  Event on NDP cache de-initialize (Op)
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetNDP_UninitCache(uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetNDP_UninitCache(uint16_t if_id) {
N    EventRecord2 (EvtNetNDP_UninitCache, if_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xCF & 0xFFU) << 8) | (52 & 0xFFU)), if_id, 0);
N  }
N#else
S  #define EvrNetNDP_UninitCache(if_id)
N#endif
N
N
N// NetUDP event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetUDP_InitSockets               EventID (EventLevelOp,    EvtNetUDP,  0)
N#define EvtNetUDP_GetSocket                 EventID (EventLevelOp,    EvtNetUDP,  1)
N#define EvtNetUDP_GetSocketInvalidParameter EventID (EventLevelError, EvtNetUDP,  2)
N#define EvtNetUDP_NoSocketAvailable         EventID (EventLevelError, EvtNetUDP,  3)
N#define EvtNetUDP_ReleaseSocket             EventID (EventLevelOp,    EvtNetUDP,  4)
N#define EvtNetUDP_ReleaseSocketNotValid     EventID (EventLevelError, EvtNetUDP,  5)
N#define EvtNetUDP_ReleaseSocketWrongState   EventID (EventLevelError, EvtNetUDP,  6)
N#define EvtNetUDP_OpenSocket                EventID (EventLevelOp,    EvtNetUDP,  7)
N#define EvtNetUDP_OpenSocketNotValid        EventID (EventLevelError, EvtNetUDP,  8)
N#define EvtNetUDP_OpenSocketWrongState      EventID (EventLevelError, EvtNetUDP,  9)
N#define EvtNetUDP_AssignLocalPort           EventID (EventLevelOp,    EvtNetUDP, 10)
N#define EvtNetUDP_OpenLocalPortInUse        EventID (EventLevelError, EvtNetUDP, 11)
N#define EvtNetUDP_CloseSocket               EventID (EventLevelOp,    EvtNetUDP, 12)
N#define EvtNetUDP_CloseSocketNotValid       EventID (EventLevelError, EvtNetUDP, 13)
N#define EvtNetUDP_SetOptionSocket           EventID (EventLevelOp,    EvtNetUDP, 14)
N#define EvtNetUDP_SetOptionSocketNotValid   EventID (EventLevelError, EvtNetUDP, 15)
N#define EvtNetUDP_SetOptionSocketWrongState EventID (EventLevelError, EvtNetUDP, 16)
N#define EvtNetUDP_SetOptionTos              EventID (EventLevelDetail,EvtNetUDP, 17)
N#define EvtNetUDP_SetOptionTtl              EventID (EventLevelDetail,EvtNetUDP, 18)
N#define EvtNetUDP_SetOptionTclass           EventID (EventLevelDetail,EvtNetUDP, 19)
N#define EvtNetUDP_SetOptionHopLimit         EventID (EventLevelDetail,EvtNetUDP, 20)
N#define EvtNetUDP_SetOptionChecksum         EventID (EventLevelDetail,EvtNetUDP, 21)
N#define EvtNetUDP_SetOptionInterface        EventID (EventLevelDetail,EvtNetUDP, 42) // End
N#define EvtNetUDP_SetOptionWrongOption      EventID (EventLevelError, EvtNetUDP, 22)
N#define EvtNetUDP_SetOptionWrongValue       EventID (EventLevelError, EvtNetUDP, 23)
N#define EvtNetUDP_GetBufferFailed           EventID (EventLevelError, EvtNetUDP, 24)
N#define EvtNetUDP_SendFrame                 EventID (EventLevelOp,    EvtNetUDP, 25)
N#define EvtNetUDP_SendBufferInvalid         EventID (EventLevelError, EvtNetUDP, 26)
N#define EvtNetUDP_SendSocketNotValid        EventID (EventLevelError, EvtNetUDP, 27)
N#define EvtNetUDP_SendAddressUnspecified    EventID (EventLevelError, EvtNetUDP, 28)
N#define EvtNetUDP_SendPortUndefined         EventID (EventLevelError, EvtNetUDP, 29)
N#define EvtNetUDP_SendSocketNotOpen         EventID (EventLevelError, EvtNetUDP, 30)
N#define EvtNetUDP_SendZeroLengthFrame       EventID (EventLevelOp,    EvtNetUDP, 31)
N#define EvtNetUDP_SendNoRouteFound          EventID (EventLevelError, EvtNetUDP, 41)
N#define EvtNetUDP_SendSizeTruncated         EventID (EventLevelOp,    EvtNetUDP, 32)
N#define EvtNetUDP_ShowFrameHeader           EventID (EventLevelDetail,EvtNetUDP, 33)
N#define EvtNetUDP_ReceiveFrame              EventID (EventLevelOp,    EvtNetUDP, 34)
N#define EvtNetUDP_FrameTooShort             EventID (EventLevelError, EvtNetUDP, 35)
N#define EvtNetUDP_MapFrameToSocket          EventID (EventLevelOp,    EvtNetUDP, 36)
N#define EvtNetUDP_FrameNotMapped            EventID (EventLevelOp,    EvtNetUDP, 37)
N#define EvtNetUDP_LinkLayerAddressed        EventID (EventLevelError, EvtNetUDP, 38)
N#define EvtNetUDP_ChecksumFailed            EventID (EventLevelError, EvtNetUDP, 39)
N#define EvtNetUDP_UninitSockets             EventID (EventLevelOp,    EvtNetUDP, 40)
N#endif
N
N/**
N  \brief  Event on UDP socket initialize (Op)
N  \param  num_sockets   number of available UDP sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_InitSockets(uint32_t num_sockets) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_InitSockets(uint32_t num_sockets) {
N    EventRecord2 (EvtNetUDP_InitSockets, num_sockets, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (0 & 0xFFU)), num_sockets, 0);
N  }
N#else
S  #define EvrNetUDP_InitSockets(num_sockets)
N#endif
N
N/**
N  \brief  Event on UDP allocate a free socket (Op)
N  \param  socket        allocated socket handle
N  \param  num_socks     number of available UDP sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_GetSocket(int32_t socket, uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_GetSocket(int32_t socket, uint32_t num_socks) {
N    EventRecord2 (EvtNetUDP_GetSocket, (uint32_t)socket, num_socks);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (1 & 0xFFU)), (uint32_t)socket, num_socks);
N  }
N#else
S  #define EvrNetUDP_GetSocket(socket,num_socks)
N#endif
N
N/**
N  \brief  Event on UDP get socket failed, invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_GetSocketInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_GetSocketInvalidParameter(void) {
N    EventRecord2 (EvtNetUDP_GetSocketInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetUDP_GetSocketInvalidParameter()
N#endif
N
N/**
N  \brief  Event on UDP get socket failed, no free socket available (Error)
N  \param  num_socks     number of available UDP sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_NoSocketAvailable(uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_NoSocketAvailable(uint32_t num_socks) {
N    EventRecord2 (EvtNetUDP_NoSocketAvailable, num_socks, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (3 & 0xFFU)), num_socks, 0);
N  }
N#else
S  #define EvrNetUDP_NoSocketAvailable(num_socks)
N#endif
N
N/**
N  \brief  Event on UDP release socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ReleaseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ReleaseSocket(int32_t socket) {
N    EventRecord2 (EvtNetUDP_ReleaseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (4 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_ReleaseSocket(socket)
N#endif
N
N/**
N  \brief  Event on UDP release failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ReleaseSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ReleaseSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_ReleaseSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (5 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_ReleaseSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on UDP release failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ReleaseSocketWrongState(int32_t socket, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ReleaseSocketWrongState(int32_t socket, uint8_t state) {
N    EventRecord2 (EvtNetUDP_ReleaseSocketWrongState, (uint32_t)socket, state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (6 & 0xFFU)), (uint32_t)socket, state);
N  }
N#else
S  #define EvrNetUDP_ReleaseSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on UDP open socket for communication (Op)
N  \param  socket        socket handle
N  \param  port          local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_OpenSocket(int32_t socket, uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_OpenSocket(int32_t socket, uint16_t port) {
N    EventRecord2 (EvtNetUDP_OpenSocket, (uint32_t)socket, port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (7 & 0xFFU)), (uint32_t)socket, port);
N  }
N#else
S  #define EvrNetUDP_OpenSocket(socket, port)
N#endif
N
N/**
N  \brief  Event on UDP open failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_OpenSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_OpenSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_OpenSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (8 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_OpenSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on UDP open socket failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_OpenSocketWrongState(int32_t socket, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_OpenSocketWrongState(int32_t socket, uint8_t state) {
N    EventRecord2 (EvtNetUDP_OpenSocketWrongState, (uint32_t)socket, state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (9 & 0xFFU)), (uint32_t)socket, state);
N  }
N#else
S  #define EvrNetUDP_OpenSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on UDP local port assigned in open socket request (Op)
N  \param  socket        socket handle
N  \param  local_port    assigned local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_AssignLocalPort(int32_t socket, uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_AssignLocalPort(int32_t socket, uint16_t local_port) {
N    EventRecord2 (EvtNetUDP_AssignLocalPort, (uint32_t)socket, local_port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (10 & 0xFFU)), (uint32_t)socket, local_port);
N  }
N#else
S  #define EvrNetUDP_AssignLocalPort(socket, local_port)
N#endif
N
N/**
N  \brief  Event on UDP open socket failed, requested port already used (Error)
N  \param  socket        socket handle
N  \param  port          local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_OpenLocalPortInUse(int32_t socket, uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_OpenLocalPortInUse(int32_t socket, uint16_t port) {
N    EventRecord2 (EvtNetUDP_OpenLocalPortInUse, (uint32_t)socket, port);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (11 & 0xFFU)), (uint32_t)socket, port);
N  }
N#else
S  #define EvrNetUDP_OpenLocalPortInUse(socket, port)
N#endif
N
N/**
N  \brief  Event on UDP close socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_CloseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_CloseSocket(int32_t socket) {
N    EventRecord2 (EvtNetUDP_CloseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (12 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_CloseSocket(socket)
N#endif
N
N/**
N  \brief  Event on UDP close socket failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_CloseSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_CloseSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_CloseSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (13 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_CloseSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on UDP set socket option (Op)
N  \param  socket        socket handle
N  \param  option        interface option as specified by \ref netUDP_Option
N  \param  val           option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionSocket(int32_t socket, int32_t option, uint32_t val) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionSocket(int32_t socket, int32_t option, uint32_t val) {
N    uint32_t val2 = (val << 8) | (uint8_t)option;
N    EventRecord2 (EvtNetUDP_SetOptionSocket, (uint32_t)socket, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (14 & 0xFFU)), (uint32_t)socket, val2);
N  }
N#else
S  #define EvrNetUDP_SetOptionSocket(socket, option, val)
N#endif
N
N/**
N  \brief  Event on UDP set socket option failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SetOptionSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (15 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SetOptionSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on UDP set socket option failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionSocketWrongState(int32_t socket, uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionSocketWrongState(int32_t socket, uint8_t state) {
N    EventRecord2 (EvtNetUDP_SetOptionSocketWrongState, (uint32_t)socket, state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (16 & 0xFFU)), (uint32_t)socket, state);
N  }
N#else
S  #define EvrNetUDP_SetOptionSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on UDP set socket option Type Of Service for IPv4 (Detail)
N  \param  socket        socket handle
N  \param  ip4_tos       type of service value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionTos(int32_t socket, uint8_t ip4_tos) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionTos(int32_t socket, uint8_t ip4_tos) {
N    EventRecord2 (EvtNetUDP_SetOptionTos, (uint32_t)socket, ip4_tos);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (17 & 0xFFU)), (uint32_t)socket, ip4_tos);
N  }
N#else
S  #define EvrNetUDP_SetOptionTos(socket, ip4_tos)
N#endif
N
N/**
N  \brief  Event on UDP set socket option Time To Live for IPv4 (Detail)
N  \param  socket        socket handle
N  \param  ip4_ttl       time to live value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionTtl(int32_t socket, uint8_t ip4_ttl) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionTtl(int32_t socket, uint8_t ip4_ttl) {
N    EventRecord2 (EvtNetUDP_SetOptionTtl, (uint32_t)socket, ip4_ttl);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (18 & 0xFFU)), (uint32_t)socket, ip4_ttl);
N  }
N#else
S  #define EvrNetUDP_SetOptionTtl(socket, ip4_ttl)
N#endif
N
N/**
N  \brief  Event on UDP set socket option Traffic Class for IPv6 (Detail)
N  \param  socket        socket handle
N  \param  ip6_tclass    traffic class value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionTclass(int32_t socket, uint8_t ip6_tclass) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionTclass(int32_t socket, uint8_t ip6_tclass) {
N    EventRecord2 (EvtNetUDP_SetOptionTclass, (uint32_t)socket, ip6_tclass);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (19 & 0xFFU)), (uint32_t)socket, ip6_tclass);
N  }
N#else
S  #define EvrNetUDP_SetOptionTclass(socket, ip6_tclass)
N#endif
N
N/**
N  \brief  Event on UDP set socket option Hop Limit for IPv6 (Detail)
N  \param  socket        socket handle
N  \param  ip6_hoplimit  hop limit value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionHopLimit(int32_t socket, uint8_t ip6_hoplimit) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionHopLimit(int32_t socket, uint8_t ip6_hoplimit) {
N    EventRecord2 (EvtNetUDP_SetOptionHopLimit, (uint32_t)socket, ip6_hoplimit);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (20 & 0xFFU)), (uint32_t)socket, ip6_hoplimit);
N  }
N#else
S  #define EvrNetUDP_SetOptionHopLimit(socket, ip6_hoplimit)
N#endif
N
N/**
N  \brief  Event on UDP set socket option checksum calculation options (Detail)
N  \param  socket        socket handle
N  \param  checksum      checksum calculation options bitmap
N                         - 0x01: calculate checksum for send frames
N                         - 0x02: verify checksum for received frames
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionChecksum(int32_t socket, uint32_t checksum) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionChecksum(int32_t socket, uint32_t checksum) {
N    EventRecord2 (EvtNetUDP_SetOptionChecksum, (uint32_t)socket, checksum);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (21 & 0xFFU)), (uint32_t)socket, checksum);
N  }
N#else
S  #define EvrNetUDP_SetOptionChecksum(socket, checksum)
N#endif
N
N/**
N  \brief  Event on UDP set socket option broadcast interface (Detail)
N  \param  socket        socket handle
N  \param  if_id         network interface identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionInterface(int32_t socket, uint16_t if_id) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionInterface(int32_t socket, uint16_t if_id) {
N    EventRecord2 (EvtNetUDP_SetOptionInterface, (uint32_t)socket, if_id);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (42 & 0xFFU)), (uint32_t)socket, if_id);
N  }
N#else
S  #define EvrNetUDP_SetOptionInterface(socket, if_id)
N#endif
N
N/**
N  \brief  Event on UDP wrong set socket option (Error)
N  \param  socket        socket handle
N  \param  udp_option    wrong set option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionWrongOption(int32_t socket, int32_t udp_option) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionWrongOption(int32_t socket, int32_t udp_option) {
N    EventRecord2 (EvtNetUDP_SetOptionWrongOption, (uint32_t)socket, (uint32_t)udp_option);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (22 & 0xFFU)), (uint32_t)socket, (uint32_t)udp_option);
N  }
N#else
S  #define EvrNetUDP_SetOptionWrongOption(socket, udp_option)
N#endif
N
N/**
N  \brief  Event on UDP wrong value for set socket option (Error)
N  \param  socket        socket handle
N  \param  opt_value     wrong value for set option
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SetOptionWrongValue(int32_t socket, uint32_t opt_value) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SetOptionWrongValue(int32_t socket, uint32_t opt_value) {
N    EventRecord2 (EvtNetUDP_SetOptionWrongValue, (uint32_t)socket, opt_value);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (23 & 0xFFU)), (uint32_t)socket, opt_value);
N  }
N#else
S  #define EvrNetUDP_SetOptionWrongValue(socket, opt_value)
N#endif
N
N/**
N  \brief  Event on UDP get buffer failed, out of memory (Error)
N  \param  mem_size      requested memory size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_GetBufferFailed(uint16_t mem_size) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_GetBufferFailed(uint16_t mem_size) {
N    EventRecord2 (EvtNetUDP_GetBufferFailed, mem_size, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (24 & 0xFFU)), mem_size, 0);
N  }
N#else
S  #define EvrNetUDP_GetBufferFailed(mem_size)
N#endif
N
N/**
N  \brief  Event on UDP send frame (Op)
N  \param  socket        socket handle
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendFrame(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendFrame(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetUDP_SendFrame, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (25 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetUDP_SendFrame(socket, length)
N#endif
N
N/**
N  \brief  Event on UDP send buffer is invalid (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendBufferInvalid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendBufferInvalid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendBufferInvalid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (26 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendBufferInvalid(socket)
N#endif
N
N/**
N  \brief  Event on UDP send socket handle is not valid (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (27 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on UDP send destination address not specified (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendAddressUnspecified(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendAddressUnspecified(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendAddressUnspecified, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (28 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendAddressUnspecified(socket)
N#endif
N
N/**
N  \brief  Event on UDP send port undefined (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendPortUndefined(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendPortUndefined(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendPortUndefined, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (29 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendPortUndefined(socket)
N#endif
N
N/**
N  \brief  Event on UDP send socket not open, invalid socket state (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendSocketNotOpen(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendSocketNotOpen(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendSocketNotOpen, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (30 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendSocketNotOpen(socket)
N#endif
N
N/**
N  \brief  Event on UDP send 0-length frame, frame is dumped (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendZeroLengthFrame(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendZeroLengthFrame(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendZeroLengthFrame, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (31 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendZeroLengthFrame(socket)
N#endif
N
N/**
N  \brief  Event on UDP send failed, no route to destination found (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendNoRouteFound(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendNoRouteFound(int32_t socket) {
N    EventRecord2 (EvtNetUDP_SendNoRouteFound, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (41 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_SendNoRouteFound(socket)
N#endif
N
N/**
N  \brief  Event on UDP send truncated over-size packet (Op)
N  \param  socket        socket handle
N  \param  new_length    truncated frame length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_SendSizeTruncated(int32_t socket, uint32_t new_length) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_SendSizeTruncated(int32_t socket, uint32_t new_length) {
N    EventRecord2 (EvtNetUDP_SendSizeTruncated, (uint32_t)socket, new_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (32 & 0xFFU)), (uint32_t)socket, new_length);
N  }
N#else
S  #define EvrNetUDP_SendSizeTruncated(socket, new_length)
N#endif
N
N/**
N  \brief  Event on UDP display send/receive frame header (Detail)
N  \param  udp_header    pointer to UDP frame header of 8 bytes
N                         - SrcPort (2 bytes)
N                         - DstPort (2 bytes)
N                         - Len     (2 bytes)
N                         - Chksum  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ShowFrameHeader(const void *udp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ShowFrameHeader(const void *udp_header) {
N    EventRecordData (EvtNetUDP_ShowFrameHeader, udp_header, 8);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (33 & 0xFFU)), udp_header, 8);
N  }
N#else
S  #define EvrNetUDP_ShowFrameHeader(udp_header)
N#endif
N
N/**
N  \brief  Event on UDP receive frame (Op)
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
N    EventRecord2 (EvtNetUDP_ReceiveFrame, length, ip_version);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (34 & 0xFFU)), length, ip_version);
N  }
N#else
S  #define EvrNetUDP_ReceiveFrame(length, ip_version)
N#endif
N
N/**
N  \brief  Event on UDP receive frame too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetUDP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (35 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetUDP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on UDP received frame mapped to a socket (Op)
N  \param  socket        mapped socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_MapFrameToSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_MapFrameToSocket(int32_t socket) {
N    EventRecord2 (EvtNetUDP_MapFrameToSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (36 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_MapFrameToSocket(socket)
N#endif
N
N/**
N  \brief  Event on UDP received frame not mapped, no open sockets found (Op)
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_FrameNotMapped(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_FrameNotMapped(uint32_t length) {
N    EventRecord2 (EvtNetUDP_FrameNotMapped, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (37 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetUDP_FrameNotMapped(length)
N#endif
N
N/**
N  \brief  Event on UDP received frame link-layer addressed (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_LinkLayerAddressed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_LinkLayerAddressed(int32_t socket) {
N    EventRecord2 (EvtNetUDP_LinkLayerAddressed, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (38 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_LinkLayerAddressed(socket)
N#endif
N
N/**
N  \brief  Event on UDP frame checksum check failed (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_ChecksumFailed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_ChecksumFailed(int32_t socket) {
N    EventRecord2 (EvtNetUDP_ChecksumFailed, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (39 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetUDP_ChecksumFailed(socket)
N#endif
N
N/**
N  \brief  Event on UDP de-initialize available sockets (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetUDP_UninitSockets(void) {
X  static __inline __attribute__((always_inline)) void EvrNetUDP_UninitSockets(void) {
N    EventRecord2 (EvtNetUDP_UninitSockets, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD0 & 0xFFU) << 8) | (40 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetUDP_UninitSockets()
N#endif
N
N
N// NetTCP event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetTCP_InitSockets               EventID (EventLevelOp,    EvtNetTCP,  0)
N#define EvtNetTCP_GetSocket                 EventID (EventLevelOp,    EvtNetTCP,  1)
N#define EvtNetTCP_GetSocketInvalidParameter EventID (EventLevelError, EvtNetTCP,  2)
N#define EvtNetTCP_NoSocketAvailable         EventID (EventLevelError, EvtNetTCP,  3)
N#define EvtNetTCP_ReleaseSocket             EventID (EventLevelOp,    EvtNetTCP,  4)
N#define EvtNetTCP_ReleaseSocketNotValid     EventID (EventLevelError, EvtNetTCP,  5)
N#define EvtNetTCP_ReleaseSocketWrongState   EventID (EventLevelError, EvtNetTCP,  6)
N#define EvtNetTCP_ListenSocket              EventID (EventLevelOp,    EvtNetTCP,  7)
N#define EvtNetTCP_ListenSocketNotValid      EventID (EventLevelError, EvtNetTCP,  8)
N#define EvtNetTCP_ListenPortUndefined       EventID (EventLevelError, EvtNetTCP,  9)
N#define EvtNetTCP_ListenSocketWrongState    EventID (EventLevelError, EvtNetTCP, 10)
N#define EvtNetTCP_ConnectSocket             EventID (EventLevelOp,    EvtNetTCP, 11)
N#define EvtNetTCP_ConnectSocketNotValid     EventID (EventLevelError, EvtNetTCP, 12)
N#define EvtNetTCP_ConnectAddressUnspecified EventID (EventLevelError, EvtNetTCP, 13)
N#define EvtNetTCP_ConnectPortUndefined      EventID (EventLevelError, EvtNetTCP, 14)
N#define EvtNetTCP_ShowNetAddress            EventID (EventLevelOp,    EvtNetTCP, 15)
N// Gap
N#define EvtNetTCP_ConnectLocalPortInvalid   EventID (EventLevelError, EvtNetTCP, 17)
N#define EvtNetTCP_AssignLocalPort           EventID (EventLevelOp,    EvtNetTCP, 18)
N#define EvtNetTCP_ConnectSocketWrongState   EventID (EventLevelError, EvtNetTCP, 19)
N#define EvtNetTCP_ConnectNoRouteFound       EventID (EventLevelError, EvtNetTCP,115) // End
N#define EvtNetTCP_ShowRttVariables          EventID (EventLevelDetail,EvtNetTCP, 20)
N#define EvtNetTCP_GetBufferFailed           EventID (EventLevelError, EvtNetTCP, 21)
N#define EvtNetTCP_SendFrame                 EventID (EventLevelOp,    EvtNetTCP, 22)
N#define EvtNetTCP_SendBufferInvalid         EventID (EventLevelError, EvtNetTCP, 23)
N#define EvtNetTCP_SendSocketNotValid        EventID (EventLevelError, EvtNetTCP, 24)
N#define EvtNetTCP_SendSocketNotConnected    EventID (EventLevelError, EvtNetTCP, 25)
N#define EvtNetTCP_SendSocketClosing         EventID (EventLevelError, EvtNetTCP, 26)
N#define EvtNetTCP_SendReenteredCall         EventID (EventLevelError, EvtNetTCP, 27)
N#define EvtNetTCP_SendDataUnacked           EventID (EventLevelError, EvtNetTCP, 28)
N#define EvtNetTCP_SendMssExceeded           EventID (EventLevelError, EvtNetTCP, 29)
N#define EvtNetTCP_SendZeroLengthFrame       EventID (EventLevelOp,    EvtNetTCP, 30)
N#define EvtNetTCP_CloseSocket               EventID (EventLevelOp,    EvtNetTCP, 31)
N#define EvtNetTCP_CloseSocketNotValid       EventID (EventLevelError, EvtNetTCP, 32)
N#define EvtNetTCP_CloseDataUnacked          EventID (EventLevelOp,    EvtNetTCP, 33)
N#define EvtNetTCP_CloseSocketWrongState     EventID (EventLevelError, EvtNetTCP, 34)
N#define EvtNetTCP_AbortSocket               EventID (EventLevelOp,    EvtNetTCP, 35)
N#define EvtNetTCP_AbortSocketNotValid       EventID (EventLevelError, EvtNetTCP, 36)
N#define EvtNetTCP_AbortSocketWrongState     EventID (EventLevelError, EvtNetTCP, 37)
N#define EvtNetTCP_SendReadySocketNotValid   EventID (EventLevelError, EvtNetTCP, 38)
N#define EvtNetTCP_SendReadyReenteredCall    EventID (EventLevelError, EvtNetTCP, 39)
N#define EvtNetTCP_ResetWindowSocketNotValid EventID (EventLevelError, EvtNetTCP, 40)
N#define EvtNetTCP_ResetWindowNotConnected   EventID (EventLevelError, EvtNetTCP, 41)
N#define EvtNetTCP_ResetWindowNoFlowControl  EventID (EventLevelError, EvtNetTCP, 42)
N#define EvtNetTCP_ResetWindowUpdate         EventID (EventLevelOp,    EvtNetTCP, 43)
N#define EvtNetTCP_SetOptionSocket           EventID (EventLevelOp,    EvtNetTCP, 44)
N#define EvtNetTCP_SetOptionSocketNotValid   EventID (EventLevelError, EvtNetTCP, 45)
N#define EvtNetTCP_SetOptionSocketWrongState EventID (EventLevelError, EvtNetTCP, 46)
N#define EvtNetTCP_SetOptionTos              EventID (EventLevelDetail,EvtNetTCP, 47)
N#define EvtNetTCP_SetOptionTclass           EventID (EventLevelDetail,EvtNetTCP, 48)
N#define EvtNetTCP_SetOptionTimeout          EventID (EventLevelDetail,EvtNetTCP, 49)
N#define EvtNetTCP_SetOptionKeepAlive        EventID (EventLevelDetail,EvtNetTCP, 50)
N#define EvtNetTCP_SetOptionFlowControl      EventID (EventLevelDetail,EvtNetTCP, 51)
N#define EvtNetTCP_SetOptionDelayedAck       EventID (EventLevelDetail,EvtNetTCP, 52)
N#define EvtNetTCP_SetOptionWrongOption      EventID (EventLevelError, EvtNetTCP, 53)
N#define EvtNetTCP_SetOptionWrongValue       EventID (EventLevelError, EvtNetTCP, 54)
N#define EvtNetTCP_SendDelayedAck            EventID (EventLevelOp,    EvtNetTCP, 55)
N#define EvtNetTCP_SendKeepAliveProbe        EventID (EventLevelOp,    EvtNetTCP, 56)
N#define EvtNetTCP_KeepAliveTimeoutClosing   EventID (EventLevelOp,    EvtNetTCP, 57)
N#define EvtNetTCP_CallbackEventAck          EventID (EventLevelOp,    EvtNetTCP, 58)
N#define EvtNetTCP_ResendOnTimeout           EventID (EventLevelOp,    EvtNetTCP, 59)
N#define EvtNetTCP_ShowCongestionVariables   EventID (EventLevelDetail,EvtNetTCP, 60)
N#define EvtNetTCP_TimeoutInState            EventID (EventLevelOp,    EvtNetTCP, 61)
N#define EvtNetTCP_TwaitTimeoutClosing       EventID (EventLevelOp,    EvtNetTCP, 62)
N#define EvtNetTCP_ClosingTimeout            EventID (EventLevelOp,    EvtNetTCP, 63)
N#define EvtNetTCP_NoRetriesLeft             EventID (EventLevelError, EvtNetTCP, 64)
N#define EvtNetTCP_ReceiveFrame              EventID (EventLevelOp,    EvtNetTCP, 65)
N#define EvtNetTCP_FrameTooShort             EventID (EventLevelError, EvtNetTCP, 66)
N#define EvtNetTCP_MapFrameToSocket          EventID (EventLevelOp,    EvtNetTCP, 67)
N#define EvtNetTCP_FrameNotMapped            EventID (EventLevelOp,    EvtNetTCP, 68)
N#define EvtNetTCP_ChecksumFailed            EventID (EventLevelError, EvtNetTCP, 69)
N#define EvtNetTCP_ShowFrameHeader           EventID (EventLevelDetail,EvtNetTCP, 70)
N#define EvtNetTCP_RstInWindow               EventID (EventLevelOp,    EvtNetTCP, 71)
N#define EvtNetTCP_RstNotValid               EventID (EventLevelOp,    EvtNetTCP, 72)
N#define EvtNetTCP_RepeatedSynAck            EventID (EventLevelOp,    EvtNetTCP, 73)
N#define EvtNetTCP_AckNotSet                 EventID (EventLevelOp,    EvtNetTCP, 74)
N#define EvtNetTCP_ShowSendWindow            EventID (EventLevelOp,    EvtNetTCP, 75)
N#define EvtNetTCP_KeepAliveSegment          EventID (EventLevelOp,    EvtNetTCP, 76)
N#define EvtNetTCP_RetransmittedSegment      EventID (EventLevelOp,    EvtNetTCP, 77)
N#define EvtNetTCP_OutOfRangeSegment         EventID (EventLevelError, EvtNetTCP, 78)
N#define EvtNetTCP_ZeroWindowProbe           EventID (EventLevelOp,    EvtNetTCP, 79)
N#define EvtNetTCP_RemotePeerClosing         EventID (EventLevelOp,    EvtNetTCP, 80)
N#define EvtNetTCP_ShowReceiveWindow         EventID (EventLevelOp,    EvtNetTCP, 81)
N#define EvtNetTCP_InvalidAck                EventID (EventLevelError, EvtNetTCP, 82)
N#define EvtNetTCP_SynNotSet                 EventID (EventLevelError, EvtNetTCP, 83)
N#define EvtNetTCP_UserConnectionReject      EventID (EventLevelOp,    EvtNetTCP, 84)
N#define EvtNetTCP_NextState                 EventID (EventLevelOp,    EvtNetTCP, 85)
N#define EvtNetTCP_WrongSynAck               EventID (EventLevelError, EvtNetTCP, 86)
N#define EvtNetTCP_WrongAckNumber            EventID (EventLevelError, EvtNetTCP, 87)
N#define EvtNetTCP_WrongSeqNumber            EventID (EventLevelError, EvtNetTCP, 88)
N#define EvtNetTCP_RepeatedSyn               EventID (EventLevelOp,    EvtNetTCP, 89)
N#define EvtNetTCP_FrameUnrecognised         EventID (EventLevelError, EvtNetTCP, 90)
N#define EvtNetTCP_SimultOpenNextState       EventID (EventLevelOp,    EvtNetTCP, 91)
N#define EvtNetTCP_WrongFinAck               EventID (EventLevelError, EvtNetTCP, 92)
N#define EvtNetTCP_FinAckNextState           EventID (EventLevelOp,    EvtNetTCP, 93)
N#define EvtNetTCP_SimultCloseNextState      EventID (EventLevelOp,    EvtNetTCP, 94)
N#define EvtNetTCP_AckNextState              EventID (EventLevelOp,    EvtNetTCP, 95)
N#define EvtNetTCP_FinNextState              EventID (EventLevelOp,    EvtNetTCP, 96)
N#define EvtNetTCP_PshAckInHalfOpen          EventID (EventLevelError, EvtNetTCP, 97)
N#define EvtNetTCP_RepeatedFin               EventID (EventLevelOp,    EvtNetTCP, 98)
N#define EvtNetTCP_LastAckNextState          EventID (EventLevelOp,    EvtNetTCP, 99)
N#define EvtNetTCP_RstReceived               EventID (EventLevelError, EvtNetTCP,100)
N#define EvtNetTCP_InvalidState              EventID (EventLevelError, EvtNetTCP,101)
N#define EvtNetTCP_SendData                  EventID (EventLevelOp,    EvtNetTCP,102)
N#define EvtNetTCP_SendControl               EventID (EventLevelOp,    EvtNetTCP,103)
N#define EvtNetTCP_SendReset                 EventID (EventLevelOp,    EvtNetTCP,104)
N#define EvtNetTCP_ParseHeaderOptions        EventID (EventLevelOp,    EvtNetTCP,105)
N#define EvtNetTCP_OptionMss                 EventID (EventLevelOp,    EvtNetTCP,106)
N#define EvtNetTCP_DuplicateAck              EventID (EventLevelOp,    EvtNetTCP,107)
N#define EvtNetTCP_FastRetransmit            EventID (EventLevelOp,    EvtNetTCP,108)
N#define EvtNetTCP_DataAcked                 EventID (EventLevelOp,    EvtNetTCP,109)
N#define EvtNetTCP_ResendData                EventID (EventLevelOp,    EvtNetTCP,110)
N#define EvtNetTCP_MapSocketWrongFlagsSet    EventID (EventLevelError, EvtNetTCP,111)
N#define EvtNetTCP_MapSocketSynNotSet        EventID (EventLevelError, EvtNetTCP,112)
N#define EvtNetTCP_MapSocketNoListenSocket   EventID (EventLevelError, EvtNetTCP,113)
N#define EvtNetTCP_UninitSockets             EventID (EventLevelOp,    EvtNetTCP,114)
N#endif
N
N/**
N  \brief  Event on TCP socket initialize (Op)
N  \param  num_sockets   number of available TCP sockets
N  \param  max_segsize   maximum segment size in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_InitSockets(uint32_t num_sockets, uint16_t max_segsize) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_InitSockets(uint32_t num_sockets, uint16_t max_segsize) {
N    EventRecord2 (EvtNetTCP_InitSockets, num_sockets, max_segsize);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (0 & 0xFFU)), num_sockets, max_segsize);
N  }
N#else
S  #define EvrNetTCP_InitSockets(num_sockets, max_segsize)
N#endif
N
N/**
N  \brief  Event on TCP allocate a free socket (Op)
N  \param  socket        allocated socket handle
N  \param  num_socks     number of available TCP sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_GetSocket(int32_t socket, uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_GetSocket(int32_t socket, uint32_t num_socks) {
N    EventRecord2 (EvtNetTCP_GetSocket, (uint32_t)socket, num_socks);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (1 & 0xFFU)), (uint32_t)socket, num_socks);
N  }
N#else
S  #define EvrNetTCP_GetSocket(socket, num_socks)
N#endif
N
N/**
N  \brief  Event on TCP get socket failed, invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_GetSocketInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_GetSocketInvalidParameter(void) {
N    EventRecord2 (EvtNetTCP_GetSocketInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_GetSocketInvalidParameter()
N#endif
N
N/**
N  \brief  Event on TCP get socket failed, no free socket available (Error)
N  \param  num_socks     number of available TCP sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_NoSocketAvailable(uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_NoSocketAvailable(uint32_t num_socks) {
N    EventRecord2 (EvtNetTCP_NoSocketAvailable, num_socks, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (3 & 0xFFU)), num_socks, 0);
N  }
N#else
S  #define EvrNetTCP_NoSocketAvailable(num_socks)
N#endif
N
N/**
N  \brief  Event on TCP release socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ReleaseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ReleaseSocket(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ReleaseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (4 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ReleaseSocket(socket)
N#endif
N
N/**
N  \brief  Event on TCP release failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ReleaseSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ReleaseSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ReleaseSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (5 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ReleaseSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP release failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ReleaseSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ReleaseSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_ReleaseSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (6 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_ReleaseSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP listen socket request (Op)
N  \param  socket        socket handle
N  \param  port          local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ListenSocket(int32_t socket, uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ListenSocket(int32_t socket, uint16_t port) {
N    EventRecord2 (EvtNetTCP_ListenSocket, (uint32_t)socket, port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (7 & 0xFFU)), (uint32_t)socket, port);
N  }
N#else
S  #define EvrNetTCP_ListenSocket(socket, port)
N#endif
N
N/**
N  \brief  Event on TCP listen failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ListenSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ListenSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ListenSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (8 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ListenSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP listen failed, listening port undefined (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ListenPortUndefined(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ListenPortUndefined(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ListenPortUndefined, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (9 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ListenPortUndefined(socket)
N#endif
N
N/**
N  \brief  Event on TCP listen failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ListenSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ListenSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_ListenSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (10 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_ListenSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP connect socket request (Op)
N  \param  socket        socket handle
N  \param  local_port    local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectSocket(int32_t socket, uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectSocket(int32_t socket, uint16_t local_port) {
N    EventRecord2 (EvtNetTCP_ConnectSocket, (uint32_t)socket, local_port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (11 & 0xFFU)), (uint32_t)socket, local_port);
N  }
N#else
S  #define EvrNetTCP_ConnectSocket(socket, local_port)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ConnectSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (12 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ConnectSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, address unspecified (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectAddressUnspecified(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectAddressUnspecified(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ConnectAddressUnspecified, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (13 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ConnectAddressUnspecified(socket)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, port undefined (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectPortUndefined(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectPortUndefined(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ConnectPortUndefined, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (14 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ConnectPortUndefined(socket)
N#endif
N
N/**
N  \brief  Event on TCP display net address (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowNetAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowNetAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTCP_ShowNetAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (15 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTCP_ShowNetAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, local port invalid (Error)
N  \param  socket        socket handle
N  \param  local_port    local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectLocalPortInvalid(int32_t socket, uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectLocalPortInvalid(int32_t socket, uint16_t local_port) {
N    EventRecord2 (EvtNetTCP_ConnectLocalPortInvalid, (uint32_t)socket, local_port);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (17 & 0xFFU)), (uint32_t)socket, local_port);
N  }
N#else
S  #define EvrNetTCP_ConnectLocalPortInvalid(socket, local_port)
N#endif
N
N/**
N  \brief  Event on TCP local port assigned in socket connect request (Op)
N  \param  socket        socket handle
N  \param  local_port    assigned local port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AssignLocalPort(int32_t socket, uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AssignLocalPort(int32_t socket, uint16_t local_port) {
N    EventRecord2 (EvtNetTCP_AssignLocalPort, (uint32_t)socket, local_port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (18 & 0xFFU)), (uint32_t)socket, local_port);
N  }
N#else
S  #define EvrNetTCP_AssignLocalPort(socket, local_port)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_ConnectSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (19 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_ConnectSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP connect failed, no route to destination found (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ConnectNoRouteFound(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ConnectNoRouteFound(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ConnectNoRouteFound, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (115 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ConnectNoRouteFound(socket)
N#endif
N
N/**
N  \brief  Event on TCP display RTT (round trip time) estimation variables (Detail)
N  \param  socket        socket handle
N  \param  sa            rtt average estimator
N  \param  sv            rtt deviation estimator
N  \remark Those variables are taken from VJs original code in his paper.
N          (Congestion avoidance and control, page 20)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowRttVariables(int32_t socket, int16_t sa, int16_t sv) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowRttVariables(int32_t socket, int16_t sa, int16_t sv) {
N    /* uint32_t rto = ((sa>>3) + sv) * 100; */
N    uint32_t val2 = (uint32_t)sa << 16  | (uint32_t)sv;
N    EventRecord2 (EvtNetTCP_ShowRttVariables, (uint32_t)socket, val2);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (20 & 0xFFU)), (uint32_t)socket, val2);
N  }
N#else
S  #define EvrNetTCP_ShowRttVariables(socket, sa, sv)
N#endif
N
N/**
N  \brief  Event on TCP get buffer failed, out of memory (Error)
N  \param  mem_size      requested memory size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_GetBufferFailed(uint16_t mem_size) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_GetBufferFailed(uint16_t mem_size) {
N    EventRecord2 (EvtNetTCP_GetBufferFailed, mem_size, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (21 & 0xFFU)), mem_size, 0);
N  }
N#else
S  #define EvrNetTCP_GetBufferFailed(mem_size)
N#endif
N
N/**
N  \brief  Event on TCP send frame (Op)
N  \param  socket        socket handle
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendFrame(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendFrame(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetTCP_SendFrame, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (22 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetTCP_SendFrame(socket, length)
N#endif
N
N/**
N  \brief  Event on TCP send failed, invalid buffer (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendBufferInvalid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendBufferInvalid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendBufferInvalid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (23 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendBufferInvalid(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, socket handle not valid (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (24 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, socket not connected (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendSocketNotConnected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendSocketNotConnected(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendSocketNotConnected, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (25 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendSocketNotConnected(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, socket closing (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendSocketClosing(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendSocketClosing(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendSocketClosing, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (26 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendSocketClosing(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, called from a callback function (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendReenteredCall(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendReenteredCall(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendReenteredCall, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (27 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendReenteredCall(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, unacked data pending (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendDataUnacked(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendDataUnacked(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendDataUnacked, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (28 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendDataUnacked(socket)
N#endif
N
N/**
N  \brief  Event on TCP send failed, Maximum Segment Size exceeded (Error)
N  \param  socket        socket handle
N  \remark Frame length is larger than MSS.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendMssExceeded(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendMssExceeded(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendMssExceeded, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (29 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendMssExceeded(socket)
N#endif
N
N/**
N  \brief  Event on TCP send 0-length frame, frame dumped (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendZeroLengthFrame(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendZeroLengthFrame(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendZeroLengthFrame, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (30 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendZeroLengthFrame(socket)
N#endif
N
N/**
N  \brief  Event on TCP close socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_CloseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_CloseSocket(int32_t socket) {
N    EventRecord2 (EvtNetTCP_CloseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (31 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_CloseSocket(socket)
N#endif
N
N/**
N  \brief  Event on TCP close socket failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_CloseSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_CloseSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_CloseSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (32 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_CloseSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP close pended, unacked data exist (Op)
N  \param  socket        socket handle
N  \param  unack_length  length of unacked data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_CloseDataUnacked(int32_t socket, uint32_t unack_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_CloseDataUnacked(int32_t socket, uint32_t unack_length) {
N    EventRecord2 (EvtNetTCP_CloseDataUnacked, (uint32_t)socket, unack_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (33 & 0xFFU)), (uint32_t)socket, unack_length);
N  }
N#else
S  #define EvrNetTCP_CloseDataUnacked(socket, unack_length)
N#endif
N
N/**
N  \brief  Event on TCP close failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_CloseSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_CloseSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_CloseSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (34 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_CloseSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP abort socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AbortSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AbortSocket(int32_t socket) {
N    EventRecord2 (EvtNetTCP_AbortSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (35 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_AbortSocket(socket)
N#endif
N
N/**
N  \brief  Event on TCP abort failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AbortSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AbortSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_AbortSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (36 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_AbortSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP abort failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AbortSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AbortSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_AbortSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (37 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_AbortSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP send ready failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendReadySocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendReadySocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendReadySocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (38 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendReadySocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP send ready failed, called from a callback function (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendReadyReenteredCall(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendReadyReenteredCall(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendReadyReenteredCall, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (39 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendReadyReenteredCall(socket)
N#endif
N
N/**
N  \brief  Event on TCP reset window failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResetWindowSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResetWindowSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ResetWindowSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (40 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ResetWindowSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP reset window failed, invalid socket state (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResetWindowNotConnected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResetWindowNotConnected(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ResetWindowNotConnected, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (41 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ResetWindowNotConnected(socket)
N#endif
N
N/**
N  \brief  Event on TCP reset window failed, flow-control not enabled (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResetWindowNoFlowControl(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResetWindowNoFlowControl(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ResetWindowNoFlowControl, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (42 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ResetWindowNoFlowControl(socket)
N#endif
N
N/**
N  \brief  Event on TCP reset window update (Error)
N  \param  socket        socket handle
N  \param  window_size   updated receive window size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResetWindowUpdate(int32_t socket, uint16_t window_size) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResetWindowUpdate(int32_t socket, uint16_t window_size) {
N    EventRecord2 (EvtNetTCP_ResetWindowUpdate, (uint32_t)socket, window_size);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (43 & 0xFFU)), (uint32_t)socket, window_size);
N  }
N#else
S  #define EvrNetTCP_ResetWindowUpdate(socket, window_size)
N#endif
N
N/**
N  \brief  Event on TCP set socket option (Op)
N  \param  socket        socket handle
N  \param  option        interface option as specified by \ref netTCP_Option
N  \param  val           option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionSocket(int32_t socket, int32_t option, uint32_t val) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionSocket(int32_t socket, int32_t option, uint32_t val) {
N    uint32_t val2 = (val << 8) | (uint8_t)option;
N    EventRecord2 (EvtNetTCP_SetOptionSocket, (uint32_t)socket, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (44 & 0xFFU)), (uint32_t)socket, val2);
N  }
N#else
S  #define EvrNetTCP_SetOptionSocket(socket, option, val)
N#endif
N
N/**
N  \brief  Event on TCP set socket option failed, not valid socket (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionSocketNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionSocketNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SetOptionSocketNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (45 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SetOptionSocketNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP set socket option failed, wrong socket state (Error)
N  \param  socket        socket handle
N  \param  state         socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionSocketWrongState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionSocketWrongState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_SetOptionSocketWrongState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (46 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_SetOptionSocketWrongState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP set socket option Type Of Service for IPv4 (Detail)
N  \param  socket        socket handle
N  \param  ip4_tos       type of service value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionTos(int32_t socket, uint8_t ip4_tos) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionTos(int32_t socket, uint8_t ip4_tos) {
N    EventRecord2 (EvtNetTCP_SetOptionTos, (uint32_t)socket, ip4_tos);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (47 & 0xFFU)), (uint32_t)socket, ip4_tos);
N  }
N#else
S  #define EvrNetTCP_SetOptionTos(socket, ip4_tos)
N#endif
N
N/**
N  \brief  Event on TCP set socket option Traffic Class for IPv6 (Detail)
N  \param  socket        socket handle
N  \param  ip6_tclass    traffic class value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionTclass(int32_t socket, uint8_t ip6_tclass) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionTclass(int32_t socket, uint8_t ip6_tclass) {
N    EventRecord2 (EvtNetTCP_SetOptionTclass, (uint32_t)socket, ip6_tclass);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (48 & 0xFFU)), (uint32_t)socket, ip6_tclass);
N  }
N#else
S  #define EvrNetTCP_SetOptionTclass(socket, ip6_tclass)
N#endif
N
N/**
N  \brief  Event on TCP set socket option connection timeout (Detail)
N  \param  socket        socket handle
N  \param  timeout       connection or keep-alive timeout in seconds
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionTimeout(int32_t socket, uint16_t timeout) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionTimeout(int32_t socket, uint16_t timeout) {
N    EventRecord2 (EvtNetTCP_SetOptionTimeout, (uint32_t)socket, timeout);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (49 & 0xFFU)), (uint32_t)socket, timeout);
N  }
N#else
S  #define EvrNetTCP_SetOptionTimeout(socket, timeout)
N#endif
N
N/**
N  \brief  Event on TCP set socket keep-alive option (Detail)
N  \param  socket        socket handle
N  \param  enable        keep-alive state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionKeepAlive(int32_t socket, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionKeepAlive(int32_t socket, uint32_t enable) {
N    EventRecord2 (EvtNetTCP_SetOptionKeepAlive, (uint32_t)socket, enable);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (50 & 0xFFU)), (uint32_t)socket, enable);
N  }
N#else
S  #define EvrNetTCP_SetOptionKeepAlive(socket, enable)
N#endif
N
N/**
N  \brief  Event on TCP set socket flow-control option (Detail)
N  \param  socket        socket handle
N  \param  enable        flow-control state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionFlowControl(int32_t socket, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionFlowControl(int32_t socket, uint32_t enable) {
N    EventRecord2 (EvtNetTCP_SetOptionFlowControl, (uint32_t)socket, enable);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (51 & 0xFFU)), (uint32_t)socket, enable);
N  }
N#else
S  #define EvrNetTCP_SetOptionFlowControl(socket, enable)
N#endif
N
N/**
N  \brief  Event on TCP set socket delayed-acknowledge option (Detail)
N  \param  socket        socket handle
N  \param  enable        delayed-acknowledge state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionDelayedAck(int32_t socket, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionDelayedAck(int32_t socket, uint32_t enable) {
N    EventRecord2 (EvtNetTCP_SetOptionDelayedAck, (uint32_t)socket, enable);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (52 & 0xFFU)), (uint32_t)socket, enable);
N  }
N#else
S  #define EvrNetTCP_SetOptionDelayedAck(socket, enable)
N#endif
N
N/**
N  \brief  Event on TCP wrong set socket option (Error)
N  \param  socket        socket handle
N  \param  tcp_option    wrong set option value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionWrongOption(int32_t socket, int32_t tcp_option) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionWrongOption(int32_t socket, int32_t tcp_option) {
N    EventRecord2 (EvtNetTCP_SetOptionWrongOption, (uint32_t)socket, (uint32_t)tcp_option);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (53 & 0xFFU)), (uint32_t)socket, (uint32_t)tcp_option);
N  }
N#else
S  #define EvrNetTCP_SetOptionWrongOption(socket, tcp_option)
N#endif
N
N/**
N  \brief  Event on TCP wrong value for set socket option (Error)
N  \param  socket        socket handle
N  \param  opt_value     wrong value for set option
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SetOptionWrongValue(int32_t socket, uint32_t opt_value) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SetOptionWrongValue(int32_t socket, uint32_t opt_value) {
N    EventRecord2 (EvtNetTCP_SetOptionWrongValue, (uint32_t)socket, opt_value);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (54 & 0xFFU)), (uint32_t)socket, opt_value);
N  }
N#else
S  #define EvrNetTCP_SetOptionWrongValue(socket, opt_value)
N#endif
N
N/**
N  \brief  Event on TCP send delayed-acknowledge (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendDelayedAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendDelayedAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendDelayedAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (55 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendDelayedAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP send keep-alive probe (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendKeepAliveProbe(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendKeepAliveProbe(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendKeepAliveProbe, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (56 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendKeepAliveProbe(socket)
N#endif
N
N/**
N  \brief  Event on TCP keep-alive timeout no response, close socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_KeepAliveTimeoutClosing(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_KeepAliveTimeoutClosing(int32_t socket) {
N    EventRecord2 (EvtNetTCP_KeepAliveTimeoutClosing, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (57 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_KeepAliveTimeoutClosing(socket)
N#endif
N
N/**
N  \brief  Event on TCP acknowledge callback notification to the user (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_CallbackEventAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_CallbackEventAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_CallbackEventAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (58 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_CallbackEventAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP resend data on timeout (Op)
N  \param  socket        socket handle
N  \param  length        length of data to resend
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResendOnTimeout(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResendOnTimeout(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetTCP_ResendOnTimeout, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (59 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetTCP_ResendOnTimeout(socket, length)
N#endif
N
N/**
N  \brief  Event on TCP display congestion avoidance/control variables (Detail)
N  \param  socket        socket handle
N  \param  cwnd          congestion window
N  \param  ssth          slow start threshold
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowCongestionVariables(int32_t socket, uint16_t cwnd, uint16_t ssth) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowCongestionVariables(int32_t socket, uint16_t cwnd, uint16_t ssth) {
N    uint32_t val2 = ((uint32_t)cwnd << 16) | ssth;
N    EventRecord2 (EvtNetTCP_ShowCongestionVariables, (uint32_t)socket, val2);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (60 & 0xFFU)), (uint32_t)socket, val2);
N  }
N#else
S  #define EvrNetTCP_ShowCongestionVariables(socket, cwnd, ssth)
N#endif
N
N/**
N  \brief  Event on TCP timeout expired in current state (Op)
N  \param  socket        socket handle
N  \param  state         current socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_TimeoutInState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_TimeoutInState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_TimeoutInState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (61 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_TimeoutInState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP timeout in TIME_WAIT state, closing socket (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_TwaitTimeoutClosing(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_TwaitTimeoutClosing(int32_t socket) {
N    EventRecord2 (EvtNetTCP_TwaitTimeoutClosing, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (62 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_TwaitTimeoutClosing(socket)
N#endif
N
N/**
N  \brief  Event on TCP timeout in CLOSING, FIN_WAIT_1 or LAST_ACK state (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ClosingTimeout(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ClosingTimeout(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ClosingTimeout, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (63 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ClosingTimeout(socket)
N#endif
N
N/**
N  \brief  Event on TCP no retries left (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_NoRetriesLeft(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_NoRetriesLeft(int32_t socket) {
N    EventRecord2 (EvtNetTCP_NoRetriesLeft, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (64 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_NoRetriesLeft(socket)
N#endif
N
N/**
N  \brief  Event on TCP receive frame (Op)
N  \param  length        frame length in bytes
N  \param  ip_version    internet protocol version
N                         - 0: IPv4
N                         - 1: IPv6
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ReceiveFrame(uint32_t length, uint8_t ip_version) {
N    EventRecord2 (EvtNetTCP_ReceiveFrame, length, ip_version);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (65 & 0xFFU)), length, ip_version);
N  }
N#else
S  #define EvrNetTCP_ReceiveFrame(length, ip_version)
N#endif
N
N/**
N  \brief  Event on TCP receive frame too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetTCP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (66 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetTCP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on TCP received frame not mapped, no active socket found (Op)
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FrameNotMapped(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FrameNotMapped(uint32_t length) {
N    EventRecord2 (EvtNetTCP_FrameNotMapped, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (68 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetTCP_FrameNotMapped(length)
N#endif
N
N/**
N  \brief  Event on TCP received frame mapped to a socket (Op)
N  \param  socket        mapped socket handle
N  \param  state         current socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_MapFrameToSocket(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_MapFrameToSocket(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_MapFrameToSocket, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (67 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_MapFrameToSocket(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP frame checksum check failed (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ChecksumFailed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ChecksumFailed(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ChecksumFailed, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (69 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ChecksumFailed(socket)
N#endif
N
N/**
N  \brief  Event on TCP display send/receive frame header (Detail)
N  \param  tcp_header    pointer to TCP frame header of 20 bytes
N                         - SrcPort (2 bytes)
N                         - DstPort (2 bytes)
N                         - SeqNr   (4 bytes)
N                         - AckNr   (4 bytes)
N                         - HLen    (1 byte)
N                         - Flags   (1 byte)
N                         - Window  (2 bytes)
N                         - Chksum  (2 bytes)
N                         - UrgPtr  (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowFrameHeader(const void *tcp_header) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowFrameHeader(const void *tcp_header) {
N    EventRecordData (EvtNetTCP_ShowFrameHeader, tcp_header, 20);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (70 & 0xFFU)), tcp_header, 20);
N  }
N#else
S  #define EvrNetTCP_ShowFrameHeader(tcp_header)
N#endif
N
N/**
N  \brief  Event on TCP RST-flag received within current receive window (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RstInWindow(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RstInWindow(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RstInWindow, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (71 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RstInWindow(socket)
N#endif
N
N/**
N  \brief  Event on TCP RST-flag received outside current receive window (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RstNotValid(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RstNotValid(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RstNotValid, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (72 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RstNotValid(socket)
N#endif
N
N/**
N  \brief  Event on TCP repeated SYN+ACK-flags received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RepeatedSynAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RepeatedSynAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RepeatedSynAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (73 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RepeatedSynAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP ACK-flag not set in received frame (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AckNotSet(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AckNotSet(int32_t socket) {
N    EventRecord2 (EvtNetTCP_AckNotSet, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (74 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_AckNotSet(socket)
N#endif
N
N/**
N  \brief  Event on TCP display current sending window size (Op)
N  \param  socket        socket handle
N  \param  send_window   current sending window size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowSendWindow(int32_t socket, uint16_t send_window) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowSendWindow(int32_t socket, uint16_t send_window) {
N    EventRecord2 (EvtNetTCP_ShowSendWindow, (uint32_t)socket, send_window);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (75 & 0xFFU)), (uint32_t)socket, send_window);
N  }
N#else
S  #define EvrNetTCP_ShowSendWindow(socket, send_window)
N#endif
N
N/**
N  \brief  Event on TCP keep-alive frame received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_KeepAliveSegment(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_KeepAliveSegment(int32_t socket) {
N    EventRecord2 (EvtNetTCP_KeepAliveSegment, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (76 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_KeepAliveSegment(socket)
N#endif
N
N/**
N  \brief  Event on TCP retransmitted frame received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RetransmittedSegment(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RetransmittedSegment(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RetransmittedSegment, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (77 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RetransmittedSegment(socket)
N#endif
N
N/**
N  \brief  Event on TCP out of range segment received (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_OutOfRangeSegment(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_OutOfRangeSegment(int32_t socket) {
N    EventRecord2 (EvtNetTCP_OutOfRangeSegment, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (78 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_OutOfRangeSegment(socket)
N#endif
N
N/**
N  \brief  Event on TCP zero-window probe received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ZeroWindowProbe(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ZeroWindowProbe(int32_t socket) {
N    EventRecord2 (EvtNetTCP_ZeroWindowProbe, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (79 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_ZeroWindowProbe(socket)
N#endif
N
N/**
N  \brief  Event on TCP FIN-flag received, remote peer wants to close (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RemotePeerClosing(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RemotePeerClosing(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RemotePeerClosing, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (80 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RemotePeerClosing(socket)
N#endif
N
N/**
N  \brief  Event on TCP display current receiving window size (Op)
N  \param  socket        socket handle
N  \param  rec_window    current receiving window size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ShowReceiveWindow(int32_t socket, uint16_t rec_window) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ShowReceiveWindow(int32_t socket, uint16_t rec_window) {
N    EventRecord2 (EvtNetTCP_ShowReceiveWindow, (uint32_t)socket, rec_window);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (81 & 0xFFU)), (uint32_t)socket, rec_window);
N  }
N#else
S  #define EvrNetTCP_ShowReceiveWindow(socket, rec_window)
N#endif
N
N/**
N  \brief  Event on TCP ACK-flag set received, invalid in state LISTEN (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_InvalidAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_InvalidAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_InvalidAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (82 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_InvalidAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP SYN-flag not set in received frame (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SynNotSet(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SynNotSet(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SynNotSet, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (83 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SynNotSet(socket)
N#endif
N
N/**
N  \brief  Event on TCP user rejected inbound connection (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_UserConnectionReject(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_UserConnectionReject(int32_t socket) {
N    EventRecord2 (EvtNetTCP_UserConnectionReject, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (84 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_UserConnectionReject(socket)
N#endif
N
N/**
N  \brief  Event on TCP transition to next state (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_NextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_NextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_NextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (85 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_NextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP SYN+ACK-flags set but wrong ack number (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_WrongSynAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_WrongSynAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_WrongSynAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (86 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_WrongSynAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP ACK-flag set but wrong ack number (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_WrongAckNumber(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_WrongAckNumber(int32_t socket) {
N    EventRecord2 (EvtNetTCP_WrongAckNumber, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (87 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_WrongAckNumber(socket)
N#endif
N
N/**
N  \brief  Event on TCP ACK-flag set but wrong seq number (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_WrongSeqNumber(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_WrongSeqNumber(int32_t socket) {
N    EventRecord2 (EvtNetTCP_WrongSeqNumber, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (88 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_WrongSeqNumber(socket)
N#endif
N
N/**
N  \brief  Event on TCP repeated SYN-flag set frame received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RepeatedSyn(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RepeatedSyn(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RepeatedSyn, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (89 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RepeatedSyn(socket)
N#endif
N
N/**
N  \brief  Event on TCP unrecognised frame received (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FrameUnrecognised(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FrameUnrecognised(int32_t socket) {
N    EventRecord2 (EvtNetTCP_FrameUnrecognised, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (90 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_FrameUnrecognised(socket)
N#endif
N
N/**
N  \brief  Event on TCP SYN-flag set received in simultaneous open (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SimultOpenNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SimultOpenNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_SimultOpenNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (91 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_SimultOpenNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP frame with FIN+ACK-flags set but wrong ack number (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_WrongFinAck(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_WrongFinAck(int32_t socket) {
N    EventRecord2 (EvtNetTCP_WrongFinAck, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (92 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_WrongFinAck(socket)
N#endif
N
N/**
N  \brief  Event on TCP frame with FIN+ACK-flags received (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FinAckNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FinAckNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_FinAckNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (93 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_FinAckNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP frame with FIN-flag received in simultaneous close (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SimultCloseNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SimultCloseNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_SimultCloseNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (94 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_SimultCloseNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP frame with ACK-flag received (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_AckNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_AckNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_AckNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (95 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_AckNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP frame with FIN-flag received (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FinNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FinNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_FinNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (96 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_FinNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP PSH+ACK-flags received in half open state FIN_WAIT_2 (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_PshAckInHalfOpen(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_PshAckInHalfOpen(int32_t socket) {
N    EventRecord2 (EvtNetTCP_PshAckInHalfOpen, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (97 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_PshAckInHalfOpen(socket)
N#endif
N
N/**
N  \brief  Event on TCP repeated FIN-flag received (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RepeatedFin(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RepeatedFin(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RepeatedFin, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (98 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RepeatedFin(socket)
N#endif
N
N/**
N  \brief  Event on TCP last ACK-flag received (Op)
N  \param  socket        socket handle
N  \param  state         next socket state
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_LastAckNextState(int32_t socket, int32_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_LastAckNextState(int32_t socket, int32_t state) {
N    EventRecord2 (EvtNetTCP_LastAckNextState, (uint32_t)socket, (uint32_t)state);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (99 & 0xFFU)), (uint32_t)socket, (uint32_t)state);
N  }
N#else
S  #define EvrNetTCP_LastAckNextState(socket, state)
N#endif
N
N/**
N  \brief  Event on TCP RST-flag received (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_RstReceived(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_RstReceived(int32_t socket) {
N    EventRecord2 (EvtNetTCP_RstReceived, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (100 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_RstReceived(socket)
N#endif
N
N/**
N  \brief  Event on TCP socket in invalid state (Error)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_InvalidState(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_InvalidState(int32_t socket) {
N    EventRecord2 (EvtNetTCP_InvalidState, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (101 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_InvalidState(socket)
N#endif
N
N/**
N  \brief  Event on TCP send data frame (Op)
N  \param  socket        socket handle
N  \param  length        data length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendData(int32_t socket, uint16_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendData(int32_t socket, uint16_t length) {
N    EventRecord2 (EvtNetTCP_SendData, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (102 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetTCP_SendData(socket, length)
N#endif
N
N/**
N  \brief  Event on TCP send control frame (Op)
N  \param  socket        socket handle
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendControl(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendControl(int32_t socket) {
N    EventRecord2 (EvtNetTCP_SendControl, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (103 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetTCP_SendControl(socket)
N#endif
N
N/**
N  \brief  Event on TCP send reset to remote host for unmapped frame (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_SendReset(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_SendReset(void) {
N    EventRecord2 (EvtNetTCP_SendReset, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (104 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_SendReset()
N#endif
N
N/**
N  \brief  Event on TCP parse header options (Op)
N  \param  socket        socket handle
N  \param  opt_length    length of header options
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ParseHeaderOptions(int32_t socket, uint32_t opt_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ParseHeaderOptions(int32_t socket, uint32_t opt_length) {
N    EventRecord2 (EvtNetTCP_ParseHeaderOptions, (uint32_t)socket, opt_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (105 & 0xFFU)), (uint32_t)socket, opt_length);
N  }
N#else
S  #define EvrNetTCP_ParseHeaderOptions(socket, opt_length)
N#endif
N
N/**
N  \brief  Event on TCP header option MSS (maximum segment size) (Op)
N  \param  socket        socket handle
N  \param  mss           maximum segment size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_OptionMss(int32_t socket, uint32_t mss) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_OptionMss(int32_t socket, uint32_t mss) {
N    EventRecord2 (EvtNetTCP_OptionMss, (uint32_t)socket, mss);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (106 & 0xFFU)), (uint32_t)socket, mss);
N  }
N#else
S  #define EvrNetTCP_OptionMss(socket, mss)
N#endif
N
N/**
N  \brief  Event on TCP duplicate acknowledge processing (Op)
N  \param  socket        socket handle
N  \param  dup_acks      number of duplicate acks
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_DuplicateAck(int32_t socket, uint32_t dup_acks) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_DuplicateAck(int32_t socket, uint32_t dup_acks) {
N    EventRecord2 (EvtNetTCP_DuplicateAck, (uint32_t)socket, dup_acks);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (107 & 0xFFU)), (uint32_t)socket, dup_acks);
N  }
N#else
S  #define EvrNetTCP_DuplicateAck(socket, dup_acks)
N#endif
N
N/**
N  \brief  Event on TCP fast retransmit, received 3 duplicate acks (Op)
N  \param  socket        socket handle
N  \param  data_length   length of data to fast retransmit
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_FastRetransmit(int32_t socket, uint32_t data_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_FastRetransmit(int32_t socket, uint32_t data_length) {
N    EventRecord2 (EvtNetTCP_FastRetransmit, (uint32_t)socket, data_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (108 & 0xFFU)), (uint32_t)socket, data_length);
N  }
N#else
S  #define EvrNetTCP_FastRetransmit(socket, data_length)
N#endif
N
N/**
N  \brief  Event on TCP data acknowledge processing (Op)
N  \param  socket        socket handle
N  \param  ack_length    acknowledged data length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_DataAcked(int32_t socket, uint32_t ack_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_DataAcked(int32_t socket, uint32_t ack_length) {
N    EventRecord2 (EvtNetTCP_DataAcked, (uint32_t)socket, ack_length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (109 & 0xFFU)), (uint32_t)socket, ack_length);
N  }
N#else
S  #define EvrNetTCP_DataAcked(socket, ack_length)
N#endif
N
N/**
N  \brief  Event on TCP resend data from transmit queue (Op)
N  \param  socket        socket handle
N  \param  length        length of the data to resend
N  \param  tout          retry timeout in 100ms ticks
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_ResendData(int32_t socket, uint32_t length, uint32_t tout) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_ResendData(int32_t socket, uint32_t length, uint32_t tout) {
N    uint32_t val2 = length << 16 | tout;
N    EventRecord2 (EvtNetTCP_ResendData, (uint32_t)socket, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (110 & 0xFFU)), (uint32_t)socket, val2);
N  }
N#else
S  #define EvrNetTCP_ResendData(socket, length, tout)
N#endif
N
N/**
N  \brief  Event on TCP map socket failed, wrong TCP flags set (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_MapSocketWrongFlagsSet(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_MapSocketWrongFlagsSet(void) {
N    EventRecord2 (EvtNetTCP_MapSocketWrongFlagsSet, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (111 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_MapSocketWrongFlagsSet()
N#endif
N
N/**
N  \brief  Event on TCP map socket failed, SYN-flag not set (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_MapSocketSynNotSet(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_MapSocketSynNotSet(void) {
N    EventRecord2 (EvtNetTCP_MapSocketSynNotSet, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (112 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_MapSocketSynNotSet()
N#endif
N
N/**
N  \brief  Event on TCP map socket failed, no listening sockets found (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_MapSocketNoListenSocket(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_MapSocketNoListenSocket(void) {
N    EventRecord2 (EvtNetTCP_MapSocketNoListenSocket, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (113 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_MapSocketNoListenSocket()
N#endif
N
N/**
N  \brief  Event on TCP de-initialize available sockets (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTCP_UninitSockets(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTCP_UninitSockets(void) {
N    EventRecord2 (EvtNetTCP_UninitSockets, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD1 & 0xFFU) << 8) | (114 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTCP_UninitSockets()
N#endif
N
N
N// NetBSD event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetBSD_InitSockets               EventID (EventLevelOp,    EvtNetBSD,  0)
N#define EvtNetBSD_SocketCreate              EventID (EventLevelAPI,   EvtNetBSD,  1)
N#define EvtNetBSD_SocketInvalidParameter    EventID (EventLevelError, EvtNetBSD,  2)
N#define EvtNetBSD_NoSocketAvailable         EventID (EventLevelError, EvtNetBSD,  3)
N#define EvtNetBSD_BindSocket                EventID (EventLevelAPI,   EvtNetBSD,  4)
N#define EvtNetBSD_BindSocketNotValid        EventID (EventLevelError, EvtNetBSD,  5)
N#define EvtNetBSD_BindInvalidParameter      EventID (EventLevelError, EvtNetBSD,  6)
N#define EvtNetBSD_BindSocketNotCreated      EventID (EventLevelError, EvtNetBSD,  7)
N#define EvtNetBSD_BindSocketAlreadyBound    EventID (EventLevelError, EvtNetBSD,  8)
N#define EvtNetBSD_BindSocketConnected       EventID (EventLevelError, EvtNetBSD,  9)
N#define EvtNetBSD_BindPortInUse             EventID (EventLevelError, EvtNetBSD, 10)
N#define EvtNetBSD_ShowNetAddress            EventID (EventLevelOp,    EvtNetBSD, 11)
N// Gap
N#define EvtNetBSD_ListenSocket              EventID (EventLevelAPI,   EvtNetBSD, 13)
N#define EvtNetBSD_ListenSocketNotValid      EventID (EventLevelError, EvtNetBSD, 14)
N#define EvtNetBSD_ListenInvalidParameter    EventID (EventLevelError, EvtNetBSD, 15)
N#define EvtNetBSD_ListenSocketNotCreated    EventID (EventLevelError, EvtNetBSD,145)
N#define EvtNetBSD_ListenSocketNotBound      EventID (EventLevelError, EvtNetBSD, 16)
N#define EvtNetBSD_ListenSocketNotStreamType EventID (EventLevelError, EvtNetBSD, 17)
N#define EvtNetBSD_ListenSockAlreadyListens  EventID (EventLevelError, EvtNetBSD, 18)
N#define EvtNetBSD_ListenBacklogCreateFailed EventID (EventLevelError, EvtNetBSD, 19)
N#define EvtNetBSD_AcceptSocket              EventID (EventLevelAPI,   EvtNetBSD, 20)
N#define EvtNetBSD_AcceptSocketNotValid      EventID (EventLevelError, EvtNetBSD, 21)
N#define EvtNetBSD_AcceptSocketNotCreated    EventID (EventLevelError, EvtNetBSD,146)
N#define EvtNetBSD_AcceptSocketNotListening  EventID (EventLevelError, EvtNetBSD, 22)
N#define EvtNetBSD_AcceptSocketNotStreamType EventID (EventLevelError, EvtNetBSD, 23)
N#define EvtNetBSD_AcceptSocketLocked        EventID (EventLevelError, EvtNetBSD, 24)
N#define EvtNetBSD_AcceptChildSockConnected  EventID (EventLevelOp,    EvtNetBSD, 25)
N#define EvtNetBSD_AcceptSocketClosed        EventID (EventLevelError, EvtNetBSD, 26)
N#define EvtNetBSD_AcceptSocketKilled        EventID (EventLevelError, EvtNetBSD, 27)
N#define EvtNetBSD_ConnectSocket             EventID (EventLevelAPI,   EvtNetBSD, 28)
N#define EvtNetBSD_ConnectSocketNotValid     EventID (EventLevelError, EvtNetBSD, 29)
N#define EvtNetBSD_ConnectInvalidParameter   EventID (EventLevelError, EvtNetBSD, 30)
N#define EvtNetBSD_ConnectSocketLocked       EventID (EventLevelError, EvtNetBSD, 31)
N#define EvtNetBSD_ConnectSocketNotCreated   EventID (EventLevelError, EvtNetBSD, 32)
N#define EvtNetBSD_ConnectSocketWrongState   EventID (EventLevelError, EvtNetBSD, 33)
N#define EvtNetBSD_ConnectDatagramSuccess    EventID (EventLevelOp,    EvtNetBSD, 34)
N#define EvtNetBSD_ConnectStreamSuccess      EventID (EventLevelOp,    EvtNetBSD, 35)
N#define EvtNetBSD_ConnectStreamTimeout      EventID (EventLevelError, EvtNetBSD, 36)
N#define EvtNetBSD_ConnectStreamRefused      EventID (EventLevelError, EvtNetBSD, 37)
N#define EvtNetBSD_ConnectSocketKilled       EventID (EventLevelError, EvtNetBSD, 38)
N#define EvtNetBSD_SendSocket                EventID (EventLevelAPI,   EvtNetBSD, 39)
N#define EvtNetBSD_SendSocketNotValid        EventID (EventLevelError, EvtNetBSD, 40)
N#define EvtNetBSD_SendInvalidParameter      EventID (EventLevelError, EvtNetBSD, 41)
N#define EvtNetBSD_SendSocketNotCreated      EventID (EventLevelError, EvtNetBSD, 42)
N#define EvtNetBSD_SendSocketLocked          EventID (EventLevelError, EvtNetBSD, 43)
N#define EvtNetBSD_SendSocketNotConnected    EventID (EventLevelError, EvtNetBSD, 44)
N#define EvtNetBSD_SendSocketWrongState      EventID (EventLevelError, EvtNetBSD, 45)
N#define EvtNetBSD_SendSocketClosed          EventID (EventLevelError, EvtNetBSD, 46)
N#define EvtNetBSD_SendCompleteNonBlocking   EventID (EventLevelOp,    EvtNetBSD, 47)
N#define EvtNetBSD_SendSocketKilled          EventID (EventLevelError, EvtNetBSD, 48)
N#define EvtNetBSD_SendStreamError           EventID (EventLevelError, EvtNetBSD, 49)
N#define EvtNetBSD_SendtoInvalidParameter    EventID (EventLevelError, EvtNetBSD, 50)
N#define EvtNetBSD_SendDestAddressUndefined  EventID (EventLevelError, EvtNetBSD, 51)
N#define EvtNetBSD_SendDatagramError         EventID (EventLevelError, EvtNetBSD, 52)
N#define EvtNetBSD_SendCompleteBlocking      EventID (EventLevelOp,    EvtNetBSD, 53)
N#define EvtNetBSD_SendTimeoutBlocking       EventID (EventLevelOp,    EvtNetBSD, 54)
N#define EvtNetBSD_SendNoMemory              EventID (EventLevelOp,    EvtNetBSD, 55)
N#define EvtNetBSD_SendmsgSocket             EventID (EventLevelAPI,   EvtNetBSD, 56)
N#define EvtNetBSD_SendmsgSocketNotValid     EventID (EventLevelError, EvtNetBSD, 57)
N#define EvtNetBSD_SendmsgInvalidParameter   EventID (EventLevelError, EvtNetBSD, 58)
N#define EvtNetBSD_SendmsgSocketNotCreated   EventID (EventLevelError, EvtNetBSD, 59)
N#define EvtNetBSD_SendmsgSocketLocked       EventID (EventLevelError, EvtNetBSD, 60)
N#define EvtNetBSD_SendmsgDestAddrUndefined  EventID (EventLevelError, EvtNetBSD, 61)
N#define EvtNetBSD_SendmsgNoMemory           EventID (EventLevelError, EvtNetBSD, 62)
N#define EvtNetBSD_SendmsgDatagramError      EventID (EventLevelError, EvtNetBSD, 63)
N#define EvtNetBSD_SendmsgSocketKilled       EventID (EventLevelError, EvtNetBSD, 64)
N#define EvtNetBSD_SendmsgComplete           EventID (EventLevelOp,    EvtNetBSD, 65)
N#define EvtNetBSD_RecvSocket                EventID (EventLevelAPI,   EvtNetBSD, 66)
N#define EvtNetBSD_RecvSocketNotValid        EventID (EventLevelError, EvtNetBSD, 67)
N#define EvtNetBSD_RecvInvalidParameter      EventID (EventLevelError, EvtNetBSD, 68)
N#define EvtNetBSD_RecvSocketNotCreated      EventID (EventLevelError, EvtNetBSD, 69)
N#define EvtNetBSD_RecvSocketNotConnected    EventID (EventLevelError, EvtNetBSD, 70)
N#define EvtNetBSD_RecvSocketWrongState      EventID (EventLevelError, EvtNetBSD, 71)
N#define EvtNetBSD_RecvSocketLocked          EventID (EventLevelError, EvtNetBSD, 72)
N#define EvtNetBSD_RecvSocketClosed          EventID (EventLevelError, EvtNetBSD, 73)
N#define EvtNetBSD_RecvTimeout               EventID (EventLevelOp,    EvtNetBSD, 74)
N#define EvtNetBSD_RecvSocketKilled          EventID (EventLevelError, EvtNetBSD, 75)
N#define EvtNetBSD_RecvQueueFree             EventID (EventLevelOp,    EvtNetBSD, 76)
N#define EvtNetBSD_RecvComplete              EventID (EventLevelOp,    EvtNetBSD, 77)
N#define EvtNetBSD_RecvmsgSocket             EventID (EventLevelAPI,   EvtNetBSD, 78)
N#define EvtNetBSD_RecvmsgSocketNotValid     EventID (EventLevelError, EvtNetBSD, 79)
N#define EvtNetBSD_RecvmsgInvalidParameter   EventID (EventLevelError, EvtNetBSD, 80)
N#define EvtNetBSD_RecvmsgSocketNotCreated   EventID (EventLevelError, EvtNetBSD, 81)
N#define EvtNetBSD_RecvmsgSocketLocked       EventID (EventLevelError, EvtNetBSD, 82)
N#define EvtNetBSD_RecvmsgSocketWrongState   EventID (EventLevelError, EvtNetBSD, 83)
N#define EvtNetBSD_RecvmsgTimeout            EventID (EventLevelOp,    EvtNetBSD, 84)
N#define EvtNetBSD_RecvmsgSocketKilled       EventID (EventLevelError, EvtNetBSD, 85)
N#define EvtNetBSD_RecvmsgComplete           EventID (EventLevelOp,    EvtNetBSD, 86)
N#define EvtNetBSD_Closesocket               EventID (EventLevelAPI,   EvtNetBSD, 87)
N#define EvtNetBSD_CloseSocketNotValid       EventID (EventLevelError, EvtNetBSD, 88)
N#define EvtNetBSD_CloseSocketNotCreated     EventID (EventLevelError, EvtNetBSD,147)
N#define EvtNetBSD_Select                    EventID (EventLevelAPI,   EvtNetBSD, 89)
N#define EvtNetBSD_SelectInvalidParameter    EventID (EventLevelError, EvtNetBSD, 90)
N#define EvtNetBSD_SelectSuspendFailed       EventID (EventLevelError, EvtNetBSD, 91)
N#define EvtNetBSD_SelectComplete            EventID (EventLevelOp,    EvtNetBSD, 92)
N#define EvtNetBSD_SelectCompleteBlocking    EventID (EventLevelOp,    EvtNetBSD, 93)
N#define EvtNetBSD_Getpeername               EventID (EventLevelAPI,   EvtNetBSD, 94)
N#define EvtNetBSD_GetpeerSocketNotValid     EventID (EventLevelError, EvtNetBSD, 95)
N#define EvtNetBSD_GetpeerSocketNotCreated   EventID (EventLevelError, EvtNetBSD,148)
N#define EvtNetBSD_GetpeerInvalidParameter   EventID (EventLevelError, EvtNetBSD, 96)
N#define EvtNetBSD_GetpeerSocketNotConnected EventID (EventLevelError, EvtNetBSD, 97)
N#define EvtNetBSD_Getsockname               EventID (EventLevelAPI,   EvtNetBSD, 98)
N#define EvtNetBSD_GetsockSocketNotValid     EventID (EventLevelError, EvtNetBSD, 99)
N#define EvtNetBSD_GetsockSocketNotCreated   EventID (EventLevelError, EvtNetBSD,149)
N#define EvtNetBSD_GetsockInvalidParameter   EventID (EventLevelError, EvtNetBSD,100)
N#define EvtNetBSD_GetsockSocketNotBound     EventID (EventLevelError, EvtNetBSD,101)
N#define EvtNetBSD_Setsockopt                EventID (EventLevelAPI,   EvtNetBSD,102)
N#define EvtNetBSD_SetoptSocketNotValid      EventID (EventLevelError, EvtNetBSD,103)
N#define EvtNetBSD_SetoptInvalidParameter    EventID (EventLevelError, EvtNetBSD,104)
N#define EvtNetBSD_SetoptSocketNotCreated    EventID (EventLevelError, EvtNetBSD,105)
N#define EvtNetBSD_SetoptOptionNotSupported  EventID (EventLevelError, EvtNetBSD,106)
N#define EvtNetBSD_SetoptKeepAlive           EventID (EventLevelOp,    EvtNetBSD,107)
N#define EvtNetBSD_SetoptRecvTimeout         EventID (EventLevelOp,    EvtNetBSD,108)
N#define EvtNetBSD_SetoptSendTimeout         EventID (EventLevelOp,    EvtNetBSD,109)
N#define EvtNetBSD_SetoptIp4Tos              EventID (EventLevelOp,    EvtNetBSD,110)
N#define EvtNetBSD_SetoptIp4Ttl              EventID (EventLevelOp,    EvtNetBSD,111)
N#define EvtNetBSD_SetoptIp4RecvDstAddr      EventID (EventLevelOp,    EvtNetBSD,112)
N#define EvtNetBSD_SetoptIp6Tclass           EventID (EventLevelOp,    EvtNetBSD,113)
N#define EvtNetBSD_SetoptIp6HopLimit         EventID (EventLevelOp,    EvtNetBSD,114)
N#define EvtNetBSD_SetoptIp6RecvDstAddr      EventID (EventLevelOp,    EvtNetBSD,115)
N#define EvtNetBSD_Getsockopt                EventID (EventLevelAPI,   EvtNetBSD,116)
N#define EvtNetBSD_GetoptSocketNotValid      EventID (EventLevelError, EvtNetBSD,117)
N#define EvtNetBSD_GetoptInvalidParameter    EventID (EventLevelError, EvtNetBSD,118)
N#define EvtNetBSD_GetoptSocketNotCreated    EventID (EventLevelError, EvtNetBSD,119)
N#define EvtNetBSD_GetoptOptionNotSupported  EventID (EventLevelError, EvtNetBSD,120)
N#define EvtNetBSD_Ioctlsocket               EventID (EventLevelAPI,   EvtNetBSD,121)
N#define EvtNetBSD_IoctlSocketNotValid       EventID (EventLevelError, EvtNetBSD,122)
N#define EvtNetBSD_IoctlInvalidParameter     EventID (EventLevelError, EvtNetBSD,123)
N#define EvtNetBSD_IoctlSocketNotCreated     EventID (EventLevelError, EvtNetBSD,124)
N#define EvtNetBSD_IoctlSocketNotStreamType  EventID (EventLevelError, EvtNetBSD,125)
N#define EvtNetBSD_IoctlNonBlocking          EventID (EventLevelOp,    EvtNetBSD,126)
N#define EvtNetBSD_IoctlDelayAck             EventID (EventLevelOp,    EvtNetBSD,127)
N#define EvtNetBSD_IoctlKeepAlive            EventID (EventLevelOp,    EvtNetBSD,128)
N#define EvtNetBSD_IoctlFlowControl          EventID (EventLevelOp,    EvtNetBSD,129)
N#define EvtNetBSD_CbfuncTcpEvent            EventID (EventLevelOp,    EvtNetBSD,130)
N#define EvtNetBSD_CbfuncTcpQueueAdd         EventID (EventLevelOp,    EvtNetBSD,131)
N#define EvtNetBSD_CbfuncTcpNoMemory         EventID (EventLevelError, EvtNetBSD,132)
N#define EvtNetBSD_CbfuncUdpQueueAdd         EventID (EventLevelOp,    EvtNetBSD,133)
N#define EvtNetBSD_CbfuncUdpDumpData         EventID (EventLevelError, EvtNetBSD,134)
N#define EvtNetBSD_UninitSockets             EventID (EventLevelOp,    EvtNetBSD,135)
N/* BSD-Host resolver events */
N#define EvtNetBSD_GetHostInit               EventID (EventLevelOp,    EvtNetBSD,136)
N#define EvtNetBSD_GetHostByName             EventID (EventLevelAPI,   EvtNetBSD,137)
N#define EvtNetBSD_GetHostNameResolved       EventID (EventLevelOp,    EvtNetBSD,138)
N#define EvtNetBSD_GetHostNameNotExisting    EventID (EventLevelOp,    EvtNetBSD,139)
N#define EvtNetBSD_GetHostResolverTimeout    EventID (EventLevelOp,    EvtNetBSD,140)
N#define EvtNetBSD_GetHostResolverError      EventID (EventLevelError, EvtNetBSD,141)
N#define EvtNetBSD_GetHostResolverBusy       EventID (EventLevelError, EvtNetBSD,142)
N#define EvtNetBSD_GetHostInvalidParameter   EventID (EventLevelError, EvtNetBSD,143)
N#define EvtNetBSD_GetHostUninit             EventID (EventLevelOp,    EvtNetBSD,144)
N#endif
N
N/**
N  \brief  Event on BSD sockets API initialize (Op)
N  \param  num_socks     number of available BSD sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_InitSockets(uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_InitSockets(uint32_t num_socks) {
N    EventRecord2 (EvtNetBSD_InitSockets, num_socks, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (0 & 0xFFU)), num_socks, 0);
N  }
N#else
S  #define EvrNetBSD_InitSockets(num_socks)
N#endif
N
N/**
N  \brief  Event on BSD \ref socket create (API)
N  \param  sock          allocated socket descriptor
N  \param  type          socket type
N                         - 1: SOCK_STREAM
N                         - 2: SOCK_DGRAM
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SocketCreate(int32_t sock, int32_t type) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SocketCreate(int32_t sock, int32_t type) {
N    EventRecord2 (EvtNetBSD_SocketCreate, (uint32_t)sock, (uint32_t)type);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (1 & 0xFFU)), (uint32_t)sock, (uint32_t)type);
N  }
N#else
S  #define EvrNetBSD_SocketCreate(sock, type)
N#endif
N
N/**
N  \brief  Event on BSD \ref socket create failed, invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SocketInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SocketInvalidParameter(void) {
N    EventRecord2 (EvtNetBSD_SocketInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (2 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_SocketInvalidParameter()
N#endif
N
N/**
N  \brief  Event on BSD \ref socket create failed, no free socket available (Error)
N  \param  num_socks     number of available BSD sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_NoSocketAvailable(uint32_t num_socks) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_NoSocketAvailable(uint32_t num_socks) {
N    EventRecord2 (EvtNetBSD_NoSocketAvailable, num_socks, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (3 & 0xFFU)), num_socks, 0);
N  }
N#else
S  #define EvrNetBSD_NoSocketAvailable(num_socks)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind socket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindSocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindSocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindSocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (4 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindSocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (5 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (6 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (7 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, socket already bound (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindSocketAlreadyBound(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindSocketAlreadyBound(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindSocketAlreadyBound, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (8 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindSocketAlreadyBound(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, socket already connected (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindSocketConnected(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindSocketConnected(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindSocketConnected, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (9 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindSocketConnected(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref bind failed, port in use (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_BindPortInUse(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_BindPortInUse(int32_t sock) {
N    EventRecord2 (EvtNetBSD_BindPortInUse, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (10 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_BindPortInUse(sock)
N#endif
N
N/**
N  \brief  Event on BSD display network address (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ShowNetAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ShowNetAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetBSD_ShowNetAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (11 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetBSD_ShowNetAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen socket (API)
N  \param  sock          socket descriptor
N  \param  backlog       max number of queued connection requests
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSocket(int32_t sock, int32_t backlog) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSocket(int32_t sock, int32_t backlog) {
N    EventRecord2 (EvtNetBSD_ListenSocket, (uint32_t)sock, (uint32_t)backlog);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (13 & 0xFFU)), (uint32_t)sock, (uint32_t)backlog);
N  }
N#else
S  #define EvrNetBSD_ListenSocket(sock, backlog)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (14 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (15 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (145 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, socket not bound (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSocketNotBound(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSocketNotBound(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenSocketNotBound, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (16 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenSocketNotBound(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, socket not stream type (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSocketNotStreamType(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSocketNotStreamType(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenSocketNotStreamType, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (17 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenSocketNotStreamType(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, socket already listens (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenSockAlreadyListens(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenSockAlreadyListens(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenSockAlreadyListens, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (18 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenSockAlreadyListens(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref listen failed, creating socket backlog failed (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ListenBacklogCreateFailed(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ListenBacklogCreateFailed(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ListenBacklogCreateFailed, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (19 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ListenBacklogCreateFailed(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept socket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (20 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (21 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (146 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket not listening (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketNotListening(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketNotListening(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketNotListening, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (22 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketNotListening(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket not stream type (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketNotStreamType(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketNotStreamType(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketNotStreamType, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (23 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketNotStreamType(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (24 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept success, child socket connected (Op)
N  \param  child_sock    child socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptChildSockConnected(int32_t child_sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptChildSockConnected(int32_t child_sock) {
N    EventRecord2 (EvtNetBSD_AcceptChildSockConnected, (uint32_t)child_sock, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (25 & 0xFFU)), (uint32_t)child_sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptChildSockConnected(child_sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket closed by peer (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketClosed(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketClosed(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketClosed, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (26 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketClosed(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref accept failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_AcceptSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_AcceptSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_AcceptSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (27 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_AcceptSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect socket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (28 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (29 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (30 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (31 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (32 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, wrong socket state (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocketWrongState(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocketWrongState(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocketWrongState, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (33 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocketWrongState(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect success, datagram socket connected (Op)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectDatagramSuccess(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectDatagramSuccess(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectDatagramSuccess, (uint32_t)sock, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (34 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectDatagramSuccess(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect success, stream socket connected (Op)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectStreamSuccess(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectStreamSuccess(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectStreamSuccess, (uint32_t)sock, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (35 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectStreamSuccess(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, connect request has timed out (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectStreamTimeout(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectStreamTimeout(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectStreamTimeout, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (36 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectStreamTimeout(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, remote host refused connection (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectStreamRefused(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectStreamRefused(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectStreamRefused, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (37 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectStreamRefused(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref connect failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_ConnectSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_ConnectSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_ConnectSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (38 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_ConnectSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send socket (API)
N  \param  sock          socket descriptor
N  \param  length        length of data to send
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocket(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocket(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_SendSocket, (uint32_t)sock, length);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (39 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_SendSocket(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (40 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (41 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (42 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (43 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket not connected (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketNotConnected(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketNotConnected(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketNotConnected, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (44 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketNotConnected(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, wrong socket state (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketWrongState(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketWrongState(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketWrongState, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (45 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketWrongState(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket closed by peer (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketClosed(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketClosed(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketClosed, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (46 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketClosed(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send complete non-blocking mode (Op)
N  \param  sock          socket descriptor
N  \param  num           number of bytes successfully sent
N  \param  length        length of data requested to send
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendCompleteNonBlocking(int32_t sock, uint32_t num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendCompleteNonBlocking(int32_t sock, uint32_t num, uint32_t length) {
N    uint32_t val2 = (num << 16) | length;
N    EventRecord2 (EvtNetBSD_SendCompleteNonBlocking, (uint32_t)sock, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (47 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_SendCompleteNonBlocking(sock, num, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (48 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, stream socket unspecified error (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendStreamError(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendStreamError(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendStreamError, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (49 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendStreamError(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendto failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendtoInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendtoInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendtoInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (50 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendtoInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, destination address unspecified (Error)
N  \param  sock          socket descriptor
N  \remark The \ref connect function was not previously called for datagram socket.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendDestAddressUndefined(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendDestAddressUndefined(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendDestAddressUndefined, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (51 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendDestAddressUndefined(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send failed, datagram socket unspecified error (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendDatagramError(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendDatagramError(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendDatagramError, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (52 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendDatagramError(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref send complete in blocking mode (Op)
N  \param  sock          socket descriptor
N  \param  num           number of bytes successfully sent
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendCompleteBlocking(int32_t sock, uint32_t num) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendCompleteBlocking(int32_t sock, uint32_t num) {
N    EventRecord2 (EvtNetBSD_SendCompleteBlocking, (uint32_t)sock, num);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (53 & 0xFFU)), (uint32_t)sock, num);
N  }
N#else
S  #define EvrNetBSD_SendCompleteBlocking(sock, num)
N#endif
N
N/**
N  \brief  Event on BSD \ref send timeout in blocking mode (Op)
N  \param  sock          socket descriptor
N  \param  num           number of bytes successfully sent
N  \param  length        length of data requested to send
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendTimeoutBlocking(int32_t sock, uint32_t num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendTimeoutBlocking(int32_t sock, uint32_t num, uint32_t length) {
N    uint32_t val2 = (num << 16) | length;
N    EventRecord2 (EvtNetBSD_SendTimeoutBlocking, (uint32_t)sock, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (54 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_SendTimeoutBlocking(sock, num, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref send out of memory (Op)
N  \param  sock          socket descriptor
N  \param  num           number of bytes successfully sent
N  \param  length        length of data requested to send
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendNoMemory(int32_t sock, uint32_t num, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendNoMemory(int32_t sock, uint32_t num, uint32_t length) {
N    uint32_t val2 = (num << 16) | length;
N    EventRecord2 (EvtNetBSD_SendNoMemory, (uint32_t)sock, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (55 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_SendNoMemory(sock, num, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg socket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgSocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgSocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgSocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (56 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgSocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (57 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (58 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (59 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (60 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, destination address unspecified (Error)
N  \param  sock          socket descriptor
N  \remark The \ref connect function was not previously called for datagram socket.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgDestAddrUndefined(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgDestAddrUndefined(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgDestAddrUndefined, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (61 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgDestAddrUndefined(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg out of memory (Error)
N  \param  sock          socket descriptor
N  \param  length        length of message requested to send
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgNoMemory(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgNoMemory(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_SendmsgNoMemory, (uint32_t)sock, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (62 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_SendmsgNoMemory(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, datagram socket unspecified error (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgDatagramError(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgDatagramError(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgDatagramError, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (63 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgDatagramError(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SendmsgSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (64 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SendmsgSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref sendmsg complete (Op)
N  \param  sock          socket descriptor
N  \param  num           number of bytes successfully sent
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SendmsgComplete(int32_t sock, uint32_t num) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SendmsgComplete(int32_t sock, uint32_t num) {
N    EventRecord2 (EvtNetBSD_SendmsgComplete, (uint32_t)sock, num);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (65 & 0xFFU)), (uint32_t)sock, num);
N  }
N#else
S  #define EvrNetBSD_SendmsgComplete(sock, num)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv socket (API)
N  \param  sock          socket descriptor
N  \param  length        length of data to receive
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocket(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocket(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_RecvSocket, (uint32_t)sock, length);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (66 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_RecvSocket(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (67 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (68 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (69 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket not connected (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketNotConnected(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketNotConnected(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketNotConnected, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (70 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketNotConnected(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, wrong socket state (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketWrongState(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketWrongState(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketWrongState, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (71 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketWrongState(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (72 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket closed by peer (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketClosed(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketClosed(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketClosed, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (73 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketClosed(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv timeout (Op)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvTimeout(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvTimeout(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvTimeout, (uint32_t)sock, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (74 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvTimeout(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (75 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv queue free (Op)
N  \param  sock          socket descriptor
N  \param  length        length of data to release
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvQueueFree(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvQueueFree(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_RecvQueueFree, (uint32_t)sock, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (76 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_RecvQueueFree(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref recv complete (Op)
N  \param  sock          socket descriptor
N  \param  length        length of data received
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvComplete(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvComplete(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_RecvComplete, (uint32_t)sock, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (77 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_RecvComplete(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg socket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (78 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (79 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (80 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (81 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, socket locked by another thread (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocketLocked(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocketLocked(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocketLocked, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (82 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocketLocked(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, wrong socket state (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocketWrongState(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocketWrongState(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocketWrongState, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (83 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocketWrongState(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg timeout (Op)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgTimeout(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgTimeout(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgTimeout, (uint32_t)sock, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (84 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgTimeout(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg failed, socket killed locally (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgSocketKilled(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgSocketKilled(int32_t sock) {
N    EventRecord2 (EvtNetBSD_RecvmsgSocketKilled, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (85 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_RecvmsgSocketKilled(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref recvmsg complete (Op)
N  \param  sock          socket descriptor
N  \param  length        length of data received
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_RecvmsgComplete(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_RecvmsgComplete(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_RecvmsgComplete, (uint32_t)sock, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (86 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_RecvmsgComplete(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD \ref closesocket (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Closesocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Closesocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_Closesocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (87 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_Closesocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref closesocket failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CloseSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CloseSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_CloseSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (88 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_CloseSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref closesocket failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CloseSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CloseSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_CloseSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (147 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_CloseSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref select (API)
N  \param  nfds          range of sockets to be tested
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Select(int32_t nfds) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Select(int32_t nfds) {
N    EventRecord2 (EvtNetBSD_Select, (uint32_t)nfds, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (89 & 0xFFU)), (uint32_t)nfds, 0);
N  }
N#else
S  #define EvrNetBSD_Select(nfds)
N#endif
N
N
N/**
N  \brief  Event on BSD \ref select failed, invalid parameter (Error)
N  \param  nfds          range of sockets to be tested
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SelectInvalidParameter(int32_t nfds) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SelectInvalidParameter(int32_t nfds) {
N    EventRecord2 (EvtNetBSD_SelectInvalidParameter, (uint32_t)nfds, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (90 & 0xFFU)), (uint32_t)nfds, 0);
N  }
N#else
S  #define EvrNetBSD_SelectInvalidParameter(nfds)
N#endif
N
N/**
N  \brief  Event on BSD \ref select suspend failed (Error)
N  \param  nfds          range of sockets to be subscribed to resume events
N  \remark Subscription to resume events has failed, no sockets subscribed.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SelectSuspendFailed(int32_t nfds) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SelectSuspendFailed(int32_t nfds) {
N    EventRecord2 (EvtNetBSD_SelectSuspendFailed, (uint32_t)nfds, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (91 & 0xFFU)), (uint32_t)nfds, 0);
N  }
N#else
S  #define EvrNetBSD_SelectSuspendFailed(nfds)
N#endif
N
N/**
N  \brief  Event on BSD \ref select complete non-blocking (Op)
N  \param  n_ready       number of ready sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SelectComplete(int32_t n_ready) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SelectComplete(int32_t n_ready) {
N    EventRecord2 (EvtNetBSD_SelectComplete, (uint32_t)n_ready, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (92 & 0xFFU)), (uint32_t)n_ready, 0);
N  }
N#else
S  #define EvrNetBSD_SelectComplete(n_ready)
N#endif
N
N/**
N  \brief  Event on BSD \ref select complete blocking (Op)
N  \param  n_ready       number of ready sockets
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SelectCompleteBlocking(int32_t n_ready) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SelectCompleteBlocking(int32_t n_ready) {
N    EventRecord2 (EvtNetBSD_SelectCompleteBlocking, (uint32_t)n_ready, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (93 & 0xFFU)), (uint32_t)n_ready, 0);
N  }
N#else
S  #define EvrNetBSD_SelectCompleteBlocking(n_ready)
N#endif
N
N/**
N  \brief  Event on BSD \ref getpeername (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Getpeername(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Getpeername(int32_t sock) {
N    EventRecord2 (EvtNetBSD_Getpeername, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (94 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_Getpeername(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getpeername failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetpeerSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetpeerSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetpeerSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (95 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetpeerSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getpeername failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetpeerSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetpeerSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetpeerSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (148 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetpeerSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getpeername failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetpeerInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetpeerInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetpeerInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (96 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetpeerInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getpeername failed, socket not connected (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetpeerSocketNotConnected(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetpeerSocketNotConnected(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetpeerSocketNotConnected, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (97 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetpeerSocketNotConnected(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockname (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Getsockname(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Getsockname(int32_t sock) {
N    EventRecord2 (EvtNetBSD_Getsockname, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (98 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_Getsockname(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockname failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetsockSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetsockSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetsockSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (99 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetsockSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockname failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetsockSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetsockSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetsockSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (149 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetsockSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockname failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetsockInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetsockInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetsockInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (100 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetsockInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockname failed, socket not bound (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetsockSocketNotBound(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetsockSocketNotBound(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetsockSocketNotBound, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (101 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetsockSocketNotBound(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt (API)
N  \param  sock          socket descriptor
N  \param  level         level at which the option is defined
N  \param  optname       socket option to be set
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Setsockopt(int32_t sock, int32_t level, int32_t optname) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Setsockopt(int32_t sock, int32_t level, int32_t optname) {
N    uint32_t val2 = (uint32_t)((level << 4) | optname);
N    EventRecord2 (EvtNetBSD_Setsockopt, (uint32_t)sock, val2);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (102 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_Setsockopt(sock, level, optname)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SetoptSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (103 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SetoptSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SetoptInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (104 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SetoptInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_SetoptSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (105 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_SetoptSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt failed, option not supported by the protocol (Error)
N  \param  sock          socket descriptor
N  \param  level         level at which the option is defined
N  \param  optname       socket option to be set
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptOptionNotSupported(int32_t sock, int32_t level, int32_t optname) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptOptionNotSupported(int32_t sock, int32_t level, int32_t optname) {
N    uint32_t val2 = (uint32_t)((level << 4) | optname);
N    EventRecord2 (EvtNetBSD_SetoptOptionNotSupported, (uint32_t)sock, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (106 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_SetoptOptionNotSupported(sock, level, optname)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt keep-alive option (Op)
N  \param  sock          socket descriptor
N  \param  enable        keep-alive state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptKeepAlive(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptKeepAlive(int32_t sock, uint32_t enable) {
N    EventRecord2 (EvtNetBSD_SetoptKeepAlive, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (107 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_SetoptKeepAlive(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt receive timeout (Op)
N  \param  sock          socket descriptor
N  \param  timeout       receive timeout in ms
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptRecvTimeout(int32_t sock, uint32_t timeout) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptRecvTimeout(int32_t sock, uint32_t timeout) {
N    EventRecord2 (EvtNetBSD_SetoptRecvTimeout, (uint32_t)sock, timeout);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (108 & 0xFFU)), (uint32_t)sock, timeout);
N  }
N#else
S  #define EvrNetBSD_SetoptRecvTimeout(sock, timeout)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt send timeout (Op)
N  \param  sock          socket descriptor
N  \param  timeout       send timeout in ms
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptSendTimeout(int32_t sock, uint32_t timeout) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptSendTimeout(int32_t sock, uint32_t timeout) {
N    EventRecord2 (EvtNetBSD_SetoptSendTimeout, (uint32_t)sock, timeout);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (109 & 0xFFU)), (uint32_t)sock, timeout);
N  }
N#else
S  #define EvrNetBSD_SetoptSendTimeout(sock, timeout)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt TOS for IPv4 (Op)
N  \param  sock          socket descriptor
N  \param  ip4_tos       type of service value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp4Tos(int32_t sock, uint8_t ip4_tos) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp4Tos(int32_t sock, uint8_t ip4_tos) {
N    EventRecord2 (EvtNetBSD_SetoptIp4Tos, (uint32_t)sock, ip4_tos);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (110 & 0xFFU)), (uint32_t)sock, ip4_tos);
N  }
N#else
S  #define EvrNetBSD_SetoptIp4Tos(sock, ip4_tos)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt TTL for IPv4 (Op)
N  \param  sock          socket descriptor
N  \param  ip4_ttl       time to live value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp4Ttl(int32_t sock, uint8_t ip4_ttl) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp4Ttl(int32_t sock, uint8_t ip4_ttl) {
N    EventRecord2 (EvtNetBSD_SetoptIp4Ttl, (uint32_t)sock, ip4_ttl);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (111 & 0xFFU)), (uint32_t)sock, ip4_ttl);
N  }
N#else
S  #define EvrNetBSD_SetoptIp4Ttl(sock, ip4_ttl)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt receive destination address for IPv4 (Op)
N  \param  sock          socket descriptor
N  \param  enable        receive dst address state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp4RecvDstAddr(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp4RecvDstAddr(int32_t sock, uint32_t enable) {
N    EventRecord2 (EvtNetBSD_SetoptIp4RecvDstAddr, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (112 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_SetoptIp4RecvDstAddr(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt Traffic Class for IPv6 (Op)
N  \param  sock          socket descriptor
N  \param  ip6_tclass    traffic class value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp6Tclass(int32_t sock, uint8_t ip6_tclass) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp6Tclass(int32_t sock, uint8_t ip6_tclass) {
N    EventRecord2 (EvtNetBSD_SetoptIp6Tclass, (uint32_t)sock, ip6_tclass);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (113 & 0xFFU)), (uint32_t)sock, ip6_tclass);
N  }
N#else
S  #define EvrNetBSD_SetoptIp6Tclass(sock, ip6_tclass)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt Hop Limit for IPv6 (Op)
N  \param  sock          socket descriptor
N  \param  ip6_hoplimit  hop limit value
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp6HopLimit(int32_t sock, uint8_t ip6_hoplimit) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp6HopLimit(int32_t sock, uint8_t ip6_hoplimit) {
N    EventRecord2 (EvtNetBSD_SetoptIp6HopLimit, (uint32_t)sock, ip6_hoplimit);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (114 & 0xFFU)), (uint32_t)sock, ip6_hoplimit);
N  }
N#else
S  #define EvrNetBSD_SetoptIp6HopLimit(sock, ip6_hoplimit)
N#endif
N
N/**
N  \brief  Event on BSD \ref setsockopt receive destination address for IPv6 (Op)
N  \param  sock          socket descriptor
N  \param  enable        receive dst address state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_SetoptIp6RecvDstAddr(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_SetoptIp6RecvDstAddr(int32_t sock, uint32_t enable) {
N    EventRecord2 (EvtNetBSD_SetoptIp6RecvDstAddr, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (115 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_SetoptIp6RecvDstAddr(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockopt (API)
N  \param  sock          socket descriptor
N  \param  level         level at which the option is defined
N  \param  optname       socket option to be retrieved
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Getsockopt(int32_t sock, int32_t level, int32_t optname) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Getsockopt(int32_t sock, int32_t level, int32_t optname) {
N    uint32_t val2 = (uint32_t)((level << 4) | optname);
N    EventRecord2 (EvtNetBSD_Getsockopt, (uint32_t)sock, val2);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (116 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_Getsockopt(sock, level, optname)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockopt failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetoptSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetoptSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetoptSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (117 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetoptSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockopt failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetoptInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetoptInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetoptInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (118 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetoptInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockopt failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetoptSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetoptSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_GetoptSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (119 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_GetoptSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref getsockopt failed, option not supported by the protocol (Error)
N  \param  sock          socket descriptor
N  \param  level         level at which the option is defined
N  \param  optname       socket option to be retrieved
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetoptOptionNotSupported(int32_t sock, int32_t level, int32_t optname) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetoptOptionNotSupported(int32_t sock, int32_t level, int32_t optname) {
N    uint32_t val2 = (uint32_t)((level << 4) | optname);
N    EventRecord2 (EvtNetBSD_GetoptOptionNotSupported, (uint32_t)sock, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (120 & 0xFFU)), (uint32_t)sock, val2);
N  }
N#else
S  #define EvrNetBSD_GetoptOptionNotSupported(sock, level, optname)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket control (API)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_Ioctlsocket(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_Ioctlsocket(int32_t sock) {
N    EventRecord2 (EvtNetBSD_Ioctlsocket, (uint32_t)sock, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (121 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_Ioctlsocket(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket control failed, socket not valid (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlSocketNotValid(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlSocketNotValid(int32_t sock) {
N    EventRecord2 (EvtNetBSD_IoctlSocketNotValid, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (122 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_IoctlSocketNotValid(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket control failed, invalid parameter (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlInvalidParameter(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlInvalidParameter(int32_t sock) {
N    EventRecord2 (EvtNetBSD_IoctlInvalidParameter, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (123 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_IoctlInvalidParameter(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket control failed, socket not created (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlSocketNotCreated(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlSocketNotCreated(int32_t sock) {
N    EventRecord2 (EvtNetBSD_IoctlSocketNotCreated, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (124 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_IoctlSocketNotCreated(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket control failed, socket not stream type (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlSocketNotStreamType(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlSocketNotStreamType(int32_t sock) {
N    EventRecord2 (EvtNetBSD_IoctlSocketNotStreamType, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (125 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_IoctlSocketNotStreamType(sock)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket enable non-blocking mode (Op)
N  \param  sock          socket descriptor
N  \param  enable        non-blocking state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlNonBlocking(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlNonBlocking(int32_t sock, uint32_t enable) {
N    if (enable) enable = 1;
N    EventRecord2 (EvtNetBSD_IoctlNonBlocking, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (126 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_IoctlNonBlocking(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket enable TCP delay-ack mode (Op)
N  \param  sock          socket descriptor
N  \param  enable        delay-ack state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlDelayAck(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlDelayAck(int32_t sock, uint32_t enable) {
N    if (enable) enable = 1;
N    EventRecord2 (EvtNetBSD_IoctlDelayAck, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (127 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_IoctlDelayAck(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket enable TCP keep-alive mode (Op)
N  \param  sock          socket descriptor
N  \param  enable        keep-alive state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlKeepAlive(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlKeepAlive(int32_t sock, uint32_t enable) {
N    if (enable) enable = 1;
N    EventRecord2 (EvtNetBSD_IoctlKeepAlive, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (128 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_IoctlKeepAlive(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD \ref ioctlsocket enable TCP flow-control mode (Op)
N  \param  sock          socket descriptor
N  \param  enable        flow-control state value
N                         - 0: disable
N                         - 1: enable
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_IoctlFlowControl(int32_t sock, uint32_t enable) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_IoctlFlowControl(int32_t sock, uint32_t enable) {
N    if (enable) enable = 1;
N    EventRecord2 (EvtNetBSD_IoctlFlowControl, (uint32_t)sock, enable);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (129 & 0xFFU)), (uint32_t)sock, enable);
N  }
N#else
S  #define EvrNetBSD_IoctlFlowControl(sock, enable)
N#endif
N
N/**
N  \brief  Event on BSD callback TCP function events (Op)
N  \param  sock          socket descriptor
N  \param  tcp_event     TCP socket event
N                         - 0: netTCP_EventConnect
N                         - 1: netTCP_EventEstablished
N                         - 2: netTCP_EventClosed
N                         - 3: netTCP_EventAborted
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CbfuncTcpEvent(int32_t sock, int32_t tcp_event) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CbfuncTcpEvent(int32_t sock, int32_t tcp_event) {
N    EventRecord2 (EvtNetBSD_CbfuncTcpEvent, (uint32_t)sock, (uint32_t)tcp_event);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (130 & 0xFFU)), (uint32_t)sock, (uint32_t)tcp_event);
N  }
N#else
S  #define EvrNetBSD_CbfuncTcpEvent(sock, tcp_event)
N#endif
N
N/**
N  \brief  Event on BSD callback TCP data received (Op)
N  \param  sock          socket descriptor
N  \param  length        length of data received
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CbfuncTcpQueueAdd(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CbfuncTcpQueueAdd(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_CbfuncTcpQueueAdd, (uint32_t)sock, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (131 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_CbfuncTcpQueueAdd(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD callback no memory for TCP data (Error)
N  \param  sock          socket descriptor
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CbfuncTcpNoMemory(int32_t sock) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CbfuncTcpNoMemory(int32_t sock) {
N    EventRecord2 (EvtNetBSD_CbfuncTcpNoMemory, (uint32_t)sock, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (132 & 0xFFU)), (uint32_t)sock, 0);
N  }
N#else
S  #define EvrNetBSD_CbfuncTcpNoMemory(sock)
N#endif
N
N/**
N  \brief  Event on BSD callback UDP data received (Op)
N  \param  sock          socket descriptor
N  \param  length        length of data received
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CbfuncUdpQueueAdd(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CbfuncUdpQueueAdd(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_CbfuncUdpQueueAdd, (uint32_t)sock, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (133 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_CbfuncUdpQueueAdd(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD callback no memory for UDP data (Error)
N  \param  sock          socket descriptor
N  \param  length        length of dumped data
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_CbfuncUdpDumpData(int32_t sock, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_CbfuncUdpDumpData(int32_t sock, uint32_t length) {
N    EventRecord2 (EvtNetBSD_CbfuncUdpDumpData, (uint32_t)sock, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (134 & 0xFFU)), (uint32_t)sock, length);
N  }
N#else
S  #define EvrNetBSD_CbfuncUdpDumpData(sock, length)
N#endif
N
N/**
N  \brief  Event on BSD de-initialize available sockets (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_UninitSockets(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_UninitSockets(void) {
N    EventRecord2 (EvtNetBSD_UninitSockets, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (135 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_UninitSockets()
N#endif
N
N// BSD-Host resolver event recorder functions ----------------------------------
N
N/**
N  \brief  Event on BSD hostname resolver initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostInit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostInit(void) {
N    EventRecord2 (EvtNetBSD_GetHostInit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (136 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostInit()
N#endif
N
N/**
N  \brief  Event on BSD \ref gethostbyname (API)
N  \param  hostname      name of the host to resolve
N  \param  length        length of the hostname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostByName(const char *hostname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostByName(const char *hostname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetBSD_GetHostByName, hostname, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (137 & 0xFFU)), hostname, length);
N  }
N#else
S  #define EvrNetBSD_GetHostByName(hostname, length)
N#endif
N
N/**
N  \brief  Event on BSD hostname resolved successfully (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostNameResolved(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostNameResolved(void) {
N    EventRecord2 (EvtNetBSD_GetHostNameResolved, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (138 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostNameResolved()
N#endif
N
N/**
N  \brief  Event on BSD requested hostname not existing (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostNameNotExisting(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostNameNotExisting(void) {
N    EventRecord2 (EvtNetBSD_GetHostNameNotExisting, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (139 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostNameNotExisting()
N#endif
N
N/**
N  \brief  Event on BSD resolver timeout expired (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostResolverTimeout(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostResolverTimeout(void) {
N    EventRecord2 (EvtNetBSD_GetHostResolverTimeout, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (140 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostResolverTimeout()
N#endif
N
N/**
N  \brief  Event on BSD resolver protocol error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostResolverError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostResolverError(void) {
N    EventRecord2 (EvtNetBSD_GetHostResolverError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (141 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostResolverError()
N#endif
N
N/**
N  \brief  Event on BSD resolver busy error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostResolverBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostResolverBusy(void) {
N    EventRecord2 (EvtNetBSD_GetHostResolverBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (142 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostResolverBusy()
N#endif
N
N/**
N  \brief  Event on BSD \ref gethostbyname invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostInvalidParameter(void) {
N    EventRecord2 (EvtNetBSD_GetHostInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (143 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostInvalidParameter()
N#endif
N
N/**
N  \brief  Event on BSD hostname resolver de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetBSD_GetHostUninit(void) {
X  static __inline __attribute__((always_inline)) void EvrNetBSD_GetHostUninit(void) {
N    EventRecord2 (EvtNetBSD_GetHostUninit, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD2 & 0xFFU) << 8) | (144 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetBSD_GetHostUninit()
N#endif
N
N
N// NetHTTPs event identifiers --------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetHTTPs_InitServer              EventID (EventLevelOp,    EvtNetHTTPs,  0)
N#define EvtNetHTTPs_ShowRootFolder          EventID (EventLevelOp,    EvtNetHTTPs,  1)
N#define EvtNetHTTPs_GetSocketFailed         EventID (EventLevelError, EvtNetHTTPs,  2)
N#define EvtNetHTTPs_SetRootPath             EventID (EventLevelAPI,   EvtNetHTTPs,  3)
N#define EvtNetHTTPs_SetUsername             EventID (EventLevelAPI,   EvtNetHTTPs,  4)
N#define EvtNetHTTPs_SetPassword             EventID (EventLevelAPI,   EvtNetHTTPs,  5)
N#define EvtNetHTTPs_StartService            EventID (EventLevelOp,    EvtNetHTTPs,  6)
N#define EvtNetHTTPs_StopService             EventID (EventLevelOp,    EvtNetHTTPs,  7)
N#define EvtNetHTTPs_FileNotFound            EventID (EventLevelError, EvtNetHTTPs,  8)
N#define EvtNetHTTPs_FileAccessForbidden     EventID (EventLevelError, EvtNetHTTPs,  9)
N#define EvtNetHTTPs_FileCached              EventID (EventLevelOp,    EvtNetHTTPs, 10)
N#define EvtNetHTTPs_CloseSession            EventID (EventLevelOp,    EvtNetHTTPs, 11)
N#define EvtNetHTTPs_SendFile                EventID (EventLevelOp,    EvtNetHTTPs, 12)
N#define EvtNetHTTPs_CgiSendFile             EventID (EventLevelOp,    EvtNetHTTPs, 13)
N#define EvtNetHTTPs_CgiIncludeFile          EventID (EventLevelOp,    EvtNetHTTPs, 14)
N#define EvtNetHTTPs_CgiStopEngine           EventID (EventLevelOp,    EvtNetHTTPs, 15)
N#define EvtNetHTTPs_CgiScriptError          EventID (EventLevelError, EvtNetHTTPs, 16)
N#define EvtNetHTTPs_UnauthorizedAccess      EventID (EventLevelError, EvtNetHTTPs, 17)
N#define EvtNetHTTPs_MethodNotImplemented    EventID (EventLevelError, EvtNetHTTPs, 18)
N#define EvtNetHTTPs_UserAccessDenied        EventID (EventLevelError, EvtNetHTTPs, 19)
N// Gap
N#define EvtNetHTTPs_SessionOpen             EventID (EventLevelOp,    EvtNetHTTPs, 21)
N#define EvtNetHTTPs_SocketAborted           EventID (EventLevelOp,    EvtNetHTTPs, 22)
N#define EvtNetHTTPs_SocketClosed            EventID (EventLevelOp,    EvtNetHTTPs, 23)
N#define EvtNetHTTPs_ReceiveFrame            EventID (EventLevelOp,    EvtNetHTTPs, 24)
N#define EvtNetHTTPs_FrameTooShort           EventID (EventLevelError, EvtNetHTTPs, 25)
N#define EvtNetHTTPs_RequestMethod           EventID (EventLevelOp,    EvtNetHTTPs, 26)
N#define EvtNetHTTPs_CgiStartEngine          EventID (EventLevelOp,    EvtNetHTTPs, 27)
N#define EvtNetHTTPs_RequestedFile           EventID (EventLevelOp,    EvtNetHTTPs, 28)
N#define EvtNetHTTPs_FileOpenDrive           EventID (EventLevelOp,    EvtNetHTTPs, 29)
N#define EvtNetHTTPs_ShowFileStatus          EventID (EventLevelOp,    EvtNetHTTPs, 30)
N#define EvtNetHTTPs_ShowRedirectionUrl      EventID (EventLevelOp,    EvtNetHTTPs, 31)
N#define EvtNetHTTPs_ShowUserCredentials     EventID (EventLevelOp,    EvtNetHTTPs, 32)
N#define EvtNetHTTPs_ShowAcceptLanguage      EventID (EventLevelOp,    EvtNetHTTPs, 33)
N#define EvtNetHTTPs_ShowXmlType             EventID (EventLevelOp,    EvtNetHTTPs, 34)
N#define EvtNetHTTPs_PostXmlEncoded          EventID (EventLevelOp,    EvtNetHTTPs, 35)
N#define EvtNetHTTPs_PostCompleteMultipacket EventID (EventLevelOp,    EvtNetHTTPs, 36)
N#define EvtNetHTTPs_PostFormUrlEncoded      EventID (EventLevelOp,    EvtNetHTTPs, 37)
N#define EvtNetHTTPs_PostDataTruncated       EventID (EventLevelError, EvtNetHTTPs, 38)
N#define EvtNetHTTPs_FileUploadRequested     EventID (EventLevelOp,    EvtNetHTTPs, 39)
N#define EvtNetHTTPs_FileUploadDataReceived  EventID (EventLevelOp,    EvtNetHTTPs, 40)
N#define EvtNetHTTPs_FileUploadRemaining     EventID (EventLevelOp,    EvtNetHTTPs, 41)
N#define EvtNetHTTPs_FileUploadComplete      EventID (EventLevelOp,    EvtNetHTTPs, 42)
N#define EvtNetHTTPs_TlsGetContextFailed     EventID (EventLevelError, EvtNetHTTPs, 43)
N#define EvtNetHTTPs_UninitServer            EventID (EventLevelOp,    EvtNetHTTPs, 44)
N#endif
N
N/**
N  \brief  Event on HTTP server initialize (Op)
N  \param  num_sessions  number of available HTTP sessions
N  \param  port          listening port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_InitServer(uint32_t num_sessions, uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_InitServer(uint32_t num_sessions, uint16_t port) {
N    EventRecord2 (EvtNetHTTPs_InitServer, num_sessions, port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (0 & 0xFFU)), num_sessions, port);
N  }
N#else
S  #define EvrNetHTTPs_InitServer(num_sessions, port)
N#endif
N
N/**
N  \brief  Event on HTTP server display root folder (Op)
N  \param  root_folder   path to server root folder
N  \param  length        length of the root_folder string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetHTTPs_ShowRootFolder, root_folder, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (1 & 0xFFU)), root_folder, length);
N  }
N#else
S  #define EvrNetHTTPs_ShowRootFolder(root_folder, length)
N#endif
N
N/**
N  \brief  Event on HTTP server failed to allocate TCP socket (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_GetSocketFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_GetSocketFailed(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_GetSocketFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (2 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_GetSocketFailed(session)
N#endif
N
N/**
N  \brief  Event on HTTP server \ref netHTTPs_SetRootPath (API)
N  \param  path          path to server root folder
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SetRootPath(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SetRootPath(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetHTTPs_SetRootPath, path, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (3 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetHTTPs_SetRootPath(path, length)
N#endif
N
N/**
N  \brief  Event on HTTP server \ref netHTTPs_SetUsername (API)
N  \param  username      new username
N  \param  length        length of the username string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SetUsername(const char *username, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SetUsername(const char *username, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetHTTPs_SetUsername, username, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (4 & 0xFFU)), username, length);
N  }
N#else
S  #define EvrNetHTTPs_SetUsername(username, length)
N#endif
N
N/**
N  \brief  Event on HTTP server \ref netHTTPs_SetPassword (API)
N  \param  password      new password
N  \param  length        length of the password string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SetPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SetPassword(const char *password, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetHTTPs_SetPassword, password, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (5 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetHTTPs_SetPassword(password, length)
N#endif
N
N/**
N  \brief  Event on HTTP server start service (Op)
N  \param  port          listening port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_StartService(uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_StartService(uint16_t port) {
N    EventRecord2 (EvtNetHTTPs_StartService, port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (6 & 0xFFU)), port, 0);
N  }
N#else
S  #define EvrNetHTTPs_StartService(port)
N#endif
N
N/**
N  \brief  Event on HTTP server stop service (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_StopService(void) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_StopService(void) {
N    EventRecord2 (EvtNetHTTPs_StopService, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (7 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetHTTPs_StopService()
N#endif
N
N/**
N  \brief  Event on HTTP server requested resource file not found (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileNotFound(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileNotFound(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_FileNotFound, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (8 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileNotFound(session)
N#endif
N
N/**
N  \brief  Event on HTTP server access to requested resource not allowed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileAccessForbidden(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileAccessForbidden(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_FileAccessForbidden, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (9 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileAccessForbidden(session)
N#endif
N
N/**
N  \brief  Event on HTTP server requested resource file cached on the client (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileCached(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileCached(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_FileCached, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (10 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileCached(session)
N#endif
N
N/**
N  \brief  Event on HTTP server session close (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CloseSession(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CloseSession(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CloseSession, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (11 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CloseSession(session)
N#endif
N
N/**
N  \brief  Event on HTTP server send a resource file (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SendFile(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SendFile(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_SendFile, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (12 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_SendFile(session)
N#endif
N
N/**
N  \brief  Event on HTTP server CGI send dynamic resource file (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CgiSendFile(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CgiSendFile(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CgiSendFile, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (13 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CgiSendFile(session)
N#endif
N
N/**
N  \brief  Event on HTTP server CGI include a file (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CgiIncludeFile(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CgiIncludeFile(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CgiIncludeFile, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (14 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CgiIncludeFile(session)
N#endif
N
N/**
N  \brief  Event on HTTP server stop CGI script interpreter engine (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CgiStopEngine(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CgiStopEngine(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CgiStopEngine, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (15 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CgiStopEngine(session)
N#endif
N
N/**
N  \brief  Event on HTTP server CGI script error found (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CgiScriptError(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CgiScriptError(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CgiScriptError, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (16 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CgiScriptError(session)
N#endif
N
N/**
N  \brief  Event on HTTP server unauthorized access (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_UnauthorizedAccess(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_UnauthorizedAccess(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_UnauthorizedAccess, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (17 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_UnauthorizedAccess(session)
N#endif
N
N/**
N  \brief  Event on HTTP server requested method not implemented (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_MethodNotImplemented(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_MethodNotImplemented(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_MethodNotImplemented, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (18 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_MethodNotImplemented(session)
N#endif
N
N/**
N  \brief  Event on HTTP server user denied access (Error)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_UserAccessDenied(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_UserAccessDenied(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetHTTPs_UserAccessDenied, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (19 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetHTTPs_UserAccessDenied(net_addr)
N#endif
N
N/**
N  \brief  Event on HTTP server session open (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SessionOpen(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SessionOpen(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_SessionOpen, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (21 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_SessionOpen(session)
N#endif
N
N/**
N  \brief  Event on HTTP server socket aborted (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SocketAborted(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SocketAborted(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_SocketAborted, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (22 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_SocketAborted(session)
N#endif
N
N/**
N  \brief  Event on HTTP server socket closed (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_SocketClosed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_SocketClosed(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_SocketClosed, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (23 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_SocketClosed(session)
N#endif
N
N/**
N  \brief  Event on HTTP server receive frame (Op)
N  \param  session       session number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ReceiveFrame(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ReceiveFrame(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_ReceiveFrame, session, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (24 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetHTTPs_ReceiveFrame(session, length)
N#endif
N
N/**
N  \brief  Event on HTTP server receive frame too short (Error)
N  \param  session       session number
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetHTTPs_FrameTooShort, session, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (25 & 0xFFU)), session, val2);
N  }
N#else
S  #define EvrNetHTTPs_FrameTooShort(session, length, min_length)
N#endif
N
N/**
N  \brief  Event on HTTP server display requested method (Op)
N  \param  session       session number
N  \param  method        http request method
N                         - 0: HEAD
N                         - 1: GET
N                         - 2: POST
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_RequestMethod(uint8_t session, uint8_t method) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_RequestMethod(uint8_t session, uint8_t method) {
N    EventRecord2 (EvtNetHTTPs_RequestMethod, session, method);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (26 & 0xFFU)), session, method);
N  }
N#else
S  #define EvrNetHTTPs_RequestMethod(session, method)
N#endif
N
N/**
N  \brief  Event on HTTP server start CGI script interpreter engine (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_CgiStartEngine(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_CgiStartEngine(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_CgiStartEngine, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (27 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_CgiStartEngine(session)
N#endif
N
N/**
N  \brief  Event on HTTP server requested resource file (Op)
N  \param  fname         name of the requested file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_RequestedFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_RequestedFile(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetHTTPs_RequestedFile, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (28 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetHTTPs_RequestedFile(fname, length)
N#endif
N
N/**
N  \brief  Event on HTTP server resource file location (Op)
N  \param  drive         where the resource file is stored
N                         - 0: ROM Image
N                         - 1: External Drive
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileOpenDrive(uint32_t drive) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileOpenDrive(uint32_t drive) {
N    EventRecord2 (EvtNetHTTPs_FileOpenDrive, drive, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (29 & 0xFFU)), drive, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileOpenDrive(drive)
N#endif
N
N/**
N  \brief  Event on HTTP server display open file status (Op)
N  \param  size          size of the open file
N  \param  lm_time       last-modified time of the file
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowFileStatus(uint32_t size, uint32_t lm_time) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowFileStatus(uint32_t size, uint32_t lm_time) {
N    EventRecord2 (EvtNetHTTPs_ShowFileStatus, size, lm_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (30 & 0xFFU)), size, lm_time);
N  }
N#else
S  #define EvrNetHTTPs_ShowFileStatus(size, lm_time)
N#endif
N
N/**
N  \brief  Event on HTTP server display resource file redirection URL (Op)
N  \param  url           redirection url in text format
N  \param  length        length of the url string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowRedirectionUrl(const char *url, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowRedirectionUrl(const char *url, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetHTTPs_ShowRedirectionUrl, url, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (31 & 0xFFU)), url, length);
N  }
N#else
S  #define EvrNetHTTPs_ShowRedirectionUrl(url, length)
N#endif
N
N/**
N  \brief  Event on HTTP server display user credentials (Op)
N  \param  credentials   user credentials in the form of: "username:password"
N  \param  length        length of the credentials string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowUserCredentials(const char *credentials, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowUserCredentials(const char *credentials, uint32_t length) {
N    if (length > 40) length = 40;
N    EventRecordData (EvtNetHTTPs_ShowUserCredentials, credentials, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (32 & 0xFFU)), credentials, length);
N  }
N#else
S  #define EvrNetHTTPs_ShowUserCredentials(credentials, length)
N#endif
N
N/**
N  \brief  Event on HTTP server display accept language http header (Op)
N  \param  accept_lang   accept language header content
N  \param  length        length of the accept_lang string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowAcceptLanguage(const char *accept_lang, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowAcceptLanguage(const char *accept_lang, uint32_t length) {
N    if (length > 8) length = 8;
N    EventRecordData (EvtNetHTTPs_ShowAcceptLanguage, accept_lang, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (33 & 0xFFU)), accept_lang, length);
N  }
N#else
S  #define EvrNetHTTPs_ShowAcceptLanguage(accept_lang, length)
N#endif
N
N/**
N  \brief  Event on HTTP server display xml content type header (Op)
N  \param  xml_type      xml content type in text format
N  \param  length        length of the xml_type string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_ShowXmlType(const char *xml_type, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_ShowXmlType(const char *xml_type, uint32_t length) {
N    if (length > 64) length = 64;
N    EventRecordData (EvtNetHTTPs_ShowXmlType, xml_type, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (34 & 0xFFU)), xml_type, length);
N  }
N#else
S  #define EvrNetHTTPs_ShowXmlType(xml_type, length)
N#endif
N
N/**
N  \brief  Event on HTTP server POST type: xml-encoded (Op)
N  \param  length        content-length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_PostXmlEncoded(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_PostXmlEncoded(uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_PostXmlEncoded, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (35 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetHTTPs_PostXmlEncoded(length)
N#endif
N
N/**
N  \brief  Event on HTTP server POST complete for multipacket POST (Op)
N  \param  length        data length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_PostCompleteMultipacket(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_PostCompleteMultipacket(uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_PostCompleteMultipacket, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (36 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetHTTPs_PostCompleteMultipacket(length)
N#endif
N
N/**
N  \brief  Event on HTTP server POST type: www-form-urlencoded (Op)
N  \param  length        content-length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_PostFormUrlEncoded(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_PostFormUrlEncoded(uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_PostFormUrlEncoded, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (37 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetHTTPs_PostFormUrlEncoded(length)
N#endif
N
N/**
N  \brief  Event on HTTP server POST data truncated in buffer mode (Error)
N  \param  new_length    truncated data length
N  \remark Buffer mode is used for www-form-urlencoded POST type only.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_PostDataTruncated(uint32_t new_length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_PostDataTruncated(uint32_t new_length) {
N    EventRecord2 (EvtNetHTTPs_PostDataTruncated, new_length, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (38 & 0xFFU)), new_length, 0);
N  }
N#else
S  #define EvrNetHTTPs_PostDataTruncated(new_length)
N#endif
N
N/**
N  \brief  Event on HTTP server file upload requested (Op)
N  \param  fname         name of the requested file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileUploadRequested(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileUploadRequested(const char *fname, uint32_t length) {
N    if (length > 64) length = 64;
N    EventRecordData (EvtNetHTTPs_FileUploadRequested, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (39 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetHTTPs_FileUploadRequested(fname, length)
N#endif
N
N/**
N  \brief  Event on HTTP server data received in file upload process (Op)
N  \param  length        length of a file data chunk
N  \remark File data is received in multiple packets.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileUploadDataReceived(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileUploadDataReceived(uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_FileUploadDataReceived, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (40 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileUploadDataReceived(length)
N#endif
N
N/**
N  \brief  Event on HTTP server file upload remaining data size to complete (Op)
N  \param  length        length of the remaining data
N  \remark File data is received in multiple packets.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileUploadRemaining(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileUploadRemaining(uint32_t length) {
N    EventRecord2 (EvtNetHTTPs_FileUploadRemaining, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (41 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileUploadRemaining(length)
N#endif
N
N/**
N  \brief  Event on HTTP server file upload completed (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_FileUploadComplete(void) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_FileUploadComplete(void) {
N    EventRecord2 (EvtNetHTTPs_FileUploadComplete, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (42 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetHTTPs_FileUploadComplete()
N#endif
N
N/**
N  \brief  Event on HTTP server failed to allocate secure TLS context (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_TlsGetContextFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_TlsGetContextFailed(uint8_t session) {
N    EventRecord2 (EvtNetHTTPs_TlsGetContextFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (43 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetHTTPs_TlsGetContextFailed(session)
N#endif
N
N/**
N  \brief  Event on HTTP server de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetHTTPs_UninitServer(void) {
X  static __inline __attribute__((always_inline)) void EvrNetHTTPs_UninitServer(void) {
N    EventRecord2 (EvtNetHTTPs_UninitServer, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD3 & 0xFFU) << 8) | (44 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetHTTPs_UninitServer()
N#endif
N
N
N// NetFTPs event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetFTPs_InitServer               EventID (EventLevelOp,    EvtNetFTPs,  0)
N#define EvtNetFTPs_ShowRootFolder           EventID (EventLevelOp,    EvtNetFTPs,  1)
N#define EvtNetFTPs_GetSocketFailed          EventID (EventLevelError, EvtNetFTPs,  2)
N#define EvtNetFTPs_SetRootPath              EventID (EventLevelAPI,   EvtNetFTPs,  3)
N#define EvtNetFTPs_SetUsername              EventID (EventLevelAPI,   EvtNetFTPs,  4)
N#define EvtNetFTPs_SetPassword              EventID (EventLevelAPI,   EvtNetFTPs,  5)
N#define EvtNetFTPs_UserAccessDenied         EventID (EventLevelError, EvtNetFTPs,  6)
N// Gap
N#define EvtNetFTPs_SessionOpen              EventID (EventLevelOp,    EvtNetFTPs,  8)
N#define EvtNetFTPs_SocketAborted            EventID (EventLevelOp,    EvtNetFTPs,  9)
N#define EvtNetFTPs_SocketClosed             EventID (EventLevelOp,    EvtNetFTPs, 10)
N#define EvtNetFTPs_UnackedDataError         EventID (EventLevelError, EvtNetFTPs, 11)
N#define EvtNetFTPs_ReceiveFrame             EventID (EventLevelOp,    EvtNetFTPs, 12)
N#define EvtNetFTPs_FrameTooShort            EventID (EventLevelError, EvtNetFTPs, 13)
N#define EvtNetFTPs_ShowCommand              EventID (EventLevelOp,    EvtNetFTPs, 14)
N#define EvtNetFTPs_VerifyUsername           EventID (EventLevelOp,    EvtNetFTPs, 15)
N#define EvtNetFTPs_VerifyPassword           EventID (EventLevelOp,    EvtNetFTPs, 16)
N#define EvtNetFTPs_AuthenticationFailed     EventID (EventLevelError, EvtNetFTPs, 17)
N#define EvtNetFTPs_UserLoginSuccess         EventID (EventLevelOp,    EvtNetFTPs, 18)
N#define EvtNetFTPs_NotAuthenticated         EventID (EventLevelOp,    EvtNetFTPs, 19)
N#define EvtNetFTPs_ShowSystemType           EventID (EventLevelOp,    EvtNetFTPs, 20)
N#define EvtNetFTPs_NoOperation              EventID (EventLevelOp,    EvtNetFTPs, 21)
N#define EvtNetFTPs_CurrentDirectory         EventID (EventLevelOp,    EvtNetFTPs, 22)
N#define EvtNetFTPs_ChangeDirectory          EventID (EventLevelOp,    EvtNetFTPs, 23)
N#define EvtNetFTPs_ChangeDirectoryLevelUp   EventID (EventLevelOp,    EvtNetFTPs, 24)
N#define EvtNetFTPs_MakeDirectory            EventID (EventLevelOp,    EvtNetFTPs, 25)
N#define EvtNetFTPs_OperationDenied          EventID (EventLevelOp,    EvtNetFTPs, 26)
N#define EvtNetFTPs_RemoveDirectory          EventID (EventLevelOp,    EvtNetFTPs, 27)
N#define EvtNetFTPs_RemoveDirectoryFailed    EventID (EventLevelError, EvtNetFTPs, 28)
N#define EvtNetFTPs_DirectoryRemoved         EventID (EventLevelOp,    EvtNetFTPs, 29)
N#define EvtNetFTPs_ShowDataMode             EventID (EventLevelOp,    EvtNetFTPs, 30)
N#define EvtNetFTPs_ActiveModeStart          EventID (EventLevelOp,    EvtNetFTPs, 31)
N#define EvtNetFTPs_PassiveModeStart         EventID (EventLevelOp,    EvtNetFTPs, 32)
N#define EvtNetFTPs_GetFileSize              EventID (EventLevelOp,    EvtNetFTPs, 33)
N#define EvtNetFTPs_GetFileLastModifiedTime  EventID (EventLevelOp,    EvtNetFTPs, 34)
N#define EvtNetFTPs_ListDirectoryBasic       EventID (EventLevelOp,    EvtNetFTPs, 35)
N#define EvtNetFTPs_ListDirectoryExtended    EventID (EventLevelOp,    EvtNetFTPs, 36)
N#define EvtNetFTPs_ReadFile                 EventID (EventLevelOp,    EvtNetFTPs, 37)
N#define EvtNetFTPs_FileNotFound             EventID (EventLevelError, EvtNetFTPs, 38)
N#define EvtNetFTPs_WriteFile                EventID (EventLevelOp,    EvtNetFTPs, 39)
N#define EvtNetFTPs_AppendFile               EventID (EventLevelOp,    EvtNetFTPs, 40)
N#define EvtNetFTPs_FileCreateFailed         EventID (EventLevelError, EvtNetFTPs, 41)
N#define EvtNetFTPs_DeleteFile               EventID (EventLevelOp,    EvtNetFTPs, 42)
N#define EvtNetFTPs_FileDeleteFailed         EventID (EventLevelError, EvtNetFTPs, 43)
N#define EvtNetFTPs_FileDeleted              EventID (EventLevelOp,    EvtNetFTPs, 44)
N#define EvtNetFTPs_RenameFileFrom           EventID (EventLevelOp,    EvtNetFTPs, 45)
N#define EvtNetFTPs_RenameFileTo             EventID (EventLevelOp,    EvtNetFTPs, 46)
N#define EvtNetFTPs_FileRenamed              EventID (EventLevelOp,    EvtNetFTPs, 47)
N#define EvtNetFTPs_FileRenameFailed         EventID (EventLevelError, EvtNetFTPs, 48)
N#define EvtNetFTPs_UnknownCommand           EventID (EventLevelError, EvtNetFTPs, 49)
N#define EvtNetFTPs_InvalidState             EventID (EventLevelError, EvtNetFTPs, 50)
N#define EvtNetFTPs_InboundConnRejected      EventID (EventLevelError, EvtNetFTPs, 51)
N#define EvtNetFTPs_DataSocketClosed         EventID (EventLevelOp,    EvtNetFTPs, 52)
N#define EvtNetFTPs_DataSocketOpen           EventID (EventLevelOp,    EvtNetFTPs, 53)
N#define EvtNetFTPs_LocalDiskWriteError      EventID (EventLevelError, EvtNetFTPs, 54)
N#define EvtNetFTPs_StartService             EventID (EventLevelOp,    EvtNetFTPs, 55)
N#define EvtNetFTPs_StopService              EventID (EventLevelOp,    EvtNetFTPs, 56)
N#define EvtNetFTPs_ShowFileFindMask         EventID (EventLevelOp,    EvtNetFTPs, 57)
N#define EvtNetFTPs_MakeDirectoryFailed      EventID (EventLevelError, EvtNetFTPs, 58)
N#define EvtNetFTPs_DirectoryCreated         EventID (EventLevelOp,    EvtNetFTPs, 59)
N#define EvtNetFTPs_ShowFileSize             EventID (EventLevelOp,    EvtNetFTPs, 60)
N#define EvtNetFTPs_ShowFileLastModifiedTime EventID (EventLevelOp,    EvtNetFTPs, 61)
N#define EvtNetFTPs_CloseDataConnection      EventID (EventLevelOp,    EvtNetFTPs, 62)
N#define EvtNetFTPs_CloseSession             EventID (EventLevelOp,    EvtNetFTPs, 63)
N#define EvtNetFTPs_SessionIdle              EventID (EventLevelOp,    EvtNetFTPs, 64)
N#define EvtNetFTPs_ShowPath                 EventID (EventLevelOp,    EvtNetFTPs, 65)
N#define EvtNetFTPs_UninitServer             EventID (EventLevelOp,    EvtNetFTPs, 66)
N#endif
N
N/**
N  \brief  Event on FTP server initialize (Op)
N  \param  num_sessions  number of available FTP sessions
N  \param  port          listening port number
N  \param  idle_tout     idle timeout in seconds (0= permanent connection)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_InitServer(uint32_t num_sessions, uint16_t port, uint16_t idle_tout) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_InitServer(uint32_t num_sessions, uint16_t port, uint16_t idle_tout) {
N    uint32_t val2 = (uint32_t)idle_tout << 16 | port;
N    EventRecord2 (EvtNetFTPs_InitServer, num_sessions, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (0 & 0xFFU)), num_sessions, val2);
N  }
N#else
S  #define EvrNetFTPs_InitServer(num_sessions, port, idle_tout)
N#endif
N
N/**
N  \brief  Event on FTP server display root folder (Op)
N  \param  root_folder   path to server root folder
N  \param  length        length of the root_folder string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ShowRootFolder, root_folder, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (1 & 0xFFU)), root_folder, length);
N  }
N#else
S  #define EvrNetFTPs_ShowRootFolder(root_folder, length)
N#endif
N
N/**
N  \brief  Event on FTP server failed to allocate TCP socket (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_GetSocketFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_GetSocketFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_GetSocketFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (2 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_GetSocketFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server \ref netFTPs_SetRootPath (API)
N  \param  path          path to server root folder
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SetRootPath(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SetRootPath(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_SetRootPath, path, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (3 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_SetRootPath(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server \ref netFTPs_SetUsername (API)
N  \param  username      new username
N  \param  length        length of the username string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SetUsername(const char *username, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SetUsername(const char *username, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetFTPs_SetUsername, username, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (4 & 0xFFU)), username, length);
N  }
N#else
S  #define EvrNetFTPs_SetUsername(username, length)
N#endif
N
N/**
N  \brief  Event on FTP server \ref netFTPs_SetPassword (API)
N  \param  password      new password
N  \param  length        length of the password string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SetPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SetPassword(const char *password, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetFTPs_SetPassword, password, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (5 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetFTPs_SetPassword(password, length)
N#endif
N
N/**
N  \brief  Event on FTP server user denied access (Error)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_UserAccessDenied(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_UserAccessDenied(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetFTPs_UserAccessDenied, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (6 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetFTPs_UserAccessDenied(net_addr)
N#endif
N
N/**
N  \brief  Event on FTP server session open (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SessionOpen(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SessionOpen(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_SessionOpen, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (8 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_SessionOpen(session)
N#endif
N
N/**
N  \brief  Event on FTP server socket aborted (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SocketAborted(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SocketAborted(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_SocketAborted, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (9 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_SocketAborted(session)
N#endif
N
N/**
N  \brief  Event on FTP server socket closed (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SocketClosed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SocketClosed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_SocketClosed, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (10 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_SocketClosed(session)
N#endif
N
N/**
N  \brief  Event on FTP server unacked data error (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_UnackedDataError(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_UnackedDataError(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_UnackedDataError, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (11 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_UnackedDataError(session)
N#endif
N
N/**
N  \brief  Event on FTP server receive frame (Op)
N  \param  session       session number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ReceiveFrame(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ReceiveFrame(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetFTPs_ReceiveFrame, session, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (12 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetFTPs_ReceiveFrame(session, length)
N#endif
N
N/**
N  \brief  Event on FTP server receive frame too short (Error)
N  \param  session       session number
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetFTPs_FrameTooShort, session, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (13 & 0xFFU)), session, val2);
N  }
N#else
S  #define EvrNetFTPs_FrameTooShort(session, length, min_length)
N#endif
N
N/**
N  \brief  Event on FTP server display command string (Op)
N  \param  cmd_client    command received from the client in text format
N  \param  length        length of the cmd_client string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowCommand(const uint8_t *cmd_client, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowCommand(const uint8_t *cmd_client, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ShowCommand, cmd_client, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (14 & 0xFFU)), cmd_client, length);
N  }
N#else
S  #define EvrNetFTPs_ShowCommand(cmd_client, length)
N#endif
N
N/**
N  \brief  Event on FTP server verify the client username (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_VerifyUsername(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_VerifyUsername(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_VerifyUsername, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (15 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_VerifyUsername(session)
N#endif
N
N/**
N  \brief  Event on FTP server verify the client password (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_VerifyPassword(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_VerifyPassword(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_VerifyPassword, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (16 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_VerifyPassword(session)
N#endif
N
N/**
N  \brief  Event on FTP server authentication failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_AuthenticationFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_AuthenticationFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_AuthenticationFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (17 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_AuthenticationFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server user login successful (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_UserLoginSuccess(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_UserLoginSuccess(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_UserLoginSuccess, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (18 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_UserLoginSuccess(session)
N#endif
N
N/**
N  \brief  Event on FTP server command ignored, user not authenticated (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_NotAuthenticated(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_NotAuthenticated(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_NotAuthenticated, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (19 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_NotAuthenticated(session)
N#endif
N
N/**
N  \brief  Event on FTP server show system identification type command (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowSystemType(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowSystemType(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_ShowSystemType, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (20 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_ShowSystemType(session)
N#endif
N
N/**
N  \brief  Event on FTP server execute no operation command (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_NoOperation(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_NoOperation(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_NoOperation, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (21 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_NoOperation(session)
N#endif
N
N/**
N  \brief  Event on FTP server display current working directory (Op)
N  \param  path          path to the working directory
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_CurrentDirectory(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_CurrentDirectory(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_CurrentDirectory, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (22 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_CurrentDirectory(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server change working directory command (Op)
N  \param  path          path to the new working directory
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ChangeDirectory(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ChangeDirectory(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ChangeDirectory, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (23 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_ChangeDirectory(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server change working directory one level up command (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ChangeDirectoryLevelUp(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ChangeDirectoryLevelUp(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_ChangeDirectoryLevelUp, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (24 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_ChangeDirectoryLevelUp(session)
N#endif
N
N/**
N  \brief  Event on FTP server make directory command (Op)
N  \param  path          path to the new directory to make
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_MakeDirectory(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_MakeDirectory(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_MakeDirectory, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (25 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_MakeDirectory(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server access or operation denied (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_OperationDenied(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_OperationDenied(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_OperationDenied, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (26 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_OperationDenied(session)
N#endif
N
N/**
N  \brief  Event on FTP server remove directory command (Op)
N  \param  path          path to the directory to remove
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_RemoveDirectory(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_RemoveDirectory(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_RemoveDirectory, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (27 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_RemoveDirectory(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server remove directory command failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_RemoveDirectoryFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_RemoveDirectoryFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_RemoveDirectoryFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (28 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_RemoveDirectoryFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server requested directory successfuly removed (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_DirectoryRemoved(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_DirectoryRemoved(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_DirectoryRemoved, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (29 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_DirectoryRemoved(session)
N#endif
N
N/**
N  \brief  Event on FTP server display transfer data mode (Op)
N  \param  session       session number
N  \param  data_mode     transfer data mode
N                         - 0: Binary mode
N                         - 1: ASCII mode
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowDataMode(uint8_t session, uint32_t data_mode) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowDataMode(uint8_t session, uint32_t data_mode) {
N    EventRecord2 (EvtNetFTPs_ShowDataMode, session, data_mode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (30 & 0xFFU)), session, data_mode);
N  }
N#else
S  #define EvrNetFTPs_ShowDataMode(session, data_mode)
N#endif
N
N/**
N  \brief  Event on FTP server start active mode (Op)
N  \param  session       session number
N  \param  port          port number to connect to
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ActiveModeStart(uint8_t session, uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ActiveModeStart(uint8_t session, uint16_t port) {
N    EventRecord2 (EvtNetFTPs_ActiveModeStart, session, port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (31 & 0xFFU)), session, port);
N  }
N#else
S  #define EvrNetFTPs_ActiveModeStart(session, port)
N#endif
N
N/**
N  \brief  Event on FTP server start passive mode (Op)
N  \param  session       session number
N  \param  local_port    local port number to accept data connection
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_PassiveModeStart(uint8_t session, uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_PassiveModeStart(uint8_t session, uint16_t local_port) {
N    EventRecord2 (EvtNetFTPs_PassiveModeStart, session, local_port);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (32 & 0xFFU)), session, local_port);
N  }
N#else
S  #define EvrNetFTPs_PassiveModeStart(session, local_port)
N#endif
N
N/**
N  \brief  Event on FTP server get file size command (Op)
N  \param  fname         name of the file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_GetFileSize(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_GetFileSize(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_GetFileSize, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (33 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_GetFileSize(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server get file last-modified time command (Op)
N  \param  fname         name of the file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_GetFileLastModifiedTime(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_GetFileLastModifiedTime(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_GetFileLastModifiedTime, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (34 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_GetFileLastModifiedTime(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server list directory names command (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ListDirectoryBasic(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ListDirectoryBasic(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_ListDirectoryBasic, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (35 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_ListDirectoryBasic(session)
N#endif
N
N/**
N  \brief  Event on FTP server list directory in extended format (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ListDirectoryExtended(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ListDirectoryExtended(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_ListDirectoryExtended, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (36 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_ListDirectoryExtended(session)
N#endif
N
N/**
N  \brief  Event on FTP server read file command (Op)
N  \param  fname         name of the file to read
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ReadFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ReadFile(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ReadFile, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (37 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_ReadFile(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server requested file not found (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileNotFound(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileNotFound(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileNotFound, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (38 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileNotFound(session)
N#endif
N
N/**
N  \brief  Event on FTP server write file command (Op)
N  \param  fname         name of the file to write
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_WriteFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_WriteFile(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_WriteFile, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (39 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_WriteFile(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server append file command (Op)
N  \param  fname         name of the file to append
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_AppendFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_AppendFile(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_AppendFile, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (40 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_AppendFile(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server requested file create failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileCreateFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileCreateFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileCreateFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (41 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileCreateFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server delete file command (Op)
N  \param  fname         name of the file to delete
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_DeleteFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_DeleteFile(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_DeleteFile, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (42 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_DeleteFile(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server requested file delete failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileDeleteFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileDeleteFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileDeleteFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (43 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileDeleteFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server requested file deleted successfuly (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileDeleted(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileDeleted(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileDeleted, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (44 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileDeleted(session)
N#endif
N
N/**
N  \brief  Event on FTP server rename file from name command (Op)
N  \param  fname         name of the file to rename
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_RenameFileFrom(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_RenameFileFrom(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_RenameFileFrom, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (45 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetFTPs_RenameFileFrom(fname, length)
N#endif
N
N/**
N  \brief  Event on FTP server rename file to new name (Op)
N  \param  new_name      new name of the file to rename to
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_RenameFileTo(const char *new_name, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_RenameFileTo(const char *new_name, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_RenameFileTo, new_name, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (46 & 0xFFU)), new_name, length);
N  }
N#else
S  #define EvrNetFTPs_RenameFileTo(new_name, length)
N#endif
N
N/**
N  \brief  Event on FTP server requested file renamed successfuly (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileRenamed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileRenamed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileRenamed, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (47 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileRenamed(session)
N#endif
N
N/**
N  \brief  Event on FTP server requested file rename failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_FileRenameFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_FileRenameFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_FileRenameFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (48 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_FileRenameFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server unknown command received (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_UnknownCommand(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_UnknownCommand(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_UnknownCommand, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (49 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_UnknownCommand(session)
N#endif
N
N/**
N  \brief  Event on FTP server session in invalid state, command ignored (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_InvalidState(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_InvalidState(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_InvalidState, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (50 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_InvalidState(session)
N#endif
N
N/**
N  \brief  Event on FTP server inbound connection rejected for data socket (Error)
N  \param  session       session number
N  \remark Inbound data connections are accepted in passive mode, rejected in active mode.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_InboundConnRejected(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_InboundConnRejected(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_InboundConnRejected, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (51 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_InboundConnRejected(session)
N#endif
N
N/**
N  \brief  Event on FTP server data socket closed when transfer completed (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_DataSocketClosed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_DataSocketClosed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_DataSocketClosed, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (52 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_DataSocketClosed(session)
N#endif
N
N/**
N  \brief  Event on FTP server data socket open for data transfer (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_DataSocketOpen(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_DataSocketOpen(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_DataSocketOpen, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (53 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_DataSocketOpen(session)
N#endif
N
N/**
N  \brief  Event on FTP server write to local disk failed, disk full (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_LocalDiskWriteError(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_LocalDiskWriteError(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_LocalDiskWriteError, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (54 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_LocalDiskWriteError(session)
N#endif
N
N/**
N  \brief  Event on FTP server start service (Op)
N  \param  port          listening port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_StartService(uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_StartService(uint16_t port) {
N    EventRecord2 (EvtNetFTPs_StartService, port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (55 & 0xFFU)), port, 0);
N  }
N#else
S  #define EvrNetFTPs_StartService(port)
N#endif
N
N/**
N  \brief  Event on FTP server stop service (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_StopService(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_StopService(void) {
N    EventRecord2 (EvtNetFTPs_StopService, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (56 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPs_StopService()
N#endif
N
N/**
N  \brief  Event on FTP server display find file(s) mask filter (Op)
N  \param  path          path to list directory
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowFileFindMask(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowFileFindMask(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ShowFileFindMask, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (57 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_ShowFileFindMask(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server requested directory create failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_MakeDirectoryFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_MakeDirectoryFailed(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_MakeDirectoryFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (58 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_MakeDirectoryFailed(session)
N#endif
N
N/**
N  \brief  Event on FTP server requested directory created successfuly (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_DirectoryCreated(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_DirectoryCreated(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_DirectoryCreated, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (59 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_DirectoryCreated(session)
N#endif
N
N/**
N  \brief  Event on FTP server display requested file size (Op)
N  \param  session       session number
N  \param  file_size     size of a file in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowFileSize(uint8_t session, uint32_t file_size) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowFileSize(uint8_t session, uint32_t file_size) {
N    EventRecord2 (EvtNetFTPs_ShowFileSize, session, file_size);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (60 & 0xFFU)), session, file_size);
N  }
N#else
S  #define EvrNetFTPs_ShowFileSize(session, file_size)
N#endif
N
N/**
N  \brief  Event on FTP server display requested file last-modified time (Op)
N  \param  session       session number
N  \param  file_time     last-modified time of a file in text format
N  \param  length        length of the file_time string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowFileLastModifiedTime(uint8_t session,
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowFileLastModifiedTime(uint8_t session,
N                                            const char *file_time, uint32_t length) {
N    evr_buf.u32[0] = session;
X    (*(union evr_access *)&net_dbg_buf).u32[0] = session;
N    memcpy (&evr_buf.u32[1], file_time, length);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[1], file_time, length);
N    EventRecordData (EvtNetFTPs_ShowFileLastModifiedTime, &evr_buf, length+4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (61 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), length+4);
N  }
N#else
S  #define EvrNetFTPs_ShowFileLastModifiedTime(session, file_time, length)
N#endif
N
N/**
N  \brief  Event on FTP server closing data connection (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_CloseDataConnection(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_CloseDataConnection(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_CloseDataConnection, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (62 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_CloseDataConnection(session)
N#endif
N
N/**
N  \brief  Event on FTP server closing session (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_CloseSession(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_CloseSession(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_CloseSession, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (63 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_CloseSession(session)
N#endif
N
N/**
N  \brief  Event on FTP server session in idle state (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_SessionIdle(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_SessionIdle(uint8_t session) {
N    EventRecord2 (EvtNetFTPs_SessionIdle, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (64 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetFTPs_SessionIdle(session)
N#endif
N
N/**
N  \brief  Event on FTP server display an absolute path for file access (Op)
N  \param  path          absolute path for file access
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_ShowPath(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_ShowPath(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetFTPs_ShowPath, path, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (65 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetFTPs_ShowPath(path, length)
N#endif
N
N/**
N  \brief  Event on FTP server de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPs_UninitServer(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPs_UninitServer(void) {
N    EventRecord2 (EvtNetFTPs_UninitServer, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD4 & 0xFFU) << 8) | (66 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPs_UninitServer()
N#endif
N
N
N// NetFTPc event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetFTPc_InitClient               EventID (EventLevelOp,    EvtNetFTPc,  0)
N#define EvtNetFTPc_GetSocketFailed          EventID (EventLevelError, EvtNetFTPc,  1)
N#define EvtNetFTPc_Connect                  EventID (EventLevelAPI,   EvtNetFTPc,  2)
N// Gap
N#define EvtNetFTPc_ConnectInvalidParameter  EventID (EventLevelError, EvtNetFTPc,  4)
N#define EvtNetFTPc_ConnectClientBusy        EventID (EventLevelError, EvtNetFTPc,  5)
N#define EvtNetFTPc_InboundConnRejected      EventID (EventLevelOp,    EvtNetFTPc,  6)
N#define EvtNetFTPc_SocketAborted            EventID (EventLevelError, EvtNetFTPc,  7)
N#define EvtNetFTPc_SocketConnected          EventID (EventLevelOp,    EvtNetFTPc,  8)
N#define EvtNetFTPc_SocketClosed             EventID (EventLevelOp,    EvtNetFTPc,  9)
N#define EvtNetFTPc_ReceiveFrame             EventID (EventLevelOp,    EvtNetFTPc, 10)
N#define EvtNetFTPc_FrameTooShort            EventID (EventLevelError, EvtNetFTPc, 11)
N#define EvtNetFTPc_ShowReplyCode            EventID (EventLevelOp,    EvtNetFTPc, 12)
N#define EvtNetFTPc_ResponseFragmented       EventID (EventLevelOp,    EvtNetFTPc, 13)
N#define EvtNetFTPc_ServerReady              EventID (EventLevelOp,    EvtNetFTPc, 14)
N#define EvtNetFTPc_UserOkNeedPassword       EventID (EventLevelOp,    EvtNetFTPc, 15)
N#define EvtNetFTPc_UserLoginFailed          EventID (EventLevelError, EvtNetFTPc, 16)
N#define EvtNetFTPc_UserLoginSuccess         EventID (EventLevelOp,    EvtNetFTPc, 17)
N#define EvtNetFTPc_WorkingDirectoryInvalid  EventID (EventLevelError, EvtNetFTPc, 18)
N#define EvtNetFTPc_ExecuteUserCommand       EventID (EventLevelOp,    EvtNetFTPc, 19)
N#define EvtNetFTPc_BinaryModeEnabled        EventID (EventLevelOp,    EvtNetFTPc, 20)
N#define EvtNetFTPc_PasvCommandFailed        EventID (EventLevelError, EvtNetFTPc, 21)
N#define EvtNetFTPc_PassiveModeStart         EventID (EventLevelOp,    EvtNetFTPc, 22)
N#define EvtNetFTPc_PortCommandFailed        EventID (EventLevelError, EvtNetFTPc, 23)
N#define EvtNetFTPc_ActiveModeStart          EventID (EventLevelOp,    EvtNetFTPc, 24)
N#define EvtNetFTPc_FileNotFoundOnServer     EventID (EventLevelError, EvtNetFTPc, 25)
N#define EvtNetFTPc_OperationNotAllowed      EventID (EventLevelError, EvtNetFTPc, 26)
N#define EvtNetFTPc_AboutToOpenDataConn      EventID (EventLevelOp,    EvtNetFTPc, 27)
N#define EvtNetFTPc_DataConnAlreadyOpen      EventID (EventLevelOp,    EvtNetFTPc, 28)
N#define EvtNetFTPc_TransferAborted          EventID (EventLevelOp,    EvtNetFTPc, 29)
N#define EvtNetFTPc_TransferCompleted        EventID (EventLevelOp,    EvtNetFTPc, 30)
N#define EvtNetFTPc_FileDeleted              EventID (EventLevelOp,    EvtNetFTPc, 31)
N#define EvtNetFTPc_NewNameRequired          EventID (EventLevelOp,    EvtNetFTPc, 32)
N#define EvtNetFTPc_FileOrDirectoryRenamed   EventID (EventLevelOp,    EvtNetFTPc, 33)
N#define EvtNetFTPc_DirectoryCreated         EventID (EventLevelOp,    EvtNetFTPc, 34)
N#define EvtNetFTPc_FileOrPathNotFound       EventID (EventLevelOp,    EvtNetFTPc, 35)
N#define EvtNetFTPc_DirectoryRemoved         EventID (EventLevelOp,    EvtNetFTPc, 36)
N#define EvtNetFTPc_CommandErrorResponse     EventID (EventLevelError, EvtNetFTPc, 37)
N#define EvtNetFTPc_WrongResponse            EventID (EventLevelError, EvtNetFTPc, 38)
N#define EvtNetFTPc_DataSocketClosed         EventID (EventLevelOp,    EvtNetFTPc, 39)
N#define EvtNetFTPc_DataSocketOpened         EventID (EventLevelOp,    EvtNetFTPc, 40)
N#define EvtNetFTPc_LocalDiskWriteError      EventID (EventLevelError, EvtNetFTPc, 41)
N#define EvtNetFTPc_ClientStopTimeoutExpired EventID (EventLevelError, EvtNetFTPc, 42)
N#define EvtNetFTPc_LocalPortAssigned        EventID (EventLevelOp,    EvtNetFTPc, 43)
N#define EvtNetFTPc_OpenLocalFile            EventID (EventLevelOp,    EvtNetFTPc, 44)
N#define EvtNetFTPc_LocalFileCreateFailed    EventID (EventLevelError, EvtNetFTPc, 45)
N#define EvtNetFTPc_LocalFileNotFound        EventID (EventLevelError, EvtNetFTPc, 46)
N#define EvtNetFTPc_OpenDataConnFailed       EventID (EventLevelError, EvtNetFTPc, 47)
N#define EvtNetFTPc_SendCommand              EventID (EventLevelDetail,EvtNetFTPc, 48)
N#define EvtNetFTPc_ClientCloseSocket        EventID (EventLevelOp,    EvtNetFTPc, 49)
N#define EvtNetFTPc_ClientDone               EventID (EventLevelOp,    EvtNetFTPc, 50)
N#define EvtNetFTPc_CloseLocalFile           EventID (EventLevelOp,    EvtNetFTPc, 51)
N#define EvtNetFTPc_UninitClient             EventID (EventLevelOp,    EvtNetFTPc, 52)
N#endif
N
N/**
N  \brief  Event on FTP client initialize (Op)
N  \param  mode           client mode of operation
N                          - 0: active mode (accepts inbound data connections)
N                          - 1: passive mode (starts outbound data connections)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_InitClient(uint32_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_InitClient(uint32_t mode) {
N    EventRecord2 (EvtNetFTPc_InitClient, mode, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (0 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetFTPc_InitClient(mode)
N#endif
N
N/**
N  \brief  Event on FTP client failed to allocate TCP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_GetSocketFailed(void) {
N    EventRecord2 (EvtNetFTPc_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on FTP client \ref netFTPc_Connect to the server (API)
N  \param  net_addr      pointer to \ref NET_ADDR server address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_Connect(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_Connect(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetFTPc_Connect, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (2 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetFTPc_Connect(net_addr)
N#endif
N
N/**
N  \brief  Event on \ref netFTPc_Connect invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ConnectInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ConnectInvalidParameter(void) {
N    EventRecord2 (EvtNetFTPc_ConnectInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_ConnectInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netFTPc_Connect failed, client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ConnectClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ConnectClientBusy(void) {
N    EventRecord2 (EvtNetFTPc_ConnectClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (5 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_ConnectClientBusy()
N#endif
N
N/**
N  \brief  Event on FTP client inbound connection rejected (Error)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_InboundConnRejected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_InboundConnRejected(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_InboundConnRejected, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (6 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_InboundConnRejected(socket)
N#endif
N
N/**
N  \brief  Event on FTP client socket aborted (Error)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_SocketAborted(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_SocketAborted(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_SocketAborted, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (7 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_SocketAborted(socket)
N#endif
N
N/**
N  \brief  Event on FTP client socket connected (Op)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_SocketConnected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_SocketConnected(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_SocketConnected, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (8 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_SocketConnected(socket)
N#endif
N
N/**
N  \brief  Event on FTP client socket closed (Op)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_SocketClosed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_SocketClosed(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_SocketClosed, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (9 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_SocketClosed(socket)
N#endif
N
N/**
N  \brief  Event on FTP client received frame (Op)
N  \param  socket        assigned TCP socket
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ReceiveFrame(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ReceiveFrame(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetFTPc_ReceiveFrame, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (10 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetFTPc_ReceiveFrame(socket, length)
N#endif
N
N/**
N  \brief  Event on FTP receive frame is too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetFTPc_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (11 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetFTPc_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on FTP client display numeric reply code received from server (Op)
N  \param  reply_code    numeric reply code in text format (3 characters)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ShowReplyCode(const uint8_t *reply_code) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ShowReplyCode(const uint8_t *reply_code) {
N    EventRecordData (EvtNetFTPc_ShowReplyCode, reply_code, 3);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (12 & 0xFFU)), reply_code, 3);
N  }
N#else
S  #define EvrNetFTPc_ShowReplyCode(reply_code)
N#endif
N
N/**
N  \brief  Event on FTP client response divided into multiple frames (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ResponseFragmented(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ResponseFragmented(void) {
N    EventRecord2 (EvtNetFTPc_ResponseFragmented, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_ResponseFragmented()
N#endif
N
N/**
N  \brief  Event on FTP client server ready response (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ServerReady(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ServerReady(void) {
N    EventRecord2 (EvtNetFTPc_ServerReady, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (14 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_ServerReady()
N#endif
N
N/**
N  \brief  Event on FTP client username ok, password needed (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_UserOkNeedPassword(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_UserOkNeedPassword(void) {
N    EventRecord2 (EvtNetFTPc_UserOkNeedPassword, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (15 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_UserOkNeedPassword()
N#endif
N
N/**
N  \brief  Event on FTP client user login to server failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_UserLoginFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_UserLoginFailed(void) {
N    EventRecord2 (EvtNetFTPc_UserLoginFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_UserLoginFailed()
N#endif
N
N/**
N  \brief  Event on FTP client user login successful (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_UserLoginSuccess(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_UserLoginSuccess(void) {
N    EventRecord2 (EvtNetFTPc_UserLoginSuccess, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (17 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_UserLoginSuccess()
N#endif
N
N/**
N  \brief  Event on FTP client change working directory failed, invalid path (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_WorkingDirectoryInvalid(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_WorkingDirectoryInvalid(void) {
N    EventRecord2 (EvtNetFTPc_WorkingDirectoryInvalid, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_WorkingDirectoryInvalid()
N#endif
N
N/**
N  \brief  Event on FTP client server ready response (Op)
N  \param  command       user command to execute
N                         - 0: Puts a file on FTP server
N                         - 1: Retrieves a file from FTP server
N                         - 2: Append file on FTP server (with create)
N                         - 3: Deletes a file on FTP server
N                         - 4: Lists files stored on FTP server
N                         - 5: Renames a file on FTP server
N                         - 6: Makes a directory on FTP server
N                         - 7: Removes an empty directory on FTP serve
N                         - 8: Lists file names only (short format)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ExecuteUserCommand(uint8_t command) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ExecuteUserCommand(uint8_t command) {
N    EventRecord2 (EvtNetFTPc_ExecuteUserCommand, command, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (19 & 0xFFU)), command, 0);
N  }
N#else
S  #define EvrNetFTPc_ExecuteUserCommand(command)
N#endif
N
N/**
N  \brief  Event on FTP client binary transfer mode enabled (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_BinaryModeEnabled(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_BinaryModeEnabled(void) {
N    EventRecord2 (EvtNetFTPc_BinaryModeEnabled, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (20 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_BinaryModeEnabled()
N#endif
N
N/**
N  \brief  Event on FTP client PASV command failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_PasvCommandFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_PasvCommandFailed(void) {
N    EventRecord2 (EvtNetFTPc_PasvCommandFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (21 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_PasvCommandFailed()
N#endif
N
N/**
N  \brief  Event on FTP client start passive server mode (Op)
N  \param  port          server port number to connect to
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_PassiveModeStart(uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_PassiveModeStart(uint16_t port) {
N    EventRecord2 (EvtNetFTPc_PassiveModeStart, port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (22 & 0xFFU)), port, 0);
N  }
N#else
S  #define EvrNetFTPc_PassiveModeStart(port)
N#endif
N
N/**
N  \brief  Event on FTP client PORT command failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_PortCommandFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_PortCommandFailed(void) {
N    EventRecord2 (EvtNetFTPc_PortCommandFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (23 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_PortCommandFailed()
N#endif
N
N/**
N  \brief  Event on FTP client start active server mode (Op)
N  \param  local_port    local port number to accept connection
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ActiveModeStart(uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ActiveModeStart(uint16_t local_port) {
N    EventRecord2 (EvtNetFTPc_ActiveModeStart, local_port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (24 & 0xFFU)), local_port, 0);
N  }
N#else
S  #define EvrNetFTPc_ActiveModeStart(local_port)
N#endif
N
N/**
N  \brief  Event on FTP client error, requested file not found on server (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_FileNotFoundOnServer(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_FileNotFoundOnServer(void) {
N    EventRecord2 (EvtNetFTPc_FileNotFoundOnServer, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (25 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_FileNotFoundOnServer()
N#endif
N
N/**
N  \brief  Event on FTP client error, operation not allowed on server (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_OperationNotAllowed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_OperationNotAllowed(void) {
N    EventRecord2 (EvtNetFTPc_OperationNotAllowed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (26 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_OperationNotAllowed()
N#endif
N
N/**
N  \brief  Event on FTP client about to open data connection (Op)
N  \param  socket        assigned TCP data socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_AboutToOpenDataConn(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_AboutToOpenDataConn(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_AboutToOpenDataConn, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (27 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_AboutToOpenDataConn(socket)
N#endif
N
N/**
N  \brief  Event on FTP client data connection already opened (Op)
N  \param  socket        assigned TCP data socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_DataConnAlreadyOpen(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_DataConnAlreadyOpen(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_DataConnAlreadyOpen, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (28 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_DataConnAlreadyOpen(socket)
N#endif
N
N/**
N  \brief  Event on FTP client data transfer aborted (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_TransferAborted(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_TransferAborted(void) {
N    EventRecord2 (EvtNetFTPc_TransferAborted, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (29 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_TransferAborted()
N#endif
N
N/**
N  \brief  Event on FTP client data transfer completed successfully (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_TransferCompleted(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_TransferCompleted(void) {
N    EventRecord2 (EvtNetFTPc_TransferCompleted, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (30 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_TransferCompleted()
N#endif
N
N/**
N  \brief  Event on FTP client file deleted on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_FileDeleted(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_FileDeleted(void) {
N    EventRecord2 (EvtNetFTPc_FileDeleted, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (31 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_FileDeleted()
N#endif
N
N/**
N  \brief  Event on FTP client new name required to rename a file on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_NewNameRequired(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_NewNameRequired(void) {
N    EventRecord2 (EvtNetFTPc_NewNameRequired, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (32 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_NewNameRequired()
N#endif
N
N/**
N  \brief  Event on FTP client file or directory renamed successfully on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_FileOrDirectoryRenamed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_FileOrDirectoryRenamed(void) {
N    EventRecord2 (EvtNetFTPc_FileOrDirectoryRenamed, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (33 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_FileOrDirectoryRenamed()
N#endif
N
N/**
N  \brief  Event on FTP client directory successfully created on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_DirectoryCreated(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_DirectoryCreated(void) {
N    EventRecord2 (EvtNetFTPc_DirectoryCreated, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (34 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_DirectoryCreated()
N#endif
N
N/**
N  \brief  Event on FTP client requested file or path not found on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_FileOrPathNotFound(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_FileOrPathNotFound(void) {
N    EventRecord2 (EvtNetFTPc_FileOrPathNotFound, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (35 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_FileOrPathNotFound()
N#endif
N
N/**
N  \brief  Event on FTP client directory removed on the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_DirectoryRemoved(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_DirectoryRemoved(void) {
N    EventRecord2 (EvtNetFTPc_DirectoryRemoved, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (36 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_DirectoryRemoved()
N#endif
N
N/**
N  \brief  Event on FTP client command error response received (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_CommandErrorResponse(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_CommandErrorResponse(void) {
N    EventRecord2 (EvtNetFTPc_CommandErrorResponse, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (37 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_CommandErrorResponse()
N#endif
N
N/**
N  \brief  Event on FTP client wrong response received (Error)
N  \param  response      response from the server in text format
N  \param  length        length of the response string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_WrongResponse(const uint8_t *response, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_WrongResponse(const uint8_t *response, uint32_t length) {
N    if (length > 40) length = 40;
N    EventRecordData (EvtNetFTPc_WrongResponse, response, length);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (38 & 0xFFU)), response, length);
N  }
N#else
S  #define EvrNetFTPc_WrongResponse(response, length)
N#endif
N
N/**
N  \brief  Event on FTP client data socket closed (Op)
N  \param  socket        assigned TCP data socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_DataSocketClosed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_DataSocketClosed(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_DataSocketClosed, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (39 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_DataSocketClosed(socket)
N#endif
N
N/**
N  \brief  Event on FTP client data socket opened (Op)
N  \param  socket        assigned TCP data socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_DataSocketOpened(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_DataSocketOpened(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_DataSocketOpened, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (40 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_DataSocketOpened(socket)
N#endif
N
N/**
N  \brief  Event on FTP client write to local disk failed, disk full (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_LocalDiskWriteError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_LocalDiskWriteError(void) {
N    EventRecord2 (EvtNetFTPc_LocalDiskWriteError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (41 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_LocalDiskWriteError()
N#endif
N
N/**
N  \brief  Event on FTP client stop operation timeout expired (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ClientStopTimeoutExpired(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ClientStopTimeoutExpired(void) {
N    EventRecord2 (EvtNetFTPc_ClientStopTimeoutExpired, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (42 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_ClientStopTimeoutExpired()
N#endif
N
N/**
N  \brief  Event on FTP client local port assigned for server active mode (Op)
N  \param  local_port    local port number to accept connection
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_LocalPortAssigned(uint16_t local_port) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_LocalPortAssigned(uint16_t local_port) {
N    EventRecord2 (EvtNetFTPc_LocalPortAssigned, local_port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (43 & 0xFFU)), local_port, 0);
N  }
N#else
S  #define EvrNetFTPc_LocalPortAssigned(local_port)
N#endif
N
N/**
N  \brief  Event on FTP client open local file (Op)
N  \param  local_fname   name of the local file
N  \param  length        length of the local_fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_OpenLocalFile(const char *local_fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_OpenLocalFile(const char *local_fname, uint32_t length) {
N    if (length > 120) length = 120;
N    EventRecordData (EvtNetFTPc_OpenLocalFile, local_fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (44 & 0xFFU)), local_fname, length);
N  }
N#else
S  #define EvrNetFTPc_OpenLocalFile(local_fname, length)
N#endif
N
N/**
N  \brief  Event on FTP client local file create failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_LocalFileCreateFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_LocalFileCreateFailed(void) {
N    EventRecord2 (EvtNetFTPc_LocalFileCreateFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (45 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_LocalFileCreateFailed()
N#endif
N
N/**
N  \brief  Event on FTP client local file not found (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_LocalFileNotFound(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_LocalFileNotFound(void) {
N    EventRecord2 (EvtNetFTPc_LocalFileNotFound, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (46 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_LocalFileNotFound()
N#endif
N
N/**
N  \brief  Event on FTP client open data connection failed (Error)
N  \param  socket        assigned TCP data socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_OpenDataConnFailed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_OpenDataConnFailed(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_OpenDataConnFailed, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (47 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_OpenDataConnFailed(socket)
N#endif
N
N/**
N  \brief  Event on FTP client send command to server (Detail)
N  \param  command       server command in text form
N  \param  length        length of the command string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_SendCommand(const uint8_t *command, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_SendCommand(const uint8_t *command, uint32_t length) {
N    if (length > 64) length = 64;
N    EventRecordData (EvtNetFTPc_SendCommand, command, length);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (48 & 0xFFU)), command, length);
N  }
N#else
S  #define EvrNetFTPc_SendCommand(command, length)
N#endif
N
N/**
N  \brief  Event on FTP client close control socket (Op)
N  \param  socket        assigned TCP control socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ClientCloseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ClientCloseSocket(int32_t socket) {
N    EventRecord2 (EvtNetFTPc_ClientCloseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (49 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetFTPc_ClientCloseSocket(socket)
N#endif
N
N/**
N  \brief  Event on FTP client completed operation (Op)
N  \param  cb_event      user callback nofication event
N                         - 0: File operation successful
N                         - 1: Timeout on file operation
N                         - 2: Login error, username/password invalid
N                         - 3: File access not allowed
N                         - 4: File not found
N                         - 5: Working directory path not found
N                         - 6: Local file read/write error
N                         - 7: Generic FTP client error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_ClientDone(uint8_t cb_event) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_ClientDone(uint8_t cb_event) {
N    EventRecord2 (EvtNetFTPc_ClientDone, cb_event, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (50 & 0xFFU)), cb_event, 0);
N  }
N#else
S  #define EvrNetFTPc_ClientDone(cb_event)
N#endif
N
N/**
N  \brief  Event on FTP client close local file (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_CloseLocalFile(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_CloseLocalFile(void) {
N    EventRecord2 (EvtNetFTPc_CloseLocalFile, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (51 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_CloseLocalFile()
N#endif
N
N/**
N  \brief  Event on FTP client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetFTPc_UninitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetFTPc_UninitClient(void) {
N    EventRecord2 (EvtNetFTPc_UninitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD5 & 0xFFU) << 8) | (52 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetFTPc_UninitClient()
N#endif
N
N
N// NetTeln event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetTeln_InitServer               EventID (EventLevelOp,    EvtNetTeln,  0)
N#define EvtNetTeln_GetSocketFailed          EventID (EventLevelError, EvtNetTeln,  1)
N#define EvtNetTeln_SetUsername              EventID (EventLevelAPI,   EvtNetTeln,  2)
N#define EvtNetTeln_SetPassword              EventID (EventLevelAPI,   EvtNetTeln,  3)
N#define EvtNetTeln_StartService             EventID (EventLevelOp,    EvtNetTeln,  4)
N#define EvtNetTeln_StopService              EventID (EventLevelOp,    EvtNetTeln,  5)
N#define EvtNetTeln_CloseSession             EventID (EventLevelOp,    EvtNetTeln,  6)
N#define EvtNetTeln_ProcessData              EventID (EventLevelOp,    EvtNetTeln,  7)
N#define EvtNetTeln_ProcessCommand           EventID (EventLevelOp,    EvtNetTeln,  8)
N#define EvtNetTeln_EchoBackspace            EventID (EventLevelOp,    EvtNetTeln,  9)
N#define EvtNetTeln_CommandHistory           EventID (EventLevelOp,    EvtNetTeln, 10)
N#define EvtNetTeln_EchoCharacters           EventID (EventLevelOp,    EvtNetTeln, 11)
N#define EvtNetTeln_LineBufferUsage          EventID (EventLevelOp,    EvtNetTeln, 12)
N#define EvtNetTeln_SendAuthorizationRequest EventID (EventLevelOp,    EvtNetTeln, 13)
N#define EvtNetTeln_SendInitialHeader        EventID (EventLevelOp,    EvtNetTeln, 14)
N#define EvtNetTeln_LoginTimeoutExpired      EventID (EventLevelOp,    EvtNetTeln, 15)
N#define EvtNetTeln_ShowPassword             EventID (EventLevelOp,    EvtNetTeln, 16)
N#define EvtNetTeln_AuthenticationFailed     EventID (EventLevelError, EvtNetTeln, 17)
N#define EvtNetTeln_UserLoginSuccess         EventID (EventLevelOp,    EvtNetTeln, 18)
N#define EvtNetTeln_ShowUsername             EventID (EventLevelOp,    EvtNetTeln, 19)
N#define EvtNetTeln_NegotiateStart           EventID (EventLevelOp,    EvtNetTeln, 20)
N#define EvtNetTeln_NegotiateFailed          EventID (EventLevelError, EvtNetTeln, 21)
N#define EvtNetTeln_UserAccessDenied         EventID (EventLevelError, EvtNetTeln, 22)
N// Gap
N#define EvtNetTeln_SessionOpen              EventID (EventLevelOp,    EvtNetTeln, 24)
N#define EvtNetTeln_SocketAborted            EventID (EventLevelOp,    EvtNetTeln, 25)
N#define EvtNetTeln_SocketClosed             EventID (EventLevelOp,    EvtNetTeln, 26)
N#define EvtNetTeln_ReceiveFrame             EventID (EventLevelOp,    EvtNetTeln, 27)
N#define EvtNetTeln_NegotiateSuccess         EventID (EventLevelOp,    EvtNetTeln, 28)
N#define EvtNetTeln_UninitServer             EventID (EventLevelOp,    EvtNetTeln, 29)
N#endif
N
N/**
N  \brief  Event on Telnet server initialize (Op)
N  \param  num_sessions  number of available Telnet sessions
N  \param  port          listening port number
N  \param  idle_tout     idle timeout in seconds (0= permanent connection)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_InitServer(uint32_t num_sessions, uint16_t port, uint16_t idle_tout) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_InitServer(uint32_t num_sessions, uint16_t port, uint16_t idle_tout) {
N    uint32_t val2 = (uint32_t)idle_tout << 16 | port;
N    EventRecord2 (EvtNetTeln_InitServer, num_sessions, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (0 & 0xFFU)), num_sessions, val2);
N  }
N#else
S  #define EvrNetTeln_InitServer(num_sessions, port, idle_tout)
N#endif
N
N/**
N  \brief  Event on Telnet server failed to allocate TCP socket (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_GetSocketFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_GetSocketFailed(uint8_t session) {
N    EventRecord2 (EvtNetTeln_GetSocketFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (1 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_GetSocketFailed(session)
N#endif
N
N/**
N  \brief  Event on Telnet server \ref netTELNETs_SetUsername (API)
N  \param  username      new username
N  \param  length        length of the username string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SetUsername(const char *username, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SetUsername(const char *username, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetTeln_SetUsername, username, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (2 & 0xFFU)), username, length);
N  }
N#else
S  #define EvrNetTeln_SetUsername(username, length)
N#endif
N
N/**
N  \brief  Event on Telnet server \ref netTELNETs_SetPassword (API)
N  \param  password      new password
N  \param  length        length of the password string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SetPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SetPassword(const char *password, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetTeln_SetPassword, password, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (3 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetTeln_SetPassword(password, length)
N#endif
N
N/**
N  \brief  Event on Telnet server start service (Op)
N  \param  port          listening port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_StartService(uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_StartService(uint16_t port) {
N    EventRecord2 (EvtNetTeln_StartService, port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (4 & 0xFFU)), port, 0);
N  }
N#else
S  #define EvrNetTeln_StartService(port)
N#endif
N
N/**
N  \brief  Event on Telnet server stop service (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_StopService(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_StopService(void) {
N    EventRecord2 (EvtNetTeln_StopService, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (5 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTeln_StopService()
N#endif
N
N/**
N  \brief  Event on Telnet server session close (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_CloseSession(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_CloseSession(uint8_t session) {
N    EventRecord2 (EvtNetTeln_CloseSession, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (6 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_CloseSession(session)
N#endif
N
N/**
N  \brief  Event on Telnet server process client data (Op)
N  \param  session       session number
N  \param  length        length of client data to process
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_ProcessData(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_ProcessData(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetTeln_ProcessData, session, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (7 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetTeln_ProcessData(session, length)
N#endif
N
N/**
N  \brief  Event on Telnet server process client command (Op)
N  \param  command       user entered command to process
N  \param  length        length of the command string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_ProcessCommand(const char *command, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_ProcessCommand(const char *command, uint32_t length) {
N    if (length > 96) length = 96;
N    EventRecordData (EvtNetTeln_ProcessCommand, command, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (8 & 0xFFU)), command, length);
N  }
N#else
S  #define EvrNetTeln_ProcessCommand(command, length)
N#endif
N
N/**
N  \brief  Event on Telnet server echo backspace (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_EchoBackspace(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_EchoBackspace(uint8_t session) {
N    EventRecord2 (EvtNetTeln_EchoBackspace, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (9 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_EchoBackspace(session)
N#endif
N
N/**
N  \brief  Event on Telnet server process command history (Op)
N  \param  command       command from the command history
N  \param  length        length of the command string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_CommandHistory(const char *command, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_CommandHistory(const char *command, uint32_t length) {
N    if (length > 96) length = 96;
N    EventRecordData (EvtNetTeln_CommandHistory, command, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (10 & 0xFFU)), command, length);
N  }
N#else
S  #define EvrNetTeln_CommandHistory(command, length)
N#endif
N
N/**
N  \brief  Event on Telnet server echo the characters from command line buffer (Op)
N  \param  line_buffer   command line buffer
N  \param  num_char      number of characters to echo
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_EchoCharacters(uint8_t *line_buffer, uint32_t num_char) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_EchoCharacters(uint8_t *line_buffer, uint32_t num_char) {
N    if (num_char > 96) num_char = 96;
N    EventRecordData (EvtNetTeln_EchoCharacters, line_buffer, num_char);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (11 & 0xFFU)), line_buffer, num_char);
N  }
N#else
S  #define EvrNetTeln_EchoCharacters(line_buffer, num_char)
N#endif
N
N/**
N  \brief  Event on Telnet server display command line buffer usage (Op)
N  \param  session       session number
N  \param  num_char      number of characters in command line buffer
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_LineBufferUsage(uint8_t session, uint32_t num_char) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_LineBufferUsage(uint8_t session, uint32_t num_char) {
N    EventRecord2 (EvtNetTeln_LineBufferUsage, session, num_char);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (12 & 0xFFU)), session, num_char);
N  }
N#else
S  #define EvrNetTeln_LineBufferUsage(session, num_char)
N#endif
N
N/**
N  \brief  Event on Telnet server send authorization request to the client (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SendAuthorizationRequest(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SendAuthorizationRequest(uint8_t session) {
N    EventRecord2 (EvtNetTeln_SendAuthorizationRequest, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (13 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_SendAuthorizationRequest(session)
N#endif
N
N/**
N  \brief  Event on Telnet server send initial telnet header to the client (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SendInitialHeader(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SendInitialHeader(uint8_t session) {
N    EventRecord2 (EvtNetTeln_SendInitialHeader, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (14 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_SendInitialHeader(session)
N#endif
N
N/**
N  \brief  Event on Telnet server login timeout expired (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_LoginTimeoutExpired(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_LoginTimeoutExpired(uint8_t session) {
N    EventRecord2 (EvtNetTeln_LoginTimeoutExpired, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (15 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_LoginTimeoutExpired(session)
N#endif
N
N/**
N  \brief  Event on Telnet server display password of the client (Op)
N  \param  password      password entered by the client
N  \param  length        length of the password string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_ShowPassword(const char *password, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_ShowPassword(const char *password, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetTeln_ShowPassword, password, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (16 & 0xFFU)), password, length);
N  }
N#else
S  #define EvrNetTeln_ShowPassword(password, length)
N#endif
N
N/**
N  \brief  Event on Telnet server user authentication failed, invalid credentials (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_AuthenticationFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_AuthenticationFailed(uint8_t session) {
N    EventRecord2 (EvtNetTeln_AuthenticationFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (17 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_AuthenticationFailed(session)
N#endif
N
N/**
N  \brief  Event on Telnet server user login successful (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_UserLoginSuccess(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_UserLoginSuccess(uint8_t session) {
N    EventRecord2 (EvtNetTeln_UserLoginSuccess, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (18 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_UserLoginSuccess(session)
N#endif
N
N/**
N  \brief  Event on Telnet server display username of the client (Op)
N  \param  username      username entered by the client
N  \param  length        length of the username string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_ShowUsername(const char *username, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_ShowUsername(const char *username, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData (EvtNetTeln_ShowUsername, username, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (19 & 0xFFU)), username, length);
N  }
N#else
S  #define EvrNetTeln_ShowUsername(username, length)
N#endif
N
N/**
N  \brief  Event on Telnet server option negotiation start (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_NegotiateStart(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_NegotiateStart(uint8_t session) {
N    EventRecord2 (EvtNetTeln_NegotiateStart, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (20 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_NegotiateStart(session)
N#endif
N
N/**
N  \brief  Event on Telnet server option negotiation failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_NegotiateFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_NegotiateFailed(uint8_t session) {
N    EventRecord2 (EvtNetTeln_NegotiateFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (21 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_NegotiateFailed(session)
N#endif
N
N/**
N  \brief  Event on Telnet server user denied access (Error)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_UserAccessDenied(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_UserAccessDenied(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTeln_UserAccessDenied, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (22 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTeln_UserAccessDenied(net_addr)
N#endif
N
N/**
N  \brief  Event on Telnet server session open (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SessionOpen(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SessionOpen(uint8_t session) {
N    EventRecord2 (EvtNetTeln_SessionOpen, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (24 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_SessionOpen(session)
N#endif
N
N/**
N  \brief  Event on Telnet server socket aborted (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SocketAborted(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SocketAborted(uint8_t session) {
N    EventRecord2 (EvtNetTeln_SocketAborted, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (25 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_SocketAborted(session)
N#endif
N
N/**
N  \brief  Event on Telnet server socket closed (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_SocketClosed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_SocketClosed(uint8_t session) {
N    EventRecord2 (EvtNetTeln_SocketClosed, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (26 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_SocketClosed(session)
N#endif
N
N/**
N  \brief  Event on Telnet server receive frame (Op)
N  \param  session       session number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_ReceiveFrame(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_ReceiveFrame(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetTeln_ReceiveFrame, session, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (27 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetTeln_ReceiveFrame(session, length)
N#endif
N
N/**
N  \brief  Event on Telnet server option negotiation success (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_NegotiateSuccess(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_NegotiateSuccess(uint8_t session) {
N    EventRecord2 (EvtNetTeln_NegotiateSuccess, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (28 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTeln_NegotiateSuccess(session)
N#endif
N
N/**
N  \brief  Event on Telnet server de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTeln_UninitServer(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTeln_UninitServer(void) {
N    EventRecord2 (EvtNetTeln_UninitServer, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD6 & 0xFFU) << 8) | (29 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTeln_UninitServer()
N#endif
N
N
N// NetTFTPs event identifiers --------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetTFTPs_InitServer              EventID (EventLevelOp,    EvtNetTFTPs,  0)
N#define EvtNetTFTPs_ShowRootFolder          EventID (EventLevelOp,    EvtNetTFTPs,  1)
N#define EvtNetTFTPs_GetSocketFailed         EventID (EventLevelError, EvtNetTFTPs,  2)
N#define EvtNetTFTPs_SetRootPath             EventID (EventLevelAPI,   EvtNetTFTPs,  3)
N#define EvtNetTFTPs_StartService            EventID (EventLevelOp,    EvtNetTFTPs,  4)
N#define EvtNetTFTPs_StopService             EventID (EventLevelOp,    EvtNetTFTPs,  5)
N#define EvtNetTFTPs_TimeoutExpiredAbort     EventID (EventLevelError, EvtNetTFTPs,  6)
N#define EvtNetTFTPs_SendBlock               EventID (EventLevelOp,    EvtNetTFTPs,  7)
N#define EvtNetTFTPs_ReceiveFrame            EventID (EventLevelOp,    EvtNetTFTPs,  8)
N#define EvtNetTFTPs_FrameTooShort           EventID (EventLevelError, EvtNetTFTPs,  9)
N#define EvtNetTFTPs_UserAccessDenied        EventID (EventLevelError, EvtNetTFTPs, 10)
N// Gap
N#define EvtNetTFTPs_AccessDeniedNoResources EventID (EventLevelError, EvtNetTFTPs, 12)
N#define EvtNetTFTPs_ShowClientAddress       EventID (EventLevelOp,    EvtNetTFTPs, 13)
N// Gap
N#define EvtNetTFTPs_OperationRequest        EventID (EventLevelOp,    EvtNetTFTPs, 15)
N#define EvtNetTFTPs_SessionRestart          EventID (EventLevelOp,    EvtNetTFTPs, 16)
N#define EvtNetTFTPs_InvalidTransferId       EventID (EventLevelError, EvtNetTFTPs, 17)
N#define EvtNetTFTPs_ErrorCodeReceived       EventID (EventLevelError, EvtNetTFTPs, 18)
N#define EvtNetTFTPs_IllegalOpcodeReceived   EventID (EventLevelError, EvtNetTFTPs, 19)
N#define EvtNetTFTPs_FileRequested           EventID (EventLevelOp,    EvtNetTFTPs, 20)
N#define EvtNetTFTPs_TransferBlockSize       EventID (EventLevelOp,    EvtNetTFTPs, 21)
N#define EvtNetTFTPs_TransferModeNotBinary   EventID (EventLevelError, EvtNetTFTPs, 22)
N#define EvtNetTFTPs_LocalFileNotFound       EventID (EventLevelError, EvtNetTFTPs, 23)
N#define EvtNetTFTPs_LocalFileCreateFailed   EventID (EventLevelError, EvtNetTFTPs, 24)
N#define EvtNetTFTPs_ReceiveDataFrame        EventID (EventLevelOp,    EvtNetTFTPs, 25)
N#define EvtNetTFTPs_DataFrameTooShort       EventID (EventLevelError, EvtNetTFTPs, 26)
N#define EvtNetTFTPs_DuplicateBlockReceived  EventID (EventLevelOp,    EvtNetTFTPs, 27)
N#define EvtNetTFTPs_TooManyRetries          EventID (EventLevelError, EvtNetTFTPs, 28)
N#define EvtNetTFTPs_BlockReceived           EventID (EventLevelOp,    EvtNetTFTPs, 29)
N#define EvtNetTFTPs_InvalidBlockReceived    EventID (EventLevelError, EvtNetTFTPs, 30)
N#define EvtNetTFTPs_WriteErrorDiskFull      EventID (EventLevelError, EvtNetTFTPs, 31)
N#define EvtNetTFTPs_BlockAckReceived        EventID (EventLevelOp,    EvtNetTFTPs, 32)
N#define EvtNetTFTPs_BlockRetransmit         EventID (EventLevelOp,    EvtNetTFTPs, 33)
N#define EvtNetTFTPs_InvalidBlockAck         EventID (EventLevelError, EvtNetTFTPs, 34)
N#define EvtNetTFTPs_ShowRequestMode         EventID (EventLevelOp,    EvtNetTFTPs, 35)
N#define EvtNetTFTPs_SendOptionAck           EventID (EventLevelOp,    EvtNetTFTPs, 36)
N#define EvtNetTFTPs_SendBlockAck            EventID (EventLevelOp,    EvtNetTFTPs, 37)
N#define EvtNetTFTPs_SendError               EventID (EventLevelOp,    EvtNetTFTPs, 38)
N#define EvtNetTFTPs_AbortSession            EventID (EventLevelOp,    EvtNetTFTPs, 39)
N#define EvtNetTFTPs_CloseSession            EventID (EventLevelOp,    EvtNetTFTPs, 40)
N#define EvtNetTFTPs_UninitServer            EventID (EventLevelOp,    EvtNetTFTPs, 41)
N#endif
N
N/**
N  \brief  Event on TFTP server initialize (Op)
N  \param  num_sessions  number of available TFTP sessions
N  \param  port          listening port number
N  \param  firewall_en   firewall support enable
N                         - 0: disabled
N                         - 1: enabled
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_InitServer(uint32_t num_sessions, uint16_t port, uint8_t firewall_en) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_InitServer(uint32_t num_sessions, uint16_t port, uint8_t firewall_en) {
N    uint32_t val2 = (uint32_t)firewall_en << 16 | port;
N    EventRecord2 (EvtNetTFTPs_InitServer, num_sessions, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (0 & 0xFFU)), num_sessions, val2);
N  }
N#else
S  #define EvrNetTFTPs_InitServer(num_sessions, port, firewall_en)
N#endif
N
N/**
N  \brief  Event on TFTP server display root folder (Op)
N  \param  root_folder   path to server root folder
N  \param  length        length of the root_folder string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ShowRootFolder(const char *root_folder, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetTFTPs_ShowRootFolder, root_folder, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (1 & 0xFFU)), root_folder, length);
N  }
N#else
S  #define EvrNetTFTPs_ShowRootFolder(root_folder, length)
N#endif
N
N/**
N  \brief  Event on TFTP server failed to allocate UDP socket (Error)
N  \param  session       session number (0= control session)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_GetSocketFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_GetSocketFailed(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_GetSocketFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (2 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_GetSocketFailed(session)
N#endif
N
N/**
N  \brief  Event on TFTP server \ref netTFTPs_SetRootPath (API)
N  \param  path          path to server root folder
N  \param  length        length of the path string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SetRootPath(const char *path, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SetRootPath(const char *path, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetTFTPs_SetRootPath, path, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (3 & 0xFFU)), path, length);
N  }
N#else
S  #define EvrNetTFTPs_SetRootPath(path, length)
N#endif
N
N/**
N  \brief  Event on TFTP server start service (Op)
N  \param  port          listening port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_StartService(uint16_t port) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_StartService(uint16_t port) {
N    EventRecord2 (EvtNetTFTPs_StartService, port, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (4 & 0xFFU)), port, 0);
N  }
N#else
S  #define EvrNetTFTPs_StartService(port)
N#endif
N
N/**
N  \brief  Event on TFTP server stop service (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_StopService(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_StopService(void) {
N    EventRecord2 (EvtNetTFTPs_StopService, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (5 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPs_StopService()
N#endif
N
N/**
N  \brief  Event on TFTP server session timeout expired, abort transfer (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_TimeoutExpiredAbort(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_TimeoutExpiredAbort(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_TimeoutExpiredAbort, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (6 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_TimeoutExpiredAbort(session)
N#endif
N
N/**
N  \brief  Event on TFTP server send block (Op)
N  \param  session       session number
N  \param  block_nr      block number
N  \param  length        length of a block
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SendBlock(uint8_t session, uint32_t block_nr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SendBlock(uint8_t session, uint32_t block_nr, uint32_t length) {
N    uint32_t val2 = (block_nr << 16) | length;
N    EventRecord2 (EvtNetTFTPs_SendBlock, session, val2);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (7 & 0xFFU)), session, val2);
N  }
N#else
S  #define EvrNetTFTPs_SendBlock(session, block_nr, length)
N#endif
N
N/**
N  \brief  Event on TFTP server receive frame (Op)
N  \param  socket        assigned UDP socket
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ReceiveFrame(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ReceiveFrame(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetTFTPs_ReceiveFrame, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (8 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetTFTPs_ReceiveFrame(socket, length)
N#endif
N
N/**
N  \brief  Event on TFTP server receive frame too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetTFTPs_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (9 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetTFTPs_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on TFTP server user denied access (Error)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_UserAccessDenied(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_UserAccessDenied(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTFTPs_UserAccessDenied, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (10 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTFTPs_UserAccessDenied(net_addr)
N#endif
N
N/**
N  \brief  Event on TFTP server denied client access on out of resources (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_AccessDeniedNoResources(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_AccessDeniedNoResources(void) {
N    EventRecord2 (EvtNetTFTPs_AccessDeniedNoResources, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (12 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPs_AccessDeniedNoResources()
N#endif
N
N/**
N  \brief  Event on TFTP server display client IP address and port number (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ShowClientAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ShowClientAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTFTPs_ShowClientAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (13 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTFTPs_ShowClientAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on TFTP server process operation request (Op)
N  \param  session       session number
N  \param  tftp_opcode   TFTP operation code
N                         - 1: read request
N                         - 2: write request
N                         - 3: data
N                         - 4: acknowledgment
N                         - 5: error
N                         - 6: option acknowledgment
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_OperationRequest(uint8_t session, uint16_t tftp_opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_OperationRequest(uint8_t session, uint16_t tftp_opcode) {
N    EventRecord2 (EvtNetTFTPs_OperationRequest, session, tftp_opcode);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (15 & 0xFFU)), session, tftp_opcode);
N  }
N#else
S  #define EvrNetTFTPs_OperationRequest(session, tftp_opcode)
N#endif
N
N/**
N  \brief  Event on TFTP server session restart, maybe our response was lost (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SessionRestart(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SessionRestart(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_SessionRestart, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (16 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_SessionRestart(session)
N#endif
N
N/**
N  \brief  Event on TFTP server invalid transfer id (TID) detected (Error)
N  \param  session       session number
N  \remark TID is treated in UDP socket as the source and destination port.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_InvalidTransferId(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_InvalidTransferId(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_InvalidTransferId, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (17 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_InvalidTransferId(session)
N#endif
N
N/**
N  \brief  Event on TFTP server error code received from the client (Error)
N  \param  session       session number
N  \param  error_code    TFTP error code
N                         - 0: not defined error
N                         - 1: file not found error
N                         - 2: access violation error
N                         - 3: disk full error
N                         - 4: illegal opcode error
N                         - 5: unknown TID error
N                         - 6: file already exists error
N                         - 7: no such user error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ErrorCodeReceived(uint8_t session, uint16_t error_code) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ErrorCodeReceived(uint8_t session, uint16_t error_code) {
N    EventRecord2 (EvtNetTFTPs_ErrorCodeReceived, session, error_code);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (18 & 0xFFU)), session, error_code);
N  }
N#else
S  #define EvrNetTFTPs_ErrorCodeReceived(session, error_code)
N#endif
N
N/**
N  \brief  Event on TFTP server illegal operation code received from the client (Error)
N  \param  session       session number
N  \param  tftp_opcode   TFTP operation code
N                         - 1: read request
N                         - 2: write request
N                         - 3: data
N                         - 4: acknowledgment
N                         - 5: error
N                         - 6: option acknowledgment
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_IllegalOpcodeReceived(uint8_t session, uint16_t tftp_opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_IllegalOpcodeReceived(uint8_t session, uint16_t tftp_opcode) {
N    EventRecord2 (EvtNetTFTPs_IllegalOpcodeReceived, session, tftp_opcode);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (19 & 0xFFU)), session, tftp_opcode);
N  }
N#else
S  #define EvrNetTFTPs_IllegalOpcodeReceived(session, tftp_opcode)
N#endif
N
N/**
N  \brief  Event on TFTP server received file request from the client (Op)
N  \param  fname         name of the requested file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_FileRequested(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_FileRequested(const char *fname, uint32_t length) {
N    if (length > 40) length = 40;
N    EventRecordData (EvtNetTFTPs_FileRequested, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (20 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetTFTPs_FileRequested(fname, length)
N#endif
N
N/**
N  \brief  Event on TFTP server display transfer block size (Op)
N  \param  session       session number
N  \param  block_size    size of transfer block
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_TransferBlockSize(uint8_t session, uint16_t block_size) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_TransferBlockSize(uint8_t session, uint16_t block_size) {
N    EventRecord2 (EvtNetTFTPs_TransferBlockSize, session, block_size);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (21 & 0xFFU)), session, block_size);
N  }
N#else
S  #define EvrNetTFTPs_TransferBlockSize(session, block_size)
N#endif
N
N/**
N  \brief  Event on TFTP server transfer mode not set to binary (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_TransferModeNotBinary(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_TransferModeNotBinary(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_TransferModeNotBinary, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (22 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_TransferModeNotBinary(session)
N#endif
N
N/**
N  \brief  Event on TFTP server error, requested file not found on server (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_LocalFileNotFound(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_LocalFileNotFound(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_LocalFileNotFound, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (23 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_LocalFileNotFound(session)
N#endif
N
N/**
N  \brief  Event on TFTP server local file create failed (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_LocalFileCreateFailed(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_LocalFileCreateFailed(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_LocalFileCreateFailed, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (24 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_LocalFileCreateFailed(session)
N#endif
N
N/**
N  \brief  Event on TFTP server receive data frame (Op)
N  \param  session       session number
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ReceiveDataFrame(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ReceiveDataFrame(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetTFTPs_ReceiveDataFrame, session, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (25 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetTFTPs_ReceiveDataFrame(session, length)
N#endif
N
N/**
N  \brief  Event on TFTP server receive data frame too short (Error)
N  \param  session       session number
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_DataFrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_DataFrameTooShort(uint8_t session, uint32_t length, uint32_t min_length) {
N    uint32_t val2 = (min_length << 16) | length;
N    EventRecord2 (EvtNetTFTPs_DataFrameTooShort, session, val2);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (26 & 0xFFU)), session, val2);
N  }
N#else
S  #define EvrNetTFTPs_DataFrameTooShort(session, length, min_length)
N#endif
N
N/**
N  \brief  Event on TFTP server duplicate block received (Op)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_DuplicateBlockReceived(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_DuplicateBlockReceived(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_DuplicateBlockReceived, session, block_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (27 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_DuplicateBlockReceived(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server too many retransmissions (Error)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_TooManyRetries(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_TooManyRetries(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_TooManyRetries, session, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (28 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_TooManyRetries(session)
N#endif
N
N/**
N  \brief  Event on TFTP server data block received (Op)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_BlockReceived(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_BlockReceived(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_BlockReceived, session, block_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (29 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_BlockReceived(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server invalid block received (Error)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_InvalidBlockReceived(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_InvalidBlockReceived(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_InvalidBlockReceived, session, block_nr);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (30 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_InvalidBlockReceived(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server write local disk failed, disk full (Error)
N  \param  session       session number
N  \param  length        block data length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_WriteErrorDiskFull(uint8_t session, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_WriteErrorDiskFull(uint8_t session, uint32_t length) {
N    EventRecord2 (EvtNetTFTPs_WriteErrorDiskFull, session, length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (31 & 0xFFU)), session, length);
N  }
N#else
S  #define EvrNetTFTPs_WriteErrorDiskFull(session, length)
N#endif
N
N/**
N  \brief  Event on TFTP server block acknowledge received (Op)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_BlockAckReceived(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_BlockAckReceived(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_BlockAckReceived, session, block_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (32 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_BlockAckReceived(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server block retransmit (Op)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_BlockRetransmit(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_BlockRetransmit(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_BlockRetransmit, session, block_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (33 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_BlockRetransmit(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server invalid block acknowledge received (Error)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_InvalidBlockAck(uint8_t session, uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_InvalidBlockAck(uint8_t session, uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_InvalidBlockAck, session, block_nr);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (34 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_InvalidBlockAck(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server display received request mode parameter (Op)
N  \param  mode          mode parameter in text format
N  \param  length        length of the mode string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_ShowRequestMode(const uint8_t *mode, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_ShowRequestMode(const uint8_t *mode, uint32_t length) {
N    if (length > 16) length = 16;
N    EventRecordData (EvtNetTFTPs_ShowRequestMode, mode, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (35 & 0xFFU)), mode, length);
N  }
N#else
S  #define EvrNetTFTPs_ShowRequestMode(mode, length)
N#endif
N
N/**
N  \brief  Event on TFTP server send option acknowledgment (Op)
N  \param  session       session number
N  \param  block_size    block size
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SendOptionAck(uint8_t session, uint32_t block_size) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SendOptionAck(uint8_t session, uint32_t block_size) {
N    EventRecord2 (EvtNetTFTPs_SendOptionAck, session, block_size);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (36 & 0xFFU)), session, block_size);
N  }
N#else
S  #define EvrNetTFTPs_SendOptionAck(session, block_size)
N#endif
N
N/**
N  \brief  Event on TFTP server send block acknowledgment (Op)
N  \param  session       session number
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SendBlockAck(uint8_t session, uint16_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SendBlockAck(uint8_t session, uint16_t block_nr) {
N    EventRecord2 (EvtNetTFTPs_SendBlockAck, session, block_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (37 & 0xFFU)), session, block_nr);
N  }
N#else
S  #define EvrNetTFTPs_SendBlockAck(session, block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server send error code (Op)
N  \param  session       session number
N  \param  error_nr      TFTP error number
N                         - 0: not defined error
N                         - 1: file not found error
N                         - 2: access violation error
N                         - 3: disk full error
N                         - 4: illegal opcode error
N                         - 5: unknown TID error
N                         - 6: file already exists error
N                         - 7: no such user error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_SendError(uint8_t session, uint16_t error_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_SendError(uint8_t session, uint16_t error_nr) {
N    EventRecord2 (EvtNetTFTPs_SendError, session, error_nr);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (38 & 0xFFU)), session, error_nr);
N  }
N#else
S  #define EvrNetTFTPs_SendError(session, error_nr)
N#endif
N
N/**
N  \brief  Event on TFTP server abnormal session close on error (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_AbortSession(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_AbortSession(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_AbortSession, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (39 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_AbortSession(session)
N#endif
N
N/**
N  \brief  Event on TFTP server normal session close (Op)
N  \param  session       session number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_CloseSession(uint8_t session) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_CloseSession(uint8_t session) {
N    EventRecord2 (EvtNetTFTPs_CloseSession, session, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (40 & 0xFFU)), session, 0);
N  }
N#else
S  #define EvrNetTFTPs_CloseSession(session)
N#endif
N
N/**
N  \brief  Event on TFTP server de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPs_UninitServer(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPs_UninitServer(void) {
N    EventRecord2 (EvtNetTFTPs_UninitServer, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD7 & 0xFFU) << 8) | (41 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPs_UninitServer()
N#endif
N
N
N// NetTFTPc event identifiers --------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetTFTPc_InitClient              EventID (EventLevelOp,    EvtNetTFTPc,  0)
N#define EvtNetTFTPc_GetSocketFailed         EventID (EventLevelError, EvtNetTFTPc,  1)
N#define EvtNetTFTPc_PutFile                 EventID (EventLevelAPI,   EvtNetTFTPc,  2)
N#define EvtNetTFTPc_PutRemoteName           EventID (EventLevelOp,    EvtNetTFTPc,  3)
N#define EvtNetTFTPc_PutInvalidParameter     EventID (EventLevelError, EvtNetTFTPc,  4)
N#define EvtNetTFTPc_PutWrongState           EventID (EventLevelError, EvtNetTFTPc,  5)
N#define EvtNetTFTPc_ShowServerAddress       EventID (EventLevelOp,    EvtNetTFTPc,  6)
N// Gap
N#define EvtNetTFTPc_OpenLocalFile           EventID (EventLevelOp,    EvtNetTFTPc,  8)
N#define EvtNetTFTPc_OpenLocalFileFailed     EventID (EventLevelError, EvtNetTFTPc,  9)
N#define EvtNetTFTPc_GetFile                 EventID (EventLevelAPI,   EvtNetTFTPc, 10)
N#define EvtNetTFTPc_GetLocalName            EventID (EventLevelOp,    EvtNetTFTPc, 11)
N#define EvtNetTFTPc_GetInvalidParameter     EventID (EventLevelError, EvtNetTFTPc, 12)
N#define EvtNetTFTPc_GetWrongState           EventID (EventLevelError, EvtNetTFTPc, 13)
N#define EvtNetTFTPc_TimeoutBlockRetransmit  EventID (EventLevelOp,    EvtNetTFTPc, 14)
N#define EvtNetTFTPc_SendBlock               EventID (EventLevelOp,    EvtNetTFTPc, 15)
N#define EvtNetTFTPc_StopClient              EventID (EventLevelOp,    EvtNetTFTPc, 16)
N#define EvtNetTFTPc_CloseLocalFile          EventID (EventLevelOp,    EvtNetTFTPc, 17)
N#define EvtNetTFTPc_WrongServerAddress      EventID (EventLevelError, EvtNetTFTPc, 18)
N// Gap
N#define EvtNetTFTPc_WrongServerPort         EventID (EventLevelError, EvtNetTFTPc, 20)
N#define EvtNetTFTPc_ServerTidAssigned       EventID (EventLevelOp,    EvtNetTFTPc, 21)
N#define EvtNetTFTPc_FrameTooShort           EventID (EventLevelError, EvtNetTFTPc, 22)
N#define EvtNetTFTPc_ReceiveFrame            EventID (EventLevelOp,    EvtNetTFTPc, 23)
N#define EvtNetTFTPc_ErrorCodeReceived       EventID (EventLevelError, EvtNetTFTPc, 24)
N#define EvtNetTFTPc_DuplicateBlockAck       EventID (EventLevelOp,    EvtNetTFTPc, 25)
N#define EvtNetTFTPc_InvalidBlockAck         EventID (EventLevelError, EvtNetTFTPc, 26)
N#define EvtNetTFTPc_BlockAckReceived        EventID (EventLevelOp,    EvtNetTFTPc, 27)
N#define EvtNetTFTPc_DuplicateBlockReceived  EventID (EventLevelOp,    EvtNetTFTPc, 28)
N#define EvtNetTFTPc_InvalidBlockReceived    EventID (EventLevelError, EvtNetTFTPc, 29)
N#define EvtNetTFTPc_BlockReceived           EventID (EventLevelOp,    EvtNetTFTPc, 30)
N#define EvtNetTFTPc_WriteErrorDiskFull      EventID (EventLevelError, EvtNetTFTPc, 31)
N#define EvtNetTFTPc_IllegalServerOperation  EventID (EventLevelError, EvtNetTFTPc, 32)
N#define EvtNetTFTPc_SendRequest             EventID (EventLevelOp,    EvtNetTFTPc, 33)
N#define EvtNetTFTPc_OptionBlockSize         EventID (EventLevelOp,    EvtNetTFTPc, 34)
N#define EvtNetTFTPc_SendAck                 EventID (EventLevelOp,    EvtNetTFTPc, 35)
N#define EvtNetTFTPc_SendError               EventID (EventLevelOp,    EvtNetTFTPc, 36)
N#define EvtNetTFTPc_OptionAckReceived       EventID (EventLevelOp,    EvtNetTFTPc, 37)
N#define EvtNetTFTPc_UninitClient            EventID (EventLevelOp,    EvtNetTFTPc, 38)
N#endif
N
N/**
N  \brief  Event on TFTP client initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_InitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_InitClient(void) {
N    EventRecord2 (EvtNetTFTPc_InitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_InitClient()
N#endif
N
N/**
N  \brief  Event on TFTP client failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_GetSocketFailed(void) {
N    EventRecord2 (EvtNetTFTPc_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on TFTP client \ref netTFTPc_Put (API)
N  \param  local_fname   name of the local file
N  \param  length        length of the local_fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_PutFile(const char *local_fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_PutFile(const char *local_fname, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData (EvtNetTFTPc_PutFile, local_fname, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (2 & 0xFFU)), local_fname, length);
N  }
N#else
S  #define EvrNetTFTPc_PutFile(local_fname, length)
N#endif
N
N/**
N  \brief  Event on TFTP client \ref netTFTPc_Put remote filename (Op)
N  \param  fname         name of the remote file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_PutRemoteName(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_PutRemoteName(const char *fname, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData (EvtNetTFTPc_PutRemoteName, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (3 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetTFTPc_PutRemoteName(fname, length)
N#endif
N
N/**
N  \brief  Event on \ref netTFTPc_Put invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_PutInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_PutInvalidParameter(void) {
N    EventRecord2 (EvtNetTFTPc_PutInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_PutInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netTFTPc_Put wrong client state (Error)
N  \param  state         client state
N                         - 0: idle
N                         - 1: put file
N                         - 2: get file
N                         - 3: stop client
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_PutWrongState(uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_PutWrongState(uint8_t state) {
N    EventRecord2 (EvtNetTFTPc_PutWrongState, state, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (5 & 0xFFU)), state, 0);
N  }
N#else
S  #define EvrNetTFTPc_PutWrongState(state)
N#endif
N
N/**
N  \brief  Event on TFTP client display server IP address (Op)
N  \param  net_addr      pointer to \ref NET_ADDR server address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_ShowServerAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_ShowServerAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTFTPc_ShowServerAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (6 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTFTPc_ShowServerAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on TFTP client open local file (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_OpenLocalFile(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_OpenLocalFile(void) {
N    EventRecord2 (EvtNetTFTPc_OpenLocalFile, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_OpenLocalFile()
N#endif
N
N/**
N  \brief  Event on TFTP client open local file failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_OpenLocalFileFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_OpenLocalFileFailed(void) {
N    EventRecord2 (EvtNetTFTPc_OpenLocalFileFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (9 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_OpenLocalFileFailed()
N#endif
N
N/**
N  \brief  Event on TFTP client \ref netTFTPc_Get (API)
N  \param  fname         name of the remote file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_GetFile(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_GetFile(const char *fname, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData (EvtNetTFTPc_GetFile, fname, length);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (10 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetTFTPc_GetFile(fname, length)
N#endif
N
N/**
N  \brief  Event on TFTP client \ref netTFTPc_Get local filename (Op)
N  \param  local_fname   name of the local file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_GetLocalName(const char *local_fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_GetLocalName(const char *local_fname, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData (EvtNetTFTPc_GetLocalName, local_fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (11 & 0xFFU)), local_fname, length);
N  }
N#else
S  #define EvrNetTFTPc_GetLocalName(local_fname, length)
N#endif
N
N/**
N  \brief  Event on \ref netTFTPc_Get invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_GetInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_GetInvalidParameter(void) {
N    EventRecord2 (EvtNetTFTPc_GetInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (12 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_GetInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netTFTPc_Get wrong client state (Error)
N  \param  state         client state
N                         - 0: idle
N                         - 1: put file
N                         - 2: get file
N                         - 3: stop client
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_GetWrongState(uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_GetWrongState(uint8_t state) {
N    EventRecord2 (EvtNetTFTPc_GetWrongState, state, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (13 & 0xFFU)), state, 0);
N  }
N#else
S  #define EvrNetTFTPc_GetWrongState(state)
N#endif
N
N/**
N  \brief  Event on TFTP client block retransmit on timeout (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_TimeoutBlockRetransmit(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_TimeoutBlockRetransmit(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_TimeoutBlockRetransmit, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (14 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_TimeoutBlockRetransmit(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client send block (Op)
N  \param  block_nr      block number
N  \param  length        length of a block
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_SendBlock(uint32_t block_nr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_SendBlock(uint32_t block_nr, uint32_t length) {
N    EventRecord2 (EvtNetTFTPc_SendBlock, block_nr, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (15 & 0xFFU)), block_nr, length);
N  }
N#else
S  #define EvrNetTFTPc_SendBlock(block_nr, length)
N#endif
N
N/**
N  \brief  Event on TFTP client stop operation (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_StopClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_StopClient(void) {
N    EventRecord2 (EvtNetTFTPc_StopClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_StopClient()
N#endif
N
N/**
N  \brief  Event on TFTP client close local file (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_CloseLocalFile(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_CloseLocalFile(void) {
N    EventRecord2 (EvtNetTFTPc_CloseLocalFile, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (17 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_CloseLocalFile()
N#endif
N
N/**
N  \brief  Event on TFTP client wrong server IP address (Error)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_WrongServerAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_WrongServerAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetTFTPc_WrongServerAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (18 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetTFTPc_WrongServerAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on TFTP client wrong server port (Error)
N  \param  udp_port      wrong UDP port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_WrongServerPort(uint16_t udp_port) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_WrongServerPort(uint16_t udp_port) {
N    EventRecord2 (EvtNetTFTPc_WrongServerPort, udp_port, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (20 & 0xFFU)), udp_port, 0);
N  }
N#else
S  #define EvrNetTFTPc_WrongServerPort(udp_port)
N#endif
N
N/**
N  \brief  Event on TFTP client assigned transfer identifier (TID) of the server (Op)
N  \param  tid           server transfer identifier
N  \remark Transfer identifier is used as UDP port number.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_ServerTidAssigned(uint16_t tid) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_ServerTidAssigned(uint16_t tid) {
N    EventRecord2 (EvtNetTFTPc_ServerTidAssigned, tid, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (21 & 0xFFU)), tid, 0);
N  }
N#else
S  #define EvrNetTFTPc_ServerTidAssigned(tid)
N#endif
N
N/**
N  \brief  Event on TFTP client receive frame too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetTFTPc_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (22 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetTFTPc_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on TFTP client receive frame (Op)
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_ReceiveFrame(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_ReceiveFrame(uint32_t length) {
N    EventRecord2 (EvtNetTFTPc_ReceiveFrame, length, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (23 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetTFTPc_ReceiveFrame(length)
N#endif
N
N/**
N  \brief  Event on TFTP client error code received from server (Error)
N  \param  error_code    TFTP error code
N                         - 0: not defined error
N                         - 1: file not found error
N                         - 2: access violation error
N                         - 3: disk full error
N                         - 4: illegal opcode error
N                         - 5: unknown TID error
N                         - 6: file already exists error
N                         - 7: no such user error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_ErrorCodeReceived(uint16_t error_code) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_ErrorCodeReceived(uint16_t error_code) {
N    EventRecord2 (EvtNetTFTPc_ErrorCodeReceived, error_code, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (24 & 0xFFU)), error_code, 0);
N  }
N#else
S  #define EvrNetTFTPc_ErrorCodeReceived(error_code)
N#endif
N
N/**
N  \brief  Event on TFTP client duplicate block acknowledge received (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_DuplicateBlockAck(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_DuplicateBlockAck(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_DuplicateBlockAck, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (25 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_DuplicateBlockAck(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client invalid block acknowledge received (Error)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_InvalidBlockAck(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_InvalidBlockAck(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_InvalidBlockAck, block_nr, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (26 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_InvalidBlockAck(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client block acknowledge received (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_BlockAckReceived(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_BlockAckReceived(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_BlockAckReceived, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (27 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_BlockAckReceived(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client duplicate block received (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_DuplicateBlockReceived(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_DuplicateBlockReceived(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_DuplicateBlockReceived, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (28 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_DuplicateBlockReceived(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client invalid block received (Error)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_InvalidBlockReceived(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_InvalidBlockReceived(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_InvalidBlockReceived, block_nr, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (29 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_InvalidBlockReceived(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client block data received (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_BlockReceived(uint32_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_BlockReceived(uint32_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_BlockReceived, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (30 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_BlockReceived(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client write local disk failed, disk full (Error)
N  \param  length        block data length
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_WriteErrorDiskFull(uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_WriteErrorDiskFull(uint32_t length) {
N    EventRecord2 (EvtNetTFTPc_WriteErrorDiskFull, length, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (31 & 0xFFU)), length, 0);
N  }
N#else
S  #define EvrNetTFTPc_WriteErrorDiskFull(length)
N#endif
N
N/**
N  \brief  Event on TFTP client deteced illegal server operation (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_IllegalServerOperation(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_IllegalServerOperation(void) {
N    EventRecord2 (EvtNetTFTPc_IllegalServerOperation, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (32 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_IllegalServerOperation()
N#endif
N
N/**
N  \brief  Event on TFTP client send operation request (Op)
N  \param  tftp_opcode   TFTP operation code
N                         - 1: read request
N                         - 2: write request
N                         - 3: data
N                         - 4: acknowledgment
N                         - 5: error
N                         - 6: option acknowledgment
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_SendRequest(uint16_t tftp_opcode) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_SendRequest(uint16_t tftp_opcode) {
N    EventRecord2 (EvtNetTFTPc_SendRequest, tftp_opcode, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (33 & 0xFFU)), tftp_opcode, 0);
N  }
N#else
S  #define EvrNetTFTPc_SendRequest(tftp_opcode)
N#endif
N
N/**
N  \brief  Event on TFTP client add block size option (Op)
N  \param  block_size    size of transfer block
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_OptionBlockSize(uint16_t block_size) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_OptionBlockSize(uint16_t block_size) {
N    EventRecord2 (EvtNetTFTPc_OptionBlockSize, block_size, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (34 & 0xFFU)), block_size, 0);
N  }
N#else
S  #define EvrNetTFTPc_OptionBlockSize(block_size)
N#endif
N
N/**
N  \brief  Event on TFTP client send acknowledgment (Op)
N  \param  block_nr      block number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_SendAck(uint16_t block_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_SendAck(uint16_t block_nr) {
N    EventRecord2 (EvtNetTFTPc_SendAck, block_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (35 & 0xFFU)), block_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_SendAck(block_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client send error code (Op)
N  \param  error_nr      TFTP error number
N                         - 0: not defined error
N                         - 1: file not found error
N                         - 2: access violation error
N                         - 3: disk full error
N                         - 4: illegal opcode error
N                         - 5: unknown TID error
N                         - 6: file already exists error
N                         - 7: no such user error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_SendError(uint16_t error_nr) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_SendError(uint16_t error_nr) {
N    EventRecord2 (EvtNetTFTPc_SendError, error_nr, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (36 & 0xFFU)), error_nr, 0);
N  }
N#else
S  #define EvrNetTFTPc_SendError(error_nr)
N#endif
N
N/**
N  \brief  Event on TFTP client option acknowledgment received (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_OptionAckReceived(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_OptionAckReceived(void) {
N    EventRecord2 (EvtNetTFTPc_OptionAckReceived, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (37 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_OptionAckReceived()
N#endif
N
N/**
N  \brief  Event on TFTP client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetTFTPc_UninitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetTFTPc_UninitClient(void) {
N    EventRecord2 (EvtNetTFTPc_UninitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD8 & 0xFFU) << 8) | (38 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetTFTPc_UninitClient()
N#endif
N
N
N// NetSMTP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetSMTP_InitClient               EventID (EventLevelOp,    EvtNetSMTP,  0)
N#define EvtNetSMTP_GetSocketFailed          EventID (EventLevelError, EvtNetSMTP,  1)
N#define EvtNetSMTP_Connect                  EventID (EventLevelAPI,   EvtNetSMTP,  2)
N// Gap
N#define EvtNetSMTP_ConnectInvalidParameter  EventID (EventLevelError, EvtNetSMTP,  4)
N#define EvtNetSMTP_ConnectClientBusy        EventID (EventLevelError, EvtNetSMTP,  5)
N#define EvtNetSMTP_SendMail                 EventID (EventLevelAPI,   EvtNetSMTP,  6)
N#define EvtNetSMTP_SendMailInvalidParameter EventID (EventLevelError, EvtNetSMTP,  7)
N#define EvtNetSMTP_SendMailTlsNotEnabled    EventID (EventLevelError, EvtNetSMTP,  8)
N#define EvtNetSMTP_SendMailClientBusy       EventID (EventLevelError, EvtNetSMTP,  9)
N#define EvtNetSMTP_SendMailNoRecipients     EventID (EventLevelError, EvtNetSMTP, 10)
N#define EvtNetSMTP_SendMailServerNotValid   EventID (EventLevelError, EvtNetSMTP, 11)
N#define EvtNetSMTP_SendMailDnsError         EventID (EventLevelError, EvtNetSMTP, 12)
N#define EvtNetSMTP_SendMailAttachNotEnabled EventID (EventLevelError, EvtNetSMTP, 13)
N#define EvtNetSMTP_SendMailAttachFailed     EventID (EventLevelError, EvtNetSMTP, 14)
N#define EvtNetSMTP_SendMailMultipart        EventID (EventLevelOp,    EvtNetSMTP, 15)
N#define EvtNetSMTP_SendMailAttachment       EventID (EventLevelOp,    EvtNetSMTP, 16)
N#define EvtNetSMTP_InboundConnRejected      EventID (EventLevelOp,    EvtNetSMTP, 17)
N#define EvtNetSMTP_SocketAborted            EventID (EventLevelError, EvtNetSMTP, 18)
N#define EvtNetSMTP_SocketConnected          EventID (EventLevelOp,    EvtNetSMTP, 19)
N#define EvtNetSMTP_SocketClosed             EventID (EventLevelOp,    EvtNetSMTP, 20)
N#define EvtNetSMTP_ReceiveFrame             EventID (EventLevelOp,    EvtNetSMTP, 21)
N#define EvtNetSMTP_UnackedDataError         EventID (EventLevelError, EvtNetSMTP, 22)
N#define EvtNetSMTP_FrameTooShort            EventID (EventLevelError, EvtNetSMTP, 23)
N#define EvtNetSMTP_ServerReady              EventID (EventLevelOp,    EvtNetSMTP, 24)
N#define EvtNetSMTP_EsmtpModeNotSupported    EventID (EventLevelOp,    EvtNetSMTP, 25)
N#define EvtNetSMTP_EhloResponseFragmented   EventID (EventLevelOp,    EvtNetSMTP, 26)
N#define EvtNetSMTP_EsmtpModeActive          EventID (EventLevelOp,    EvtNetSMTP, 27)
N#define EvtNetSMTP_StartAuthentication      EventID (EventLevelOp,    EvtNetSMTP, 28)
N#define EvtNetSMTP_AuthenticationDenied     EventID (EventLevelOp,    EvtNetSMTP, 29)
N#define EvtNetSMTP_AuthMethodNotSupported   EventID (EventLevelError, EvtNetSMTP, 30)
N#define EvtNetSMTP_SmtpModeActive           EventID (EventLevelOp,    EvtNetSMTP, 31)
N#define EvtNetSMTP_AuthenticationSuccessful EventID (EventLevelOp,    EvtNetSMTP, 32)
N#define EvtNetSMTP_AuthenticationFailed     EventID (EventLevelError, EvtNetSMTP, 33)
N#define EvtNetSMTP_ServerAcknowledge        EventID (EventLevelOp,    EvtNetSMTP, 34)
N#define EvtNetSMTP_WrongResponse            EventID (EventLevelError, EvtNetSMTP, 35)
N#define EvtNetSMTP_ClientStopTimeoutExpired EventID (EventLevelError, EvtNetSMTP, 36)
N#define EvtNetSMTP_SendMessageBody          EventID (EventLevelOp,    EvtNetSMTP, 37)
N#define EvtNetSMTP_SendMessageEnd           EventID (EventLevelOp,    EvtNetSMTP, 38)
N#define EvtNetSMTP_SendCommand              EventID (EventLevelDetail,EvtNetSMTP, 39)
N#define EvtNetSMTP_ClientCloseSocket        EventID (EventLevelOp,    EvtNetSMTP, 40)
N#define EvtNetSMTP_ClientDone               EventID (EventLevelOp,    EvtNetSMTP, 41)
N#define EvtNetSMTP_TlsSupportIndicated      EventID (EventLevelOp,    EvtNetSMTP, 42)
N#define EvtNetSMTP_StartTlsAccepted         EventID (EventLevelOp,    EvtNetSMTP, 43)
N#define EvtNetSMTP_TlsGetContextFailed      EventID (EventLevelError, EvtNetSMTP, 44)
N#define EvtNetSMTP_TlsModeStarted           EventID (EventLevelOp,    EvtNetSMTP, 45)
N#define EvtNetSMTP_TlsModeEstablished       EventID (EventLevelOp,    EvtNetSMTP, 46)
N#define EvtNetSMTP_UninitClient             EventID (EventLevelOp,    EvtNetSMTP, 47)
N#endif
N
N/**
N  \brief  Event on SMTP client initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_InitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_InitClient(void) {
N    EventRecord2 (EvtNetSMTP_InitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_InitClient()
N#endif
N
N/**
N  \brief  Event on SMTP client failed to allocate TCP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_GetSocketFailed(void) {
N    EventRecord2 (EvtNetSMTP_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on SMTP client \ref netSMTPc_Connect to the server (API)
N  \param  net_addr      pointer to \ref NET_ADDR server address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_Connect(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_Connect(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetSMTP_Connect, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (2 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetSMTP_Connect(net_addr)
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_Connect invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ConnectInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ConnectInvalidParameter(void) {
N    EventRecord2 (EvtNetSMTP_ConnectInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_ConnectInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_Connect failed, client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ConnectClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ConnectClientBusy(void) {
N    EventRecord2 (EvtNetSMTP_ConnectClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (5 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_ConnectClientBusy()
N#endif
N
N/**
N  \brief  Event on SMTP client \ref netSMTPc_SendMail to mail server (API)
N  \param  num_rcpt      number of mail recipients (To, CC, BCC)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMail(uint8_t num_rcpt) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMail(uint8_t num_rcpt) {
N    EventRecord2 (EvtNetSMTP_SendMail, num_rcpt, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (6 & 0xFFU)), num_rcpt, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMail(num_rcpt)
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailInvalidParameter(void) {
N    EventRecord2 (EvtNetSMTP_SendMailInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (7 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail secure TLS not enabled (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailTlsNotEnabled(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailTlsNotEnabled(void) {
N    EventRecord2 (EvtNetSMTP_SendMailTlsNotEnabled, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailTlsNotEnabled()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail failed, client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailClientBusy(void) {
N    EventRecord2 (EvtNetSMTP_SendMailClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (9 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailClientBusy()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail failed, mail recipient not specified (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailNoRecipients(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailNoRecipients(void) {
N    EventRecord2 (EvtNetSMTP_SendMailNoRecipients, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (10 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailNoRecipients()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail failed, mail server not valid (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailServerNotValid(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailServerNotValid(void) {
N    EventRecord2 (EvtNetSMTP_SendMailServerNotValid, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (11 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailServerNotValid()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail failed, DNS host resolver error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailDnsError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailDnsError(void) {
N    EventRecord2 (EvtNetSMTP_SendMailDnsError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (12 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailDnsError()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail failed, support for attachments not enabled (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailAttachNotEnabled(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailAttachNotEnabled(void) {
N    EventRecord2 (EvtNetSMTP_SendMailAttachNotEnabled, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailAttachNotEnabled()
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail attach file failed, fopen failed (Error)
N  \param  fname         name of the requested file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailAttachFailed(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailAttachFailed(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetSMTP_SendMailAttachFailed, fname, length);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (14 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetSMTP_SendMailAttachFailed(fname, length)
N#endif
N
N/**
N  \brief  Event on SMTP client \ref netSMTPc_SendMail multipart with attachments (Op)
N  \param  num_files     number of files to attach
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailMultipart(uint8_t num_files) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailMultipart(uint8_t num_files) {
N    EventRecord2 (EvtNetSMTP_SendMailMultipart, num_files, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (15 & 0xFFU)), num_files, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMailMultipart(num_files)
N#endif
N
N/**
N  \brief  Event on \ref netSMTPc_SendMail attach file (Op)
N  \param  fname         name of the requested file
N  \param  length        length of the fname string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMailAttachment(const char *fname, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMailAttachment(const char *fname, uint32_t length) {
N    if (length > 80) length = 80;
N    EventRecordData (EvtNetSMTP_SendMailAttachment, fname, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (16 & 0xFFU)), fname, length);
N  }
N#else
S  #define EvrNetSMTP_SendMailAttachment(fname, length)
N#endif
N
N/**
N  \brief  Event on SMTP client inbound connection rejected (Error)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_InboundConnRejected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_InboundConnRejected(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_InboundConnRejected, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (17 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_InboundConnRejected(socket)
N#endif
N
N/**
N  \brief  Event on SMTP client socket aborted (Error)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SocketAborted(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SocketAborted(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_SocketAborted, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (18 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_SocketAborted(socket)
N#endif
N
N/**
N  \brief  Event on SMTP client socket connected (Op)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SocketConnected(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SocketConnected(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_SocketConnected, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (19 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_SocketConnected(socket)
N#endif
N
N/**
N  \brief  Event on SMTP client socket closed (Op)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SocketClosed(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SocketClosed(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_SocketClosed, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (20 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_SocketClosed(socket)
N#endif
N
N/**
N  \brief  Event on SMTP client received frame (Op)
N  \param  socket        assigned TCP socket
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ReceiveFrame(int32_t socket, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ReceiveFrame(int32_t socket, uint32_t length) {
N    EventRecord2 (EvtNetSMTP_ReceiveFrame, (uint32_t)socket, length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (21 & 0xFFU)), (uint32_t)socket, length);
N  }
N#else
S  #define EvrNetSMTP_ReceiveFrame(socket, length)
N#endif
N
N/**
N  \brief  Event on SMTP client unacked data error (Error)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_UnackedDataError(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_UnackedDataError(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_UnackedDataError, (uint32_t)socket, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (22 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_UnackedDataError(socket)
N#endif
N
N/**
N  \brief  Event on SMTP receive frame is too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetSMTP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (23 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetSMTP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on SMTP client server ready response (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ServerReady(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ServerReady(void) {
N    EventRecord2 (EvtNetSMTP_ServerReady, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (24 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_ServerReady()
N#endif
N
N/**
N  \brief  Event on SMTP client Extended SMTP mode (ESMTP) not supported (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_EsmtpModeNotSupported(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_EsmtpModeNotSupported(void) {
N    EventRecord2 (EvtNetSMTP_EsmtpModeNotSupported, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (25 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_EsmtpModeNotSupported()
N#endif
N
N/**
N  \brief  Event on SMTP client EHLO response divided into multiple frames (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_EhloResponseFragmented(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_EhloResponseFragmented(void) {
N    EventRecord2 (EvtNetSMTP_EhloResponseFragmented, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (26 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_EhloResponseFragmented()
N#endif
N
N/**
N  \brief  Event on SMTP client Extended SMTP mode (ESMTP) active (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_EsmtpModeActive(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_EsmtpModeActive(void) {
N    EventRecord2 (EvtNetSMTP_EsmtpModeActive, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (27 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_EsmtpModeActive()
N#endif
N
N/**
N  \brief  Event on SMTP client start authentication (Op)
N  \param  auth_mode     SMTP authentication mode
N                         - 0: not required
N                         - 1: PLAIN
N                         - 2: LOGIN
N                         - 3: DIGEST-MD5
N                         - 4: CRAM-MD5
N                         - 5: NTLM
N                         - 6: unknown
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_StartAuthentication(uint8_t auth_mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_StartAuthentication(uint8_t auth_mode) {
N    EventRecord2 (EvtNetSMTP_StartAuthentication, auth_mode, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (28 & 0xFFU)), auth_mode, 0);
N  }
N#else
S  #define EvrNetSMTP_StartAuthentication(auth_mode)
N#endif
N
N/**
N  \brief  Event on SMTP client authentication denied by the user (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_AuthenticationDenied(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_AuthenticationDenied(void) {
N    EventRecord2 (EvtNetSMTP_AuthenticationDenied, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (29 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_AuthenticationDenied()
N#endif
N
N/**
N  \brief  Event on SMTP client authentication method not supported (Error)
N  \param  auth_mode     SMTP authentication mode
N                         - 0: not required
N                         - 1: PLAIN
N                         - 2: LOGIN
N                         - 3: DIGEST-MD5
N                         - 4: CRAM-MD5
N                         - 5: NTLM
N                         - 6: unknown
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_AuthMethodNotSupported(uint8_t auth_mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_AuthMethodNotSupported(uint8_t auth_mode) {
N    EventRecord2 (EvtNetSMTP_AuthMethodNotSupported, auth_mode, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (30 & 0xFFU)), auth_mode, 0);
N  }
N#else
S  #define EvrNetSMTP_AuthMethodNotSupported(auth_mode)
N#endif
N
N/**
N  \brief  Event on SMTP client basic SMTP mode active (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SmtpModeActive(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SmtpModeActive(void) {
N    EventRecord2 (EvtNetSMTP_SmtpModeActive, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (31 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SmtpModeActive()
N#endif
N
N/**
N  \brief  Event on SMTP client authentication completed successfully (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_AuthenticationSuccessful(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_AuthenticationSuccessful(void) {
N    EventRecord2 (EvtNetSMTP_AuthenticationSuccessful, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (32 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_AuthenticationSuccessful()
N#endif
N
N/**
N  \brief  Event on SMTP client authentication failed (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_AuthenticationFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_AuthenticationFailed(void) {
N    EventRecord2 (EvtNetSMTP_AuthenticationFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (33 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_AuthenticationFailed()
N#endif
N
N/**
N  \brief  Event on SMTP client received server acknowledgment (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ServerAcknowledge(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ServerAcknowledge(void) {
N    EventRecord2 (EvtNetSMTP_ServerAcknowledge, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (34 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_ServerAcknowledge()
N#endif
N
N/**
N  \brief  Event on SMTP client received wrong response from server (Error)
N  \param  response      server response in text form
N  \param  length        length of the response string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_WrongResponse(const uint8_t *response, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_WrongResponse(const uint8_t *response, uint32_t length) {
N    if (length > 64) length = 64;
N    EventRecordData (EvtNetSMTP_WrongResponse, response, length);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (35 & 0xFFU)), response, length);
N  }
N#else
S  #define EvrNetSMTP_WrongResponse(response, length)
N#endif
N
N/**
N  \brief  Event on SMTP client stop operation, timeout expired (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ClientStopTimeoutExpired(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ClientStopTimeoutExpired(void) {
N    EventRecord2 (EvtNetSMTP_ClientStopTimeoutExpired, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (36 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_ClientStopTimeoutExpired()
N#endif
N
N/**
N  \brief  Event on SMTP client send message body start (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMessageBody(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMessageBody(void) {
N    EventRecord2 (EvtNetSMTP_SendMessageBody, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (37 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMessageBody()
N#endif
N
N/**
N  \brief  Event on SMTP client send end of message sequence (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendMessageEnd(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendMessageEnd(void) {
N    EventRecord2 (EvtNetSMTP_SendMessageEnd, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (38 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_SendMessageEnd()
N#endif
N
N/**
N  \brief  Event on SMTP client send command to server (Detail)
N  \param  command       server command in text form
N  \param  length        length of the command string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_SendCommand(const uint8_t *command, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_SendCommand(const uint8_t *command, uint32_t length) {
N    if (length > 64) length = 64;
N    EventRecordData (EvtNetSMTP_SendCommand, command, length);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (39 & 0xFFU)), command, length);
N  }
N#else
S  #define EvrNetSMTP_SendCommand(command, length)
N#endif
N
N/**
N  \brief  Event on SMTP client close socket (Op)
N  \param  socket        assigned TCP socket
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ClientCloseSocket(int32_t socket) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ClientCloseSocket(int32_t socket) {
N    EventRecord2 (EvtNetSMTP_ClientCloseSocket, (uint32_t)socket, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (40 & 0xFFU)), (uint32_t)socket, 0);
N  }
N#else
S  #define EvrNetSMTP_ClientCloseSocket(socket)
N#endif
N
N/**
N  \brief  Event on SMTP client completed operation (Op)
N  \param  cb_event      user callback nofication event
N                         - 0: Email successfully sent
N                         - 1: Timeout on sending email
N                         - 2: Login failed, username/password invalid
N                         - 3: Generoc SMTP client error
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_ClientDone(uint8_t cb_event) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_ClientDone(uint8_t cb_event) {
N    EventRecord2 (EvtNetSMTP_ClientDone, cb_event, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (41 & 0xFFU)), cb_event, 0);
N  }
N#else
S  #define EvrNetSMTP_ClientDone(cb_event)
N#endif
N
N/**
N  \brief  Event on SMTP client TLS support indicated by the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_TlsSupportIndicated(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_TlsSupportIndicated(void) {
N    EventRecord2 (EvtNetSMTP_TlsSupportIndicated, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (42 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_TlsSupportIndicated()
N#endif
N
N/**
N  \brief  Event on SMTP client STARTTLS command accepted by the server (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_StartTlsAccepted(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_StartTlsAccepted(void) {
N    EventRecord2 (EvtNetSMTP_StartTlsAccepted, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (43 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_StartTlsAccepted()
N#endif
N
N/**
N  \brief  Event on SMTP client failed to allocate secure TLS context (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_TlsGetContextFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_TlsGetContextFailed(void) {
N    EventRecord2 (EvtNetSMTP_TlsGetContextFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (44 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_TlsGetContextFailed()
N#endif
N
N/**
N  \brief  Event on SMTP client started secure TLS mode (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_TlsModeStarted(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_TlsModeStarted(void) {
N    EventRecord2 (EvtNetSMTP_TlsModeStarted, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (45 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_TlsModeStarted()
N#endif
N
N/**
N  \brief  Event on SMTP client established secure TLS session (Op)
N  \param  tls_id        TLS session identifier
N*/
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_TlsModeEstablished(uint8_t tls_id) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_TlsModeEstablished(uint8_t tls_id) {
N    EventRecord2 (EvtNetSMTP_TlsModeEstablished, tls_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (46 & 0xFFU)), tls_id, 0);
N  }
N#else
S  #define EvrNetSMTP_TlsModeEstablished(tls_id)
N#endif
N
N/**
N  \brief  Event on SMTP client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSMTP_UninitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSMTP_UninitClient(void) {
N    EventRecord2 (EvtNetSMTP_UninitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xD9 & 0xFFU) << 8) | (47 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSMTP_UninitClient()
N#endif
N
N
N// NetDNS event identifiers ----------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetDNS_InitClient                EventID (EventLevelOp,    EvtNetDNS,  0)
N#define EvtNetDNS_GetSocketFailed           EventID (EventLevelError, EvtNetDNS,  1)
N#define EvtNetDNS_ChangeDnsServer           EventID (EventLevelOp,    EvtNetDNS,  2)
N#define EvtNetDNS_ClientStopTimeoutExpired  EventID (EventLevelError, EvtNetDNS,  3)
N#define EvtNetDNS_ReceiveFrame              EventID (EventLevelOp,    EvtNetDNS,  4)
N// Gap
N#define EvtNetDNS_WrongServerPort           EventID (EventLevelError, EvtNetDNS,  6)
N#define EvtNetDNS_FrameTooShort             EventID (EventLevelError, EvtNetDNS,  7)
N#define EvtNetDNS_WrongServerAddress        EventID (EventLevelError, EvtNetDNS,  8)
N#define EvtNetDNS_ShowFrameHeader           EventID (EventLevelDetail,EvtNetDNS,  9)
N#define EvtNetDNS_WrongTransactionId        EventID (EventLevelError, EvtNetDNS, 10)
N#define EvtNetDNS_DnsRequestReceived        EventID (EventLevelError, EvtNetDNS, 11)
N#define EvtNetDNS_OpcodeOrTruncated         EventID (EventLevelError, EvtNetDNS, 12)
N#define EvtNetDNS_NoSuchNameFound           EventID (EventLevelOp,    EvtNetDNS, 13)
N#define EvtNetDNS_RcodeAndRecursion         EventID (EventLevelError, EvtNetDNS, 14)
N#define EvtNetDNS_MoreAnswersReceived       EventID (EventLevelError, EvtNetDNS, 15)
N#define EvtNetDNS_QnameNotTheSame           EventID (EventLevelError, EvtNetDNS, 16)
N#define EvtNetDNS_QtypeNotTheSame           EventID (EventLevelError, EvtNetDNS, 17)
N#define EvtNetDNS_QclassNotInet             EventID (EventLevelError, EvtNetDNS, 18)
N#define EvtNetDNS_GotHostAddress            EventID (EventLevelOp,    EvtNetDNS, 19)
N// Gap
N#define EvtNetDNS_GotAuthorityAddress       EventID (EventLevelOp,    EvtNetDNS, 21)
N// Gap
N#define EvtNetDNS_RecordTypeNotSupported    EventID (EventLevelError, EvtNetDNS, 23)
N#define EvtNetDNS_Resolve                   EventID (EventLevelOp,    EvtNetDNS, 24)
N#define EvtNetDNS_ResolveInvalidParameter   EventID (EventLevelError, EvtNetDNS, 25)
N#define EvtNetDNS_ResolveClientBusy         EventID (EventLevelError, EvtNetDNS, 26)
N#define EvtNetDNS_ResolvedAddress           EventID (EventLevelOp,    EvtNetDNS, 27)
N// Gap
N#define EvtNetDNS_ResolveDnsServerUnknown   EventID (EventLevelError, EvtNetDNS, 29)
N#define EvtNetDNS_SendRequest               EventID (EventLevelOp,    EvtNetDNS, 30)
N// Gap
N#define EvtNetDNS_ClearCache                EventID (EventLevelAPI,   EvtNetDNS, 32)
N#define EvtNetDNS_ClearCacheClientBusy      EventID (EventLevelError, EvtNetDNS, 33)
N#define EvtNetDNS_UninitClient              EventID (EventLevelOp,    EvtNetDNS, 34)
N#endif
N
N/**
N  \brief  Event on DNS client initialize (Op)
N  \param  num_entries   number of entries available in cache
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_InitClient(uint32_t num_entries) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_InitClient(uint32_t num_entries) {
N    EventRecord2 (EvtNetDNS_InitClient, num_entries, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (0 & 0xFFU)), num_entries, 0);
N  }
N#else
S  #define EvrNetDNS_InitClient(num_entries)
N#endif
N
N/**
N  \brief  Event on DNS client failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_GetSocketFailed(void) {
N    EventRecord2 (EvtNetDNS_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on DNS client change active DNS server (Error)
N  \param  server        DNS server to use
N                         - 0: primary
N                         - 1: secondary
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ChangeDnsServer(int32_t server) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ChangeDnsServer(int32_t server) {
N    EventRecord2 (EvtNetDNS_ChangeDnsServer, (uint32_t)server, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (2 & 0xFFU)), (uint32_t)server, 0);
N  }
N#else
S  #define EvrNetDNS_ChangeDnsServer(server)
N#endif
N
N/**
N  \brief  Event on DNS client stop operation timeout expired (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ClientStopTimeoutExpired(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ClientStopTimeoutExpired(void) {
N    EventRecord2 (EvtNetDNS_ClientStopTimeoutExpired, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (3 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_ClientStopTimeoutExpired()
N#endif
N
N/**
N  \brief  Event on DNS client receive frame from the server (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address of the server
N  \param  length        frame length in bytes
N  \remark Port member is undefined and reused for the length parameter.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ReceiveFrame(const void *net_addr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ReceiveFrame(const void *net_addr, uint32_t length) {
N    const EVR_ADDR *addr = net_addr;
N    evr_buf.u16[0] = (uint16_t)addr->type;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = (uint16_t)addr->type;
N    evr_buf.u16[1] = (uint16_t)length;
X    (*(union evr_access *)&net_dbg_buf).u16[1] = (uint16_t)length;
N    memcpy (&evr_buf.u8[4], &addr->addr,  addr->type ? 16 : 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], &addr->addr,  addr->type ? 16 : 4);
N    EventRecordData (EvtNetDNS_ReceiveFrame, &evr_buf, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (4 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetDNS_ReceiveFrame(net_addr, length)
N#endif
N
N/**
N  \brief  Event on DNS client wrong server port (Error)
N  \param  udp_port      wrong UDP port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_WrongServerPort(uint16_t udp_port) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_WrongServerPort(uint16_t udp_port) {
N    EventRecord2 (EvtNetDNS_WrongServerPort, udp_port, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (6 & 0xFFU)), udp_port, 0);
N  }
N#else
S  #define EvrNetDNS_WrongServerPort(udp_port)
N#endif
N
N/**
N  \brief  Event on DNS client receive frame is too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetDNS_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (7 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetDNS_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on DNS client wrong DNS server address received (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_WrongServerAddress(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_WrongServerAddress(void) {
N    EventRecord2 (EvtNetDNS_WrongServerAddress, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_WrongServerAddress()
N#endif
N
N/**
N  \brief  Event on DNS client display send/receive frame header (Detail)
N  \param  dns_header    pointer to DNS frame header of 12 bytes
N                         - TID     (2 bytes)
N                         - Flags   (2 bytes)
N                         - QDCOUNT (2 bytes)
N                         - ANCOUNT (2 bytes)
N                         - NSCOUNT (2 bytes)
N                         - ARCOUNT (2 bytes)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ShowFrameHeader(const void *dns_header) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ShowFrameHeader(const void *dns_header) {
N    EventRecordData (EvtNetDNS_ShowFrameHeader, dns_header, 12);
X    EventRecordData (((0x30000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (9 & 0xFFU)), dns_header, 12);
N  }
N#else
S  #define EvrNetDNS_ShowFrameHeader(dns_header)
N#endif
N
N/**
N  \brief  Event on DNS client wrong transaction identifier (TID) received (Error)
N  \param  tid           received transaction identifier
N  \param  tid_valid     valid transaction identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_WrongTransactionId(uint16_t tid, uint16_t tid_valid) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_WrongTransactionId(uint16_t tid, uint16_t tid_valid) {
N    EventRecord2 (EvtNetDNS_WrongTransactionId, tid, tid_valid);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (10 & 0xFFU)), tid, tid_valid);
N  }
N#else
S  #define EvrNetDNS_WrongTransactionId(tid, tid_valid)
N#endif
N
N/**
N  \brief  Event on DNS client received a DNS request (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_DnsRequestReceived(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_DnsRequestReceived(void) {
N    EventRecord2 (EvtNetDNS_DnsRequestReceived, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (11 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_DnsRequestReceived()
N#endif
N
N/**
N  \brief  Event on DNS client OPCODE not zero or message truncated received (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_OpcodeOrTruncated(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_OpcodeOrTruncated(void) {
N    EventRecord2 (EvtNetDNS_OpcodeOrTruncated, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (12 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_OpcodeOrTruncated()
N#endif
N
N/**
N  \brief  Event on DNS client no such name found message received (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_NoSuchNameFound(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_NoSuchNameFound(void) {
N    EventRecord2 (EvtNetDNS_NoSuchNameFound, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_NoSuchNameFound()
N#endif
N
N/**
N  \brief  Event on DNS client RCODE not zero and recursion available received (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_RcodeAndRecursion(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_RcodeAndRecursion(void) {
N    EventRecord2 (EvtNetDNS_RcodeAndRecursion, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (14 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_RcodeAndRecursion()
N#endif
N
N/**
N  \brief  Event on DNS client more than one answer received (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_MoreAnswersReceived(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_MoreAnswersReceived(void) {
N    EventRecord2 (EvtNetDNS_MoreAnswersReceived, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (15 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_MoreAnswersReceived()
N#endif
N
N/**
N  \brief  Event on DNS client QNAME in a response not the same as requested (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_QnameNotTheSame(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_QnameNotTheSame(void) {
N    EventRecord2 (EvtNetDNS_QnameNotTheSame, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (16 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_QnameNotTheSame()
N#endif
N
N/**
N  \brief  Event on DNS client QTYPE in a response not the same as requested (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_QtypeNotTheSame(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_QtypeNotTheSame(void) {
N    EventRecord2 (EvtNetDNS_QtypeNotTheSame, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (17 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_QtypeNotTheSame()
N#endif
N
N/**
N  \brief  Event on DNS client QCLASS in a response is not CLASS_INET (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_QclassNotInet(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_QclassNotInet(void) {
N    EventRecord2 (EvtNetDNS_QclassNotInet, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_QclassNotInet()
N#endif
N
N/**
N  \brief  Event on DNS client receive resolved IP address (Op)
N  \param  net_addr      pointer to network address of the host
N  \param  ttl           address expiration timeout
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_GotHostAddress(const void *net_addr, uint32_t ttl) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_GotHostAddress(const void *net_addr, uint32_t ttl) {
N    const EVR_ADDR *addr = net_addr;
N    evr_buf.u32[0] = (ttl << 1) | (addr->type & 0x1);
X    (*(union evr_access *)&net_dbg_buf).u32[0] = (ttl << 1) | (addr->type & 0x1);
N    memcpy (&evr_buf.u8[4], &addr->addr, addr->type ? 16 : 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], &addr->addr, addr->type ? 16 : 4);
N    EventRecordData (EvtNetDNS_GotHostAddress, &evr_buf, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (19 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetDNS_GotHostAddress(net_addr, ttl)
N#endif
N
N/**
N  \brief  Event on DNS client receive IP address of the authority (Op)
N  \param  net_addr      pointer to net address of the authority
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_GotAuthorityAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_GotAuthorityAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetDNS_GotAuthorityAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (21 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetDNS_GotAuthorityAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on DNS client can not handle resource record type (Error)
N  \param  rr_type       recource record type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_RecordTypeNotSupported(uint16_t rr_type) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_RecordTypeNotSupported(uint16_t rr_type) {
N    EventRecord2 (EvtNetDNS_RecordTypeNotSupported, rr_type, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (23 & 0xFFU)), rr_type, 0);
N  }
N#else
S  #define EvrNetDNS_RecordTypeNotSupported(rr_type)
N#endif
N
N/**
N  \brief  Event on DNS client resolve host requested (Op)
N  \param  host_name     name of the host to resolve
N  \param  length        length of the host_name string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_Resolve(const char *host_name, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_Resolve(const char *host_name, uint32_t length) {
N    if (length > 40) length = 40;
N    EventRecordData (EvtNetDNS_Resolve, host_name, length);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (24 & 0xFFU)), host_name, length);
N  }
N#else
S  #define EvrNetDNS_Resolve(host_name, length)
N#endif
N
N/**
N  \brief  Event on DNS client invalid parameter for resolve request (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ResolveInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ResolveInvalidParameter(void) {
N    EventRecord2 (EvtNetDNS_ResolveInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (25 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_ResolveInvalidParameter()
N#endif
N
N/**
N  \brief  Event on DNS client resolve request failed, client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ResolveClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ResolveClientBusy(void) {
N    EventRecord2 (EvtNetDNS_ResolveClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (26 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_ResolveClientBusy()
N#endif
N
N/**
N  \brief  Event on DNS client resolved IP address internally (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ResolvedAddress(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ResolvedAddress(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetDNS_ResolvedAddress, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (27 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetDNS_ResolvedAddress(net_addr)
N#endif
N
N/**
N  \brief  Event on DNS client resolve failed, DNS server unknown (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ResolveDnsServerUnknown(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ResolveDnsServerUnknown(void) {
N    EventRecord2 (EvtNetDNS_ResolveDnsServerUnknown, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (29 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_ResolveDnsServerUnknown()
N#endif
N
N/**
N  \brief  Event on DNS client send resolve request to the server (Op)
N  \param  net_addr      pointer to \ref NET_ADDR address structure
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_SendRequest(const void *net_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_SendRequest(const void *net_addr) {
N    const EVR_ADDR *addr = net_addr;
N    EventRecordData (EvtNetDNS_SendRequest, addr, addr->type ? 20 : 8);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (30 & 0xFFU)), addr, addr->type ? 20 : 8);
N  }
N#else
S  #define EvrNetDNS_SendRequest(net_addr)
N#endif
N
N/**
N  \brief  Event on DNS client clear cache requested (API)
N  \param  used          number of used entries flushed from cache
N  \param  available     number of entries available in cache
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ClearCache(uint32_t used, uint32_t available) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ClearCache(uint32_t used, uint32_t available) {
N    EventRecord2 (EvtNetDNS_ClearCache, used, available);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (32 & 0xFFU)), used, available);
N  }
N#else
S  #define EvrNetDNS_ClearCache(used, available)
N#endif
N
N/**
N  \brief  Event on DNS client clear cache request failed, client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_ClearCacheClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_ClearCacheClientBusy(void) {
N    EventRecord2 (EvtNetDNS_ClearCacheClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (33 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_ClearCacheClientBusy()
N#endif
N
N/**
N  \brief  Event on DNS client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetDNS_UninitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetDNS_UninitClient(void) {
N    EventRecord2 (EvtNetDNS_UninitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDA & 0xFFU) << 8) | (34 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetDNS_UninitClient()
N#endif
N
N
N// NetSNMP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetSNMP_InitAgent                EventID (EventLevelOp,    EvtNetSNMP,  0)
N#define EvtNetSNMP_GetSocketFailed          EventID (EventLevelError, EvtNetSNMP,  1)
N#define EvtNetSNMP_ShowCommunity            EventID (EventLevelOp,    EvtNetSNMP,  2)
N#define EvtNetSNMP_SetCommunity             EventID (EventLevelAPI,   EvtNetSNMP,  3)
N#define EvtNetSNMP_SetCommunityInvalidParam EventID (EventLevelError, EvtNetSNMP,  4)
N#define EvtNetSNMP_SetMibTable              EventID (EventLevelAPI,   EvtNetSNMP,  5)
N#define EvtNetSNMP_SetMibTableInvalidParam  EventID (EventLevelError, EvtNetSNMP,  6)
N#define EvtNetSNMP_Trap                     EventID (EventLevelAPI,   EvtNetSNMP,  7)
N#define EvtNetSNMP_TrapInvalidParameter     EventID (EventLevelError, EvtNetSNMP,  8)
N#define EvtNetSNMP_TrapMibTableNotSet       EventID (EventLevelError, EvtNetSNMP,  9)
N#define EvtNetSNMP_TrapMissingSysObjectId   EventID (EventLevelError, EvtNetSNMP, 10)
N#define EvtNetSNMP_TrapGenericTrapInvalid   EventID (EventLevelError, EvtNetSNMP, 11)
N#define EvtNetSNMP_TrapTooManyObjects       EventID (EventLevelError, EvtNetSNMP, 12)
N#define EvtNetSNMP_TrapObjectNotExisting    EventID (EventLevelError, EvtNetSNMP, 13)
N#define EvtNetSNMP_TrapMessageTooBig        EventID (EventLevelError, EvtNetSNMP, 14)
N#define EvtNetSNMP_AddObject                EventID (EventLevelDetail,EvtNetSNMP, 15)
N#define EvtNetSNMP_ReceiveFrame             EventID (EventLevelOp,    EvtNetSNMP, 16)
N#define EvtNetSNMP_FrameTooShort            EventID (EventLevelError, EvtNetSNMP, 17)
N#define EvtNetSNMP_FrameProtocolError       EventID (EventLevelError, EvtNetSNMP, 18)
N#define EvtNetSNMP_VersionNotSupported      EventID (EventLevelOp,    EvtNetSNMP, 19)
N#define EvtNetSNMP_WrongCommunityReceived   EventID (EventLevelOp,    EvtNetSNMP, 20)
N#define EvtNetSNMP_InvalidRequestType       EventID (EventLevelError, EvtNetSNMP, 21)
N#define EvtNetSNMP_ShowRequest              EventID (EventLevelOp,    EvtNetSNMP, 22)
N#define EvtNetSNMP_TooManyObjectsReceived   EventID (EventLevelError, EvtNetSNMP, 23)
N#define EvtNetSNMP_ObjectNotFound           EventID (EventLevelError, EvtNetSNMP, 24)
N#define EvtNetSNMP_ObjectWrongType          EventID (EventLevelError, EvtNetSNMP, 25)
N#define EvtNetSNMP_ObjectReadOnly           EventID (EventLevelError, EvtNetSNMP, 26)
N#define EvtNetSNMP_ObjectWriteFailed        EventID (EventLevelError, EvtNetSNMP, 27)
N#define EvtNetSNMP_SendErrorStatus          EventID (EventLevelOp,    EvtNetSNMP, 28)
N#define EvtNetSNMP_ResponseMessageTooBig    EventID (EventLevelError, EvtNetSNMP, 29)
N#define EvtNetSNMP_SendGetResponse          EventID (EventLevelOp,    EvtNetSNMP, 30)
N#define EvtNetSNMP_UninitAgent              EventID (EventLevelOp,    EvtNetSNMP, 31)
N#endif
N
N/**
N  \brief  Event on SNMP agent initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_InitAgent(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_InitAgent(void) {
N    EventRecord2 (EvtNetSNMP_InitAgent, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (0 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_InitAgent()
N#endif
N
N/**
N  \brief  Event on SNMP agent failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_GetSocketFailed(void) {
N    EventRecord2 (EvtNetSNMP_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on SNMP agent display community (Op)
N  \param  community     pointer to SNMP community string
N  \param  length        length of the community string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ShowCommunity(const char *community, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ShowCommunity(const char *community, uint32_t length) {
N    if (length > 24) length = 24;
N    EventRecordData(EvtNetSNMP_ShowCommunity, community, length);
X    EventRecordData(((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (2 & 0xFFU)), community, length);
N  }
N#else
S  #define EvrNetSNMP_ShowCommunity(community, length)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_SetCommunity (API)
N  \param  community     pointer to SNMP community string
N  \param  length        length of the community string
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SetCommunity(const char *community, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SetCommunity(const char *community, uint32_t length) {
N    if (length > 32) length = 32;
N    EventRecordData(EvtNetSNMP_SetCommunity, community, length);
X    EventRecordData(((0x10000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (3 & 0xFFU)), community, length);
N  }
N#else
S  #define EvrNetSNMP_SetCommunity(community, length)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_SetCommunity invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SetCommunityInvalidParam(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SetCommunityInvalidParam(void) {
N    EventRecord2 (EvtNetSNMP_SetCommunityInvalidParam, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (4 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_SetCommunityInvalidParam()
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_SetMIB_Table (API)
N  \param  num_entries   number of entries in MIB table
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SetMibTable(uint32_t num_entries) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SetMibTable(uint32_t num_entries) {
N    EventRecord2 (EvtNetSNMP_SetMibTable, num_entries, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (5 & 0xFFU)), num_entries, 0);
N  }
N#else
S  #define EvrNetSNMP_SetMibTable(num_entries)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_SetMIB_Table invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SetMibTableInvalidParam(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SetMibTableInvalidParam(void) {
N    EventRecord2 (EvtNetSNMP_SetMibTableInvalidParam, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (6 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_SetMibTableInvalidParam()
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap (API)
N  \param  ip4_addr      trap server IPv4 address
N  \param  generic       generic trap type
N                         - 0: coldStart trap
N                         - 1: warmStart trap
N                         - 2: linkDown trap
N                         - 3: linkUp trap
N                         - 4: authenticationFailure trap
N                         - 5: egpNeighborLoss trap
N                         - 6: enterpriseSpecific trap
N  \param  specific      specific trap type for generic enterpriseSpecific trap
N                         - must be set to 0 for generic traps 0 .. 5
N  \param  nobj          number of objects in a trap message
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_Trap(const uint8_t *ip4_addr, uint8_t generic, uint8_t specific, uint16_t nobj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_Trap(const uint8_t *ip4_addr, uint8_t generic, uint8_t specific, uint16_t nobj) {
N    evr_buf.u16[0] = nobj;
X    (*(union evr_access *)&net_dbg_buf).u16[0] = nobj;
N    evr_buf.u8[2]  = generic;
X    (*(union evr_access *)&net_dbg_buf).u8[2]  = generic;
N    evr_buf.u8[3]  = specific;
X    (*(union evr_access *)&net_dbg_buf).u8[3]  = specific;
N    memcpy (&evr_buf.u8[4], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u8[4], ip4_addr, 4);
N    EventRecordData (EvtNetSNMP_Trap, &evr_buf, 8);
X    EventRecordData (((0x10000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (7 & 0xFFU)), &(*(union evr_access *)&net_dbg_buf), 8);
N  }
N#else
S  #define EvrNetSNMP_Trap(ip4_addr, generic, specific, nobj)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapInvalidParameter(void) {
N    EventRecord2 (EvtNetSNMP_TrapInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_TrapInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapMibTableNotSet(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapMibTableNotSet(void) {
N    EventRecord2 (EvtNetSNMP_TrapMibTableNotSet, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (9 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_TrapMibTableNotSet()
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap missing 'sysObjectID' object in MIB table (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapMissingSysObjectId(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapMissingSysObjectId(void) {
N    EventRecord2 (EvtNetSNMP_TrapMissingSysObjectId, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (10 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_TrapMissingSysObjectId()
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap generic trap invalid (Error)
N  \param  generic       invalid generic trap type
N  \param  max_generic   maximum value for generic trap type
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapGenericTrapInvalid(uint8_t generic, uint8_t max_generic) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapGenericTrapInvalid(uint8_t generic, uint8_t max_generic) {
N    EventRecord2 (EvtNetSNMP_TrapGenericTrapInvalid, generic, max_generic);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (11 & 0xFFU)), generic, max_generic);
N  }
N#else
S  #define EvrNetSNMP_TrapGenericTrapInvalid(generic, max_generic)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap maximum number of objects exceeded (Error)
N  \param  nobj          number of TLV objects
N  \param  max_nobj      maximum number of TLV objects
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapTooManyObjects(int32_t nobj, int32_t max_nobj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapTooManyObjects(int32_t nobj, int32_t max_nobj) {
N    EventRecord2 (EvtNetSNMP_TrapTooManyObjects, (uint32_t)nobj, (uint32_t)max_nobj);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (12 & 0xFFU)), (uint32_t)nobj, (uint32_t)max_nobj);
N  }
N#else
S  #define EvrNetSNMP_TrapTooManyObjects(nobj, max_nobj)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap requested TLV object not existing in MIB table (Error)
N  \param  obj           object identification number
N  \param  max_obj       maximum value for object identification number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapObjectNotExisting(int32_t obj, int32_t max_obj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapObjectNotExisting(int32_t obj, int32_t max_obj) {
N    EventRecord2 (EvtNetSNMP_TrapObjectNotExisting, (uint32_t)obj, (uint32_t)max_obj);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (13 & 0xFFU)), (uint32_t)obj, (uint32_t)max_obj);
N  }
N#else
S  #define EvrNetSNMP_TrapObjectNotExisting(obj, max_obj)
N#endif
N
N/**
N  \brief  Event on \ref netSNMP_Trap generated message too big (Error)
N  \param  size          requested message size
N  \param  max_size      maximum message size accepted
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TrapMessageTooBig(uint16_t size, uint16_t max_size) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TrapMessageTooBig(uint16_t size, uint16_t max_size) {
N    EventRecord2 (EvtNetSNMP_TrapMessageTooBig, size, max_size);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (14 & 0xFFU)), size, max_size);
N  }
N#else
S  #define EvrNetSNMP_TrapMessageTooBig(size, max_size)
N#endif
N
N/**
N  \brief  Event on SNMP add object to SNMP message (Detail)
N  \param  obj           object identification number
N  \param  obj_type      object data type
N                         - 0x02: Integer Data Type (signed integer)
N                         - 0x04: Octet String Data Type
N                         - 0x05: Null Item Data Type
N                         - 0x06: Object Identifier Data Type
N                         - 0x30: Sequence Data Type
N                         - 0x40: IP Address Data Type
N                         - 0x41: Counter Data Type (pos.integer)
N                         - 0x42: Gauge Data Type (pos.integer)
N                         - 0x43: Time Ticks Data Type (pos.integer)
N                         - 0x44: Opaque Data Type (ASN.1 encoded)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_AddObject(int32_t obj, uint8_t obj_type) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_AddObject(int32_t obj, uint8_t obj_type) {
N    EventRecord2 (EvtNetSNMP_AddObject, (uint32_t)obj, obj_type);
X    EventRecord2 (((0x30000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (15 & 0xFFU)), (uint32_t)obj, obj_type);
N  }
N#else
S  #define EvrNetSNMP_AddObject(obj, obj_type)
N#endif
N
N/**
N  \brief  Event on SNMP receive frame (Op)
N  \param  ip4_addr      pointer to IPv4 address of the server
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ReceiveFrame(const uint8_t *ip4_addr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ReceiveFrame(const uint8_t *ip4_addr, uint32_t length) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetSNMP_ReceiveFrame, length, evr_buf.u32[0]);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (16 & 0xFFU)), length, (*(union evr_access *)&net_dbg_buf).u32[0]);
N  }
N#else
S  #define EvrNetSNMP_ReceiveFrame(ip4_addr, length)
N#endif
N
N/**
N  \brief  Event on SNMP receive frame is too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetSNMP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (17 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetSNMP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on SNMP received frame protocol error detected (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_FrameProtocolError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_FrameProtocolError(void) {
N    EventRecord2 (EvtNetSNMP_FrameProtocolError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (18 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_FrameProtocolError()
N#endif
N
N/**
N  \brief  Event on SNMP received protocol version not supported (Op)
N  \param  version       received SNMP protocol version
N                         - 1: SNMPv1
N                         - 2: SNMPv2
N                         - 3: SNMPv3
N  \remark Only SNMPv1 is currently supported.
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_VersionNotSupported(int32_t version) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_VersionNotSupported(int32_t version) {
N    if (version == 0) version = 1;
N    EventRecord2 (EvtNetSNMP_VersionNotSupported, (uint32_t)version, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (19 & 0xFFU)), (uint32_t)version, 0);
N  }
N#else
S  #define EvrNetSNMP_VersionNotSupported(version)
N#endif
N
N/**
N  \brief  Event on SNMP received community wrong (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_WrongCommunityReceived(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_WrongCommunityReceived(void) {
N    EventRecord2 (EvtNetSNMP_WrongCommunityReceived, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (20 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_WrongCommunityReceived()
N#endif
N
N/**
N  \brief  Event on SNMP received invalid PDU request type (Error)
N  \param  req_type      PDU request type
N                         - 0xA0: GetRequest PDU
N                         - 0xA1: GetNextRequest PDU
N                         - 0xA2: Response PDU
N                         - 0xA3: SetRequest PDU
N                         - 0xA4: Trap PDU
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_InvalidRequestType(uint8_t req_type) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_InvalidRequestType(uint8_t req_type) {
N    EventRecord2 (EvtNetSNMP_InvalidRequestType, req_type, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (21 & 0xFFU)), req_type, 0);
N  }
N#else
S  #define EvrNetSNMP_InvalidRequestType(req_type)
N#endif
N
N/**
N  \brief  Event on SNMP display received PDU request type and id (Error)
N  \param  req_type      PDU request type
N                         - 0xA0: GetRequest PDU
N                         - 0xA1: GetNextRequest PDU
N                         - 0xA2: Response PDU
N                         - 0xA3: SetRequest PDU
N                         - 0xA4: Trap PDU
N  \param  req_id        PDU request identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ShowRequest(uint8_t req_type, int32_t req_id) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ShowRequest(uint8_t req_type, int32_t req_id) {
N    EventRecord2 (EvtNetSNMP_ShowRequest, req_type, (uint32_t)req_id);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (22 & 0xFFU)), req_type, (uint32_t)req_id);
N  }
N#else
S  #define EvrNetSNMP_ShowRequest(req_type, req_id)
N#endif
N
N/**
N  \brief  Event on SNMP received too many TLV objects (Error)
N  \param  nobj          number of TLV objects
N  \param  max_nobj      maximum number of TLV objects
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_TooManyObjectsReceived(int32_t nobj, int32_t max_nobj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_TooManyObjectsReceived(int32_t nobj, int32_t max_nobj) {
N    EventRecord2 (EvtNetSNMP_TooManyObjectsReceived, (uint32_t)nobj, (uint32_t)max_nobj);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (23 & 0xFFU)), (uint32_t)nobj, (uint32_t)max_nobj);
N  }
N#else
S  #define EvrNetSNMP_TooManyObjectsReceived(nobj, max_nobj)
N#endif
N
N/**
N  \brief  Event on SNMP receive message object not found in the MIB table (Error)
N  \param  obj           object identification number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ObjectNotFound(int32_t obj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ObjectNotFound(int32_t obj) {
N    EventRecord2 (EvtNetSNMP_ObjectNotFound, (uint32_t)obj, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (24 & 0xFFU)), (uint32_t)obj, 0);
N  }
N#else
S  #define EvrNetSNMP_ObjectNotFound(obj)
N#endif
N
N/**
N  \brief  Event on SNMP receive message object type not the same as in the MIB table (Error)
N  \param  obj           object identification number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ObjectWrongType(int32_t obj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ObjectWrongType(int32_t obj) {
N    EventRecord2 (EvtNetSNMP_ObjectWrongType, (uint32_t)obj, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (25 & 0xFFU)), (uint32_t)obj, 0);
N  }
N#else
S  #define EvrNetSNMP_ObjectWrongType(obj)
N#endif
N
N/**
N  \brief  Event on SNMP write read-only object not allowed (Error)
N  \param  obj           object identification number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ObjectReadOnly(int32_t obj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ObjectReadOnly(int32_t obj) {
N    EventRecord2 (EvtNetSNMP_ObjectReadOnly, (uint32_t)obj, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (26 & 0xFFU)), (uint32_t)obj, 0);
N  }
N#else
S  #define EvrNetSNMP_ObjectReadOnly(obj)
N#endif
N
N/**
N  \brief  Event on SNMP object write attempt failed for unknown reason (Error)
N  \param  obj           object identification number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ObjectWriteFailed(int32_t obj) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ObjectWriteFailed(int32_t obj) {
N    EventRecord2 (EvtNetSNMP_ObjectWriteFailed, (uint32_t)obj, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (27 & 0xFFU)), (uint32_t)obj, 0);
N  }
N#else
S  #define EvrNetSNMP_ObjectWriteFailed(obj)
N#endif
N
N/**
N  \brief  Event on SNMP send error status response to a SNMP request (Op)
N  \param  stat          error status
N  \param  obj_index     error object index
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SendErrorStatus(uint8_t stat, uint8_t obj_index) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SendErrorStatus(uint8_t stat, uint8_t obj_index) {
N    EventRecord2 (EvtNetSNMP_SendErrorStatus, stat, obj_index);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (28 & 0xFFU)), stat, obj_index);
N  }
N#else
S  #define EvrNetSNMP_SendErrorStatus(stat, obj_index)
N#endif
N
N/**
N  \brief  Event on SNMP response message would be too big (Error)
N  \param  size          response message size
N  \param  max_size      maximum message size allowed
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_ResponseMessageTooBig(uint16_t size, uint16_t max_size) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_ResponseMessageTooBig(uint16_t size, uint16_t max_size) {
N    EventRecord2 (EvtNetSNMP_ResponseMessageTooBig, size, max_size);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (29 & 0xFFU)), size, max_size);
N  }
N#else
S  #define EvrNetSNMP_ResponseMessageTooBig(size, max_size)
N#endif
N
N/**
N  \brief  Event on SNMP send get-response to a SNMP request (Op)
N  \param  req_id        PDU request identifier
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_SendGetResponse(int32_t req_id) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_SendGetResponse(int32_t req_id) {
N    EventRecord2 (EvtNetSNMP_SendGetResponse, (uint32_t)req_id, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (30 & 0xFFU)), (uint32_t)req_id, 0);
N  }
N#else
S  #define EvrNetSNMP_SendGetResponse(req_id)
N#endif
N
N/**
N  \brief  Event on SNMP agent de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNMP_UninitAgent(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNMP_UninitAgent(void) {
N    EventRecord2 (EvtNetSNMP_UninitAgent, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDB & 0xFFU) << 8) | (31 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNMP_UninitAgent()
N#endif
N
N
N// NetSNTP event identifiers ---------------------------------------------------
N#ifdef DEBUG_EVR
N#define EvtNetSNTP_InitClient               EventID (EventLevelOp,    EvtNetSNTP,  0)
N#define EvtNetSNTP_GetSocketFailed          EventID (EventLevelError, EvtNetSNTP,  1)
N#define EvtNetSNTP_GetTime                  EventID (EventLevelAPI,   EvtNetSNTP,  2)
N#define EvtNetSNTP_GetTimeInvalidParameter  EventID (EventLevelError, EvtNetSNTP,  3)
N#define EvtNetSNTP_GetTimeWrongState        EventID (EventLevelError, EvtNetSNTP,  4)
N#define EvtNetSNTP_GetTimeOpen              EventID (EventLevelOp,    EvtNetSNTP,  5)
N#define EvtNetSNTP_GetTimeClose             EventID (EventLevelOp,    EvtNetSNTP,  6)
N#define EvtNetSNTP_GetTimeServerUnknown     EventID (EventLevelError, EvtNetSNTP,  7)
N#define EvtNetSNTP_GetTimexInvalidParameter EventID (EventLevelError, EvtNetSNTP,  8)
N#define EvtNetSNTP_GetTimexClientBusy       EventID (EventLevelError, EvtNetSNTP,  9)
N#define EvtNetSNTP_GetTimexServerNotValid   EventID (EventLevelError, EvtNetSNTP, 10)
N#define EvtNetSNTP_GetTimexDnsError         EventID (EventLevelError, EvtNetSNTP, 11)
N#define EvtNetSNTP_SetMode                  EventID (EventLevelAPI,   EvtNetSNTP, 12)
N#define EvtNetSNTP_SetModeInvalidParameter  EventID (EventLevelError, EvtNetSNTP, 13)
N#define EvtNetSNTP_SetModeWrongState        EventID (EventLevelError, EvtNetSNTP, 14)
N#define EvtNetSNTP_SendMessage              EventID (EventLevelOp,    EvtNetSNTP, 15)
N#define EvtNetSNTP_ServerNotResponding      EventID (EventLevelOp,    EvtNetSNTP, 16)
N#define EvtNetSNTP_ReceiveFrame             EventID (EventLevelOp,    EvtNetSNTP, 17)
N#define EvtNetSNTP_WrongServerPort          EventID (EventLevelError, EvtNetSNTP, 18)
N#define EvtNetSNTP_FrameTooShort            EventID (EventLevelError, EvtNetSNTP, 19)
N#define EvtNetSNTP_WrongServerAddress       EventID (EventLevelError, EvtNetSNTP, 20)
N#define EvtNetSNTP_ModeNotServer            EventID (EventLevelError, EvtNetSNTP, 21)
N#define EvtNetSNTP_ModeNotBroadcast         EventID (EventLevelError, EvtNetSNTP, 22)
N#define EvtNetSNTP_AnswerInWrongState       EventID (EventLevelError, EvtNetSNTP, 23)
N#define EvtNetSNTP_ShowTimeStamp            EventID (EventLevelOp,    EvtNetSNTP, 24)
N#define EvtNetSNTP_TimeStampInvalid         EventID (EventLevelOp,    EvtNetSNTP, 25)
N#define EvtNetSNTP_UninitClient             EventID (EventLevelOp,    EvtNetSNTP, 26)
N#endif
N
N/**
N  \brief  Event on SNTP client initialize (Op)
N  \param  mode          operation mode of the client
N                         - 0: unicast
N                         - 1: broadcast
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_InitClient(uint8_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_InitClient(uint8_t mode) {
N    EventRecord2 (EvtNetSNTP_InitClient, mode, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (0 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetSNTP_InitClient(mode)
N#endif
N
N/**
N  \brief  Event on SNTP failed to allocate UDP socket (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetSocketFailed(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetSocketFailed(void) {
N    EventRecord2 (EvtNetSNTP_GetSocketFailed, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (1 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetSocketFailed()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime (API)
N  \param  mode          operation mode of the client
N                         - 0: unicast
N                         - 1: broadcast
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTime(uint8_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTime(uint8_t mode) {
N    EventRecord2 (EvtNetSNTP_GetTime, mode, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (2 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTime(mode)
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimeInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimeInvalidParameter(void) {
N    EventRecord2 (EvtNetSNTP_GetTimeInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (3 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimeInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime wrong client state (Error)
N  \param  state         client state
N                         - 0: idle
N                         - 1: busy in unicast send
N                         - 2: open in broadcast receive
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimeWrongState(uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimeWrongState(uint8_t state) {
N    EventRecord2 (EvtNetSNTP_GetTimeWrongState, state, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (4 & 0xFFU)), state, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimeWrongState(state)
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime open broadcast receive (Op)
N  \param  ip4_addr      pointer to IPv4 address of NTP server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimeOpen(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimeOpen(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSNTP_GetTimeOpen, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (5 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSNTP_GetTimeOpen(ip4_addr)
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime close broadcast receive (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimeClose(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimeClose(void) {
N    EventRecord2 (EvtNetSNTP_GetTimeClose, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (6 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimeClose()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTime unknown server for unicast mode (Error)
N  \param  ip4_addr      pointer to IPv4 address of NTP server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimeServerUnknown(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimeServerUnknown(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSNTP_GetTimeServerUnknown, ip4_addr, 4);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (7 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSNTP_GetTimeServerUnknown(ip4_addr)
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTimeX invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimexInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimexInvalidParameter(void) {
N    EventRecord2 (EvtNetSNTP_GetTimexInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (8 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimexInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTimeX client busy (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimexClientBusy(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimexClientBusy(void) {
N    EventRecord2 (EvtNetSNTP_GetTimexClientBusy, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (9 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimexClientBusy()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTimeX server name not valid (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimexServerNotValid(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimexServerNotValid(void) {
N    EventRecord2 (EvtNetSNTP_GetTimexServerNotValid, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (10 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimexServerNotValid()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_GetTimeX host name resolver error (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_GetTimexDnsError(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_GetTimexDnsError(void) {
N    EventRecord2 (EvtNetSNTP_GetTimexDnsError, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (11 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_GetTimexDnsError()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_SetMode (API)
N  \param  mode          operation mode of the client
N                         - 0: unicast
N                         - 1: broadcast
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_SetMode(uint8_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_SetMode(uint8_t mode) {
N    EventRecord2 (EvtNetSNTP_SetMode, mode, 0);
X    EventRecord2 (((0x10000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (12 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetSNTP_SetMode(mode)
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_SetMode invalid parameter (Error)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_SetModeInvalidParameter(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_SetModeInvalidParameter(void) {
N    EventRecord2 (EvtNetSNTP_SetModeInvalidParameter, 0, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (13 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_SetModeInvalidParameter()
N#endif
N
N/**
N  \brief  Event on \ref netSNTPc_SetMode wrong client state (Error)
N  \param  state         client state
N                         - 0: idle
N                         - 1: busy in unicast send
N                         - 2: open in broadcast receive
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_SetModeWrongState(uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_SetModeWrongState(uint8_t state) {
N    EventRecord2 (EvtNetSNTP_SetModeWrongState, state, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (14 & 0xFFU)), state, 0);
N  }
N#else
S  #define EvrNetSNTP_SetModeWrongState(state)
N#endif
N
N/**
N  \brief  Event on SNTP send message to NTP server (Op)
N  \param  ip4_addr      pointer to IPv4 address of NTP server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_SendMessage(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_SendMessage(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSNTP_SendMessage, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (15 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSNTP_SendMessage(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SNTP send message timeout (Op)
N  \param  ip4_addr      pointer to IPv4 address of NTP server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_ServerNotResponding(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_ServerNotResponding(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSNTP_ServerNotResponding, ip4_addr, 4);
X    EventRecordData (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (16 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSNTP_ServerNotResponding(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SNTP receive frame (Op)
N  \param  ip4_addr      pointer to IPv4 address of the server
N  \param  length        frame length in bytes
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_ReceiveFrame(const uint8_t *ip4_addr, uint32_t length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_ReceiveFrame(const uint8_t *ip4_addr, uint32_t length) {
N    memcpy (&evr_buf.u32[0], ip4_addr, 4);
X    memcpy (&(*(union evr_access *)&net_dbg_buf).u32[0], ip4_addr, 4);
N    EventRecord2 (EvtNetSNTP_ReceiveFrame, evr_buf.u32[0], length);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (17 & 0xFFU)), (*(union evr_access *)&net_dbg_buf).u32[0], length);
N  }
N#else
S  #define EvrNetSNTP_ReceiveFrame(ip4_addr, length)
N#endif
N
N/**
N  \brief  Event on SNTP wrong server port (Error)
N  \param  udp_port      wrong UDP port number
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_WrongServerPort(uint16_t udp_port) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_WrongServerPort(uint16_t udp_port) {
N    EventRecord2 (EvtNetSNTP_WrongServerPort, udp_port, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (18 & 0xFFU)), udp_port, 0);
N  }
N#else
S  #define EvrNetSNTP_WrongServerPort(udp_port)
N#endif
N
N/**
N  \brief  Event on SNTP receive frame is too short (Error)
N  \param  length        frame length in bytes
N  \param  min_length    minimum length of the frame
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_FrameTooShort(uint32_t length, uint32_t min_length) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_FrameTooShort(uint32_t length, uint32_t min_length) {
N    EventRecord2 (EvtNetSNTP_FrameTooShort, length, min_length);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (19 & 0xFFU)), length, min_length);
N  }
N#else
S  #define EvrNetSNTP_FrameTooShort(length, min_length)
N#endif
N
N/**
N  \brief  Event on SNTP wrong NTP server address (Error)
N  \param  ip4_addr      pointer to IPv4 address of NTP server
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_WrongServerAddress(const uint8_t *ip4_addr) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_WrongServerAddress(const uint8_t *ip4_addr) {
N    EventRecordData (EvtNetSNTP_WrongServerAddress, ip4_addr, 4);
X    EventRecordData (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (20 & 0xFFU)), ip4_addr, 4);
N  }
N#else
S  #define EvrNetSNTP_WrongServerAddress(ip4_addr)
N#endif
N
N/**
N  \brief  Event on SNTP message mode not server (Error)
N  \param  mode          message mode
N                         - 0: reserved
N                         - 1: symetric active
N                         - 2: symetric passive
N                         - 3: client
N                         - 4: server
N                         - 5: broadcast
N                         - 6: reserved
N                         - 7: reserved
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_ModeNotServer(uint8_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_ModeNotServer(uint8_t mode) {
N    EventRecord2 (EvtNetSNTP_ModeNotServer, mode, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (21 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetSNTP_ModeNotServer(mode)
N#endif
N
N/**
N  \brief  Event on SNTP message mode not broadcast (Error)
N  \param  mode          message mode
N                         - 0: reserved
N                         - 1: symetric active
N                         - 2: symetric passive
N                         - 3: client
N                         - 4: server
N                         - 5: broadcast
N                         - 6: reserved
N                         - 7: reserved
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_ModeNotBroadcast(uint8_t mode) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_ModeNotBroadcast(uint8_t mode) {
N    EventRecord2 (EvtNetSNTP_ModeNotBroadcast, mode, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (22 & 0xFFU)), mode, 0);
N  }
N#else
S  #define EvrNetSNTP_ModeNotBroadcast(mode)
N#endif
N
N/**
N  \brief  Event on SNTP answer received in wrong state (Error)
N  \param  state         client state
N                         - 0: idle
N                         - 1: busy in unicast send
N                         - 2: open in broadcast receive
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_AnswerInWrongState(uint8_t state) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_AnswerInWrongState(uint8_t state) {
N    EventRecord2 (EvtNetSNTP_AnswerInWrongState, state, 0);
X    EventRecord2 (((0x00000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (23 & 0xFFU)), state, 0);
N  }
N#else
S  #define EvrNetSNTP_AnswerInWrongState(state)
N#endif
N
N/**
N  \brief  Event on SNTP display time stamp in seconds (Op)
N  \param  ref_time      reference time (since Jan 1, 1900)
N  \param  utc_time      utc time       (since Jan 1, 1970)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_ShowTimeStamp(uint32_t ref_time, uint32_t utc_time) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_ShowTimeStamp(uint32_t ref_time, uint32_t utc_time) {
N    EventRecord2 (EvtNetSNTP_ShowTimeStamp, ref_time, utc_time);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (24 & 0xFFU)), ref_time, utc_time);
N  }
N#else
S  #define EvrNetSNTP_ShowTimeStamp(ref_time, utc_time)
N#endif
N
N/**
N  \brief  Event on SNTP invalid time stamp (Op)
N  \param  ref_time      reference time (since Jan 1, 1900)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_TimeStampInvalid(uint32_t ref_time) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_TimeStampInvalid(uint32_t ref_time) {
N    EventRecord2 (EvtNetSNTP_TimeStampInvalid, ref_time, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (25 & 0xFFU)), ref_time, 0);
N  }
N#else
S  #define EvrNetSNTP_TimeStampInvalid(ref_time)
N#endif
N
N/**
N  \brief  Event on SNTP client de-initialize (Op)
N */
N#ifdef DEBUG_EVR
N  __STATIC_INLINE void EvrNetSNTP_UninitClient(void) {
X  static __inline __attribute__((always_inline)) void EvrNetSNTP_UninitClient(void) {
N    EventRecord2 (EvtNetSNTP_UninitClient, 0, 0);
X    EventRecord2 (((0x20000U & 0x30000U) | ((0xDC & 0xFFU) << 8) | (26 & 0xFFU)), 0, 0);
N  }
N#else
S  #define EvrNetSNTP_UninitClient()
N#endif
L 278 "C:\Users\Mohammad\AppData\Local\Arm\Packs\Keil\MDK-Middleware\7.12.0\Network\Include\net_debug.h" 2
N
N#define __FILTER(dbg)   (dbg == 1) ? EventRecordError : EventRecordAll
N
N#define EVR_ENABLE_FILTER(dbg,s,e) if (dbg) EventRecorderEnable(__FILTER(dbg),s,e)
N
Nvoid net_evr_init (void) {
N#if (DBG_SYSTEM_EN)
X#if (1)
N  EventRecorderDisable(EventRecordAll, EvtNetSYS, EvtNetLOOP);
X  EventRecorderDisable(0x0FU, 0xC0, 0xC5);
N  EVR_ENABLE_FILTER(2,        EvtNetSYS,  EvtNetSYS);
X  if (2) EventRecorderEnable((2 == 1) ? 0x01U : 0x0FU,0xC0,0xC0);
N  EVR_ENABLE_FILTER(DBG_MEM,  EvtNetMEM,  EvtNetMEM);
X  if (1) EventRecorderEnable((1 == 1) ? 0x01U : 0x0FU,0xC1,0xC1);
N  EVR_ENABLE_FILTER(DBG_ETH,  EvtNetETH,  EvtNetETH);
X  if (1) EventRecorderEnable((1 == 1) ? 0x01U : 0x0FU,0xC2,0xC2);
N  EVR_ENABLE_FILTER(DBG_WIFI, EvtNetWiFi, EvtNetWiFi);
X  if (1) EventRecorderEnable((1 == 1) ? 0x01U : 0x0FU,0xDD,0xDD);
N  EVR_ENABLE_FILTER(DBG_PPP,  EvtNetPPP,  EvtNetPPP);
X  if (0) EventRecorderEnable((0 == 1) ? 0x01U : 0x0FU,0xC3,0xC3);
N  EVR_ENABLE_FILTER(DBG_SLIP, EvtNetSLIP, EvtNetSLIP);
X  if (0) EventRecorderEnable((0 == 1) ? 0x01U : 0x0FU,0xC4,0xC4);
N  EVR_ENABLE_FILTER(DBG_LOOP, EvtNetLOOP, EvtNetLOOP);
X  if (1) EventRecorderEnable((1 == 1) ? 0x01U : 0x0FU,0xC5,0xC5);
N#endif
N#if (DBG_CORE4_EN)
X#if (0)
S  EventRecorderDisable(EventRecordAll, EvtNetIP4, EvtNetARP);
S  EVR_ENABLE_FILTER(DBG_IP4,  EvtNetIP4,  EvtNetIP4);
S  EVR_ENABLE_FILTER(DBG_ICMP, EvtNetICMP, EvtNetICMP);
S  EVR_ENABLE_FILTER(DBG_IGMP, EvtNetIGMP, EvtNetIGMP);
S  EVR_ENABLE_FILTER(DBG_NBNS, EvtNetNBNS, EvtNetNBNS);
S  EVR_ENABLE_FILTER(DBG_DHCP, EvtNetDHCP, EvtNetDHCP);
S  EVR_ENABLE_FILTER(DBG_ARP,  EvtNetARP,  EvtNetARP);
N#endif
N#if (DBG_CORE6_EN)
X#if (0)
S  EventRecorderDisable(EventRecordAll, EvtNetIP6, EvtNetNDP);
S  EVR_ENABLE_FILTER(DBG_IP6,  EvtNetIP6,  EvtNetIP6);
S  EVR_ENABLE_FILTER(DBG_ICMP6,EvtNetICMP6,EvtNetICMP6);
S  EVR_ENABLE_FILTER(DBG_DHCP6,EvtNetDHCP6,EvtNetDHCP6);
S  EVR_ENABLE_FILTER(DBG_NDP6, EvtNetNDP,  EvtNetNDP);
N#endif
N#if (DBG_SOCKET_EN)
X#if (0)
S  EventRecorderDisable(EventRecordAll,EvtNetUDP, EvtNetBSD);
S  EVR_ENABLE_FILTER(DBG_UDP_SOCKET,   EvtNetUDP, EvtNetUDP);
S  EVR_ENABLE_FILTER(DBG_TCP_SOCKET,   EvtNetTCP, EvtNetTCP);
S  EVR_ENABLE_FILTER(DBG_BSD_SOCKET,   EvtNetBSD, EvtNetBSD);
N#endif
N#if (DBG_SERVICE_EN)
X#if (0)
S  EventRecorderDisable(EventRecordAll,EvtNetHTTPs,EvtNetSNTP);
S  EVR_ENABLE_FILTER(DBG_HTTP_SERVER,  EvtNetHTTPs,EvtNetHTTPs);
S  EVR_ENABLE_FILTER(DBG_FTP_SERVER,   EvtNetFTPs, EvtNetFTPs);
S  EVR_ENABLE_FILTER(DBG_FTP_CLIENT,   EvtNetFTPc, EvtNetFTPc);
S  EVR_ENABLE_FILTER(DBG_TELNET_SERVER,EvtNetTeln, EvtNetTeln);
S  EVR_ENABLE_FILTER(DBG_TFTP_SERVER,  EvtNetTFTPs,EvtNetTFTPs);
S  EVR_ENABLE_FILTER(DBG_TFTP_CLIENT,  EvtNetTFTPc,EvtNetTFTPc);
S  EVR_ENABLE_FILTER(DBG_SMTP_CLIENT,  EvtNetSMTP, EvtNetSMTP);
S  EVR_ENABLE_FILTER(DBG_DNS_CLIENT,   EvtNetDNS,  EvtNetDNS);
S  EVR_ENABLE_FILTER(DBG_SNMP_AGENT,   EvtNetSNMP, EvtNetSNMP);
S  EVR_ENABLE_FILTER(DBG_SNTP_CLIENT,  EvtNetSNTP, EvtNetSNTP);
N#endif
N}
N#endif
L 161 "RTE\Network\Net_Debug.c" 2
N
N
N/**
N  \fn          void net_debug_init (void)
N  \brief       Initialize Network Debug Interface.
N*/
Nvoid net_debug_init (void) {
N  /* Add your code to initialize the debug output device. */
N  /* This is usually the serial interface or ITM channel. */
N
N}
